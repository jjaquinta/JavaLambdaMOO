================================#0 The System Object===============================================
#0 The System Object.container rc = MOOObjRef #8
#0 The System Object.verb_editor rc = MOOObjRef #49
#0 The System Object.command_utils rc = MOOObjRef #56
#0 The System Object.generic_editor rc = MOOObjRef #50
#0 The System Object.no_connect_message rc = MOONumber 0
#0 The System Object.convert_utils rc = MOOObjRef #93
#0 The System Object.site_log rc = MOOObjRef #70
#0 The System Object.no_one r = MOOObjRef #38
#0 The System Object.sysobj r = MOOObjRef #0
#0 The System Object.gripe_recipients rc = MOOList [ #2 ]
#0 The System Object.quota_utils rc = MOOObjRef #79
#0 The System Object.you r = MOOObjRef #35
#0 The System Object.editor_help rc = MOOObjRef #44
#0 The System Object.mail_recipient rc = MOOObjRef #45
#0 The System Object.match_utils rc = MOOObjRef #51
#0 The System Object.builder_help r = MOOObjRef #84
#0 The System Object.lock_utils rc = MOOObjRef #53
#0 The System Object.nothing rc = MOOObjRef #-1
#0 The System Object.seq_utils rc = MOOObjRef #33
#0 The System Object.note_editor rc = MOOObjRef #48
#0 The System Object.mail_agent rc = MOOObjRef #46
#0 The System Object.exit rc = MOOObjRef #7
#0 The System Object.mail_editor rc = MOOObjRef #47
#0 The System Object.last_restart_time rc = MOONumber 1529543472
#0 The System Object.letter rc = MOOObjRef #54
#0 The System Object.guest r = MOOObjRef #31
#0 The System Object.wiz_utils rc = MOOObjRef #24
#0 The System Object.math_utils rc = MOOObjRef #26
#0 The System Object.prog_help rc = MOOObjRef #22
#0 The System Object.set_utils rc = MOOObjRef #27
#0 The System Object.failed_match rc = MOOObjRef #-3
#0 The System Object.build_options rc = MOOObjRef #77
#0 The System Object.password_verifier r = MOOObjRef #87
#0 The System Object.pasting_feature rc = MOOObjRef #90
#0 The System Object.generic_db rc = MOOObjRef #37
#0 The System Object.guest_log r = MOOObjRef #12
#0 The System Object.mail_options rc = MOOObjRef #65
#0 The System Object.shutdown_time rc = MOONumber 0
#0 The System Object.housekeeper rc = MOOObjRef #71
#0 The System Object.login r = MOOObjRef #10
#0 The System Object.local rc = MOOObjRef #-1
#0 The System Object.trig_utils rc = MOOObjRef #26
#0 The System Object.mail_help r = MOOObjRef #85
#0 The System Object.feature rc = MOOObjRef #74
#0 The System Object.force_input_count rc = MOONumber 19398082
#0 The System Object.builder rc = MOOObjRef #4
#0 The System Object.string_utils rc = MOOObjRef #20
#0 The System Object.site_db rc = MOOObjRef #25
#0 The System Object.ftp rc = MOOObjRef #86
#0 The System Object.time_utils rc = MOOObjRef #43
#0 The System Object.prog rc = MOOObjRef #58
#0 The System Object.building_utils rc = MOOObjRef #21
#0 The System Object.newt_log rc = MOOObjRef #70
#0 The System Object.help rc = MOOObjRef #60
#0 The System Object.class_registry rc = MOOList [ [ "generics", "Generic objects intended for use as the parents of new objects", [ #3, #7, #5, #9, #54, #8, #1, #6, #58, #57, #50, #45, #46 ] ], [ "utilities", "Objects holding useful general-purpose verbs", [ #20, #55, #24, #27, #41, #26, #43, #51, #52, #53, #56, #42, #21, #33, #13, #79, #81, #59, #91, #93 ] ] ]
#0 The System Object.hacker rc = MOOObjRef #36
#0 The System Object.toad_log rc = MOOObjRef #70
#0 The System Object.frand_help rc = MOOObjRef #92
#0 The System Object.thing rc = MOOObjRef #5
#0 The System Object.code_utils rc = MOOObjRef #59
#0 The System Object.big_mail_recipient rc = MOOObjRef #14
#0 The System Object.new_player_log rc = MOOObjRef #17
#0 The System Object.maxint rc = MOONumber 2147483647
#0 The System Object.core_help rc = MOOObjRef #19
#0 The System Object.generic_biglist_home r = MOOObjRef #73
#0 The System Object.wiz_help rc = MOOObjRef #23
#0 The System Object.byte_quota_utils rc = MOOObjRef #79
#0 The System Object.shutdown_task rc = MOONumber 0
#0 The System Object.perm_utils rc = MOOObjRef #42
#0 The System Object.mail_recipient_class rc = MOOObjRef #40
#0 The System Object.core_history r = MOOList [ [ "LambdaMOO", "1.8.3+47", 1529447738 ] ]
#0 The System Object.quota_log rc = MOOObjRef #34
#0 The System Object.object_utils rc = MOOObjRef #52
#0 The System Object.generic_options rc = MOOObjRef #68
#0 The System Object.list_utils rc = MOOObjRef #55
#0 The System Object.builtin_function_help rc = MOOObjRef #28
#0 The System Object.gopher r = MOOObjRef #75
#0 The System Object.spell rc = MOOObjRef #32
#0 The System Object.matrix_utils r = MOOObjRef #91
#0 The System Object.minint rc = MOONumber -2147483648
#0 The System Object.garbage rc = MOOObjRef #64
#0 The System Object.ambiguous_match rc = MOOObjRef #-2
#0 The System Object.registration_db rc = MOOObjRef #16
#0 The System Object.gender_utils r = MOOObjRef #41
#0 The System Object.object_quota_utils rc = MOOObjRef #81
#0 The System Object.biglist rc = MOOObjRef #13
#0 The System Object.http rc = MOOObjRef #97
#0 The System Object.prog_options rc = MOOObjRef #76
#0 The System Object.server_options rc = MOOObjRef #82
#0 The System Object.note rc = MOOObjRef #9
#0 The System Object.max_ticks rc = MOONumber 30000
#0 The System Object.edit_options rc = MOOObjRef #66
#0 The System Object.root_class rc = MOOObjRef #1
#0 The System Object.error rc = MOOObjRef #69
#0 The System Object.network rc = MOOObjRef #72
#0 The System Object.last_huh r = MOOObjRef #11
#0 The System Object.paranoid_db r = MOOObjRef #80
#0 The System Object.recycler rc = MOOObjRef #63
#0 The System Object.display_options rc = MOOObjRef #67
#0 The System Object.player rc = MOOObjRef #6
#0 The System Object.max_seconds rc = MOONumber 5
#0 The System Object.news rc = MOOObjRef #61
#0 The System Object.player_start rc = MOOObjRef #62
#0 The System Object.generic_utils rc = MOOObjRef #78
#0 The System Object.player_class rc = MOOObjRef #40
#0 The System Object.shutdown_message rc = MOOString ""
#0 The System Object.wiz rc = MOOObjRef #57
#0 The System Object.room rc = MOOObjRef #3
#0 The System Object.verb_help rc = MOOObjRef #18
#0 The System Object.frand_class rc = MOOObjRef #88
#0 The System Object.gendered_object r = MOOObjRef #94
#0 The System Object.stage_talk rc = MOOObjRef #89
#0 The System Object.list_editor rc = MOOObjRef #95
#0 The System Object.dump_interval rc = MOONumber 3600
#0 The System Object.player_db r = MOOObjRef #39
#0 The System Object.new_prog_log rc = MOOObjRef #29
#0 The System Object.generic_help rc = MOOObjRef #30
#0 The System Object.limbo rc = MOOObjRef #15
#0 The System Object.feature_warehouse r = MOOObjRef #83
#0 The System Object:do_login_command this n/a this
function do_login_command() {
	"...This code should only be run as a server task...";
	if (callers().length > 1) {
		raise(E_PERM);
	}
	if (typeof(h = $network.incoming_connection(player)) == OBJ) {
		"connected to an object";
		return h;
	} else if (h) {
		return 0;
	}
	host = $string_utils.connection_hostname(connection_name(player));
	if ($login.redlisted(host)) {
		boot_player(player);
		server_log(tostr("REDLISTED: ", player, " from ", host));
		return 0;
	}
	"HTTP server by Krate";
	try {
		newargs = $http.handle_connection.apply($http.handle_connection, args);
		if (!newargs) {
			return 0;
		}
		args = newargs;
	} catch (ANY) {}
	"...checks to see if the login is spamming the server with too many commands...";
	if (!$login.maybe_limit_commands()) {
		args = $login.parse_command.apply($login.parse_command, args);
		return $login[args[1]].apply($login[args[1]], listdelete(args, 1));
	}
}
do_login_command();
-------------------------------------------------------------------------------
#0 The System Object:server_started this n/a this
if (!callers()) {
$last_restart_time = time();
$network.server_started();
$login.server_started();
}
-------------------------------------------------------------------------------
#0 The System Object:core_object_info core_objects this n/a this
set_task_perms($no_one);
{?core_variant = "Imnotsurewhatthisshouldbeyetdontdependonthis", ?in_mcd = 0} = args;
if (in_mcd)
{vb, perms, loc} = callers()[1][2..4];
if (((vb != "make-core-database") || (!perms.wizard)) || (loc != $wiz))
raise(E_PERM);
endif
endif
core_objects = {};
proxy_original = proxy_incore = core_properties = skipped_parents = {};
todo = {{#0, {"sysobj", "owner"}}};
"...lucky for us #0 has a self-referential property";
while ({?sfc, @todo} = todo)
{o, ?props_to_follow = {}} = sfc;
o_props = {};
for p in (props_to_follow)
v = o.(p);
if ((typeof(v) != OBJ) || (!valid(v)))
continue p;
endif
o_props = {@o_props, p};
if ((v in proxy_original) || (v in core_objects))
"...we have been here before...";
continue p;
endif
if ($object_utils:has_callable_verb(v, "proxy_for_core"))
"...proxy_for_core() returns an object to";
"...take the place of v in the final core.";
proxy_original[1..0] = {v};
try
vnew = v:proxy_for_core(core_variant, in_mcd);
if (typeof(vnew) != OBJ)
raise(E_TYPE, "returned non-object");
elseif ((vnew in proxy_original) > 1)
raise(E_RECMOVE, "proxy loop");
endif
except e (ANY)
player:notify(tostr("Error from ", v, ":proxy_for_core => ", e[2]));
player:notify(toliteral(e[4]));
vnew = #-1;
endtry
if (vnew == v)
proxy_original[1..1] = {};
else
proxy_incore[1..0] = {vnew};
if ((vnew in core_objects) || (!valid(vnew)))
continue p;
endif
v = vnew;
endif
endif
if ($object_utils:has_callable_verb(v, "include_for_core"))
"...include_for_core() returns a list of properties on v";
"...to be searched for additional core objects.";
try
v_props = v:include_for_core(core_variant);
if (typeof(v_props) != LIST)
raise(E_TYPE, "returned non-list");
endif
if (v_props)
todo = {@todo, {v, v_props}};
endif
except e (ANY)
player:notify(tostr("Error from ", v, ":include_for_core => ", e[2]));
player:notify(toliteral(e[4]));
endtry
endif
core_objects = setadd(core_objects, v);
endfor
core_properties = {@core_properties, {o, o_props}};
endwhile
for o in (core_objects)
p = parent(o);
while (valid(p))
if (!(p in core_objects))
skipped_parents = setadd(skipped_parents, p);
endif
p = parent(p);
endwhile
endfor
if (verb == "core_object_info")
"... what make-core-database needs";
return {core_objects, core_properties, skipped_parents, proxy_original, proxy_incore};
else
"... what most people care about";
return core_objects;
endif
-------------------------------------------------------------------------------
#0 The System Object:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
`delete_property(this, "mail_name_db") ! E_PROPNF';
`delete_verb(this, "do_command") ! E_VERBNF';
$core_history = {{$network.MOO_name, server_version(), time()}, @$core_history};
$shutdown_message = "";
$shutdown_time = 0;
$dump_interval = 3600;
$gripe_recipients = {player};
$class_registry = {{"generics", "Generic objects intended for use as the parents of new objects", {$room, $exit, $thing, $note, $letter, $container, $root_class, $player, $prog, $wiz, $generic_editor, $mail_recipient, $mail_agent}}, {"utilities", "Objects holding useful general-purpose verbs", children($generic_utils)}};
for v in ({"do_login_command", "server_started"})
c = {};
for i in (verb_code(this, v))
c = {@c, strsub(i, "$local.login", "$login")};
endfor
set_verb_code(#0, v, c);
endfor
endif
-------------------------------------------------------------------------------
#0 The System Object:user_created user_connected this n/a this
"Copied from The System Object (#0):user_connected by Slartibartfast (#4242) Sun May 21 18:14:16 1995 PDT";
if (callers())
return;
endif
user = args[1];
set_task_perms(user);
try
user.location:confunc(user);
user:confunc();
except id (ANY)
user:tell("Confunc failed: ", id[2], ".");
for tb in (id[4])
user:tell("... called from ", tb[4], ":", tb[2], (tb[4] != tb[1]) ? tostr(" (this == ", tb[1], ")") | "", ", line ", tb[6]);
endfor
user:tell("(End of traceback)");
endtry
-------------------------------------------------------------------------------
#0 The System Object:user_disconnected user_client_disconnected this n/a this
if (callers())
return;
endif
if (args[1] < #0)
"not logged in user.  probably should do something clever here involving Carrot's no-spam hack.  --yduJ";
return;
endif
user = args[1];
user.last_disconnect_time = time();
set_task_perms(user);
where = user.location;
`user:disfunc() ! ANY => 0';
if (user.location != where)
`where.location:disfunc(user) ! ANY => 0';
endif
`user.location:disfunc(user) ! ANY => 0';
-------------------------------------------------------------------------------
#0 The System Object:bf_chparent chparent this n/a this
"chparent(object, new-parent) -- see help on the builtin.";
who = caller_perms();
{what, papa} = args;
if (typeof(what) != OBJ)
retval = E_TYPE;
elseif (!valid(what))
retval = E_INVARG;
elseif (typeof(papa) != OBJ)
retval = E_TYPE;
elseif ((!valid(papa)) && (papa != #-1))
retval = E_INVIND;
elseif (!$perm_utils:controls(who, what))
retval = E_PERM;
elseif ((is_player(what) && (!$object_utils:isa(papa, $player_class))) && (!who.wizard))
retval = E_PERM;
elseif ((is_player(what) && (!$object_utils:isa(what, $player_class))) && (!who.wizard))
retval = E_PERM;
elseif ((children(what) && $object_utils:isa(what, $player_class)) && (!$object_utils:isa(papa, $player_class)))
retval = E_PERM;
elseif ((is_player(what) && (what in $wiz_utils.chparent_restricted)) && (!who.wizard))
retval = E_PERM;
elseif ((((what.location == $mail_agent) && $object_utils:isa(what, $mail_recipient)) && (!$object_utils:isa(papa, $mail_recipient))) && (!who.wizard))
retval = E_PERM;
elseif ((!valid(papa)) || ($perm_utils:controls(who, papa) || papa.f))
retval = `chparent(@args) ! ANY';
else
retval = E_PERM;
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:bf_add_verb add_verb this n/a this
"add_verb() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_verb exists and is true and caller_perms() are not wizardly.";
who = caller_perms();
what = args[1];
info = args[2];
if (typeof(what) != OBJ)
retval = E_TYPE;
elseif (!valid(what))
retval = E_INVARG;
elseif ((!$perm_utils:controls(who, what)) && (!what.w))
"caller_perms() is not allowed to hack on the object in question";
retval = E_PERM;
elseif (!$perm_utils:controls(who, info[1]))
"caller_perms() is not permitted to add a verb with the specified owner.";
retval = E_PERM;
elseif (index(info[2], "w") && (!$server_options.permit_writable_verbs))
retval = E_INVARG;
elseif (!$quota_utils:verb_addition_permitted(who))
retval = E_QUOTA;
elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:verb_addition_permitted(what.owner)))
retval = E_QUOTA;
elseif (!who.programmer)
retval = E_PERM;
else
"we now know that the caller's perms control the object or the object is writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)";
retval = `add_verb(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:bf_add_property add_property this n/a this
"add_property() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_add_property exists and is true and caller_perms() are not wizardly.";
who = caller_perms();
{what, propname, value, info} = args;
if (typeof(what) != OBJ)
retval = E_TYPE;
elseif (!valid(what))
retval = E_INVARG;
elseif ((!$perm_utils:controls(who, what)) && (!what.w))
retval = E_PERM;
elseif (!$perm_utils:controls(who, info[1]))
retval = E_PERM;
elseif (!$quota_utils:property_addition_permitted(who))
retval = E_QUOTA;
elseif (((what.owner != who) && (!who.wizard)) && (!$quota_utils:property_addition_permitted(what.owner)))
retval = E_QUOTA;
"elseif (!who.programmer)";
"  return E_PERM;     I wanted to do this, but $builder:@newmessage relies upon nonprogs being able to call add_property.  --Nosredna";
elseif ((propname in {"object_size", "size_quota", "queued_task_limit"}) && (!who.wizard))
retval = E_PERM;
else
"we now know that the caller's perms control the object (or the object is writable), and that the caller's perms are permitted to control the new property's owner.";
retval = `add_property(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:bf_recycle recycle this n/a this
"recycle(object) -- see help on the builtin. This verb is called by the server when $server_options.protect_recycle exists and is true and caller_perms() are not wizardly.";
if (!valid(what = args[1]))
retval = E_INVARG;
elseif (!$perm_utils:controls(who = caller_perms(), what))
retval = E_PERM;
elseif ((p = is_player(what)) && (!who.wizard))
for p in ($wiz_utils:connected_wizards_unadvertised())
p:tell($string_utils:pronoun_sub("%N (%#) is currently trying to recycle %t (%[#t])", who, what));
endfor
retval = E_PERM;
else
if (p)
$wiz_utils:unset_player(what);
endif
$recycler:kill_all_tasks(what);
retval = `recycle(what) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:user_reconnected this n/a this
if (callers())
return;
endif
if ($object_utils:isa(user = args[1], $guest))
"from $guest:boot";
oldloc = user.location;
move(user, $nothing);
"..force enterfunc to be called so that the newbie gets a room description.";
move(user, user.home);
user:do_reset();
if ($object_utils:isa(oldloc, $room))
oldloc:announce("In the distance you hear someone's alarm clock going off.");
if (oldloc != user.location)
oldloc:announce(user.name, " wavers and vanishes into insubstantial mist.");
else
oldloc:announce(user.name, " undergoes a wrenching personality shift.");
endif
endif
set_task_perms(user);
`user:confunc() ! ANY';
endif
-------------------------------------------------------------------------------
#0 The System Object:bf_set_verb_info set_verb_info this n/a this
"set_verb_info() -- see help on the builtin for more information. This verb is called by the server when $server_options.protect_set_verb_info exists and is true and caller_perms() are not wizardly.";
{o, v, i} = args;
if (typeof(vi = `verb_info(o, v) ! ANY') == ERR)
"probably verb doesn't exist";
retval = vi;
elseif (!$perm_utils:controls(cp = caller_perms(), vi[1]))
"perms don't control the current verb owner";
retval = E_PERM;
elseif ((typeof(i) != LIST) || (typeof(no = i[1]) != OBJ))
"info is malformed";
retval = E_TYPE;
elseif ((!valid(no)) || (!is_player(no)))
"invalid new verb owner";
retval = E_INVARG;
elseif (!$perm_utils:controls(cp, no))
"perms don't control prospective verb owner";
retval = E_PERM;
elseif (index(i[2], "w") && (!`$server_options.permit_writable_verbs ! E_PROPNF, E_INVIND => 1'))
retval = E_INVARG;
else
retval = `set_verb_info(o, v, i) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:bf_match match this n/a this
m = `match(@args) ! ANY';
return ((typeof(m) == ERR) && $code_utils:dflag_on()) ? raise(m) | m;
if ((length(args[1]) > 256) && index(args[2], "*"))
return E_INVARG;
else
return match(@args);
endif
-------------------------------------------------------------------------------
#0 The System Object:bf_rmatch rmatch this n/a this
r = `rmatch(@args) ! ANY';
return ((typeof(r) == ERR) && $code_utils:dflag_on()) ? raise(r) | r;
if ((length(args[1]) > 256) && index(args[2], "*"))
return E_INVARG;
else
return rmatch(@args);
endif
-------------------------------------------------------------------------------
#0 The System Object:checkpoint_finished this n/a this
"Copied from The System Object (#0):checkpoint_finished [verb author Heathcliff (#89987)] at Fri May  7 12:02:22 2004 PDT";
callers() && raise(E_PERM);
$login.checkpoint_in_progress = 0;
`$local.checkpoint_notification:checkpoint_finished(@args) ! ANY';
-------------------------------------------------------------------------------
#0 The System Object:do_out_of_band_command doobc this n/a this
"do_out_of_band_command -- a cheap and very dirty do_out_of_band verb.  Forwards to verb on player with same name if it exists, otherwise forwards to $login.  May only be called by the server in response to an out of band command, otherwise E_PERM is returned.";
if (((caller == #-1) && (caller_perms() == #-1)) && (callers() == {}))
if (valid(player) && is_player(player))
set_task_perms(player);
$object_utils:has_callable_verb(player, "do_out_of_band_command") && player:do_out_of_band_command(@args);
else
$login:do_out_of_band_command(@args);
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#0 The System Object:handle_uncaught_error this n/a this
if (!callers())
{code, msg, value, stack, traceback} = args;
if (!$object_utils:connected(player))
"Mail the player the traceback if e isn't connected.";
$mail_agent:send_message(#0, player, {"traceback", $gripe_recipients}, traceback);
endif
"now let the player do something with it if e wants...";
return `player:(verb)(@args) ! ANY';
endif
-------------------------------------------------------------------------------
#0 The System Object:checkpoint_started this n/a this
callers() && raise(E_PERM);
$login.checkpoint_in_progress = 1;
`$local.checkpoint_notification:checkpoint_started(@args) ! ANY';
-------------------------------------------------------------------------------
#0 The System Object:bf_force_input this n/a this
"Copied from Jay (#3920):bf_force_input Mon Jun 16 20:55:27 1997 PDT";
"force_input(conn, line [, at-front])";
"see help on the builtin for more information. This verb is called by the server when $server_options.protect_force_input exists and is true and caller_perms() are not wizardly.";
{conn, line, ?at_front = 0} = args;
if (caller_perms() != conn)
retval = E_PERM;
elseif (conn in $login.newted)
retval = E_PERM;
else
retval = `force_input(@args) ! ANY';
this.force_input_count = this.force_input_count + 1;
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:moveto this n/a this
"Let's keep bozos from partying.  --Nosredna the partypooper";
return pass(#-1);
-------------------------------------------------------------------------------
#0 The System Object:bf_set_property_info set_property_info this n/a this
who = caller_perms();
retval = 0;
try
{what, propname, info} = args;
except (E_ARGS)
retval = E_ARGS;
endtry
try
{owner, perms, ?newname = 0} = info;
except (E_ARGS)
retval = E_ARGS;
except (E_TYPE)
retval = E_TYPE;
endtry
if (retval != 0)
elseif ((newname in {"object_size", "size_quota", "queued_task_limit"}) && (!who.wizard))
retval = E_PERM;
else
set_task_perms(who);
retval = `set_property_info(@args) ! ANY';
endif
return ((typeof(retval) == ERR) && $code_utils:dflag_on()) ? raise(retval) | retval;
-------------------------------------------------------------------------------
#0 The System Object:include_for_core this n/a this
return properties(this);
-------------------------------------------------------------------------------
#0 The System Object:handle_task_timeout this n/a this
if (!callers())
{resource, stack, traceback} = args;
if (!$object_utils:connected(player))
"Mail the player the traceback if e isn't connected.";
$mail_agent:send_message(#0, player, {"traceback", $gripe_recipients}, traceback);
endif
"now let the player do something with it if e wants...";
return `player:(verb)(@args) ! ANY';
endif
-------------------------------------------------------------------------------
================================#1 Root Class===============================================
#1 Root Class.aliases rc = MOOList [ ]
#1 Root Class.description rc = MOOString ""
#1 Root Class.key c = MOONumber 0
#1 Root Class.object_size r = MOOList [ 22038, 1084848672 ]
#1 Root Class:initialize this n/a this
if (typeof(this.owner.owned_objects) == LIST)
this.owner.owned_objects = setadd(this.owner.owned_objects, this);
endif
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
if (is_clear_property(this, "object_size"))
"If this isn't clear, then we're being hacked.";
this.object_size = {0, 0};
endif
this.key = 0;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#1 Root Class:recycle this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
try
if ((typeof(this.owner.owned_objects) == LIST) && (!is_clear_property(this.owner, "owned_objects")))
this.owner.owned_objects = setremove(this.owner.owned_objects, this);
$recycler.lost_souls = setadd($recycler.lost_souls, this);
endif
except (ANY)
"Oy, doesn't have a .owned_objects??, or maybe .owner is $nothing";
"Should probably do something...like send mail somewhere.";
endtry
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#1 Root Class:set_name this n/a this
"set_name(newname) attempts to change this.name to newname";
"  => E_PERM   if you don't own this or aren't its parent, or are a player trying to do an end-run around $player_db...";
if ((!caller_perms().wizard) && (is_player(this) || ((caller_perms() != this.owner) && (this != caller))))
return E_PERM;
else
return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;
endif
-------------------------------------------------------------------------------
#1 Root Class:title this n/a this
return this.name;
-------------------------------------------------------------------------------
#1 Root Class:titlec this n/a this
return `this.namec ! E_PROPNF => $string_utils:capitalize(this:title())';
-------------------------------------------------------------------------------
#1 Root Class:set_aliases this n/a this
"set_aliases(alias_list) attempts to change this.aliases to alias_list";
"  => E_PERM   if you don't own this or aren't its parent";
"  => E_TYPE   if alias_list is not a list";
"  => E_INVARG if any element of alias_list is not a string";
"  => 1        if aliases are set exactly as expected (default)";
"  => 0        if aliases were set differently than expected";
"              (children with custom :set_aliases should be aware of this)";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (typeof(aliases = args[1]) != LIST)
return E_TYPE;
else
for s in (aliases)
if (typeof(s) != STR)
return E_INVARG;
endif
endfor
this.aliases = aliases;
return 1;
endif
-------------------------------------------------------------------------------
#1 Root Class:match this n/a this
c = this:contents();
return $string_utils:match(args[1], c, "name", c, "aliases");
-------------------------------------------------------------------------------
#1 Root Class:match_object this n/a this
":match_object(string [,who])";
args[2..1] = {this};
return $string_utils:match_object(@args);
-------------------------------------------------------------------------------
#1 Root Class:set_description this n/a this
"set_description(newdesc) attempts to change this.description to newdesc";
"  => E_PERM   if you don't own this or aren't its parent";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (typeof(desc = args[1]) in {LIST, STR})
this.description = desc;
return 1;
else
return E_TYPE;
endif
-------------------------------------------------------------------------------
#1 Root Class:description this n/a this
return this.description;
-------------------------------------------------------------------------------
#1 Root Class:look_self this n/a this
desc = this:description();
if (desc)
player:tell_lines(desc);
else
player:tell("You see nothing special.");
endif
-------------------------------------------------------------------------------
#1 Root Class:notify this n/a this
if (is_player(this))
notify(this, @args);
endif
-------------------------------------------------------------------------------
#1 Root Class:tell this n/a this
this:notify(tostr(@args));
-------------------------------------------------------------------------------
#1 Root Class:tell_lines this n/a this
lines = args[1];
if (typeof(lines) == LIST)
for line in (lines)
this:tell(line);
endfor
else
this:tell(lines);
endif
-------------------------------------------------------------------------------
#1 Root Class:accept this n/a this
set_task_perms(caller_perms());
return this:acceptable(@args);
-------------------------------------------------------------------------------
#1 Root Class:moveto this n/a this
set_task_perms(this.owner);
return `move(this, args[1]) ! ANY';
-------------------------------------------------------------------------------
#1 Root Class:eject eject_nice eject_basic this n/a this
"eject(victim) --- usable by the owner of this to remove victim from this.contents.  victim goes to its home if different from here, or $nothing or $player_start according as victim is a player.";
"eject_basic(victim) --- victim goes to $nothing or $player_start according as victim is a player; victim:moveto is not called.";
what = args[1];
nice = verb != "eject_basic";
perms = caller_perms();
if ((!perms.wizard) && (perms != this.owner))
raise(E_PERM);
elseif ((!(what in this.contents)) || what.wizard)
return 0;
endif
if ((((nice && $object_utils:has_property(what, "home")) && (typeof(where = what.home) == OBJ)) && (where != this)) && (is_player(what) ? `where:accept_for_abode(what) ! ANY' | `where:acceptable(what) ! ANY'))
else
where = is_player(what) ? $player_start | $nothing;
endif
fork (0)
if (what.location == this)
"It didn't move when we asked it to, or :moveto is broken. Force it.";
move(what, where);
endif
endfork
return nice ? `what:moveto(where) ! ANY' | `move(what, where) ! ANY';
-------------------------------------------------------------------------------
#1 Root Class:is_unlocked_for this n/a this
return (this.key == 0) || $lock_utils:eval_key(this.key, args[1]);
-------------------------------------------------------------------------------
#1 Root Class:huh this n/a this
set_task_perms((caller_perms() != #-1) ? caller_perms() | player);
$command_utils:do_huh(verb, args);
-------------------------------------------------------------------------------
#1 Root Class:set_message this n/a this
":set_message(msg_name,new_value)";
"Does the actual dirty work of @<msg_name> object is <new_value>";
"changing the raw value of the message msg_name to be new_value.";
"Both msg_name and new_value should be strings, though their interpretation is up to the object itself.";
" => error value (use E_PROPNF if msg_name isn't recognized)";
" => string error message if something else goes wrong.";
" => 1 (true non-string) if the message is successfully set";
" => 0 (false non-error) if the message is successfully `cleared'";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
else
return `this.(args[1] + "_msg") = args[2] ! ANY' && 1;
endif
-------------------------------------------------------------------------------
#1 Root Class:do_examine this n/a this
"do_examine(examiner)";
"the guts of examine";
"call a series of verbs and report their return values to the player";
who = args[1];
"if (caller == this || caller == who)";
if (caller == who)
"set_task_perms();";
who:notify_lines(this:examine_names(who) || {});
"this:examine_names(who);";
who:notify_lines(this:examine_owner(who) || {});
"this:examine_owner(who);";
who:notify_lines(this:examine_desc(who) || {});
"this:examine_desc(who);";
who:notify_lines(this:examine_key(who) || {});
"this:examine_key(who);";
who:notify_lines(this:examine_contents(who) || {});
who:notify_lines(this:examine_verbs(who) || {});
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#1 Root Class:examine_key this n/a this
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr("Key:  ", $lock_utils:unparse_key(this.key))};
endif
-------------------------------------------------------------------------------
#1 Root Class:examine_names this n/a this
"examine_names(examiner)";
"Return a list of strings to be told to the player, indicating the name and aliases (and, by default, the object number) of this.";
return {tostr(this.name, " (aka ", $string_utils:english_list({tostr(this), @this.aliases}), ")")};
-------------------------------------------------------------------------------
#1 Root Class:examine_desc this n/a this
"examine_desc(who) - return the description, probably";
"who is the player examining";
"this should probably go away";
desc = this:description();
if (desc)
if (typeof(desc) != LIST)
desc = {desc};
endif
return desc;
else
return {"(No description set.)"};
endif
-------------------------------------------------------------------------------
#1 Root Class:examine_contents this n/a this
"examine_contents(examiner)";
"by default, calls :tell_contents.";
"Should probably go away.";
who = args[1];
if (caller == this)
try
this:tell_contents(this.contents, this.ctype);
except (ANY)
"Just ignore it. We shouldn't care about the contents unless the object wants to tell us about them via :tell_contents ($container, $room)";
endtry
endif
-------------------------------------------------------------------------------
#1 Root Class:examine_verbs this n/a this
"Return a list of strings to be told to the player.  Standard format says \"Obvious verbs:\" followed by a series of lines explaining syntax for each usable verb.";
if (caller != this)
return E_PERM;
endif
who = args[1];
name = dobjstr;
vrbs = {};
commands_ok = `this:examine_commands_ok(who) ! ANY => 0';
dull_classes = {$root_class, $room, $player, $prog, $builder};
what = this;
hidden_verbs = this:hidden_verbs(who);
while (what != $nothing)
$command_utils:suspend_if_needed(0);
if (!(what in dull_classes))
for i in [1..length(verbs(what))]
$command_utils:suspend_if_needed(0);
info = verb_info(what, i);
syntax = verb_args(what, i);
if (this:examine_verb_ok(what, i, info, syntax, commands_ok, hidden_verbs))
{dobj, prep, iobj} = syntax;
if (syntax == {"any", "any", "any"})
prep = "none";
endif
if (prep != "none")
for x in ($string_utils:explode(prep, "/"))
if (length(x) <= length(prep))
prep = x;
endif
endfor
endif
"This is the correct way to handle verbs ending in *";
vname = info[3];
while (j = index(vname, "* "))
vname = tostr(vname[1..j - 1], "<anything>", vname[j + 1..$]);
endwhile
if (vname[$] == "*")
vname = vname[1..$ - 1] + "<anything>";
endif
vname = strsub(vname, " ", "/");
rest = "";
if (prep != "none")
rest = " " + ((prep == "any") ? "<anything>" | prep);
if (iobj != "none")
rest = tostr(rest, " ", (iobj == "this") ? name | "<anything>");
endif
endif
if (dobj != "none")
rest = tostr(" ", (dobj == "this") ? name | "<anything>", rest);
endif
vrbs = setadd(vrbs, ("  " + vname) + rest);
endif
endfor
endif
what = parent(what);
endwhile
if ($code_utils:verb_or_property(this, "help_msg"))
vrbs = {@vrbs, tostr("  help ", dobjstr)};
endif
return vrbs && {"Obvious verbs:", @vrbs};
-------------------------------------------------------------------------------
#1 Root Class:get_message this n/a this
":get_message(msg_name)";
"Use this to obtain a given user-customizable message's raw value, i.e., the value prior to any pronoun-substitution or incorporation of any variant elements --- the value one needs to supply to :set_message().";
"=> error (use E_PROPNF if msg_name isn't recognized)";
"=> string or list-of-strings raw value";
"=> {2, @(list of {msg_name_n,rawvalue_n} pairs to give to :set_message)}";
"=> {1, other kind of raw value}";
"=> {E_NONE, error message} ";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (((t = typeof(msg = `this.(args[1] + "_msg") ! ANY')) in {ERR, STR}) || (((t == LIST) && msg) && (typeof(msg[1]) == STR)))
return msg;
else
return {1, msg};
endif
-------------------------------------------------------------------------------
#1 Root Class:room_announce*_all_but this n/a this
try
this.location:(verb)(@args);
except (ANY)
endtry
-------------------------------------------------------------------------------
#1 Root Class:init_for_core this n/a this
if (caller_perms().wizard)
deletes = {};
for vnum in [1..length(verbs(this))]
$command_utils:suspend_if_needed(0);
for name in ($string_utils:explode(verb_info(this, vnum)[3]))
if (rindex(name, "(old)") == max(1, length(name) - 4))
deletes[1..0] = {vnum};
break;
elseif (rindex(name, "(core)") == max(1, length(name) - 5))
deletes[1..0] = {vnum};
set_verb_code(this, name[1..$ - 6], verb_code(this, vnum));
break;
endif
endfor
endfor
for vnum in (deletes)
delete_verb(this, vnum);
endfor
endif
-------------------------------------------------------------------------------
#1 Root Class:contents this n/a this
"Returns a list of the objects that are apparently inside this one.  Don't confuse this with .contents, which is a property kept consistent with .location by the server.  This verb should be used in `VR' situations, for instance when looking in a room, and does not necessarily have anything to do with the value of .contents (although the default implementation does).  `Non-VR' commands (like @contents) should look directly at .contents.";
return this.contents;
-------------------------------------------------------------------------------
#1 Root Class:examine_verb_ok this n/a this
"examine_verb_ok(loc, index, info, syntax, commands_ok, hidden_verbs)";
"loc is the object that defines the verb; index is which verb on the object; info is verb_info; syntax is verb_args; commands_ok is determined by this:commands_ok, probably, but passed in so we don't have to calculate it for each verb.";
"hidden_verbs is passed in for the same reasons.  It should be a list, each of whose entries is either a string with the full verb name to be hidden (e.g., \"d*rop th*row\") or a list of the form {verb location, full verb name, args}.";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
{loc, index, info, syntax, commands_ok, hidden_verbs} = args;
vname = info[3];
return (((((syntax[2..3] != {"none", "this"}) && (!index(vname, "("))) && (commands_ok || ("this" in syntax))) && `verb_code(loc, index) ! ANY') && (!(vname in hidden_verbs))) && (!({loc, vname, syntax} in hidden_verbs));
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#1 Root Class:is_listening this n/a this
"return 1 if the object can hear a :tell, or cares. Useful for active objects that want to stop when nothing is listening.";
return 0;
-------------------------------------------------------------------------------
#1 Root Class:hidden_verbs this n/a this
"hidden_verbs(who)";
"returns a list of verbs on this that should be hidden from examine";
"the player who's examining is passed in, so objects can hide verbs from specific players";
"verbs are returned as {location, full_verb_name, args} or just full_verb_name.  full_verb name is what shows up in verb_info(object, verb)[2], for example \"d*op th*row\".";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
hidden = {};
what = this;
while (what != $nothing)
for i in [1..length(verbs(what))]
info = verb_info(what, i);
if (!index(info[2], "r"))
hidden = setadd(hidden, {what, info[3], verb_args(what, i)});
endif
endfor
what = parent(what);
endwhile
return hidden;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#1 Root Class:examine_owner this n/a this
"examine_owner(examiner)";
"Return a list of strings to be told to the player, indicating who owns this.";
return {tostr("Owned by ", this.owner.name, ".")};
-------------------------------------------------------------------------------
#1 Root Class:announce*_all_but this n/a this
return;
-------------------------------------------------------------------------------
#1 Root Class:tell_lines_suspended this n/a this
lines = args[1];
if (typeof(lines) == LIST)
for line in (lines)
this:tell(line);
$command_utils:suspend_if_needed(0);
endfor
else
this:tell(lines);
endif
-------------------------------------------------------------------------------
#1 Root Class:acceptable this n/a this
return 0;
"intended as a 'quiet' way to determine if :accept will succeed. Currently, some objects have a noisy :accept verb since it is the only thing that a builtin move() call is guaranteed to call.";
"if you want to tell, before trying, whether :accept will fail, use :acceptable instead. Normally, they'll do the same thing.";
-------------------------------------------------------------------------------
================================#2 Wizard===============================================
================================#3 generic room===============================================
#3 generic room.blessed_task rc = MOONumber 0
#3 generic room.ejection_msg rc = MOOString "You expel %d from %i."
#3 generic room.exits c = MOOList [ ]
#3 generic room.free_entry rc = MOONumber 1
#3 generic room.dark rc = MOONumber 0
#3 generic room.entrances c = MOOList [ ]
#3 generic room.who_location_msg rc = MOOString "%T"
#3 generic room.blessed_object rc = MOOObjRef #-1
#3 generic room.oejection_msg rc = MOOString "%N unceremoniously %{!expels} %d from %i."
#3 generic room.ctype rc = MOONumber 3
#3 generic room.free_home rc = MOONumber 0
#3 generic room.victim_ejection_msg rc = MOOString "You have been expelled from %i by %n."
#3 generic room.residents rc = MOOList [ ]
#3 generic room:confunc this n/a this
if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))
"Need the first check because guests don't control themselves";
this:look_self(player.brief);
this:announce($string_utils:pronoun_sub("%N %<has> connected.", player));
endif
-------------------------------------------------------------------------------
#3 generic room:disfunc this n/a this
if ((((cp = caller_perms()) == player) || $perm_utils:controls(cp, player)) || (caller == this))
this:announce($string_utils:pronoun_sub("%N %<has> disconnected.", player));
"need the first check since guests don't control themselves";
if (!$object_utils:isa(player, $guest))
"guest disfuncs are handled by $guest:disfunc. Don't add them here";
$housekeeper:move_players_home(player);
endif
endif
-------------------------------------------------------------------------------
#3 generic room:say any ?-2? any
try
player:tell("You say, \"", argstr, "\"");
this:announce(player.name, " ", $gender_utils:get_conj("says", player), ", \"", argstr, "\"");
except (ANY)
"Don't really need to do anything but ignore the idiot who has a bad :tell";
endtry
-------------------------------------------------------------------------------
#3 generic room:emote any ?-2? any
if ((argstr != "") && (argstr[1] == ":"))
this:announce_all(player.name, argstr[2..length(argstr)]);
else
this:announce_all(player.name, " ", argstr);
endif
-------------------------------------------------------------------------------
#3 generic room:announce this n/a this
for dude in (setremove(this:contents(), player))
try
dude:tell(@args);
except (ANY)
"Just skip the dude with the bad :tell";
continue dude;
endtry
endfor
-------------------------------------------------------------------------------
#3 generic room:match_exit this n/a this
what = args[1];
if (what)
yes = $failed_match;
for e in (this.exits)
if (valid(e) && (what in {e.name, @e.aliases}))
if (yes == $failed_match)
yes = e;
elseif (yes != e)
return $ambiguous_match;
endif
endif
endfor
return yes;
else
return $nothing;
endif
-------------------------------------------------------------------------------
#3 generic room:add_exit this n/a this
set_task_perms(caller_perms());
return `this.exits = setadd(this.exits, args[1]) ! E_PERM' != E_PERM;
-------------------------------------------------------------------------------
#3 generic room:tell_contents this n/a this
{contents, ctype} = args;
if ((!this.dark) && (contents != {}))
if (ctype == 0)
player:tell("Contents:");
for thing in (contents)
player:tell("  ", thing:title());
endfor
elseif (ctype == 1)
for thing in (contents)
if (is_player(thing))
player:tell($string_utils:pronoun_sub(tostr("%N ", $gender_utils:get_conj("is", thing), " here."), thing));
else
player:tell("You see ", thing:title(), " here.");
endif
endfor
elseif (ctype == 2)
player:tell("You see ", $string_utils:title_list(contents), " here.");
elseif (ctype == 3)
players = things = {};
for x in (contents)
if (is_player(x))
players = {@players, x};
else
things = {@things, x};
endif
endfor
if (things)
player:tell("You see ", $string_utils:title_list(things), " here.");
endif
if (players)
player:tell($string_utils:title_listc(players), (length(players) == 1) ? " " + $gender_utils:get_conj("is", players[1]) | " are", " here.");
endif
endif
endif
-------------------------------------------------------------------------------
#3 generic room:@exits none n/a none
if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))
player:tell("Sorry, only the owner of a room may list its exits.");
elseif (this.exits == {})
player:tell("This room has no conventional exits.");
else
try
for exit in (this.exits)
try
player:tell(exit.name, " (", exit, ") leads to ", valid(exit.dest) ? exit.dest.name | "???", " (", exit.dest, ") via {", $string_utils:from_list(exit.aliases, ", "), "}.");
except (ANY)
player:tell("Bad exit or missing .dest property:  ", $string_utils:nn(exit));
continue exit;
endtry
endfor
except (E_TYPE)
player:tell("Bad .exits property. This should be a list of exit objects. Please fix this.");
endtry
endif
-------------------------------------------------------------------------------
#3 generic room:look_self this n/a this
{?brief = 0} = args;
player:tell(this:title());
if (!brief)
pass();
endif
this:tell_contents(setremove(this:contents(), player), this.ctype);
-------------------------------------------------------------------------------
#3 generic room:acceptable this n/a this
what = args[1];
return this:is_unlocked_for(what) && (((this:free_entry(@args) || ((what == this.blessed_object) && (task_id() == this.blessed_task))) || (what.owner == this.owner)) || ((typeof(this.residents) == LIST) && ((what in this.residents) || (what.owner in this.residents))));
-------------------------------------------------------------------------------
#3 generic room:add_entrance this n/a this
set_task_perms(caller_perms());
return `this.entrances = setadd(this.entrances, args[1]) ! E_PERM' != E_PERM;
-------------------------------------------------------------------------------
#3 generic room:bless_for_entry this n/a this
if (caller in {@this.entrances, this})
this.blessed_object = args[1];
this.blessed_task = task_id();
endif
-------------------------------------------------------------------------------
#3 generic room:@entrances none n/a none
if (!$perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))
player:tell("Sorry, only the owner of a room may list its entrances.");
elseif (this.entrances == {})
player:tell("This room has no conventional entrances.");
else
try
for exit in (this.entrances)
try
player:tell(exit.name, " (", exit, ") comes from ", valid(exit.source) ? exit.source.name | "???", " (", exit.source, ") via {", $string_utils:from_list(exit.aliases, ", "), "}.");
except (ANY)
player:tell("Bad entrance object or missing .source property: ", $string_utils:nn(exit));
continue exit;
endtry
endfor
except (E_TYPE)
player:tell("Bad .entrances property. This should be a list of exit objects. Please fix this.");
endtry
endif
-------------------------------------------------------------------------------
#3 generic room:go any ?-2? any
if ((!args) || (!(dir = args[1])))
player:tell("You need to specify a direction.");
return E_INVARG;
elseif (valid(exit = player.location:match_exit(dir)))
exit:invoke();
if (length(args) > 1)
old_room = player.location;
"Now give objects in the room we just entered a chance to act.";
suspend(0);
if (player.location == old_room)
"player didn't move or get moved while we were suspended";
player.location:go(@listdelete(args, 1));
endif
endif
elseif (exit == $failed_match)
player:tell("You can't go that way (", dir, ").");
else
player:tell("I don't know which direction `", dir, "' you mean.");
endif
-------------------------------------------------------------------------------
#3 generic room:l*ook any ?-2? any
if ((dobjstr == "") && (!prepstr))
this:look_self();
elseif ((prepstr != "in") && (prepstr != "on"))
if ((!dobjstr) && (prepstr == "at"))
dobjstr = iobjstr;
iobjstr = "";
else
dobjstr = dobjstr + (prepstr && ((dobjstr && " ") + prepstr));
dobjstr = dobjstr + (iobjstr && ((dobjstr && " ") + iobjstr));
endif
dobj = this:match_object(dobjstr);
if (!$command_utils:object_match_failed(dobj, dobjstr))
dobj:look_self();
endif
elseif (!iobjstr)
player:tell(verb, " ", prepstr, " what?");
else
iobj = this:match_object(iobjstr);
if (!$command_utils:object_match_failed(iobj, iobjstr))
if (dobjstr == "")
iobj:look_self();
elseif ((thing = iobj:match(dobjstr)) == $failed_match)
player:tell("I don't see any \"", dobjstr, "\" ", prepstr, " ", iobj.name, ".");
elseif (thing == $ambiguous_match)
player:tell("There are several things ", prepstr, " ", iobj.name, " one might call \"", dobjstr, "\".");
else
thing:look_self();
endif
endif
endif
-------------------------------------------------------------------------------
#3 generic room:announce_all this n/a this
for dude in (this:contents())
try
dude:tell(@args);
except (ANY)
"Just ignore the dude with the stupid :tell";
continue dude;
endtry
endfor
-------------------------------------------------------------------------------
#3 generic room:announce_all_but this n/a this
":announce_all_but(LIST objects to ignore, text)";
{ignore, @text} = args;
contents = this:contents();
for l in (ignore)
contents = setremove(contents, l);
endfor
for listener in (contents)
try
listener:tell(@text);
except (ANY)
"Ignure listener with bad :tell";
continue listener;
endtry
endfor
-------------------------------------------------------------------------------
#3 generic room:enterfunc this n/a this
object = args[1];
if (is_player(object) && (object.location == this))
player = object;
this:look_self(player.brief);
endif
if (object == this.blessed_object)
this.blessed_object = #-1;
endif
-------------------------------------------------------------------------------
#3 generic room:exitfunc this n/a this
return;
-------------------------------------------------------------------------------
#3 generic room:remove_exit this n/a this
exit = args[1];
if (caller != exit)
set_task_perms(caller_perms());
endif
return `this.exits = setremove(this.exits, exit) ! E_PERM' != E_PERM;
-------------------------------------------------------------------------------
#3 generic room:remove_entrance this n/a this
exit = args[1];
if (caller != exit)
set_task_perms(caller_perms());
endif
return `this.entrances = setremove(this.entrances, exit) ! E_PERM' != E_PERM;
-------------------------------------------------------------------------------
#3 generic room:@add-exit any n/a none
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @add-exit <exit-number>");
return;
endif
exit = this:match_object(dobjstr);
if ($command_utils:object_match_failed(exit, dobjstr))
return;
endif
if (!($exit in $object_utils:ancestors(exit)))
player:tell("That doesn't look like an exit object to me...");
return;
endif
try
dest = exit.dest;
except (E_PERM)
player:tell("You can't read the exit's destination to check that it's consistent!");
return;
endtry
try
source = exit.source;
except (E_PERM)
player:tell("You can't read that exit's source to check that it's consistent!");
return;
endtry
if (source == $nothing)
player:tell("That exit's source has not yet been set; set it to be this room, then run @add-exit again.");
return;
elseif (source != this)
player:tell("That exit wasn't made to be attached here; it was made as an exit from ", source.name, " (", source, ").");
return;
elseif (((typeof(dest) != OBJ) || (!valid(dest))) || (!($room in $object_utils:ancestors(dest))))
player:tell("That exit doesn't lead to a room!");
return;
endif
if (!this:add_exit(exit))
player:tell("Sorry, but you must not have permission to add exits to this room.");
else
player:tell("You have added ", exit, " as an exit that goes to ", exit.dest.name, " (", exit.dest, ") via ", $string_utils:english_list(setadd(exit.aliases, exit.name)), ".");
endif
-------------------------------------------------------------------------------
#3 generic room:@add-entrance any n/a none
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @add-entrance <exit-number>");
return;
endif
exit = this:match_object(dobjstr);
if ($command_utils:object_match_failed(exit, dobjstr))
return;
endif
if (!($exit in $object_utils:ancestors(exit)))
player:tell("That doesn't look like an exit object to me...");
return;
endif
try
dest = exit.dest;
except (E_PERM)
player:tell("You can't read the exit's destination to check that it's consistent!");
return;
endtry
if (dest != this)
player:tell("That exit doesn't lead here!");
return;
endif
if (!this:add_entrance(exit))
player:tell("Sorry, but you must not have permission to add entrances to this room.");
else
player:tell("You have added ", exit, " as an entrance that gets here via ", $string_utils:english_list(setadd(exit.aliases, exit.name)), ".");
endif
-------------------------------------------------------------------------------
#3 generic room:recycle this n/a this
"Make a mild attempt to keep people and objects from ending up in #-1 when people recycle a room";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
"... first try spilling them out onto the floor of enclosing room if any";
if (valid(this.location))
for x in (this.contents)
try
x:moveto(this.location);
except (ANY)
continue x;
endtry
endfor
endif
"... try sending them home...";
for x in (this.contents)
if (is_player(x))
if ((typeof(x.home) == OBJ) && valid(x.home))
try
x:moveto(x.home);
except (ANY)
continue x;
endtry
endif
if (x.location == this)
move(x, $player_start);
endif
elseif (valid(x.owner))
try
x:moveto(x.owner);
except (ANY)
continue x;
endtry
endif
endfor
pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#3 generic room:e east w west s south n north ne northeast nw northwest se southeast sw southwest u up d down none n/a none
set_task_perms((caller_perms() == #-1) ? player | caller_perms());
exit = this:match_exit(verb);
if (valid(exit))
exit:invoke();
elseif (exit == $failed_match)
player:tell("You can't go that way.");
else
player:tell("I don't know which direction `", verb, "' you mean.");
endif
-------------------------------------------------------------------------------
#3 generic room:@eject @eject! @eject!! any n/a none
set_task_perms(player);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
elseif (dobj.location != this)
is = $gender_utils:get_conj("is", dobj);
player:tell(dobj.name, "(", dobj, ") ", is, " not here.");
return;
elseif (!$perm_utils:controls(player, this))
player:tell("You are not the owner of this room.");
return;
elseif (dobj.wizard)
player:tell("Sorry, you can't ", verb, " a wizard.");
dobj:tell(player.name, " tried to ", verb, " you.");
return;
endif
iobj = this;
player:tell(this:ejection_msg());
this:((verb == "@eject") ? "eject" | "eject_basic")(dobj);
if (verb != "@eject!!")
dobj:tell(this:victim_ejection_msg());
endif
this:announce_all_but({player, dobj}, this:oejection_msg());
-------------------------------------------------------------------------------
#3 generic room:ejection_msg oejection_msg victim_ejection_msg this n/a this
return $gender_utils:pronoun_sub(this.(verb));
-------------------------------------------------------------------------------
#3 generic room:accept_for_abode this n/a this
who = args[1];
return this:basic_accept_for_abode(who) && this:acceptable(who);
-------------------------------------------------------------------------------
#3 generic room:@resident*s any n/a none
if (!$perm_utils:controls(player, this))
player:tell("You must own this room to manipulate the legal residents list.  Try contacting ", this.owner.name, ".");
else
if (typeof(this.residents) != LIST)
this.residents = {this.residents};
endif
if (!dobjstr)
"First, remove !valid objects from this room...";
for x in (this.residents)
if ((typeof(x) != OBJ) || (!$recycler:valid(x)))
player:tell("Warning: removing ", x, ", an invalid object, from the residents list.");
this.residents = setremove(this.residents, x);
endif
endfor
player:tell("Allowable residents in this room:  ", $string_utils:english_list($list_utils:map_prop(this.residents, "name"), "no one"), ".");
return;
elseif (dobjstr[1] == "!")
notflag = 1;
dobjstr = dobjstr[2..$];
else
notflag = 0;
endif
result = $string_utils:match_player_or_object(dobjstr);
if (!result)
return;
else
"a one element list was returned to us if it won.";
result = result[1];
if (notflag)
if (!(result in this.residents))
player:tell(result.name, " doesn't appear to be in the residents list of ", this.name, ".");
else
this.residents = setremove(this.residents, result);
player:tell(result.name, " removed from the residents list of ", this.name, ".");
endif
else
if (result in this.residents)
is = $gender_utils:get_conj("is", result);
player:tell(result.name, " ", is, " already an allowed resident of ", this.name, ".");
else
this.residents = {@this.residents, result};
player:tell(result.name, " added to the residents list of ", this.name, ".");
endif
endif
endif
endif
-------------------------------------------------------------------------------
#3 generic room:match this n/a this
target = {@this:contents(), @this:exits()};
return $string_utils:match(args[1], target, "name", target, "aliases");
-------------------------------------------------------------------------------
#3 generic room:@remove-exit any n/a none
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @remove-exit <exit>");
return;
endif
exit = this:match_object(dobjstr);
if (!(exit in this.exits))
if ($command_utils:object_match_failed(exit, dobjstr))
return;
endif
player:tell("Couldn't find \"", dobjstr, "\" in the exits list of ", this.name, ".");
return;
elseif (!this:remove_exit(exit))
player:tell("Sorry, but you do not have permission to remove exits from this room.");
else
name = valid(exit) ? exit.name | "<recycled>";
player:tell("Exit ", exit, " (", name, ") removed from exit list of ", this.name, " (", this, ").");
endif
-------------------------------------------------------------------------------
#3 generic room:@remove-entrance any n/a none
set_task_perms(player);
if (!dobjstr)
player:tell("Usage:  @remove-entrance <entrance>");
return;
endif
entrance = $string_utils:match(dobjstr, this.entrances, "name", this.entrances, "aliases");
if (!valid(entrance))
"Try again to parse it.  Maybe they gave object number.  Don't complain if it's invalid though; maybe it's been recycled in some nefarious way.";
entrance = this:match_object(dobjstr);
endif
if (!(entrance in this.entrances))
player:tell("Couldn't find \"", dobjstr, "\" in the entrances list of ", this.name, ".");
return;
elseif (!this:remove_entrance(entrance))
player:tell("Sorry, but you do not have permission to remove entrances from this room.");
else
name = valid(entrance) ? entrance.name | "<recycled>";
player:tell("Entrance ", entrance, " (", name, ") removed from entrance list of ", this.name, " (", this, ").");
endif
-------------------------------------------------------------------------------
#3 generic room:moveto this n/a this
if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#3 generic room:who_location_msg this n/a this
return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg, args[1]) | "";
-------------------------------------------------------------------------------
#3 generic room:exits entrances this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return this.(verb);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#3 generic room:obvious_exits obvious_entrances this n/a this
exits = {};
for exit in (`(verb == "obvious_exits") ? this.exits | this.entrances ! ANY => {}')
if (`$code_utils:verb_or_property(exit, "obvious") ! ANY')
exits = setadd(exits, exit);
endif
endfor
return exits;
-------------------------------------------------------------------------------
#3 generic room:here_huh this n/a this
":here_huh(verb,args)  -- room-specific :huh processing.  This should return 1 if it finds something interesting to do and 0 otherwise; see $command_utils:do_huh.";
"For the generic room, we check for the case of the caller specifying an exit for which a corresponding verb was never defined.";
set_task_perms(caller_perms());
if (args[2] || ($failed_match == (exit = this:match_exit(verb = args[1]))))
"... okay, it's not an exit.  we give up...";
return 0;
elseif (valid(exit))
exit:invoke();
else
"... ambiguous exit ...";
player:tell("I don't know which direction `", verb, "' you mean.");
endif
return 1;
-------------------------------------------------------------------------------
#3 generic room:room_announce*_all_but this n/a this
this:(verb[6..$])(@args);
-------------------------------------------------------------------------------
#3 generic room:examine_commands_ok this n/a this
return this == args[1].location;
-------------------------------------------------------------------------------
#3 generic room:examine_key this n/a this
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr(this:title(), " will accept only objects matching the following key:"), tostr("  ", $lock_utils:unparse_key(this.key))};
endif
-------------------------------------------------------------------------------
#3 generic room:examine_contents this n/a this
"examine_contents(who)";
if (caller == this)
this:tell_contents(this.contents, this.ctype);
endif
-------------------------------------------------------------------------------
#3 generic room:free_entry this n/a this
return this.free_entry;
-------------------------------------------------------------------------------
#3 generic room:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
if (this == $player_start)
"... If there are ever multiple rooms, then the question of";
"....which one is to be $player_start may well be an option of some sort,";
"... so this goes better here than hardcoded into some specific room:init_for_core verb.";
move(player, this);
endif
endif
-------------------------------------------------------------------------------
#3 generic room:dark this n/a this
return this.(verb);
-------------------------------------------------------------------------------
#3 generic room:announce_lines_x this n/a this
"Copied from generic room (#3):announce by Haakon (#2) Thu Oct 24 16:15:01 1996 PDT";
for dude in (setremove(this:contents(), player))
try
dude:tell_lines(@args);
except id (ANY)
endtry
endfor
-------------------------------------------------------------------------------
#3 generic room:basic_accept_for_abode this n/a this
who = args[1];
return valid(who) && ((this.free_home || $perm_utils:controls(who, this)) || ((typeof(residents = this.residents) == LIST) ? who in this.residents | (who == this.residents)));
-------------------------------------------------------------------------------
================================#4 generic builder===============================================
#4 generic builder.build_options rc = MOOList [ ]
#4 generic builder:@quota any n/a none
set_task_perms(player);
if (dobjstr == "")
dobj = player;
else
dobj = $string_utils:match_player(dobjstr);
endif
if (!valid(dobj))
player:notify("Show whose quota?");
return;
endif
$quota_utils:display_quota(dobj);
try
if (dobj in $local.informed_quota_consumers.uninformed_quota_consumers)
player:notify(tostr("Note that quota is held in escrow -- `look ", $local.informed_quota_consumers, "' for more details."));
endif
except id (ANY)
endtry
-------------------------------------------------------------------------------
#4 generic builder:@create any ?-2? any
set_task_perms(player);
nargs = length(args);
pos = "named" in args;
if ((pos <= 1) || (pos == nargs))
pos = "called" in args;
endif
if ((pos <= 1) || (pos == nargs))
player:notify("Usage:  @create <parent-class> named [name:]alias,...,alias");
player:notify("   or:  @create <parent-class> named name-and-alias,alias,...,alias");
player:notify("");
player:notify("where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.");
player:notify("You can use \"called\" instead of \"named\", if you wish.");
return;
endif
parentstr = $string_utils:from_list(args[1..pos - 1], " ");
namestr = $string_utils:from_list(args[pos + 1..$], " ");
if (!namestr)
player:notify("You must provide a name.");
return;
endif
if (parentstr[1] == "$")
parent = $string_utils:literal_object(parentstr);
if ((parent == $failed_match) || (typeof(parent) != OBJ))
player:notify(tostr("\"", parentstr, "\" does not name an object."));
return;
endif
else
parent = player:my_match_object(parentstr);
if ($command_utils:object_match_failed(parent, parentstr))
return;
endif
endif
object = player:_create(parent);
if (typeof(object) == ERR)
player:notify(tostr(object));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
object.(f) = 1;
endfor
"move() shouldn't, but could bomb. Say if player has a stupid :accept";
`move(object, player) ! ANY';
$building_utils:set_names(object, namestr);
if ((other_names = setremove(object.aliases, object.name)) != {})
aka = (" (aka " + $string_utils:english_list(other_names)) + ")";
else
aka = "";
endif
player:notify(tostr("You now have ", object.name, aka, " with object number ", object, " and parent ", parent.name, " (", parent, ")."));
-------------------------------------------------------------------------------
#4 generic builder:@recycle any n/a none
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if (dobj == $nothing)
player:notify(tostr("Usage:  ", verb, " <object>"));
elseif ($command_utils:object_match_failed(dobj, dobjstr))
"...bogus object...";
elseif (player == dobj)
player:notify($wiz_utils.suicide_string);
elseif (!$perm_utils:controls(player, dobj))
player:notify(tostr(E_PERM));
else
name = dobj.name;
result = player:_recycle(dobj);
if (typeof(result) == ERR)
player:notify(tostr(result));
else
player:notify(tostr(name, " (", dobj, ") recycled."));
endif
endif
-------------------------------------------------------------------------------
#4 generic builder:@recreate any for/abount any
"@recreate <object> as <parent-class> named [name:]alias,alias,...";
"  effectively recycles and creates <object> all over again.";
set_task_perms(player);
as = prepstr in args;
named = "named" in args;
if ((named <= (as + 1)) || (named == length(args)))
named = "called" in args;
endif
if ((named <= (as + 1)) || (named == length(args)))
player:notify_lines({tostr("Usage:  ", verb, " <object> as <parent-class> named [name:]alias,...,alias"), "", "where <parent-class> is one of the standard classes ($note, $letter, $thing, or $container) or an object number (e.g., #999), or the name of some object in the current room.  The [name:]alias... specification is as in @create.", "", "You can use \"called\" instead of \"named\", if you wish."});
return;
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
return;
elseif (is_player(dobj))
player:notify("You really *don't* want to do that!");
return;
endif
parentstr = $string_utils:from_list(args[as + 1..named - 1], " ");
namestr = $string_utils:from_list(args[named + 1..$], " ");
if (parentstr[1] == "$")
parent = $string_utils:literal_object(parentstr);
if ((parent == $failed_match) || (typeof(parent) != OBJ))
player:notify(tostr("\"", parentstr, "\" does not name an object."));
return;
endif
else
parent = player:my_match_object(parentstr);
if ($command_utils:object_match_failed(parent, parentstr))
return;
endif
endif
if (!(e = $building_utils:recreate(dobj, parent)))
player:notify(tostr(e));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
dobj.(f) = 1;
endfor
"move() shouldn't, but could, bomb. Say if player has a stupid :accept";
`move(dobj, player) ! ANY';
$building_utils:set_names(dobj, namestr);
if ((other_names = setremove(dobj.aliases, dobj.name)) != {})
aka = (" (aka " + $string_utils:english_list(other_names)) + ")";
else
aka = "";
endif
player:notify(tostr("Object number ", dobj, " is now ", dobj.name, aka, " with parent ", parent.name, " (", parent, ")."));
-------------------------------------------------------------------------------
#4 generic builder:@dig any ?-2? any
set_task_perms(player);
nargs = length(args);
if (nargs == 1)
room = args[1];
exit_spec = "";
elseif ((nargs >= 3) && (args[2] == "to"))
exit_spec = args[1];
room = $string_utils:from_list(args[3..$], " ");
elseif (argstr && (!prepstr))
room = argstr;
exit_spec = "";
else
player:notify(tostr("Usage:  ", verb, " <new-room-name>"));
player:notify(tostr("    or  ", verb, " <exit-description> to <new-room-name-or-old-room-object-number>"));
return;
endif
if (room != tostr(other_room = toobj(room)))
room_kind = player:build_option("dig_room");
if (room_kind == 0)
room_kind = $room;
endif
other_room = player:_create(room_kind);
if (typeof(other_room) == ERR)
player:notify(tostr("Cannot create new room as a child of ", $string_utils:nn(room_kind), ": ", other_room, ".  See `help @build-options' for information on how to specify the kind of room this command tries to create."));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
other_room.(f) = 1;
endfor
other_room.name = room;
other_room.aliases = {room};
move(other_room, $nothing);
player:notify(tostr(other_room.name, " (", other_room, ") created."));
elseif (nargs == 1)
player:notify("You can't dig a room that already exists!");
return;
elseif ((!valid(player.location)) || (!($room in $object_utils:ancestors(player.location))))
player:notify(tostr("You may only use the ", verb, " command from inside a room."));
return;
elseif ((!valid(other_room)) || (!($room in $object_utils:ancestors(other_room))))
player:notify(tostr(other_room, " doesn't look like a room to me..."));
return;
endif
if (exit_spec)
exit_kind = player:build_option("dig_exit");
if (exit_kind == 0)
exit_kind = $exit;
endif
exits = $string_utils:explode(exit_spec, "|");
if ((length(exits) < 1) || (length(exits) > 2))
player:notify("The exit-description must have the form");
player:notify("     [name:]alias,...,alias");
player:notify("or   [name:]alias,...,alias|[name:]alias,...,alias");
return;
endif
do_recreate = !player:build_option("bi_create");
to_ok = $building_utils:make_exit(exits[1], player.location, other_room, do_recreate, exit_kind);
if (to_ok && (length(exits) == 2))
$building_utils:make_exit(exits[2], other_room, player.location, do_recreate, exit_kind);
endif
endif
-------------------------------------------------------------------------------
#4 generic builder:@audit any ?-2? any
"Usage:  @audit [player] [from <start>] [to <end>] [for <matching string>]";
set_task_perms(player);
dobj = $string_utils:match_player(dobjstr);
if (!dobjstr)
dobj = player;
elseif ($command_utils:player_match_result(dobj, dobjstr)[1])
return;
endif
dobjwords = $string_utils:words(dobjstr);
if (args[1..length(dobjwords)] == dobjwords)
args = args[length(dobjwords) + 1..$];
endif
if (!(parse_result = $code_utils:_parse_audit_args(@args)))
player:notify(tostr("Usage:  ", verb, " [player] [from <start>] [to <end>] [for <match>]"));
return;
endif
return $building_utils:do_audit(dobj, @parse_result);
-------------------------------------------------------------------------------
#4 generic builder:@count any n/a none
if (!dobjstr)
dobj = player;
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
endif
set_task_perms(player);
if (typeof(dobj.owned_objects) == LIST)
count = length(dobj.owned_objects);
player:notify(tostr(dobj.name, " currently owns ", count, " object", (count == 1) ? "." | "s."));
if ($quota_utils.byte_based)
player:notify(tostr("Total bytes consumed:  ", $string_utils:group_number($quota_utils:get_size_quota(dobj)[2]), "."));
endif
else
player:notify(tostr(dobj.name, " is not enrolled in the object ownership system.  Use @countDB instead."));
endif
-------------------------------------------------------------------------------
#4 generic builder:@countDB any n/a none
if (!dobjstr)
dobj = player;
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
endif
set_task_perms(player);
count = 0;
for o in [#1..max_object()]
if ($command_utils:running_out_of_time())
player:notify("Counting...");
suspend(5);
endif
if (valid(o) && (o.owner == dobj))
count = count + 1;
endif
endfor
player:notify(tostr(dobj.name, " currently owns ", count, " object", (count == 1) ? "." | "s."));
-------------------------------------------------------------------------------
#4 generic builder:@sort-owned*-objects any n/a none
"$player:owned_objects -- sorts a players .owned_objects property in ascending";
"order so it looks nice on @audit.";
if (player != this)
return E_PERM;
endif
if (typeof(player.owned_objects) == LIST)
if ((!dobjstr) || (index("object", dobjstr) == 1))
ret = $list_utils:sort_suspended(0, player.owned_objects);
elseif (index("size", dobjstr) == 1)
ret = $list_utils:reverse_suspended($list_utils:sort_suspended(0, player.owned_objects, $list_utils:slice($list_utils:map_prop(player.owned_objects, "object_size"))));
endif
if (typeof(ret) == LIST)
player.owned_objects = ret;
player:tell("Your .owned_objects list has been sorted.");
return 1;
else
player:tell("Something went wrong. .owned_objects not sorted.");
return 0;
endif
else
player:tell("You are not enrolled in .owned_objects scheme, sorry.");
endif
-------------------------------------------------------------------------------
#4 generic builder:@add-owned any n/a none
if (player != this)
player:tell("Permission Denied");
return E_PERM;
endif
if (!valid(dobj))
player:tell("Don't understand `", dobjstr, "' as an object to add.");
elseif (dobj.owner != player)
player:tell("You don't own ", dobj.name, ".");
elseif (dobj in player.owned_objects)
player:tell(dobj.name, " is already recorded in your .owned_objects.");
else
player.owned_objects = setadd(player.owned_objects, dobj);
player:tell("Added ", dobj, " to your .owned_objects.");
endif
-------------------------------------------------------------------------------
#4 generic builder:@verify-owned none n/a none
for x in (player.owned_objects)
if ((!valid(x)) || (x.owner != player))
player.owned_objects = setremove(player.owned_objects, x);
if (valid(x))
player:tell("Removing ", x.name, "(", x, "), owned by ", valid(x.owner) ? x.owner.name | "<recycled player>", " from your .owned_objects property.");
else
player:tell("Removing invalid object ", x, " from your .owned_objects property.");
endif
endif
$command_utils:suspend_if_needed(2, tostr("Suspending @verify-owned ... ", x));
endfor
player:tell(".owned_objects property verified.");
-------------------------------------------------------------------------------
#4 generic builder:@unlock any n/a none
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
try
dobj.key = 0;
player:notify(tostr("Unlocked ", dobj.name, "."));
except error (ANY)
player:notify(error[2]);
endtry
-------------------------------------------------------------------------------
#4 generic builder:@lock any none any
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
key = $lock_utils:parse_keyexp(iobjstr, player);
if (typeof(key) == STR)
player:notify("That key expression is malformed:");
player:notify(tostr("  ", key));
else
try
dobj.key = key;
player:notify(tostr("Locked ", dobj.name, " to this key:"));
player:notify(tostr("  ", $lock_utils:unparse_key(key)));
except error (ANY)
player:notify(error[2]);
endtry
endif
-------------------------------------------------------------------------------
#4 generic builder:@newmess*age any ?-2? any
"Usage:  @newmessage <message-name> [<message>] [on <object>]";
"Add a message property to an object (default is player), and optionally";
"set its value.  For use by non-programmers, who aren't allowed to add";
"properties generally.";
"To undo the effects of this, use @unmessage.";
set_task_perms(player);
dobjwords = $string_utils:words(dobjstr);
if (!dobjwords)
player:notify(tostr("Usage:  ", verb, " <message-name> [<message>] [on <object>]"));
return;
endif
object = valid(iobj) ? iobj | player;
name = this:_messagify(dobjwords[1]);
value = dobjstr[length(dobjwords[1]) + 2..$];
nickname = "@" + name[1..$ - 4];
e = `add_property(object, name, value, {player, "rc"}) ! ANY';
if (typeof(e) != ERR)
player:notify(tostr(nickname, " on ", object.name, " is now \"", object.(name), "\"."));
elseif (e != E_INVARG)
player:notify(tostr(e));
elseif ($object_utils:has_property(object, name))
"object already has property";
player:notify(tostr(object.name, " already has a ", nickname, " message."));
else
player:notify(tostr("Unable to add ", nickname, " message to ", object.name, ": ", e));
endif
-------------------------------------------------------------------------------
#4 generic builder:@unmess*age any ?-2? any
"Usage:  @unmessage <message-name> [from <object>]";
"Remove a message property from an object (default is player).";
set_task_perms(player);
if ((!dobjstr) || (length($string_utils:words(dobjstr)) > 1))
player:notify(tostr("Usage:  ", verb, " <message-name> [from <object>]"));
return;
endif
object = valid(iobj) ? iobj | player;
name = this:_messagify(dobjstr);
nickname = "@" + name[1..$ - 4];
try
delete_property(object, name);
player:notify(tostr(nickname, " message removed from ", object.name, "."));
except (E_PROPNF)
player:notify(tostr("No ", nickname, " message found on ", object.name, "."));
except error (ANY)
player:notify(error[2]);
endtry
-------------------------------------------------------------------------------
#4 generic builder:_messagify this n/a this
"Given any of several formats people are likely to use for a @message";
"property, return the canonical form (\"foobar_msg\").";
name = args[1];
if (name[1] == "@")
name = name[2..$];
endif
if ((length(name) < 4) || (name[$ - 3..$] != "_msg"))
name = name + "_msg";
endif
return name;
-------------------------------------------------------------------------------
#4 generic builder:@kids any n/a none
"'@kids <obj>' - List the children of an object. This is handy for seeing whether anybody's actually using your carefully-wrought public objects.";
thing = player:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(thing, dobjstr))
kids = children(thing);
if (kids)
player:notify(tostr(thing:title(), "(", thing, ") has ", length(kids), " kid", (length(kids) == 1) ? "" | "s", "."));
player:notify(tostr($string_utils:names_of(kids)));
else
player:notify(tostr(thing:title(), "(", thing, ") has no kids."));
endif
endif
-------------------------------------------------------------------------------
#4 generic builder:@contents any n/a none
"'@contents <obj> - list the contents of an object, with object numbers.";
set_task_perms(player);
if (!dobjstr)
dobj = player.location;
else
dobj = player:my_match_object(dobjstr);
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
else
contents = dobj.contents;
if (contents)
player:notify(tostr(dobj:title(), "(", dobj, ") contains:"));
player:notify(tostr($string_utils:names_of(contents)));
else
player:notify(tostr(dobj:title(), "(", dobj, ") contains nothing."));
endif
endif
-------------------------------------------------------------------------------
#4 generic builder:@par*ents any n/a none
"'@parents <thing>' - List <thing> and its ancestors, all the way back to the Root Class (#1).";
if (player != this)
return player:notify("Permission denied: not a builder.");
elseif (!dobjstr)
player:notify(tostr("Usage:  ", verb, " <object>"));
return;
endif
set_task_perms(player);
o = player:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(o, dobjstr))
player:notify($string_utils:names_of({o, @$object_utils:ancestors(o)}));
endif
-------------------------------------------------------------------------------
#4 generic builder:@location*s any n/a none
"@locations <thing> - List <thing> and its containers, all the way back to the outermost one.";
set_task_perms(player);
if (!dobjstr)
what = player;
elseif ((!valid(what = player:my_match_object(dobjstr))) && (!valid(what = $string_utils:match_player(dobjstr))))
$command_utils:object_match_failed(dobj, dobjstr);
return;
endif
player:notify($string_utils:names_of({what, @$object_utils:locations(what)}));
-------------------------------------------------------------------------------
#4 generic builder:@cl*asses any ?-2? any
"$class_registry is in the following format:";
"        { {name, description, members}, ... }";
"where `name' is the name of a particular class of objects, `description' is a one-sentence description of the membership of the class, and `members' is a list of object numbers, the members of the class.";
"";
if (!$command_utils:yes_or_no("This command can be very spammy.  Are you certain you need this information?"))
return player:tell("OK, aborting.  The lag thanks you.");
endif
if (args)
members = {};
for name in (args)
class = $list_utils:assoc_prefix(name, $class_registry);
if (class)
for o in (class[3])
members = setadd(members, o);
endfor
else
player:tell("There is no defined class of objects named `", name, "'; type `@classes' to see a complete list of defined classes.");
return;
endif
endfor
printed = {};
for o in (members)
what = o;
while (valid(what))
printed = setadd(printed, what);
what = parent(what);
endwhile
endfor
player:tell("Members of the class", (length(args) > 1) ? "es" | "", " named ", $string_utils:english_list(args), ":");
player:tell();
set_task_perms(player);
this:classes_2($root_class, "", members, printed);
player:tell();
else
"List all class names and descriptions";
player:tell("The following classes of objects have been defined:");
for class in ($class_registry)
name = class[1];
description = class[2];
player:tell();
player:tell("-- ", name, ": ", description);
endfor
player:tell();
player:tell("Type `@classes <name>' to see the members of the class with the given <name>.");
endif
-------------------------------------------------------------------------------
#4 generic builder:classes_2 this n/a this
{root, indent, members, printed} = args;
if (root in members)
player:tell(indent, root.name, " (", root, ")");
else
player:tell(indent, "<", root.name, " (", root, ")>");
endif
printed = setremove(printed, root);
indent = indent + "  ";
set_task_perms(caller_perms());
for c in ($list_utils:sort_suspended(2, $set_utils:intersection(children(root), printed)))
$command_utils:suspend_if_needed(10);
this:classes_2(c, indent, members, printed);
endfor
-------------------------------------------------------------------------------
#4 generic builder:_create this n/a this
set_task_perms(caller_perms());
if (this:build_option("bi_create"))
return $quota_utils:bi_create(@args);
else
return $recycler:(verb)(@args);
endif
-------------------------------------------------------------------------------
#4 generic builder:_recycle this n/a this
set_task_perms(caller_perms());
if (this:build_option("bi_create"))
return recycle(@args);
else
return $recycler:(verb)(@args);
endif
-------------------------------------------------------------------------------
#4 generic builder:@chparent any any any
set_task_perms(player);
if ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))
"...bogus object...";
elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))
"...bogus new parent...";
elseif ((this != player) && (!$object_utils:isa(player, $player)))
"...They chparented to #1 and want to chparent back to $prog.  Probably for some nefarious purpose...";
player:notify("You don't seem to already be a valid player class.  Perhaps chparenting away from the $player hierarchy was not such a good idea.  Permission denied.");
elseif (is_player(object) && (!$object_utils:isa(parent, $player)))
player:notify(tostr(object, " is a player and ", parent, " is not a player class."));
player:notify("You really *don't* want to do this.  Trust me.");
else
if ($object_utils:isa(object, $mail_recipient))
if (!$command_utils:yes_or_no("Chparenting a mailing list is usually a really bad idea.  Do you really want to do it?  (If you don't know why we're asking this question, please say 'no'.)"))
return player:tell("Aborted.");
endif
endif
try
result = player:_chparent(object, parent);
player:notify("Parent changed.");
except (E_INVARG)
if (valid(object) && valid(parent))
player:notify(tostr("Some property existing on ", parent, " is defined on ", object, " or one of its descendants."));
player:notify(tostr("Try @check-chparent ", dobjstr, " to ", iobjstr));
else
player:notify("Either that is not a valid object or not a valid parent");
endif
except (E_PERM)
player:notify("Either you don't own the object, don't own the parent, or the parent is not fertile.");
except (E_RECMOVE)
player:notify("That parent object is a descendant of the object!");
endtry
endif
-------------------------------------------------------------------------------
#4 generic builder:@check-chp*arent any any any
"Copied from generic programmer (#217):@check-chparent by ur-Rog (#6349) Sun Nov  8 22:13:53 1992 PST";
"@check-chparent object to newparent";
"checks for property name conflicts that would make @chparent bomb.";
set_task_perms(player);
if (!(dobjstr && iobjstr))
player:notify(tostr("Usage:  ", verb, " <object> to <newparent>"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(dobjstr), dobjstr))
"...bogus object...";
elseif ($command_utils:object_match_failed(parent = player:my_match_object(iobjstr), iobjstr))
"...bogus new parent...";
elseif (player != this)
player:notify(tostr(E_PERM));
elseif (typeof(result = $object_utils:property_conflicts(object, parent)) == ERR)
player:notify(tostr(result));
elseif (result)
su = $string_utils;
player:notify("");
player:notify(su:left("Property", 30) + "Also Defined on");
player:notify(su:left("--------", 30) + "---------------");
for r in (result)
player:notify(su:left(tostr(parent, ".", r[1]), 30) + su:from_list(listdelete(r, 1), " "));
$command_utils:suspend_if_needed(0);
endfor
else
player:notify("No property conflicts found.");
endif
-------------------------------------------------------------------------------
#4 generic builder:@set*prop any any any
"Syntax:  @set <object>.<prop-name> to <value>";
"";
"Changes the value of the specified object's property to the given value.";
"You must have permission to modify the property, either because you own the property or if it is writable.";
set_task_perms(player);
if (this != player)
return player:tell(E_PERM);
endif
l = $code_utils:parse_propref(dobjstr);
if (l)
dobj = player:my_match_object(l[1], player.location);
if ($command_utils:object_match_failed(dobj, l[1]))
return;
endif
prop = l[2];
to_i = "to" in args;
at_i = "at" in args;
i = (to_i && at_i) ? min(to_i, at_i) | (to_i || at_i);
iobjstr = argstr[$string_utils:word_start(argstr)[i][2] + 1..$];
iobjstr = $string_utils:trim(iobjstr);
if (!iobjstr)
try
val = dobj.(prop) = "";
except e (ANY)
player:tell("Unable to set ", dobj, ".", prop, ": ", e[2]);
return;
endtry
iobjstr = "\"\"";
"elseif (iobjstr[1] == \"\\\"\")";
"val = dobj.(prop) = iobjstr;";
"iobjstr = \"\\\"\" + iobjstr + \"\\\"\";";
else
val = $string_utils:to_value(iobjstr);
if (!val[1])
player:tell("Could not parse: ", iobjstr);
return;
elseif (!$object_utils:has_property(dobj, prop))
player:tell("That object does not define that property.");
return;
endif
try
val = dobj.(prop) = val[2];
except e (ANY)
player:tell("Unable to set ", dobj, ".", prop, ": ", e[2]);
return;
endtry
endif
player:tell("Property ", dobj, ".", prop, " set to ", $string_utils:print(val), ".");
else
player:tell("Property ", dobjstr, " not found.");
endif
-------------------------------------------------------------------------------
#4 generic builder:build_option this n/a this
":build_option(name)";
"Returns the value of the specified builder option";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return $build_options:get(this.build_options, args[1]);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#4 generic builder:set_build_option this n/a this
":set_build_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
"...this is kludgy, but it saves me from writing the same verb n times.";
"...there's got to be a better way to do this...";
verb[1..4] = "";
foo_options = verb + "s";
"...";
if (typeof(s = #0.(foo_options):set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
return 1;
endif
-------------------------------------------------------------------------------
#4 generic builder:@build-o*ptions @buildo*ptions @builder-o*ptions @buildero*ptions any ?-2? any
"@<what>-option <option> [is] <value>   sets <option> to <value>";
"@<what>-option <option>=<value>        sets <option> to <value>";
"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@<what>-option -<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option !<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option <option>      displays value of <option>";
set_task_perms(player);
what = "build";
options = what + "_options";
option_pkg = #0.(options);
set_option = ("set_" + what) + "_option";
if (!args)
player:notify_lines({("Current " + what) + " options:", "", @option_pkg:show(this.(options), option_pkg.names)});
return;
elseif (typeof(presult = option_pkg:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:(set_option)(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines(option_pkg:show(this.(options), presult[1]));
endif
-------------------------------------------------------------------------------
#4 generic builder:@meas*ure any ?-2? any
"Syntax:";
"  @measure object <object name>";
"  @measure summary [player]";
"  @measure new [player]";
"  @measure breakdown <object name>";
"  @measure recent [number of days] [player]";
if (length(args) < 1)
player:tell_lines($code_utils:verb_documentation());
return;
endif
if (index("object", args[1]) == 1)
"Object.";
what = player.location:match_object(name = $string_utils:from_list(args[2..$], " "));
lag = $login:current_lag();
if (!valid(what))
player:tell("Sorry, I didn't understand `", name, "'");
elseif (((((($object_utils:has_property(what, "object_size") && (what.object_size[1] > $byte_quota_utils.too_large)) && (!player.wizard)) && (player != $byte_quota_utils.owner)) && (player != $hacker)) && (player != what.owner)) && (lag > 0))
player:tell($string_utils:nn(what), " when last measured was ", $string_utils:group_number(what.object_size[1]), " bytes.  To reduce lag induced by multiple players re-measuring large objects multiple times, you may not measure that object.");
elseif (((lag > 0) && (`what.object_size[2] ! ANY => 0' > (time() - 86400))) && (!$command_utils:yes_or_no(tostr("That object was measured only ", $string_utils:from_seconds(time() - what.object_size[2]), " ago.  Please don't lag the MOO by remeasuring things frequently.  Are you sure you want to remeasure it?"))))
return player:tell("Not measuring.  It was ", $string_utils:group_number(what.object_size[1]), " bytes when last measured.");
else
player:tell("Checking size of ", what.name, " (", what, ")...");
player:tell("Size of ", what.name, " (", what, ") is ", $string_utils:group_number($byte_quota_utils:object_bytes(what)), " bytes.");
endif
elseif (index("summary", args[1]) == 1)
"Summarize player.";
if (length(args) == 1)
what = player;
else
what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], " "));
endif
if (!valid(what))
player:tell("Sorry, I don't know who you mean by `", name, "'");
else
$byte_quota_utils:do_summary(what);
endif
elseif (index("new", args[1]) == 1)
if (length(args) == 1)
what = player;
elseif (!valid(what = $string_utils:match_player(name = $string_utils:from_list(args[2..$], " "))))
return $command_utils:player_match_failed(what, name);
endif
player:tell("Measuring the sizes of ", what.name, "'s recently created objects...");
total = 0;
unmeasured_index = 4;
unmeasured_multiplier = 100;
nunmeasured = 0;
if (typeof(what.owned_objects) == LIST)
for x in (what.owned_objects)
if (!$object_utils:has_property(x, "object_size"))
nunmeasured = nunmeasured + 1;
elseif (!x.object_size[1])
player:tell("Measured ", $string_utils:nn(x), ":  ", size = $byte_quota_utils:object_bytes(x), " bytes.");
total = total + size;
endif
$command_utils:suspend_if_needed(5);
endfor
if (nunmeasured && (what.size_quota[unmeasured_index] < (unmeasured_multiplier * nunmeasured)))
what.size_quota[unmeasured_index] = (what.size_quota[unmeasured_index] % unmeasured_multiplier) + (nunmeasured * unmeasured_multiplier);
endif
player:tell("Total bytes used in new creations: ", total, ".", nunmeasured ? tostr("There were a total of ", nunmeasured, " object(s) found with no .object_size property.  This will prevent additional building.") | "");
else
player:tell("Sorry, ", what.name, " is not enrolled in the object measurement scheme.");
endif
elseif (index("recent", args[1]) == 1)
"@measure recent days player";
if (length(args) > 1)
days = $code_utils:toint(args[2]);
else
days = $byte_quota_utils.cycle_days;
endif
if (!days)
return player:tell("Couldn't understand `", args[2], "' as a positive integer.");
endif
if (length(args) > 2)
if (!valid(who = $string_utils:match_player(name = $string_utils:from_list(args[3..$], " "))))
return $command_utils:player_match_failed(who, name);
endif
else
who = player;
endif
if (typeof(who.owned_objects) == LIST)
player:tell("Re-measuring objects of ", $string_utils:nn(who), " which have not been measured in the past ", days, " days.");
when = time() - (days * 86400);
which = {};
for x in (who.owned_objects)
if (x.object_size[2] < when)
$byte_quota_utils:object_size(x);
which = setadd(which, x);
$command_utils:suspend_if_needed(3, "...measuring");
endif
endfor
player:tell("Done, re-measured ", length(which), " objects.", (length(which) > 0) ? "  Recommend you use @measure summary to update the display of @quota." | "");
else
player:tell("Sorry, ", who.name, " is not enrolled in the object measurement scheme.");
endif
elseif (index("breakdown", args[1]) == 1)
what = player.location:match_object(name = $string_utils:from_list(args[2..$], " "));
if (!valid(what))
player:tell("Sorry, I didn't understand `", name, "'");
elseif (!$byte_quota_utils:can_peek(player, what.owner))
return player:tell("Sorry, you don't control ", what.name, " (", what, ")");
else
if (mail = $command_utils:yes_or_no("This might be kinda long.  Want me to mail you the result?"))
player:tell("Result will be mailed.");
endif
info = $byte_quota_utils:do_breakdown(what);
if (typeof(info) == ERR)
player:tell(info);
endif
if (mail)
$mail_agent:send_message($byte_quota_utils.owner, {player}, tostr("Object breakdown of ", what.name, " (", what, ")"), info);
else
player:tell_lines_suspended(info);
endif
endif
else
player:tell("Not a sub-command of @measure: ", args[1]);
player:tell_lines($code_utils:verb_documentation());
endif
-------------------------------------------------------------------------------
#4 generic builder:init_for_core this n/a this
if (caller_perms().wizard)
if (this == $builder)
this.build_options = {};
else
clear_property(this, "build_options");
endif
return pass(@args);
endif
-------------------------------------------------------------------------------
#4 generic builder:@listedit @pedit any n/a none
"@listedit|@pedit object.prop -- invokes the list editor.";
"   if you are editing a list of strings, you're better off using @notedit.";
$list_editor:invoke(dobjstr, verb);
-------------------------------------------------------------------------------
================================#5 generic thing===============================================
#5 generic thing.otake_succeeded_msg rc = MOOString "picks up %t."
#5 generic thing.otake_failed_msg rc = MOOString ""
#5 generic thing.drop_succeeded_msg rc = MOOString "You drop %t."
#5 generic thing.odrop_failed_msg rc = MOOString "tries to drop %t but fails!"
#5 generic thing.take_succeeded_msg rc = MOOString "You take %t."
#5 generic thing.take_failed_msg rc = MOOString "You can't pick that up."
#5 generic thing.drop_failed_msg rc = MOOString "You can't seem to drop %t here."
#5 generic thing.odrop_succeeded_msg rc = MOOString "drops %t."
#5 generic thing:g*et t*ake this n/a none
set_task_perms(callers() ? caller_perms() | player);
if (this.location == player)
player:tell("You already have that!");
elseif (this.location != player.location)
player:tell("I don't see that here.");
else
this:moveto(player);
if (this.location == player)
player:tell(this:take_succeeded_msg() || "Taken.");
if (msg = this:otake_succeeded_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell(this:take_failed_msg() || "You can't pick that up.");
if (msg = this:otake_failed_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
-------------------------------------------------------------------------------
#5 generic thing:d*rop th*row this n/a none
set_task_perms(callers() ? caller_perms() | player);
if (this.location != player)
player:tell("You don't have that.");
elseif (!player.location:acceptable(this))
player:tell("You can't drop that here.");
else
this:moveto(player.location);
if (this.location == player.location)
player:tell_lines(this:drop_succeeded_msg() || "Dropped.");
if (msg = this:odrop_succeeded_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell_lines(this:drop_failed_msg() || "You can't seem to drop that here.");
if (msg = this:odrop_failed_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
-------------------------------------------------------------------------------
#5 generic thing:moveto this n/a this
where = args[1];
"if (!valid(where) || this:is_unlocked_for(where))";
if (this:is_unlocked_for(where))
pass(where);
endif
-------------------------------------------------------------------------------
#5 generic thing:take_failed_msg take_succeeded_msg otake_failed_msg otake_succeeded_msg drop_failed_msg drop_succeeded_msg odrop_failed_msg odrop_succeeded_msg this n/a this
set_task_perms(caller_perms());
return $string_utils:pronoun_sub(this.(verb));
-------------------------------------------------------------------------------
#5 generic thing:gi*ve ha*nd this any any
set_task_perms(callers() ? caller_perms() | player);
if (this.location != player)
player:tell("You don't have that!");
elseif (!valid(player.location))
player:tell("I see no \"", iobjstr, "\" here.");
elseif ($command_utils:object_match_failed(who = player.location:match_object(iobjstr), iobjstr))
elseif (who.location != player.location)
player:tell("I see no \"", iobjstr, "\" here.");
elseif (who == player)
player:tell("Give it to yourself?");
else
this:moveto(who);
if (this.location == who)
player:tell("You hand ", this:title(), " to ", who:title(), ".");
who:tell(player:titlec(), " ", $gender_utils:get_conj("hands/hand", player), " you ", this:title(), ".");
else
player:tell(who:titlec(), " ", $gender_utils:get_conj("does/do", who), " not want that item.");
endif
endif
-------------------------------------------------------------------------------
#5 generic thing:examine_key this n/a this
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr(this:title(), " can only be moved to locations matching this key:"), tostr("  ", $lock_utils:unparse_key(this.key))};
endif
-------------------------------------------------------------------------------
================================#6 generic player===============================================
#6 generic player.pp rc = MOOString "its"
#6 generic player.pq rc = MOOString "its"
#6 generic player.pr rc = MOOString "itself"
#6 generic player.pqc rc = MOOString "Its"
#6 generic player.ps rc = MOOString "it"
#6 generic player.size_quota  = MOOList [ ]
#6 generic player.last_connect_place  = MOOString "?"
#6 generic player.linesleft r = MOONumber 0
#6 generic player.features r = MOOList [ ]
#6 generic player.password  = MOOString "impossible password to type"
#6 generic player.dict rc = MOOList [ ]
#6 generic player.previous_connection  = MOONumber 0
#6 generic player.last_password_time  = MOONumber 0
#6 generic player.linetask r = MOOList [ 0, 0 ]
#6 generic player.prc rc = MOOString "Itself"
#6 generic player.all_connect_places  = MOOList [ ]
#6 generic player.current_folder c = MOONumber 1
#6 generic player.linelen r = MOONumber -79
#6 generic player.paranoid rc = MOONumber 0
#6 generic player.page_echo_msg rc = MOOString "Your message has been sent."
#6 generic player.first_connect_time r = MOONumber 2147483647
#6 generic player.last_connect_time r = MOONumber 0
#6 generic player.pagelen r = MOONumber 0
#6 generic player.verb_subs rc = MOOList [ ]
#6 generic player.psc rc = MOOString "It"
#6 generic player.gender rc = MOOString "neuter"
#6 generic player.poc rc = MOOString "It"
#6 generic player.edit_options rc = MOOList [ ]
#6 generic player.ownership_quota  = MOONumber 0
#6 generic player.linebuffer  = MOOList [ ]
#6 generic player.page_absent_msg rc = MOOString "%N is not currently logged in."
#6 generic player.lines c = MOONumber 0
#6 generic player.last_connect_attempt  = MOONumber 0
#6 generic player.display_options rc = MOOList [ ]
#6 generic player.brief rc = MOONumber 0
#6 generic player.ppc rc = MOOString "Its"
#6 generic player.gaglist rc = MOOList [ ]
#6 generic player.more_msg rc = MOOString "*** More ***  %n lines left.  Do @more [rest|flush] for more."
#6 generic player.home rc = MOOObjRef #62
#6 generic player.last_disconnect_time r = MOONumber 0
#6 generic player.help rc = MOONumber 0
#6 generic player.page_origin_msg rc = MOOString "You sense that %n is looking for you in %l."
#6 generic player.email_address  = MOOString ""
#6 generic player.owned_objects r = MOOList [ ]
#6 generic player.po rc = MOOString "it"
#6 generic player:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.home = (this in {$no_one, $hacker, $generic_editor.owner}) ? $nothing | $player_start;
if (a = $list_utils:assoc(this, {{$prog, {$prog_help, $builtin_function_help, $verb_help, $core_help}}, {$wiz, $wiz_help}, {$mail_recipient_class, $mail_help}, {$builder, $builder_help}, {$frand_class, $frand_help}}))
this.help = a[2];
else
this.help = 0;
endif
if (this != $player)
for p in ({"last_connect_place", "all_connect_places", "features", "previous_connection", "last_connect_time"})
clear_property(this, p);
endfor
if (is_player(this))
this.first_connect_time = $maxint;
this.last_disconnect_time = $maxint;
endif
endif
endif
-------------------------------------------------------------------------------
#6 generic player:confunc this n/a this
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
endif
this:("@last-connection")();
$news:check();
-------------------------------------------------------------------------------
#6 generic player:disfunc this n/a this
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
endif
this:expunge_rmm();
this:erase_paranoid_data();
this:gc_gaglist();
return;
-------------------------------------------------------------------------------
#6 generic player:initialize this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
this.help = 0;
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:acceptable this n/a this
return !is_player(args[1]);
-------------------------------------------------------------------------------
#6 generic player:my_huh this n/a this
"Extra parsing of player commands.  Called by $command_utils:do_huh.";
"This version of my_huh just handles features.";
permissions = (((caller == this) || $perm_utils:controls(caller_perms(), this)) && $command_utils:validate_feature(@args)) ? this | $no_one;
"verb - obvious                 pass - would be args";
"plist - list of prepspecs that this command matches";
"dlist and ilist - likewise for dobjspecs, iobjspecs";
verb = args[1];
if (`$server_options.support_numeric_verbname_strings ! E_PROPNF => 0' && $string_utils:is_integer(verb))
return;
endif
pass = args[2];
plist = {"any", prepstr ? $code_utils:full_prep(prepstr) | "none"};
dlist = dobjstr ? {"any"} | {"none", "any"};
ilist = iobjstr ? {"any"} | {"none", "any"};
for fobj in (this.features)
if (!$recycler:valid(fobj))
this:remove_feature(fobj);
else
fverb = 0;
try
"Ask the FO for a matching verb.";
fverb = fobj:has_feature_verb(verb, dlist, plist, ilist);
except e (E_VERBNF)
"Try to match it ourselves.";
if (`valid(loc = $object_utils:has_callable_verb(fobj, verb)[1]) ! ANY => 0')
vargs = verb_args(loc, verb);
if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))
fverb = verb;
endif
endif
endtry
if (fverb)
"(got rid of notify_huh - use @find to locate feature verbs)";
set_task_perms(permissions);
fobj:(fverb)(@pass);
return 1;
endif
endif
if ($command_utils:running_out_of_time())
player:tell("You have too many features.  Parsing your command runs out of ticks while checking ", fobj.name, " (", fobj, ").");
return 1;
endif
endfor
-------------------------------------------------------------------------------
#6 generic player:last_huh this n/a this
":last_huh(verb,args)  final attempt to parse a command...";
set_task_perms(caller_perms());
{verb, args} = args;
if ((verb[1] == "@") && (prepstr == "is"))
"... set or show _msg property ...";
set_task_perms(player);
$last_huh:(verb)(@args);
return 1;
elseif (verb in {"give", "hand", "get", "take", "drop", "throw"})
$last_huh:(verb)(@args);
return 1;
else
return 0;
endif
-------------------------------------------------------------------------------
#6 generic player:my_match_object this n/a this
":my_match_object(string [,location])";
return $string_utils:match_object(@{@args, this.location}[1..2], this);
-------------------------------------------------------------------------------
#6 generic player:tell_contents this n/a this
c = args[1];
if (c)
longear = {};
gear = {};
width = player:linelen();
half = width / 2;
player:tell("Carrying:");
for thing in (c)
cx = tostr(" ", thing:title());
if (length(cx) > half)
longear = {@longear, cx};
else
gear = {@gear, cx};
endif
endfor
player:tell_lines($string_utils:columnize(gear, 2, width));
player:tell_lines(longear);
endif
-------------------------------------------------------------------------------
#6 generic player:titlec this n/a this
return `this.namec ! E_PROPNF => this:title()';
-------------------------------------------------------------------------------
#6 generic player:notify this n/a this
line = args[1];
if (!(this in connected_players()))
"...drop it on the floor...";
return 0;
elseif ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
if (this.pagelen)
"...need wizard perms if this and this.owner are different, since...";
"...only this can notify() and only this.owner can read .linebuffer...";
if ((player == this) && (this.linetask[2] != task_id()))
"...player has started a new task...";
"....linetask[2] is the taskid of the most recent player task...";
if (this.linetask[2] != this.linetask[1])
this.linesleft = this.pagelen - 2;
endif
this.linetask[2] = task_id();
endif
"... digest the current line...";
if (this.linelen > 0)
lbuf = {@this.linebuffer, @this:linesplit(line, this.linelen)};
else
lbuf = {@this.linebuffer, line};
endif
"... print out what we can...";
if (this.linesleft)
howmany = min(this.linesleft, length(lbuf));
for l in (lbuf[1..howmany])
pass(l);
endfor
this.linesleft = this.linesleft - howmany;
lbuf[1..howmany] = {};
endif
if (lbuf)
"...see if we need to say ***More***";
if (this.linetask[1] != this.linetask[2])
"....linetask[1] is the taskid of the most recent player task";
"...   for which ***More*** was printed...";
this.linetask[1] = this.linetask[2];
fork (0)
if (lb = this.linebuffer)
pass(strsub(this.more_msg, "%n", tostr(length(lb))));
endif
endfork
endif
llen = length(lbuf);
if (llen > 500)
"...way too much saved text, flush some of it...";
lbuf[1..llen - 100] = {"*** buffer overflow, lines flushed ***"};
endif
endif
this.linebuffer = lbuf;
else
if (this.linelen > 0)
for l in (this:linesplit(line, this.linelen))
pass(l);
endfor
else
pass(line);
endif
endif
-------------------------------------------------------------------------------
#6 generic player:notify_lines this n/a this
if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))
set_task_perms(caller_perms());
for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)
this:notify(tostr(line));
endfor
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:linesplit this n/a this
":linesplit(line,len) => list of substrings of line";
"used by :notify to split up long lines if .linelen>0";
{line, len} = args;
cline = {};
while (length(line) > len)
cutoff = rindex(line[1..len], " ");
if (nospace = cutoff < ((4 * len) / 5))
cutoff = len + 1;
nospace = line[cutoff] != " ";
endif
cline = {@cline, line[1..cutoff - 1]};
line = (nospace ? " " | "") + line[cutoff..$];
endwhile
return {@cline, line};
-------------------------------------------------------------------------------
#6 generic player:linelen this n/a this
return abs(this.linelen);
-------------------------------------------------------------------------------
#6 generic player:@more any n/a none
if (player != this)
"... somebody's being sneaky...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
elseif (!(lbuf = this.linebuffer))
this.linesleft = this.pagelen - 2;
notify(this, "*** No more ***");
elseif (index("flush", dobjstr || "x") == 1)
this.linesleft = this.pagelen - 2;
notify(this, tostr("*** Flushed ***  ", length(lbuf), " lines"));
this.linebuffer = {};
elseif ((index("rest", dobjstr || "x") == 1) || (!this.pagelen))
this.linesleft = this.pagelen - 2;
for l in (lbuf)
notify(this, l);
endfor
this.linebuffer = {};
else
howmany = min(this.pagelen - 2, llen = length(lbuf = this.linebuffer));
for l in (lbuf[1..howmany])
notify(this, l);
endfor
this.linesleft = (this.pagelen - 2) - howmany;
this.linebuffer = lbuf[howmany + 1..llen];
if (howmany < llen)
notify(this, strsub(this.more_msg, "%n", tostr(llen - howmany)));
this.linetask[1] = task_id();
endif
endif
this.linetask[2] = task_id();
-------------------------------------------------------------------------------
#6 generic player:@wrap none ?-2? none
if (player != this)
"... someone is being sneaky...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
endif
linelen = player.linelen;
if (!(prepstr in {"on", "off"}))
player:notify("Usage:  @wrap on|off");
player:notify(tostr("Word wrap is currently ", (linelen > 0) ? "on" | "off", "."));
return;
endif
player.linelen = abs(linelen) * ((prepstr == "on") ? 1 | -1);
player:notify(tostr("Word wrap is now ", prepstr, "."));
-------------------------------------------------------------------------------
#6 generic player:@linelen*gth any n/a none
if (callers() ? (caller != this) && (!$perm_utils:controls(caller_perms(), this)) | (player != this))
"... somebody is being sneaky ...";
return;
endif
curlen = player.linelen;
wrap = curlen > 0;
wrapstr = wrap ? "on" | "off";
if (!dobjstr)
player:notify(tostr("Usage:  ", verb, " <number>"));
player:notify(tostr("Current line length is ", abs(curlen), ".  Word wrapping is ", wrapstr, "."));
return;
endif
newlen = toint(dobjstr);
if (newlen < 0)
player:notify("Line length can't be a negative number.");
return;
elseif (newlen == 0)
return player:notify("Linelength zero makes no sense.  You want to use '@wrap off' if you want to turn off wrapping.");
elseif (newlen < 10)
player:notify("You don't want your linelength that small.  Setting it to 10.");
newlen = 10;
elseif (newlen > 1000)
player:notify("You don't want your line length that large.  Setting it to 1000.");
newlen = 1000;
endif
this:set_linelength(newlen);
player:notify(tostr("Line length is now ", abs(player.linelen), ".  Word wrapping is ", wrapstr, "."));
if (!wrap)
player:notify("To enable word wrapping, type `@wrap on'.");
endif
-------------------------------------------------------------------------------
#6 generic player:@pagelen*gth any n/a none
"@pagelength number  -- sets page buffering to that many lines (or 0 to turn off page buffering)";
if (player != this)
"... somebody is being sneaky ...";
"... Can't do set_task_perms(player) since we need to be `this'...";
"... to notify and `this.owner' to change +c properties...";
return;
elseif (!dobjstr)
notify(player, tostr("Usage:  ", verb, " <number>"));
notify(player, tostr("Current page length is ", player.pagelen, "."));
return;
elseif (0 > (newlen = toint(dobjstr)))
notify(player, "Page length can't be a negative number.");
return;
elseif (newlen == 0)
player.pagelen = 0;
notify(player, "Page buffering off.");
if (lb = this.linebuffer)
"queued text remains";
this:notify_lines(lb);
clear_property(this, "linebuffer");
endif
elseif (newlen < 5)
player.pagelen = 5;
notify(player, "Too small.  Setting it to 5.");
else
notify(player, tostr("Page length is now ", player.pagelen = newlen, "."));
endif
if (this.linebuffer)
notify(this, strsub(this.more_msg, "%n", tostr(length(this.linebuffer))));
player.linetask = {task_id(), task_id()};
player.linesleft = 0;
else
player.linetask = {0, task_id()};
player.linesleft = player.pagelen - 2;
endif
-------------------------------------------------------------------------------
#6 generic player:tell this n/a this
if (this.gaglist || this.paranoid)
"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.";
if (this:gag_p())
return;
endif
if (this.paranoid == 1)
$paranoid_db:add_data(this, {{@callers(1), {player, "<cmd-line>", player}}, args});
elseif (this.paranoid == 2)
z = this:whodunnit({@callers(), {player, "", player}}, {this, $no_one}, {})[3];
args = {"(", z.name, " ", z, ") ", @args};
endif
endif
pass(@args);
-------------------------------------------------------------------------------
#6 generic player:gag_p this n/a this
if (player in this.gaglist)
return 1;
elseif (gag = this.gaglist)
for x in (callers())
if (((x[1] == #-1) && (x[3] == #-1)) && (x[2] != ""))
elseif ((x[1] in gag) || (x[4] in gag))
return 1;
endif
endfor
endif
return 0;
"--- old definition --";
if (player in this.gaglist)
return 1;
elseif (this.gaglist)
for x in (callers())
if (valid(x[1]))
if (x[1] in this.gaglist)
return 1;
endif
endif
endfor
endif
return 0;
-------------------------------------------------------------------------------
#6 generic player:set_gaglist this n/a this
":set_gaglist(@newlist) => this.gaglist = newlist";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
else
return this.gaglist = args;
endif
-------------------------------------------------------------------------------
#6 generic player:@gag*! any ?-2? any
set_task_perms(player);
if (player != this)
player:notify("Permission denied.");
return;
endif
if (!args)
player:notify(tostr("Usage:  ", verb, " <player or object> [<player or object>...]"));
return;
endif
victims = $string_utils:match_player_or_object(@args);
changed = 0;
for p in (victims)
if (p in player.gaglist)
player:notify(tostr("You are already gagging ", p.name, "."));
elseif (p == player)
player:notify("Gagging yourself is a bad idea.");
elseif (children(p) && (verb != "@gag!"))
player:tell("If you really want to gag all descendents of ", $string_utils:nn(p), ", use `@gag! ", p, "' instead.");
else
changed = 1;
player:set_gaglist(@setadd(this.gaglist, p));
endif
endfor
if (changed)
this:("@listgag")();
endif
-------------------------------------------------------------------------------
#6 generic player:@listgag @gaglist @gagged any n/a none
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
if (!this.gaglist)
player:notify(tostr("You are ", callers() ? "no longer gagging anything." | "not gagging anything right now."));
else
player:notify(tostr("You are ", callers() ? "now" | "currently", " gagging ", $string_utils:nn(this.gaglist), "."));
endif
gl = {};
if (args)
player:notify("Searching for players who may be gagging you...");
for p in (players())
if ((typeof(`p.gaglist ! E_PERM') == LIST) && (this in p.gaglist))
gl = {@gl, p};
endif
$command_utils:suspend_if_needed(10, "...searching gaglist...");
endfor
if (gl || (!callers()))
player:notify(tostr($string_utils:nn(gl, " ", "No one"), " appear", (length(gl) <= 1) ? "s" | "", " to be gagging you."));
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@ungag any n/a none
if ((player != this) || ((caller != this) && (!$perm_utils:controls(caller_perms(), this))))
player:notify("Permission denied.");
elseif (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <player>  or  ", verb, " everyone"));
elseif (dobjstr == "everyone")
this.gaglist = {};
player:notify("You are no longer gagging anyone or anything.");
else
if (valid(dobj))
match = dobj;
elseif ((match = toobj(dobjstr)) > #0)
else
match = $string_utils:match(dobjstr, this.gaglist, "name", this.gaglist, "aliases");
endif
if (match == $failed_match)
player:notify(tostr("You don't seem to be gagging anything named ", dobjstr, "."));
elseif (match == $ambiguous_match)
player:notify(tostr("I don't know which \"", dobjstr, "\" you mean."));
else
this.gaglist = setremove(this.gaglist, match);
player:notify(tostr(valid(match) ? match.name | match, " removed from gag list."));
endif
this:("@listgag")();
endif
-------------------------------------------------------------------------------
#6 generic player:whodunnit this n/a this
{record, trust, mistrust} = args;
s = {this, "???", this};
for w in (record)
if (((((!valid(s[3])) || s[3].wizard) || (s[3] in trust)) && (!(s[3] in mistrust))) || (s[1] == this))
s = w;
else
return s;
endif
endfor
return s;
-------------------------------------------------------------------------------
#6 generic player:@ch*eck-full any ?-2? any
responsible = $paranoid_db:get_data(this);
if (length(verb) <= 6)
"@check, not @check-full";
n = 5;
trust = {this, $no_one};
"... trust no one, my friend.... no one....  --Herod";
mistrust = {};
for k in (args)
if (z = $code_utils:toint(k))
n = z;
elseif (k[1] == "!")
mistrust = listappend(mistrust, $string_utils:match_player(k[2..$]));
else
trust = listappend(trust, $string_utils:match_player(k));
endif
endfor
msg_width = player:linelen() - 60;
for q in ((n > (y = length(responsible))) ? responsible | responsible[(y - n) + 1..y])
msg = tostr(@q[2]);
if (length(msg) > msg_width)
msg = msg[1..msg_width];
endif
s = this:whodunnit(q[1], trust, mistrust);
text = valid(s[1]) ? s[1].name | "** NONE **";
this:notify(tostr($string_utils:left(tostr((length(text) > 13) ? text[1..13] | text, " (", s[1], ")"), 20), $string_utils:left(s[2], 15), $string_utils:left(tostr((length(s[3].name) > 13) ? s[3].name[1..13] | s[3].name, " (", s[3], ")"), 20), msg));
endfor
this:notify("*** finished ***");
else
"@check-full, from @traceback by APHiD";
"s_i_n's by Ho_Yan 10/18/94";
matches = {};
if (length(match = argstr) == 0)
player:notify(tostr("Usage: ", verb, " <string> --or-- ", verb, " <number>"));
return;
endif
if (!responsible)
player:notify("No text has been saved by the monitor.  (See `help @paranoid').");
else
if (typeof(x = $code_utils:toint(argstr)) == ERR)
for line in (responsible)
if (index(tostr(@line[$]), argstr))
matches = {@matches, line};
endif
endfor
else
matches = responsible[($ - min(x, $)) + 1..$];
endif
if (matches)
for match in (matches)
$command_utils:suspend_if_needed(3);
text = tostr(@match[$]);
player:notify("Traceback for:");
player:notify(text);
"Moved cool display code to $code_utils, 3/29/95, Ho_Yan";
$code_utils:display_callers(listdelete(mm = match[1], length(mm)));
endfor
player:notify("**** finished ****");
else
player:notify(tostr("No matches for \"", argstr, "\" found."));
endif
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@paranoid any ?-2? any
if ((args == {}) || ((typ = args[1]) == ""))
$paranoid_db:set_kept_lines(this, 10);
this.paranoid = 1;
this:notify("Anti-spoofer on and keeping 10 lines.");
elseif (index("immediate", typ))
$paranoid_db:set_kept_lines(this, 0);
this.paranoid = 2;
this:notify("Anti-spoofer now in immediate mode.");
elseif (index("off", typ) || (typ == "0"))
this.paranoid = 0;
$paranoid_db:set_kept_lines(this, 0);
this:notify("Anti-spoofer off.");
elseif ((tostr(y = toint(typ)) != typ) || (y < 0))
this:notify(tostr("Usage: ", verb, " <lines to be kept>     to turn on your anti-spoofer."));
this:notify(tostr("       ", verb, " off                    to turn it off."));
this:notify(tostr("       ", verb, " immediate              to use immediate mode."));
else
this.paranoid = 1;
kept = $paranoid_db:set_kept_lines(this, y);
this:notify(tostr("Anti-spoofer on and keeping ", kept, " lines."));
endif
-------------------------------------------------------------------------------
#6 generic player:@sw*eep none n/a none
buggers = 1;
found_listener = 0;
here = this.location;
for thing in (setremove(here.contents, this))
tellwhere = $object_utils:has_verb(thing, "tell");
notifywhere = $object_utils:has_verb(thing, "notify");
if (thing in connected_players())
this:notify(tostr(thing.name, " (", thing, ") is listening."));
found_listener = 1;
elseif ($object_utils:has_callable_verb(thing, "sweep_msg") && (typeof(msg = thing:sweep_msg()) == STR))
this:notify(tostr(thing.name, " (", thing, ") ", msg, "."));
found_listener = 1;
elseif (tellwhere && (((owner = verb_info(tellwhere[1], "tell")[1]) != this) && (!owner.wizard)))
this:notify(tostr(thing.name, " (", thing, ") has been taught to listen by ", owner.name, " (", owner, ")"));
found_listener = 1;
elseif (notifywhere && (((owner = verb_info(notifywhere[1], "notify")[1]) != this) && (!owner.wizard)))
this:notify(tostr(thing.name, " (", thing, ") has been taught to listen by ", owner.name, " (", owner, ")"));
found_listener = 1;
endif
endfor
buggers = {};
for v in ({"announce", "announce_all", "announce_all_but", "say", "emote", "huh", "here_huh", "huh2", "whisper", "here_explain_syntax"})
vwhere = $object_utils:has_verb(here, v);
if (vwhere && (((owner = verb_info(vwhere[1], v)[1]) != this) && (!owner.wizard)))
buggers = setadd(buggers, owner);
endif
endfor
if (buggers != {})
if ($object_utils:has_verb(here, "sweep_msg") && (typeof(msg = here:sweep_msg()) == STR))
this:notify(tostr(here.name, " (", here, ") ", msg, "."));
else
this:notify(tostr(here.name, " (", here, ") may have been bugged by ", $string_utils:english_list($list_utils:map_prop(buggers, "name")), "."));
endif
elseif (!found_listener)
this:notify("Communications look secure.");
endif
-------------------------------------------------------------------------------
#6 generic player:wh*isper any any this
this:tell(player.name, " whispers, \"", dobjstr, "\"");
player:tell("You whisper, \"", dobjstr, "\" to ", this.name, ".");
-------------------------------------------------------------------------------
#6 generic player:page any ?-2? any
nargs = length(args);
if (nargs < 1)
player:notify(tostr("Usage: ", verb, " <player> [with <message>]"));
return;
endif
who = $string_utils:match_player(args[1]);
if ($command_utils:player_match_result(who, args[1])[1])
return;
elseif (who in this.gaglist)
player:tell("You have ", who:title(), " @gagged.  If you paged ", $gender_utils:get_pronoun("o", who), ", ", $gender_utils:get_pronoun("s", who), " wouldn't be able to answer you.");
return;
endif
"for pronoun_sub's benefit...";
dobj = who;
iobj = player;
header = player:page_origin_msg();
text = "";
if (nargs > 1)
if ((args[2] == "with") && (nargs > 2))
msg_start = 3;
else
msg_start = 2;
endif
msg = $string_utils:from_list(args[msg_start..nargs], " ");
text = tostr($string_utils:pronoun_sub(($string_utils:index_delimited(header, player.name) ? "%S" | "%N") + " %<pages>, \""), msg, "\"");
endif
result = text ? who:receive_page(header, text) | who:receive_page(header);
if (result == 2)
"not connected";
player:tell((typeof(msg = who:page_absent_msg()) == STR) ? msg | $string_utils:pronoun_sub("%n is not currently logged in.", who));
else
player:tell(who:page_echo_msg());
endif
-------------------------------------------------------------------------------
#6 generic player:receive_page this n/a this
"called by $player:page.  Two args, the page header and the text, all pre-processed by the page command.  Could be extended to provide haven abilities, multiline pages, etc.  Indeed, at the moment it just does :tell_lines, so we already do have multiline pages, if someone wants to take advantage of it.";
"Return codes:";
"  1:  page was received";
"  2:  player is not connected";
"  0:  page refused";
"If a specialization wants to refuse a page, it should return 0 to say it was refused.  If it uses pass(@args) it should propagate back up the return value.  It is possible that this code should interact with gagging and return 0 if the page was gagged.";
if (this:is_listening())
this:tell_lines_suspended(args);
return 1;
else
return 2;
endif
-------------------------------------------------------------------------------
#6 generic player:page_origin_msg page_echo_msg page_absent_msg this n/a this
"set_task_perms(this.owner)";
return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(this.(verb), this) | "";
-------------------------------------------------------------------------------
#6 generic player:i inv*entory none n/a none
if (c = player:contents())
this:tell_contents(c);
else
player:tell("You are empty-handed.");
endif
-------------------------------------------------------------------------------
#6 generic player:look_self this n/a this
player:tell(this:titlec());
pass();
if (!(this in connected_players()))
player:tell($gender_utils:pronoun_sub("%{:He} %{!is} sleeping.", this));
elseif ((idle = idle_seconds(this)) < 60)
player:tell($gender_utils:pronoun_sub("%{:He} %{!is} awake and %{!looks} alert.", this));
else
time = $string_utils:from_seconds(idle);
player:tell($gender_utils:pronoun_sub("%{:He} %{!is} awake, but %{!has} been staring off into space for ", this), time, ".");
endif
if (c = this:contents())
this:tell_contents(c);
endif
-------------------------------------------------------------------------------
#6 generic player:home none n/a none
start = this.location;
if (start == this.home)
player:tell("You're already home!");
return;
elseif (typeof(this.home) != OBJ)
player:tell("You've got a weird home, pal.  I've reset it to the default one.");
this.home = $player_start;
elseif (!valid(this.home))
player:tell("Oh no!  Your home's been recycled.  Time to look around for a new one.");
this.home = $player_start;
else
player:tell("You click your heels three times.");
endif
this:moveto(this.home);
if (!valid(start))
elseif (start == this.location)
start:announce(player.name, " ", $gender_utils:get_conj("learns", player), " that you can never go home...");
else
try
start:announce(player.name, " ", $gender_utils:get_conj("goes", player), " home.");
except e (E_VERBNF)
"start did not support announce";
endtry
endif
if (this.location == this.home)
this.location:announce(player.name, " ", $gender_utils:get_conj("comes", player), " home.");
elseif (this.location == start)
player:tell("Either home doesn't want you, or you don't really want to go.");
else
player:tell("Wait a minute!  This isn't your home...");
if (valid(this.location))
this.location:announce(player.name, " ", $gender_utils:get_conj("arrives", player), ", looking quite bewildered.");
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@sethome none n/a none
set_task_perms(this);
here = this.location;
if (!$perm_utils:controls(player, player))
player:notify("Players who do not own themselves may not modify their home.");
elseif (!$object_utils:has_callable_verb(here, "accept_for_abode"))
player:notify("This is a pretty odd place.  You should make your home in an actual room.");
elseif (here:accept_for_abode(this))
this.home = here;
player:notify(tostr(here.name, " is your new home."));
else
player:notify(tostr("This place doesn't want to be your home.  Contact ", here.owner.name, " to be added to the residents list of this place, or choose another place as your home."));
endif
-------------------------------------------------------------------------------
#6 generic player:g*et take this n/a none
player:tell("This is not a pick-up joint!");
this:tell(player.name, " tried to pick you up.");
-------------------------------------------------------------------------------
#6 generic player:@move @teleport any any any
"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.";
set_task_perms((caller == this) ? this | $no_one);
dobj = this:my_match_object(dobjstr);
iobj = this:my_match_object(iobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr) || ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr)))
return;
endif
if ((!$perm_utils:controls(this, dobj)) && (this != dobj))
player:tell("You may only @move your own things.");
return;
endif
old_loc = dobj.location;
if (old_loc == iobj)
player:tell(dobj.name, " is already ", valid(iobj) ? "in " + iobj.name | "nowhere", ".");
return;
endif
dobj:moveto(iobj);
if (dobj.location == iobj)
player:tell("Moved.");
if (is_player(dobj))
if (valid(old_loc))
old_loc:announce_all(dobj.name, " disappears suddenly for parts unknown.");
if (dobj != player)
dobj:tell("You have been moved by ", player.name, ".");
endif
endif
if (valid(dobj.location))
dobj.location:announce(dobj.name, " materializes out of thin air.");
endif
endif
elseif (dobj.location == old_loc)
if ($object_utils:contains(dobj, iobj))
player:tell(iobj.name, " is inside of ", dobj.name, "!");
else
player:tell($string_utils:pronoun_sub("Either %d doesn't want to go, or %i doesn't want to accept %[dpo]."));
endif
elseif (dobj == player)
player:tell("You have been deflected from your original destination.");
else
player:tell($string_utils:pronoun_sub("%D has been deflected from %[dpp] original destination."));
endif
-------------------------------------------------------------------------------
#6 generic player:@eject @eject! @eject!! any in/inside/into any
set_task_perms(player);
if (iobjstr == "here")
iobj = player.location;
elseif (iobjstr == "me")
iobj = player;
elseif ($command_utils:object_match_failed(iobj, iobjstr))
return;
endif
if (!$perm_utils:controls(player, iobj))
player:notify(tostr("You are not the owner of ", iobj.name, "."));
return;
endif
if (dobjstr == "me")
dobj = player;
elseif (($failed_match == (dobj = $string_utils:literal_object(dobjstr))) && $command_utils:object_match_failed(dobj = iobj:match(dobjstr), dobjstr))
return;
endif
if (dobj.location != iobj)
player:notify(tostr(dobj.name, "(", dobj, ") is not in ", iobj.name, "(", iobj, ")."));
return;
endif
if (dobj.wizard)
player:notify(tostr("Sorry, you can't ", verb, " a wizard."));
dobj:tell(player.name, " tried to ", verb, " you.");
return;
endif
iobj:((verb == "@eject") ? "eject" | "eject_basic")(dobj);
player:notify($object_utils:has_callable_verb(iobj, "ejection_msg") ? iobj:ejection_msg() | $room:ejection_msg());
if (verb != "@eject!!")
dobj:tell($object_utils:has_callable_verb(iobj, "victim_ejection_msg") ? iobj:victim_ejection_msg() | $room:victim_ejection_msg());
endif
iobj:announce_all_but({player, dobj}, $object_utils:has_callable_verb(iobj, "oejection_msg") ? iobj:oejection_msg() | $room:oejection_msg());
-------------------------------------------------------------------------------
#6 generic player:where*is @where*is any ?-2? any
if (!args)
them = connected_players();
else
who = $command_utils:player_match_result($string_utils:match_player(args), args);
if (length(who) <= 1)
if (!who[1])
player:notify("Where is who?");
endif
return;
elseif (who[1])
player:notify("");
endif
them = listdelete(who, 1);
endif
lmax = rmax = 0;
for p in (them)
player:notify(tostr($string_utils:left($string_utils:nn(p), 25), " ", $string_utils:nn(p.location)));
endfor
-------------------------------------------------------------------------------
#6 generic player:@who any ?-2? any
if (caller != player)
return E_PERM;
endif
plyrs = args ? listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1) | connected_players();
if (!plyrs)
return;
elseif (length(plyrs) > 100)
player:tell("You have requested a listing of ", length(plyrs), " players.  Please either specify individual players you are interested in, to reduce the number of players in any single request, or else use the `@users' command instead.  The lag thanks you.");
return;
endif
$code_utils:show_who_listing(plyrs);
-------------------------------------------------------------------------------
#6 generic player:@wizards any n/a none
"@wizards [all]";
if (caller != player)
return E_PERM;
endif
if (args)
$code_utils:show_who_listing($wiz_utils:all_wizards());
else
$code_utils:show_who_listing($wiz_utils:connected_wizards()) || player:notify("No wizards currently logged in.");
endif
-------------------------------------------------------------------------------
#6 generic player:?* help info*rmation @help any ?-2? any
set_task_perms(callers() ? caller_perms() | player);
"...this code explicitly relies on being !d in several places...";
if ((index(verb, "?") != 1) || (length(verb) <= 1))
what = $string_utils:trimr(argstr);
elseif (argstr)
what = tostr(verb[2..$], " ", $string_utils:trimr(argstr));
else
what = verb[2..$];
endif
"...find a db that claims to know about `what'...";
dblist = $code_utils:help_db_list();
result = $code_utils:help_db_search(what, dblist);
if (!result)
"... note: all of the last-resort stuff...";
"... is now located on $help:find_topics/get_topic...";
$wiz_utils:missed_help(what, result);
player:notify(tostr("Sorry, but no help is available on `", what, "'."));
elseif (result[1] == $ambiguous_match)
$wiz_utils:missed_help(what, result);
player:notify_lines(tostr("Sorry, but the topic-name `", what, "' is ambiguous.  I don't know which of the following topics you mean:"));
for x in ($help:columnize(@$help:sort_topics(result[2])))
player:notify(tostr("   ", x));
endfor
else
{help, topic} = result;
if (topic != what)
player:notify(tostr("Showing help on `", topic, "':"));
player:notify("----");
endif
dblist = dblist[1 + (help in dblist)..$];
if (1 == (text = help:get_topic(topic, dblist)))
"...get_topic took matters into its own hands...";
elseif (text)
"...these can get long...";
for line in ((typeof(text) == LIST) ? text | {text})
if (typeof(line) != STR)
player:notify("Odd results from help -- complain to a wizard.");
else
player:notify(line);
endif
$command_utils:suspend_if_needed(0);
endfor
else
player:notify(tostr("Help DB ", help, " thinks it knows about `", what, "' but something's messed up."));
player:notify(tostr("Tell ", help.owner.wizard ? "" | tostr(help.owner.name, " (", help.owner, ") or "), "a wizard."));
endif
endif
-------------------------------------------------------------------------------
#6 generic player:display_option this n/a this
":display_option(name) => returns the value of the specified @display option";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return $display_options:get(this.display_options, args[1]);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:edit_option this n/a this
":edit_option(name) => returns the value of the specified edit option";
if ((caller == this) || ($object_utils:isa(caller, $generic_editor) || $perm_utils:controls(caller_perms(), this)))
return $edit_options:get(this.edit_options, args[1]);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:set_mail_option set_edit_option set_display_option this n/a this
":set_edit_option(oname,value)";
":set_display_option(oname,value)";
":set_mail_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
"...this is kludgy, but it saves me from writing the same verb 3 times.";
"...there's got to be a better way to do this...";
verb[1..4] = "";
foo_options = verb + "s";
"...";
if (typeof(s = #0.(foo_options):set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
return 1;
endif
-------------------------------------------------------------------------------
#6 generic player:@mailo*ptions @mail-o*ptions @edito*ptions @edit-o*ptions @displayo*ptions @display-o*ptions any ?-2? any
"@<what>-option <option> [is] <value>   sets <option> to <value>";
"@<what>-option <option>=<value>        sets <option> to <value>";
"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@<what>-option -<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option !<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option <option>      displays value of <option>";
set_task_perms(player);
what = {"mail", "edit", "display"}[index("med", verb[2])];
options = what + "_options";
option_pkg = #0.(options);
set_option = ("set_" + what) + "_option";
if (!args)
player:notify_lines({("Current " + what) + " options:", "", @option_pkg:show(this.(options), option_pkg.names)});
return;
elseif (typeof(presult = option_pkg:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:(set_option)(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines(option_pkg:show(this.(options), presult[1]));
endif
-------------------------------------------------------------------------------
#6 generic player:set_name this n/a this
"set_name(newname) attempts to change this.name to newname";
"  => E_PERM   if you don't own this";
"  => E_INVARG if the name is already taken or prohibited for some reason";
"  => E_NACC   if the player database is not taking new names right now.";
"  => E_ARGS   if the name is too long (controlled by $login.max_player_name)";
"  => E_QUOTA  if the player is not allowed to change eir name.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (!is_player(this))
"we don't worry about the names of player classes.";
set_task_perms(caller_perms());
return pass(@args);
elseif ($player_db.frozen)
return E_NACC;
elseif (length(name = args[1]) > $login.max_player_name)
return E_ARGS;
elseif (!($player_db:available(name, this) in {this, 1}))
return E_INVARG;
else
old = this.name;
this.name = name;
if ((name != old) && (!(old in this.aliases)))
$player_db:delete(old);
endif
$player_db:insert(name, this);
return 1;
endif
-------------------------------------------------------------------------------
#6 generic player:set_aliases this n/a this
"set_aliases(alias_list)";
"For changing player aliases, we check to make sure that none of the aliases match existing player names/aliases.  Aliases containing spaces are not entered in the $player_db and so are not subject to this restriction ($string_utils:match_player will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).";
"Also we make sure that the .name is included in the .alias list.  In any situation where .name and .aliases are both being changed, do the name change first.";
"  => 1        if successful, and aliases changed from previous setting.";
"  => 0        if resulting work didn't change aliases from previous.";
"  => E_PERM   if you don't own this";
"  => E_NACC   if the player database is not taking new aliases right now.";
"  => E_TYPE   if alias_list is not a list";
"  => E_INVARG if any element of alias_list is not a string";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
elseif (!is_player(this))
"we don't worry about the names of player classes.";
return pass(@args);
elseif ($player_db.frozen)
return E_NACC;
elseif (typeof(aliases = args[1]) != LIST)
return E_TYPE;
elseif ((length(aliases = setadd(aliases, this.name)) > ($object_utils:has_property($local, "max_player_aliases") ? $local.max_player_aliases | $maxint)) && (length(aliases) >= length(this.aliases)))
return E_INVARG;
else
for a in (aliases)
if (typeof(a) != STR)
return E_INVARG;
endif
if ((!(index(a, " ") || index(a, "	"))) && (!($player_db:available(a, this) in {this, 1})))
aliases = setremove(aliases, a);
endif
endfor
old = this.aliases;
this.aliases = aliases;
for a in (old)
if (!(a in aliases))
$player_db:delete2(a, this);
endif
endfor
for a in (aliases)
if (!(index(a, " ") || index(a, "	")))
$player_db:insert(a, this);
endif
endfor
return this.aliases != old;
endif
-------------------------------------------------------------------------------
#6 generic player:@rename*# any any any
if ((player != caller) || (player != this))
return;
endif
set_task_perms(player);
bynumber = verb == "@rename#";
spec = $code_utils:parse_verbref(dobjstr);
if (spec)
if (!player.programmer)
return player:notify(tostr(E_PERM));
endif
object = this:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
vname = $code_utils:toint(vname);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
try
result = set_verb_info(object, vname, listset(info, iobjstr, 3));
player:notify("Verb name changed.");
except e (ANY)
player:notify(e[2]);
endtry
except (E_VERBNF)
player:notify("That object does not define that verb.");
except e (ANY)
player:notify(e[2]);
endtry
endif
elseif (bynumber)
player:notify("@rename# can only be used with verbs.");
elseif (pspec = $code_utils:parse_propref(dobjstr))
if (!player.programmer)
return player:notify(tostr(E_PERM));
endif
object = this:my_match_object(pspec[1]);
if (!$command_utils:object_match_failed(object, pspec[1]))
pname = pspec[2];
try
info = property_info(object, pname);
try
result = set_property_info(object, pname, {@info, iobjstr});
player:notify("Property name changed.");
except e (ANY)
player:notify(e[2]);
endtry
except (E_PROPNF)
player:notify("That object does not define that property.");
except e (ANY)
player:notify(e[2]);
endtry
endif
else
object = this:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(object, dobjstr))
old_name = object.name;
old_aliases = object.aliases;
if (e = $building_utils:set_names(object, iobjstr))
if (strcmp(object.name, old_name) == 0)
name_message = tostr("Name of ", object, " (", old_name, ") is unchanged");
else
name_message = tostr("Name of ", object, " changed to \"", object.name, "\"");
endif
aliases = $string_utils:from_value(object.aliases, 1);
if (object.aliases == old_aliases)
alias_message = tostr(".  Aliases are unchanged (", aliases, ").");
else
alias_message = tostr(", with aliases ", aliases, ".");
endif
player:notify(name_message + alias_message);
elseif (e == E_INVARG)
player:notify("That particular name change not allowed (see help @rename).");
if (object == player)
player:notify($player_db:why_bad_name(player, iobjstr));
endif
elseif (e == E_NACC)
player:notify("Oops.  You can't update that name right now; try again in a few minutes.");
elseif (e == E_ARGS)
player:notify(tostr("Sorry, name too long.  Maximum number of characters in a name:  ", $login.max_player_name));
elseif (e == 0)
player:notify("Name and aliases remain unchanged.");
else
player:notify(tostr(e));
endif
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@addalias*# @add-alias*# any any any
"Syntax: @addalias <alias>[,...,<alias>] to <object>";
"        @addalias <alias>[,...,<alias>] to <object>:<verb>";
"";
"The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.";
"";
"Example:";
"Muchkin wants to add new aliases to Rover the Wonder Dog:";
"  @addalias Dog,Wonder Dog to Rover";
"Since Rover the Wonder Dog already has the alias \"Dog\" but does not have the alias \"Wonder Dog\", Munchkin sees:";
"  Rover the Wonder Dog(#4237) already has the alias Dog.";
"  Alias Wonder Dog added to Rover the Wonder Dog(#4237).";
"";
"If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.";
"";
"Example:";
"Munchkin wants to add his nicknames to his own list of aliases:";
"  @addalias Foobar Davey to me";
"@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias \"Davey\" so Munchkin sees:";
"  DaveTheMan(#5432) is already using the alias Davey";
"  Alias Foobar added to Munchkin(#1523).";
"";
"The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.";
if (player != this)
return;
endif
set_task_perms(player);
bynumber = verb[$] == "#";
spec = $code_utils:parse_verbref(iobjstr);
if (spec)
if (!player.programmer)
return player:notify(tostr(E_PERM));
endif
object = player:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
if ((vname = $code_utils:toint(vname)) == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
old_aliases = $string_utils:explode(info[3]);
used = {};
for alias in (new_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, ",", " "))))
if (alias in old_aliases)
used = {@used, alias};
new_aliases = setremove(new_aliases, alias);
endif
endfor
if (used)
player:notify(tostr(object.name, "(", object, "):", vname, " already has the alias", (length(used) > 1) ? "es" | "", " ", $string_utils:english_list(used), "."));
endif
if (new_aliases)
info = listset(info, aliases = $string_utils:from_list({@old_aliases, @new_aliases}, " "), 3);
try
result = set_verb_info(object, vname, info);
player:notify(tostr("Alias", (length(new_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(new_aliases), " added to verb ", object.name, "(", object, "):", vname));
player:notify(tostr("Verbname is now ", object.name, "(", object, "):\"", aliases, "\""));
except e (ANY)
player:notify(e[2]);
endtry
endif
if ((!new_aliases) && (!used))
"Pathological case, we failed to parse dobjstr, possibly consisted only of commas, spaces, or just the empty string";
player:notify("Did not understand what aliases to add from value:  " + dobjstr);
endif
except (E_VERBNF)
player:notify("That object does not define that verb.");
except e (ANY)
player:notify(e[2]);
endtry
endif
elseif (bynumber)
player:notify(tostr(verb, " can only be used with verbs."));
else
object = player:my_match_object(iobjstr);
if (!$command_utils:object_match_failed(object, iobjstr))
old_aliases = object.aliases;
used = {};
for alias in (new_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, "trim", $string_utils:explode(is_player(object) ? strsub(dobjstr, " ", ",") | dobjstr, ","))))
if (alias in old_aliases)
used = {@used, alias};
new_aliases = setremove(new_aliases, alias);
elseif (is_player(object) && valid(someone = $player_db:find_exact(alias)))
player:notify(tostr(someone.name, "(", someone, ") is already using the alias ", alias, "."));
new_aliases = setremove(new_aliases, alias);
endif
endfor
if (used)
player:notify(tostr(object.name, "(", object, ") already has the alias", (length(used) > 1) ? "es" | "", " ", $string_utils:english_list(used), "."));
endif
if (new_aliases)
if ((e = object:set_aliases(aliases = {@old_aliases, @new_aliases})) && (object.aliases == aliases))
player:notify(tostr("Alias", (length(new_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(new_aliases), " added to ", object.name, "(", object, ")."));
player:notify(tostr("Aliases for ", $string_utils:nn(object), " are now ", $string_utils:from_value(aliases, 1)));
elseif (e)
player:notify("That particular name change not allowed (see help @rename or help @addalias).");
elseif (e == E_INVARG)
if ($object_utils:has_property(#0, "local"))
if ($object_utils:has_property($local, "max_player_aliases"))
max = $local.max_player_aliases;
player:notify(("You are not allowed more than " + tostr(max)) + " aliases.");
endif
else
player:notify("You are not allowed any more aliases.");
endif
elseif (e == E_NACC)
player:notify("Oops.  You can't update that object's aliases right now; try again in a few minutes.");
elseif (e == 0)
player:notify("Aliases not changed as expected!");
player:notify(tostr("Aliases for ", $string_utils:nn(object), " are now ", $string_utils:from_value(object.aliases, 1)));
else
player:notify(tostr(e));
endif
else
player:tell("No new aliases found to add.");
endif
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@rmalias*# @rm-alias*# any in/inside/into any
"Syntax: @rmalias <alias>[,...,<alias>] from <object>";
"        @rmalias <alias>[,...,<alias>] from <object>:<verb>";
"";
"The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.";
"[5/10/93 Nosredna: flushed above is_player feature";
"Note that @rmalias will not affect the object's name, only its aliases.";
"";
"The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.";
if (player != this)
return;
endif
set_task_perms(player);
bynumber = verb[$] == "#";
spec = $code_utils:parse_verbref(iobjstr);
if (spec)
if (!player.programmer)
player:notify(tostr(E_PERM));
endif
object = player:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
if ((vname = $code_utils:toint(vname)) == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
old_aliases = $string_utils:explode(info[3]);
not_used = {};
for alias in (bad_aliases = $list_utils:remove_duplicates($string_utils:explode(strsub(dobjstr, ",", " "))))
if (!(alias in old_aliases))
not_used = {@not_used, alias};
bad_aliases = setremove(bad_aliases, alias);
else
old_aliases = setremove(old_aliases, alias);
endif
endfor
if (not_used)
player:notify(tostr(object.name, "(", object, "):", vname, " does not have the alias", (length(not_used) > 1) ? "es" | "", " ", $string_utils:english_list(not_used), "."));
endif
if (bad_aliases && old_aliases)
info = listset(info, aliases = $string_utils:from_list(old_aliases, " "), 3);
try
result = set_verb_info(object, vname, info);
player:notify(tostr("Alias", (length(bad_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(bad_aliases), " removed from verb ", object.name, "(", object, "):", vname));
player:notify(tostr("Verbname is now ", object.name, "(", object, "):\"", aliases, "\""));
except e (ANY)
player:notify(e[2]);
endtry
elseif (!old_aliases)
player:notify("You have to leave a verb with at least one alias.");
else
player:notify("No aliases removed.");
endif
except (E_VERBNF)
player:notify("That object does not define that verb.");
except e (ANY)
player:notify(e[2]);
endtry
endif
elseif (bynumber)
player:notify(tostr(verb, " can only be used with verbs."));
else
object = player:my_match_object(iobjstr);
if (!$command_utils:object_match_failed(object, iobjstr))
old_aliases = object.aliases;
not_used = {};
for alias in (bad_aliases = $list_utils:remove_duplicates($list_utils:map_arg($string_utils, "trim", $string_utils:explode(dobjstr, ","))))
"removed is_player(object) ? strsub(dobjstr, \" \", \",\") | --Nosredna";
if (!(alias in old_aliases))
not_used = {@not_used, alias};
bad_aliases = setremove(bad_aliases, alias);
else
old_aliases = setremove(old_aliases, alias);
endif
endfor
if (not_used)
player:notify(tostr(object.name, "(", object, ") does not have the alias", (length(not_used) > 1) ? "es" | "", " ", $string_utils:english_list(not_used), "."));
endif
if (bad_aliases)
if (e = object:set_aliases(old_aliases))
player:notify(tostr("Alias", (length(bad_aliases) > 1) ? "es" | "", " ", $string_utils:english_list(bad_aliases), " removed from ", object.name, "(", object, ")."));
player:notify(tostr("Aliases for ", object.name, "(", object, ") are now ", $string_utils:from_value(old_aliases, 1)));
elseif (e == E_INVARG)
player:notify("That particular name change not allowed (see help @rename or help @rmalias).");
elseif (e == E_NACC)
player:notify("Oops.  You can't update that object's aliases right now; try again in a few minutes.");
elseif (e == 0)
player:notify("Aliases not changed as expected!");
player:notify(tostr("Aliases for ", $string_utils:nn(object), " are ", $string_utils:from_value(object.aliases, 1)));
else
player:notify(tostr(e));
endif
else
player:notify("Aliases unchanged.");
endif
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@desc*ribe any for/abount any
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
"...lose...";
elseif (e = dobj:set_description(iobjstr))
player:notify("Description set.");
else
player:notify(tostr(e));
endif
-------------------------------------------------------------------------------
#6 generic player:@mess*ages any n/a none
set_task_perms(player);
if (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <object>"));
return;
endif
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
found_one = 0;
props = $object_utils:all_properties(dobj);
if (typeof(props) == ERR)
player:notify("You can't read the messages on that.");
return;
endif
for pname in (props)
len = length(pname);
if ((len > 4) && (pname[len - 3..len] == "_msg"))
found_one = 1;
msg = `dobj.(pname) ! ANY';
if (msg == E_PERM)
value = "isn't readable by you.";
elseif (!msg)
value = "isn't set.";
elseif (typeof(msg) == LIST)
value = "is a list.";
elseif (typeof(msg) != STR)
value = "is corrupted! **";
else
value = "is " + $string_utils:print(msg);
endif
player:notify(tostr("@", pname[1..len - 4], " ", dobjstr, " ", value));
endif
endfor
if (!found_one)
player:notify("That object doesn't have any messages to set.");
endif
-------------------------------------------------------------------------------
#6 generic player:@notedit any n/a none
$note_editor:invoke(dobjstr, verb);
-------------------------------------------------------------------------------
#6 generic player:@last-c*onnection any n/a none
"@last-c           reports when and from where you last connected.";
"@last-c all       adds the 10 most recent places you connected from.";
"@last-c confunc   is like `@last-c' but is silent on first login.";
opts = {"all", "confunc"};
i = 0;
if (caller != this)
return E_PERM;
elseif (args && ((length(args) > 1) || (!(i = $string_utils:find_prefix(args[1], opts)))))
this:notify(tostr("Usage:  ", verb, " [all]"));
return;
endif
opt_all = i && (opts[i] == "all");
opt_confunc = i && (opts[i] == "confunc");
if (!(prev = this.previous_connection))
this:notify("Something was broken when you logged in; tell a wizard.");
elseif (prev[1] == 0)
opt_confunc || this:notify("Your previous connection was before we started keeping track.");
elseif (prev[1] > time())
this:notify("This is your first time connected.");
else
this:notify(tostr("Last connected ", this:ctime(prev[1]), " from ", prev[2]));
if (opt_all)
this:notify("Previous connections have been from the following sites:");
for l in (this.all_connect_places)
this:notify("   " + l);
endfor
endif
endif
-------------------------------------------------------------------------------
#6 generic player:set_gender this n/a this
"set_gender(newgender) attempts to change this.gender to newgender";
"  => E_PERM   if you don't own this or aren't its parent";
"  => Other return values as from $gender_utils:set.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
result = $gender_utils:set(this, args[1]);
this.gender = (typeof(result) == STR) ? result | args[1];
return result;
endif
-------------------------------------------------------------------------------
#6 generic player:@gender any n/a none
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
if (!args)
player:notify(tostr("Your gender is currently ", this.gender, "."));
player:notify($string_utils:pronoun_sub("Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R"));
player:notify(tostr("Available genders:  ", $string_utils:english_list($gender_utils.genders, "", " or ")));
else
result = this:set_gender(args[1]);
quote = (result == E_NONE) ? "\"" | "";
player:notify(tostr("Gender set to ", quote, this.gender, quote, "."));
if (typeof(result) != ERR)
player:notify($string_utils:pronoun_sub("Your pronouns:  %s,%o,%p,%q,%r,%S,%O,%P,%Q,%R"));
elseif (result != E_NONE)
player:notify(tostr("Couldn't set pronouns:  ", result));
else
player:notify("Pronouns unchanged.");
endif
endif
-------------------------------------------------------------------------------
#6 generic player:set_brief this n/a this
"set_brief(value)";
"set_brief(value, anything)";
"If <anything> is given, add value to the current value; otherwise, just set the value.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
if (length(args) == 1)
this.brief = args[1];
else
this.brief = this.brief + args[1];
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@mode any ?-2? any
"@mode <mode>";
"Current modes are brief and verbose.";
"General verb for setting player `modes'.";
"Modes are coded right here in the verb.";
if (caller != this)
player:tell("You can't set someone else's modes.");
return E_PERM;
endif
modes = {"brief", "verbose"};
mode = `modes[$string_utils:find_prefix(dobjstr, modes)] ! E_TYPE, E_RANGE => 0';
if (!mode)
player:tell("Unknown mode \"", dobjstr, "\".  Known modes:");
for mode in (modes)
player:tell("  ", mode);
endfor
return 0;
elseif (mode == "brief")
this:set_brief(1);
elseif (mode == "verbose")
this:set_brief(0);
endif
player:tell($string_utils:capitalize(mode), " mode set.");
return 1;
-------------------------------------------------------------------------------
#6 generic player:@exam*ine any n/a none
"This verb should probably go away once 'examine' is in place.";
if (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <object>"));
return;
endif
what = $string_utils:match_object(dobjstr, player.location);
if ($command_utils:object_match_failed(what, dobjstr))
return;
endif
player:notify(tostr(what.name, " (", what, ") is owned by ", valid(what.owner) ? what.owner.name | "a recycled player", " (", what.owner, ")."));
player:notify(tostr("Aliases:  ", $string_utils:english_list(what.aliases)));
desc = what:description();
if (desc)
player:notify_lines(desc);
else
player:notify("(No description set.)");
endif
if ($perm_utils:controls(player, what))
player:notify(tostr("Key:  ", $lock_utils:unparse_key(what.key)));
endif
contents = what.contents;
if (contents)
player:notify("Contents:");
for item in (contents)
player:notify(tostr("  ", item.name, " (", item, ")"));
endfor
endif
"Use dobjstr, not shortest alias.";
name = dobjstr;
"name = what.name;";
"if (typeof(what.aliases) == LIST && what.aliases != {})";
"for alias in (what.aliases)";
"if (length(alias) <= length(name))";
"name = alias;";
"endif";
"endfor";
"endif";
vrbs = {};
commands_ok = what in {player, player.location};
dull_classes = {$root_class, $room, $player, $prog};
what = what;
printed_working_msg = 0;
while (what != $nothing)
if ($command_utils:running_out_of_time())
if (!printed_working_msg)
player:notify("Working on list of obvious verbs...");
printed_working_msg = 1;
endif
suspend(0);
endif
if (!(what in dull_classes))
for i in [1..length(verbs(what))]
if ($command_utils:running_out_of_time())
if (!printed_working_msg)
player:notify("Working on list of obvious verbs...");
printed_working_msg = 1;
endif
suspend(0);
endif
info = verb_info(what, i);
syntax = verb_args(what, i);
if ((index(info[2], "r") && ((syntax[2..3] != {"none", "this"}) && (commands_ok || ("this" in syntax)))) && verb_code(what, i))
{dobj, prep, iobj} = syntax;
if (syntax == {"any", "any", "any"})
prep = "none";
endif
if (prep != "none")
for x in ($string_utils:explode(prep, "/"))
if (length(x) <= length(prep))
prep = x;
endif
endfor
endif
"This is the correct way to handle verbs ending in *";
vname = info[3];
while (j = index(vname, "* "))
vname = tostr(vname[1..j - 1], "<anything>", vname[j + 1..$]);
endwhile
if (vname[$] == "*")
vname = vname[1..$ - 1] + "<anything>";
endif
vname = strsub(vname, " ", "/");
rest = "";
if (prep != "none")
rest = " " + ((prep == "any") ? "<anything>" | prep);
if (iobj != "none")
rest = tostr(rest, " ", (iobj == "this") ? name | "<anything>");
endif
endif
if (dobj != "none")
rest = tostr(" ", (dobj == "this") ? name | "<anything>", rest);
endif
vrbs = setadd(vrbs, ("  " + vname) + rest);
endif
endfor
endif
what = parent(what);
endwhile
if (vrbs)
player:notify("Obvious Verbs:");
player:notify_lines(vrbs);
printed_working_msg && player:notify("(End of list.)");
elseif (printed_working_msg)
player:notify("No obvious verbs found.");
endif
-------------------------------------------------------------------------------
#6 generic player:exam*ine any n/a none
set_task_perms(player);
if (!dobjstr)
player:notify(tostr("Usage:  ", verb, " <object>"));
return E_INVARG;
endif
what = player.location:match_object(dobjstr);
if ($command_utils:object_match_failed(what, dobjstr))
return;
endif
what:do_examine(player);
-------------------------------------------------------------------------------
#6 generic player:add_feature this n/a this
"Add a feature to this player's features list.  Caller must be this or have suitable permissions (this or wizardly).";
"If this is a nonprogrammer, then ask feature if it is feature_ok (that is, if it has a verb :feature_ok which returns a true value, or a property .feature_ok which is true).";
"After adding feature, call feature:feature_add(this).";
"Returns true if successful, E_INVARG if not a valid object, and E_PERM if !feature_ok or if caller doesn't have permission.";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
feature = args[1];
if ((typeof(feature) != OBJ) || (!valid(feature)))
return E_INVARG;
"Not a valid object.";
endif
if ($code_utils:verb_or_property(feature, "feature_ok", this))
"The object is willing to be a feature.";
if (typeof(this.features) == LIST)
"If list, we can simply setadd the feature.";
this.features = setadd(this.features, feature);
else
"If not, we erase the old value and create a new list.";
this.features = {feature};
endif
"Tell the feature it's just been added.";
try
feature:feature_add(this);
except (ANY)
"just ignore errors.";
endtry
return 1;
"We're done.";
else
return E_PERM;
"Feature isn't feature_ok.";
endif
else
return E_PERM;
"Caller doesn't have permission.";
endif
-------------------------------------------------------------------------------
#6 generic player:remove_feature this n/a this
"Remove a feature from this player's features list.  Caller must be this, or have permissions of this, a wizard, or feature.owner.";
"Returns true if successful, E_PERM if caller didn't have permission.";
feature = args[1];
if (((caller == this) || $perm_utils:controls(caller_perms(), this)) || (caller_perms() == feature.owner))
if (typeof(this.features) == LIST)
"If this is a list, we can just setremove...";
this.features = setremove(this.features, feature);
"Otherwise, we leave it alone.";
endif
"Let the feature know it's been removed.";
try
feature:feature_remove(this);
except (ANY)
"just ignore errors.";
endtry
return 1;
"We're done.";
else
return E_PERM;
"Caller didn't have permission.";
endif
-------------------------------------------------------------------------------
#6 generic player:@add-feature @addfeature any n/a none
"Usage:";
"  @add-feature";
"  @add-feature <feature object>";
"Modified 10 Oct 94, by Michele, to check the warehouse and match.";
"Lists all features or adds an object to your features list.";
set_task_perms(player);
if (dobjstr)
if (dobj == $failed_match)
dobj = $feature.warehouse:match_object(dobjstr);
endif
if (!$command_utils:object_match_failed(dobj, dobjstr))
if (dobj in player.features)
player:tell(dobjstr, " is already one of your features.");
elseif (player:add_feature(dobj))
player:tell(dobj, " (", dobj.name, ") added as a feature.");
else
player:tell("You can't seem to add ", dobj, " (", dobj.name, ") to your features list.");
endif
endif
else
player:tell("Usage:  @add-feature <object>");
if (length($feature.warehouse.contents) < 20)
player:tell("Available features include:");
player:tell("--------------------------");
fe = {};
for c in ($feature.warehouse.contents)
fe = {(c in player.features) ? c:title() + " (*)" | c:title()};
player:tell("  " + $string_utils:english_list(fe));
endfor
player:tell("--------------------------");
player:tell("A * after the feature name means that you already have that feature.");
endif
endif
-------------------------------------------------------------------------------
#6 generic player:@remove-feature @rmfeature any n/a none
"Usage:  @remove-feature <feature object>";
"Remove an object from your .features list.";
set_task_perms(player);
if (dobjstr)
features = player.features;
if (!valid(dobj))
dobj = $string_utils:match(dobjstr, features, "name", features, "aliases");
endif
if (!$command_utils:object_match_failed(dobj, dobjstr))
if (dobj in features)
player:remove_feature(dobj);
player:tell(dobj, " (", dobj.name, ") removed from your features list.");
else
player:tell(dobjstr, " is not one of your features.");
endif
endif
else
player:tell("Usage:  @remove-feature <object>");
endif
-------------------------------------------------------------------------------
#6 generic player:@features any behind any
"Usage:  @features [<name>] for <player>";
"List the feature objects matching <name> used by <player>.";
if (!iobjstr)
player:tell("Usage: @features [<name>] for <player>");
return;
elseif ($command_utils:player_match_failed(whose = $string_utils:match_player(iobjstr), iobjstr))
return;
endif
features = {};
for feature in (whose.features)
if (!valid(feature))
whose:remove_feature(feature);
elseif ((!dobjstr) || ((dobjstr in feature.aliases) || ((pref = $string_utils:find_prefix(dobjstr, feature.aliases)) || (pref == $ambiguous_match))))
features = listappend(features, feature);
endif
endfor
if (features)
len = max(length("Feature"), length(tostr(max_object()))) + 1;
player:tell($string_utils:left("Feature", len), "Name");
player:tell($string_utils:left("-------", len), "----");
for feature in (features)
player:tell($string_utils:left(tostr(feature), len), feature.name);
endfor
player:tell($string_utils:left("-------", len), "----");
cstr = ((tostr(length(features)) + " feature") + ((length(features) > 1) ? "s" | "")) + " found";
if (whose != this)
cstr = ((((cstr + " on ") + whose.name) + " (") + tostr(whose)) + ")";
endif
if (dobjstr)
cstr = ((cstr + " matching \"") + dobjstr) + "\"";
endif
cstr = cstr + ".";
player:tell(cstr);
elseif (dobjstr)
player:tell("No features found on ", whose.name, " (", whose, ") matching \"", dobjstr, "\".");
else
player:tell("No features found on ", whose.name, " (", whose, ").");
endif
-------------------------------------------------------------------------------
#6 generic player:@features any n/a none
"Usage:  @features [<name>]";
"List the feature objects matching <name> used by player.";
iobjstr = player.name;
iobj = player;
this:("@features")();
-------------------------------------------------------------------------------
#6 generic player:@memory none n/a none
stats = memory_usage();
if (!stats)
player:notify("Sorry, but no memory-usage statistics are available for this server.");
return;
endif
su = $string_utils;
player:notify("Block Size   # In Use    # Free    Bytes In Use   Bytes Free");
player:notify("----------   --------   --------   ------------   ----------");
nused = nfree = bytesused = bytesfree = 0;
kilo = 1024;
meg = kilo * kilo;
for x in (stats)
if (x[2..3] != {0, 0})
bsize = x[1];
if ((bsize % meg) == 0)
bsize = tostr(bsize / meg, " M");
elseif ((bsize % kilo) == 0)
bsize = tostr(bsize / kilo, " K");
endif
bused = x[1] * x[2];
bfree = x[1] * x[3];
player:notify(tostr(su:left(bsize, 10), "   ", su:right(su:group_number(x[2]), 8), "   ", su:right(su:group_number(x[3]), 8), "   ", su:right(su:group_number(bused), 12), "   ", su:right(su:group_number(bfree), 10)));
nused = nused + x[2];
nfree = nfree + x[3];
bytesused = bytesused + bused;
bytesfree = bytesfree + bfree;
endif
endfor
player:notify("");
player:notify(tostr(su:left("Totals:", 10), "   ", su:right(su:group_number(nused), 8), "   ", su:right(su:group_number(nfree), 8), "   ", su:right(su:group_number(bytesused), 12), "   ", su:right(su:group_number(bytesfree), 10)));
player:notify("");
player:notify(tostr("Total Memory Size: ", su:group_number(bytesused + bytesfree), " bytes."));
-------------------------------------------------------------------------------
#6 generic player:@version none n/a none
if ($object_utils:has_property($local, "server_hardware"))
hw = (" on " + $local.server_hardware) + ".";
else
hw = ".";
endif
server_version = server_version();
if (server_version[1] == "v")
server_version[1..1] = "";
endif
player:notify(tostr("The MOO is currently running version ", server_version, " of the LambdaMOO server code", hw));
try
{MOOname, sversion, coretime} = $core_history[1];
player:notify(tostr("The database was derived from a core created on ", $time_utils:time_sub("$n $t, $Y", coretime), " at ", MOOname, " for version ", sversion, " of the server."));
except (E_RANGE)
player:notify("The database was created from scratch.");
except (ANY)
player:notify("No information is available on the database version.");
endtry
-------------------------------------------------------------------------------
#6 generic player:@uptime none n/a none
player:notify(tostr($network.MOO_name, " has been up for ", $time_utils:english_time(time() - $last_restart_time, $last_restart_time), "."));
-------------------------------------------------------------------------------
#6 generic player:@quit none n/a none
boot_player(player);
"-- argh, let the player decide; #3:disfunc() takes care of this --Rog";
"player:moveto(player.home)";
-------------------------------------------------------------------------------
#6 generic player:examine_commands_ok this n/a this
return this == args[1];
-------------------------------------------------------------------------------
#6 generic player:is_listening this n/a this
"return true if player is active.";
return typeof(`idle_seconds(this) ! ANY') != ERR;
-------------------------------------------------------------------------------
#6 generic player:moveto this n/a this
if (args[1] == #-1)
return E_INVARG;
this:notify("You are now in #-1, The Void.  Type `home' to get back.");
endif
set_task_perms(caller_perms());
pass(@args);
-------------------------------------------------------------------------------
#6 generic player:announce*_all_but this n/a this
return this.location:(verb)(@args);
"temporarily let player:announce be noisy to player";
if (verb == "announce_all_but")
if (this in args[1])
return;
endif
args = args[2..$];
endif
this:tell("(from within you) ", @args);
-------------------------------------------------------------------------------
#6 generic player:linewrap this n/a this
"Return a true value if this needs linewrapping.";
"default is true if .linelen > 0";
return this.linelen > 0;
-------------------------------------------------------------------------------
#6 generic player:@set-note-string @set-note-text any n/a none
"Usage:  @set-note-{string | text} {#xx | #xx.pname}";
"        ...lines of text...";
"        .";
"";
"For use by clients' local editors, to save new text for a note or object property.  See $note_editor:local_editing_info() for details.";
text = $command_utils:read_lines_escape((active = player in $note_editor.active) ? {} | {"@edit"}, {tostr("Changing ", argstr, "."), @active ? {} | {"Type `@edit' to take this into the note editor."}});
if (text && (text[1] == "@edit"))
$note_editor:invoke(argstr, verb);
who = $note_editor:loaded(player);
if (who)
$note_editor.texts[who] = text[2];
endif
return;
endif
set_task_perms(player);
text = text[2];
if ((verb == "@set-note-string") && (length(text) <= 1))
text = text ? text[1] | "";
endif
if (spec = $code_utils:parse_propref(argstr))
o = player:my_match_object(spec[1]);
p = spec[2];
if ($object_utils:has_verb(o, vb = "set_" + p) && (typeof(e = o:(vb)(text)) != ERR))
player:tell("Set ", p, " property of ", o.name, " (", o, ") via :", vb, ".");
elseif (text != (e = `o.(p) = text ! ANY'))
player:tell("Error:  ", e);
else
player:tell("Set ", p, " property of ", o.name, " (", o, ").");
endif
elseif (typeof(note = $code_utils:toobj(argstr)) == OBJ)
e = note:set_text(text);
if (typeof(e) == ERR)
player:tell("Error:  ", e);
else
player:tell("Set text of ", note.name, " (", note, ").");
endif
else
player:tell("Error:  Malformed argument to ", verb, ": ", argstr);
endif
-------------------------------------------------------------------------------
#6 generic player:verb_sub this n/a this
text = args[1];
if (a = `$list_utils:assoc(text, this.verb_subs) ! ANY')
return a[2];
else
return $gender_utils:get_conj(text, this);
endif
-------------------------------------------------------------------------------
#6 generic player:ownership_quota this n/a this
if ($perm_utils:controls(caller_perms(), this))
return this.(verb);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:tell_lines this n/a this
lines = args[1];
if (typeof(lines) != LIST)
lines = {lines};
endif
if (this.gaglist || this.paranoid)
"Check the above first, default case, to save ticks.  Paranoid gaggers are cost an extra three or so ticks by this, probably a net savings.";
if (this:gag_p())
return;
endif
if (this.paranoid == 2)
z = this:whodunnit({@callers(1), {player, "", player}}, {this, $no_one}, {})[3];
lines = {((("[start text by " + z.name) + " (") + tostr(z)) + ")]", @lines, ((("[end text by " + z.name) + " (") + tostr(z)) + ")]"};
elseif (this.paranoid == 1)
$paranoid_db:add_data(this, {{@callers(1), {player, "<cmd-line>", player}}, lines});
endif
endif
"don't gather stats for now: $list_utils:check_nonstring_tell_lines(lines)";
this:notify_lines(lines);
-------------------------------------------------------------------------------
#6 generic player:@lastlog any n/a none
"Copied from generic room (#3):@lastlog by Haakon (#2) Wed Dec 30 13:30:02 1992 PST";
if (dobjstr != "")
dobj = $string_utils:match_player(dobjstr);
if (!valid(dobj))
player:tell("Who?");
return;
endif
folks = {dobj};
else
folks = players();
endif
if (length(folks) > 100)
player:tell("You have requested a listing of ", length(folks), " players.  That is too long a list; specify individual players you are interested in.");
return;
endif
day = week = month = ever = never = {};
a_day = (24 * 60) * 60;
a_week = 7 * a_day;
a_month = 30 * a_day;
now = time();
for x in (folks)
when = x.last_connect_time;
how_long = now - when;
if ((when == 0) || (when > now))
never = {@never, x};
elseif (how_long < a_day)
day = {@day, x};
elseif (how_long < a_week)
week = {@week, x};
elseif (how_long < a_month)
month = {@month, x};
else
ever = {@ever, x};
endif
endfor
for entry in ({{day, "the last day"}, {week, "the last week"}, {month, "the last 30 days"}, {ever, "recorded history"}})
if (entry[1])
player:tell("Players who have connected within ", entry[2], ":");
for x in (entry[1])
player:tell("  ", x.name, " last connected ", ctime(x.last_connect_time), ".");
endfor
endif
endfor
if (never)
player:tell("Players who have never connected:");
player:tell("  ", $string_utils:english_list($list_utils:map_prop(never, "name")));
endif
-------------------------------------------------------------------------------
#6 generic player:set_linelength this n/a this
"Set linelength.  Linelength must be an integer >= 10.";
"If wrap is currently off (i.e. linelength is less than 0), maintains sign.  That is, this function *takes* an absolute value, and coerces the sign to be appropriate.";
"If you want to override the dwimming of wrap, pass in a second argument.";
"returns E_PERM if not allowed, E_INVARG if linelength is too low, otherwise the linelength.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (abs(len = args[1]) < 10)
return E_INVARG;
elseif (length(args) > 1)
this.linelen = len;
else
"DWIM here.";
this.linelen = (this.linelen > 0) ? len | (-len);
return len;
endif
-------------------------------------------------------------------------------
#6 generic player:set_pagelength this n/a this
"Set pagelength. Must be an integer >= 5, or 0 to turn pagelength off.";
"Returns E_PERM if you shouldn't be doing this, E_INVARG if it's too low, otherwise, what it got set to.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (((len = args[1]) < 5) && (len != 0))
return E_INVARG;
else
if ((this.pagelen = len) == 0)
if (lb = this.linebuffer)
"queued text remains";
this:notify_lines(lb);
clear_property(this, "linebuffer");
endif
endif
return len;
endif
-------------------------------------------------------------------------------
#6 generic player:set_home this n/a this
"set_home(newhome) attempts to change this.home to newhome";
"E_TYPE   if newhome doesn't have a callable :accept_for_abode verb.";
"E_INVARG if newhome won't accept you as a resident.";
"E_PERM   if you don't own this and aren't its parent.";
"1        if it works.";
newhome = args[1];
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
if ($object_utils:has_callable_verb(newhome, "accept_for_abode"))
if (newhome:accept_for_abode(this))
return (typeof(e = `this.home = args[1] ! ANY') != ERR) || e;
else
return E_INVARG;
endif
else
return E_TYPE;
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:@registerme any ?-2? any
"@registerme as <email-address> -- enter a new email address for player";
"   will change the database entry, assign a new password, and mail the new password to the player at the given email address.";
if (player != this)
return player:notify(tostr(E_PERM));
endif
who = this;
if ($object_utils:isa(this, $guest))
who:notify("Sorry, guests should use the '@request' command to request a character.");
return;
endif
connection = $string_utils:connection_hostname(connection_name(who));
if (!argstr)
if ($wiz_utils:get_email_address(who))
player:tell("You are currently registered as:  ", $wiz_utils:get_email_address(who));
else
player:tell("You are not currently registered.");
endif
player:tell("Use @registerme as <address> to change this.");
return;
elseif (((prepstr != "as") || (!iobjstr)) || dobjstr)
player:tell("Usage: @registerme as <address>");
return;
endif
email = iobjstr;
if (email == $wiz_utils:get_email_address(this))
who:notify("That is your current address.  Not changed.");
return;
elseif (reason = $wiz_utils:check_reregistration(this, email, connection))
if (reason[1] == "-")
if (!$command_utils:yes_or_no(reason[2..$] + ". Automatic registration not allowed. Ask to be registered at this address anyway?"))
who:notify("Okay.");
return;
endif
else
return who:notify(tostr(reason, " Please try again."));
endif
endif
if ($network.active && (!reason))
if (!$command_utils:yes_or_no(tostr("If you continue, your password will be changed, the new password mailed to `", email, "'. Do you want to continue?")))
return who:notify("Registration terminated.");
endif
password = $wiz_utils:random_password(5);
old = $wiz_utils:get_email_address(who) || "[ unregistered ]";
who:notify(tostr("Registering you, and changing your password and mailing new one to ", email, "."));
result = $network:sendmail(email, tostr("Your ", $network.MOO_Name, " character, ", who.name), "Reply-to: " + $login.registration_address, @$generic_editor:fill_string(tostr("Your ", $network.MOO_name, " character, ", $string_utils:nn(who), " has been registered to this email address (", email, "), and a new password assigned.  The new password is `", password, "'. Please keep your password secure. You can change your password with the @password command."), 75));
if (result != 0)
who:notify(tostr("Mail sending did not work: ", reason, ". Reregistration terminated."));
return;
endif
who:notify(tostr("Mail with your new password forwarded. If you do not get it, send regular email to ", $login.registration_address, " with your character name."));
$mail_agent:send_message($new_player_log, $new_player_log, "reg " + $string_utils:nn(this), {email, tostr("formerly ", old)});
$registration_db:add(this, email, "Reregistered at " + ctime());
$wiz_utils:set_email_address(this, email);
who.password = crypt(password);
who.last_password_time = time();
else
who:notify("No automatic reregistration: your request will be forwarded.");
if (typeof(curreg = $registration_db:find(email)) == LIST)
additional_info = {"Current registration information for this email address:", @$registration_db:describe_registration(curreg)};
else
additional_info = {};
endif
$mail_agent:send_message(this, $registration_db.registrar, "Registration request", {((("Reregistration request from " + $string_utils:nn(who)) + " connected via ") + connection) + ":", "", (("@register " + who.name) + " ") + email, ("@new-password " + who.name) + " is ", "", "Reason this request was forwarded:", reason, @additional_info});
endif
-------------------------------------------------------------------------------
#6 generic player:ctime this n/a this
":ctime([INT time]) => STR as the function.";
"May be hacked by players and player-classes to reflect differences in time-zone.";
return ctime(@args);
-------------------------------------------------------------------------------
#6 generic player:@age any n/a none
if ((dobjstr == "") || (dobj == player))
dobj = player;
else
dobj = $string_utils:match_player(dobjstr);
if (!valid(dobj))
$command_utils:player_match_failed(dobj, dobjstr);
return;
endif
endif
time = dobj.first_connect_time;
if (time == $maxint)
duration = time() - dobj.last_disconnect_time;
if (duration < 86400)
notice = $string_utils:from_seconds(duration);
else
notice = $time_utils:english_time((duration / 86400) * 86400);
endif
player:notify(tostr(dobj.name, " has never connected.  It was created ", notice, " ago."));
elseif (time == 0)
player:notify(tostr(dobj.name, " first connected before initial connections were being recorded."));
else
player:notify(tostr(dobj.name, " first connected on ", ctime(time)));
duration = time() - time;
if (duration < 86400)
notice = $string_utils:from_seconds(duration);
else
notice = $time_utils:english_time((duration / 86400) * 86400);
endif
player:notify(tostr($string_utils:pronoun_sub("%S %<is> ", dobj), notice, " old."));
endif
-------------------------------------------------------------------------------
#6 generic player:news any n/a none
"Usage: news [contents] [articles]";
"";
"Common uses:";
"news           -- display all current news, or as @mail-options decree";
"news new       -- display articles you haven't seen yet";
"news all       -- display all current news";
"news contents  -- display headers of current news";
"news <article> -- display article";
"news archive   -- display news which has been marked as archived.";
set_task_perms(player);
cur = this:get_current_message($news) || {0, 0};
arch = 0;
if (((!args) && (o = player:mail_option("news"))) && (o != "all"))
"no arguments, use the player's default";
args = {o};
elseif (args == {"all"})
args = {};
elseif (args == {"archive"})
arch = 1;
args = {};
endif
if (hdrs_only = args && (args[1] == "contents"))
"Do the mail contents list";
args[1..1] = {};
endif
if (args)
if (typeof(seq = $news:_parse(args, @cur)) == STR)
player:notify(seq);
return;
elseif (seq = $seq_utils:intersection(seq, $news.current_news))
else
player:notify((args == {"new"}) ? "No new news." | "None of those are current articles.");
return;
endif
elseif (arch && (seq = $news.archive_news))
"yduJ hates this coding style.  Just so you know.";
elseif (seq = $news.current_news)
else
player:notify("No news");
return;
endif
if (hdrs_only)
$news:display_seq_headers(seq, @cur);
else
player:set_current_message($news, @$news:news_display_seq_full(seq));
endif
-------------------------------------------------------------------------------
#6 generic player:@edit any ?-2? any
"Calls the verb editor on verbs, the note editor on properties, and on anything else assumes it's an object for which you want to edit the .description.";
if (!args)
((player in $note_editor.active) ? $note_editor | $verb_editor):invoke(dobjstr, verb);
elseif ($code_utils:parse_verbref(args[1]))
if (player.programmer)
$verb_editor:invoke(argstr, verb);
else
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
endif
else
$note_editor:invoke(dobjstr, verb);
endif
-------------------------------------------------------------------------------
#6 generic player:erase_paranoid_data this n/a this
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
$paranoid_db:erase_data(this);
endif
-------------------------------------------------------------------------------
#6 generic player:@move-new any ?-2? any
"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.";
set_task_perms((caller == this) ? this | $no_one);
if ((prepstr != "to") || (!iobjstr))
player:tell("Usage: @move <object> to <location>");
return;
endif
if ((!dobjstr) || (dobjstr == "me"))
dobj = this;
else
dobj = here:match_object(dobjstr);
if (!valid(dobj))
dobj = player:my_match_object(dobjstr);
endif
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
iobj = this:lookup_room(iobjstr);
if ((iobj != $nothing) && $command_utils:object_match_failed(iobj, iobjstr))
return;
endif
if (((!player.programmer) && (!$perm_utils:controls(this, dobj))) && (this != dobj))
player:tell("You may only @move your own things.");
return;
endif
this:teleport(dobj, iobj);
-------------------------------------------------------------------------------
#6 generic player:notify_lines_suspended this n/a this
if (($perm_utils:controls(caller_perms(), this) || (caller == this)) || (caller_perms() == this))
set_task_perms(caller_perms());
for line in ((typeof(lines = args[1]) != LIST) ? {lines} | lines)
$command_utils:suspend_if_needed(0);
this:notify(tostr(line));
endfor
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#6 generic player:_chparent this n/a this
set_task_perms(caller_perms());
return chparent(@args);
-------------------------------------------------------------------------------
#6 generic player:@users none n/a none
"Prints a count and compact list of the currently-connected players, sorted into columns.";
cp = connected_players();
linelen = player:linelen() || 79;
player:tell(("There are " + tostr(length(cp))) + " players connected:");
dudes = $list_utils:map_prop(cp, "name");
dudes = $list_utils:sort_suspended($login.current_lag, dudes);
player:tell_lines($string_utils:columnize(dudes, 4, linelen));
-------------------------------------------------------------------------------
#6 generic player:@password any ?-2? any
if (typeof(player.password) != STR)
if (length(args) != 1)
return player:notify(tostr("Usage:  ", verb, " <new-password>"));
else
new_password = args[1];
endif
elseif (length(args) != 2)
player:notify(tostr("Usage:  ", verb, " <old-password> <new-password>"));
return;
elseif (player.password != crypt(tostr(args[1]), player.password))
player:notify("That's not your old password.");
return;
elseif (is_clear_property(player, "password"))
player:notify("Your password has a `clear' property.  Please refer to a wizard for assistance in changing it.");
return;
elseif (player in $wiz_utils.change_password_restricted)
player:notify("You are not permitted to change your own password.");
return;
else
new_password = args[2];
endif
if (r = $password_verifier:reject_password(new_password, player))
player:notify(r);
return;
endif
player.password = crypt(tostr(new_password));
player.last_password_time = time();
player:notify("New password set.");
-------------------------------------------------------------------------------
#6 generic player:recycle this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
pass(@args);
features = this.features;
for x in (features)
"Have to do this, or :feature_remove thinks you're a liar and doesn't believe.";
this.features = setremove(this.features, x);
if ($object_utils:has_verb(x, "feature_remove"))
try
x:feature_remove(this);
except (ANY)
player:tell("Failure in ", x, ":feature_remove for player ", $string_utils:nn(this));
endtry
endif
$command_utils:suspend_if_needed(0);
endfor
endif
-------------------------------------------------------------------------------
#6 generic player:gc_gaglist this n/a this
((caller == this) || $perm_utils:controls(caller_perms(), this)) || raise(E_PERM);
if (g = this.gaglist)
recycler = $recycler;
for o in (g)
if (!recycler:valid(o))
g = setremove(g, o);
endif
endfor
this.gaglist = g;
endif
-------------------------------------------------------------------------------
#6 generic player:email_address this n/a this
set_task_perms(caller_perms());
return this.email_address;
-------------------------------------------------------------------------------
#6 generic player:set_email_address this n/a this
set_task_perms(caller_perms());
this.email_address = args[1];
-------------------------------------------------------------------------------
#6 generic player:reconfunc this n/a this
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != $sysobj))
return E_PERM;
endif
return this:confunc(@args);
-------------------------------------------------------------------------------
#6 generic player:@owner any n/a none
if ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
return;
endif
player:tell($string_utils:nn(dobj), " is owned by ", $string_utils:nn(dobj.owner), ".");
-------------------------------------------------------------------------------
================================#7 generic exit===============================================
#7 generic exit.arrive_msg rc = MOONumber 0
#7 generic exit.nogo_msg rc = MOONumber 0
#7 generic exit.source rc = MOOObjRef #-1
#7 generic exit.oarrive_msg rc = MOONumber 0
#7 generic exit.oleave_msg rc = MOONumber 0
#7 generic exit.dest rc = MOOObjRef #-1
#7 generic exit.leave_msg rc = MOONumber 0
#7 generic exit.onogo_msg rc = MOONumber 0
#7 generic exit.obvious rc = MOONumber 1
#7 generic exit:invoke this n/a this
set_task_perms(caller_perms());
this:move(player);
-------------------------------------------------------------------------------
#7 generic exit:move this n/a this
set_task_perms(caller_perms());
what = args[1];
"if ((what.location != this.source) || (!(this in this.source.exits)))";
"  player:tell(\"You can't go that way.\");";
"  return;";
"endif";
unlocked = this:is_unlocked_for(what);
if (unlocked)
this.dest:bless_for_entry(what);
endif
if (unlocked && this.dest:acceptable(what))
start = what.location;
if (msg = this:leave_msg(what))
what:tell_lines(msg);
endif
what:moveto(this.dest);
if (what.location != start)
"Don't print oleave messages if WHAT didn't actually go anywhere...";
this:announce_msg(start, what, (this:oleave_msg(what) || this:defaulting_oleave_msg(what)) || "has left.");
endif
if (what.location == this.dest)
"Don't print arrive messages if WHAT didn't really end up there...";
if (msg = this:arrive_msg(what))
what:tell_lines(msg);
endif
this:announce_msg(what.location, what, this:oarrive_msg(what) || "has arrived.");
endif
else
if (msg = this:nogo_msg(what))
what:tell_lines(msg);
else
what:tell("You can't go that way.");
endif
if (msg = this:onogo_msg(what))
this:announce_msg(what.location, what, msg);
endif
endif
-------------------------------------------------------------------------------
#7 generic exit:recycle this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
try
this.source:remove_exit(this);
this.dest:remove_entrance(this);
except id (ANY)
endtry
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#7 generic exit:leave_msg oleave_msg arrive_msg oarrive_msg nogo_msg onogo_msg this n/a this
msg = this.(verb);
return msg ? $string_utils:pronoun_sub(msg, @args) | "";
-------------------------------------------------------------------------------
#7 generic exit:set_name this n/a this
if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))
return (typeof(e = `this.name = args[1] ! ANY') != ERR) || e;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#7 generic exit:set_aliases this n/a this
if ($perm_utils:controls(cp = caller_perms(), this) || (valid(this.source) && (this.source.owner == cp)))
if (typeof(e = `this.aliases = args[1] ! ANY') == ERR)
return e;
else
return 1;
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#7 generic exit:announce_all_but this n/a this
"This is intended to be called only by exits, for announcing various oxxx messages.  First argument is room to announce in.  Second argument is as in $room:announce_all_but's first arg, who not to announce to.  Rest args are what to say.  If the final arg is a list, prepends all the other rest args to the first line and emits the lines separately.";
where = args[1];
whobut = args[2];
last = args[$];
if (typeof(last) == LIST)
where:announce_all_but(whobut, @args[3..$ - 1], last[1]);
for line in (last[2..$])
where:announce_all_but(whobut, line);
endfor
else
where:announce_all_but(@args[3..$]);
endif
-------------------------------------------------------------------------------
#7 generic exit:defaulting_oleave_msg this n/a this
for k in ({this.name, @this.aliases})
if (k in {"east", "west", "south", "north", "northeast", "southeast", "southwest", "northwest", "out", "up", "down", "nw", "sw", "ne", "se", "in"})
return ("goes " + k) + ".";
elseif (k in {"leave", "out", "exit"})
return "leaves";
endif
endfor
if ((index(this.name, "an ") == 1) || (index(this.name, "a ") == 1))
return ("leaves for " + this.name) + ".";
else
return ("leaves for the " + this.name) + ".";
endif
-------------------------------------------------------------------------------
#7 generic exit:moveto this n/a this
if ((caller in {this, this.owner}) || $perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#7 generic exit:examine_key this n/a this
"examine_key(examiner)";
"return a list of strings to be told to the player, indicating what the key on this type of object means, and what this object's key is set to.";
"the default will only tell the key to a wizard or this object's owner.";
who = args[1];
if (((caller == this) && $perm_utils:controls(who, this)) && (this.key != 0))
return {tostr(this:title(), " will only transport objects matching this key:"), tostr("  ", $lock_utils:unparse_key(this.key))};
endif
-------------------------------------------------------------------------------
#7 generic exit:announce_msg this n/a this
":announce_msg(place, what, msg)";
"  announce msg in place (except to what). Prepend with what:title if it isn't part of the string";
msg = args[3];
what = args[2];
title = what:titlec();
if (!$string_utils:index_delimited(msg, title))
msg = tostr(title, " ", msg);
endif
args[1]:announce_all_but({what}, msg);
-------------------------------------------------------------------------------
================================#8 generic container===============================================
#8 generic container.open_fail_msg rc = MOOString "You can't open that."
#8 generic container.oput_fail_msg rc = MOOString ""
#8 generic container.oopen_fail_msg rc = MOOString ""
#8 generic container.oput_msg rc = MOOString "puts %d in %i."
#8 generic container.dark r = MOONumber 1
#8 generic container.open_key c = MOONumber 0
#8 generic container.oremove_msg rc = MOOString "removes %d from %i."
#8 generic container.put_msg rc = MOOString "You put %d in %i."
#8 generic container.oremove_fail_msg rc = MOOString ""
#8 generic container.opaque r = MOONumber 1
#8 generic container.oopen_msg rc = MOOString "opens %d."
#8 generic container.opened r = MOONumber 0
#8 generic container.empty_msg rc = MOOString "It is empty."
#8 generic container.oclose_msg rc = MOOString "closes %d."
#8 generic container.remove_fail_msg rc = MOOString "You can't remove that."
#8 generic container.close_msg rc = MOOString "You close %d."
#8 generic container.remove_msg rc = MOOString "You remove %d from %i."
#8 generic container.put_fail_msg rc = MOOString "You can't put %d in that."
#8 generic container.open_msg rc = MOOString "You open %d."
#8 generic container:p*ut in*sert d*rop any at/to this
if ((this.location != player) && (this.location != player.location))
player:tell("You can't get at ", this.name, ".");
elseif (dobj == $nothing)
player:tell("What do you want to put ", prepstr, " ", this.name, "?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif ((dobj.location != player) && (dobj.location != player.location))
player:tell("You don't have ", dobj.name, ".");
elseif (!this.opened)
player:tell(this.name, " is closed.");
else
set_task_perms(callers() ? caller_perms() | player);
dobj:moveto(this);
if (dobj.location == this)
player:tell(this:put_msg());
if (msg = this:oput_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell(this:put_fail_msg());
if (msg = this:oput_fail_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
-------------------------------------------------------------------------------
#8 generic container:re*move ta*ke g*et any in/inside/into this
if (!(this.location in {player, player.location}))
player:tell("Sorry, you're too far away.");
elseif (!this.opened)
player:tell(this.name, " is not open.");
elseif (this.dark)
player:tell("You can't see into ", this.name, " to remove anything.");
elseif ((dobj = this:match_object(dobjstr)) == $nothing)
player:tell("What do you want to take from ", this.name, "?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif (!(dobj in this:contents()))
player:tell(dobj.name, " isn't in ", this.name, ".");
else
set_task_perms(callers() ? caller_perms() | player);
dobj:moveto(player);
if (dobj.location == player)
player:tell(this:remove_msg());
if (msg = this:oremove_msg())
player.location:announce(player.name, " ", msg);
endif
else
dobj:moveto(this.location);
if (dobj.location == this.location)
player:tell(this:remove_msg());
if (msg = this:oremove_msg())
player.location:announce(player.name, " ", msg);
endif
player:tell("You can't pick up ", dobj.name, ", so it tumbles onto the floor.");
else
player:tell(this:remove_fail_msg());
if (msg = this:oremove_fail_msg())
player.location:announce(player.name, " ", msg);
endif
endif
endif
endif
-------------------------------------------------------------------------------
#8 generic container:look_self this n/a this
pass();
if (!this.dark)
this:tell_contents();
endif
-------------------------------------------------------------------------------
#8 generic container:acceptable this n/a this
return !is_player(args[1]);
-------------------------------------------------------------------------------
#8 generic container:open this n/a none
perms = (callers() && (caller != this)) ? caller_perms() | player;
if (this.opened)
player:tell("It's already open.");
"elseif (this:is_openable_by(player))";
elseif (this:is_openable_by(perms))
this:set_opened(1);
player:tell(this:open_msg());
if (msg = this:oopen_msg())
player.location:announce(player.name, " ", msg);
endif
else
player:tell(this:open_fail_msg());
if (msg = this:oopen_fail_msg())
player.location:announce(player.name, " ", msg);
endif
endif
-------------------------------------------------------------------------------
#8 generic container:@lock_for_open @lock-for-open this none any
set_task_perms(player);
key = $lock_utils:parse_keyexp(iobjstr, player);
if (typeof(key) == STR)
player:tell("That key expression is malformed:");
player:tell("  ", key);
else
try
this.open_key = key;
player:tell("Locked opening of ", this.name, " with this key:");
player:tell("  ", $lock_utils:unparse_key(key));
except error (ANY)
player:tell(error[2], ".");
endtry
endif
-------------------------------------------------------------------------------
#8 generic container:is_openable_by this n/a this
return (this.open_key == 0) || $lock_utils:eval_key(this.open_key, args[1]);
-------------------------------------------------------------------------------
#8 generic container:close this n/a none
if (!this.opened)
player:tell("It's already closed.");
else
this:set_opened(0);
player:tell(this:close_msg());
if (msg = this:oclose_msg())
player.location:announce(player.name, " ", msg);
endif
endif
-------------------------------------------------------------------------------
#8 generic container:@unlock_for_open @unlock-for-open this n/a none
set_task_perms(player);
try
dobj.open_key = 0;
player:tell("Unlocked ", dobj.name, " for opening.");
except error (ANY)
player:tell(error[2], ".");
endtry
-------------------------------------------------------------------------------
#8 generic container:tell_contents this n/a this
if (this.contents)
player:tell("Contents:");
for thing in (this:contents())
player:tell("  ", thing:title());
endfor
elseif (msg = this:empty_msg())
player:tell(msg);
endif
-------------------------------------------------------------------------------
#8 generic container:set_opened this n/a this
if (!$perm_utils:controls(caller.owner, this))
return E_PERM;
else
this.opened = opened = !(!args[1]);
this.dark = this.opaque > opened;
return opened;
endif
-------------------------------------------------------------------------------
#8 generic container:@opacity this beside any
if (!$perm_utils:controls(player, this))
player:tell("Can't set opacity of something you don't own.");
elseif ((iobjstr != "0") && (!toint(iobjstr)))
player:tell("Opacity must be an integer (0, 1, 2).");
else
player:tell("Opacity changed:  Now " + {"transparent.", "opaque.", "a black hole."}[1 + this:set_opaque(toint(iobjstr))]);
endif
-------------------------------------------------------------------------------
#8 generic container:set_opaque this n/a this
if (!$perm_utils:controls(caller.owner, this))
return E_PERM;
elseif (typeof(number = args[1]) != INT)
return E_INVARG;
else
number = (number < 0) ? 0 | ((number > 2) ? 2 | number);
this.dark = number > this.opened;
return this.opaque = number;
endif
-------------------------------------------------------------------------------
#8 generic container:oclose_msg close_msg oopen_msg open_msg oput_fail_msg put_fail_msg oremove_fail_msg oremove_msg remove_fail_msg remove_msg oput_msg put_msg oopen_fail_msg open_fail_msg empty_msg this n/a this
return (msg = `this.(verb) ! ANY') ? $string_utils:pronoun_sub(msg) | "";
-------------------------------------------------------------------------------
#8 generic container:dark this n/a this
return this.(verb);
-------------------------------------------------------------------------------
================================#9 generic note===============================================
#9 generic note.writers rc = MOOList [ ]
#9 generic note.encryption_key c = MOONumber 0
#9 generic note.text c = MOOList [ ]
#9 generic note:r*ead this n/a none
if (!this:is_readable_by(valid(caller_perms()) ? caller_perms() | player))
player:tell("Sorry, but it seems to be written in some code that you can't read.");
else
this:look_self();
player:tell();
player:tell_lines_suspended(this:text());
player:tell();
player:tell("(You finish reading.)");
endif
-------------------------------------------------------------------------------
#9 generic note:er*ase this n/a none
if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))
this:set_text({});
player:tell("Note erased.");
else
player:tell("You can't erase this note.");
endif
-------------------------------------------------------------------------------
#9 generic note:wr*ite any in front of this
if (this:is_writable_by(valid(caller_perms()) ? caller_perms() | player))
this:set_text({@this.text, dobjstr});
player:tell("Line added to note.");
else
player:tell("You can't write on this note.");
endif
-------------------------------------------------------------------------------
#9 generic note:del*ete rem*ove any in/inside/into this
if (!this:is_writable_by(player))
player:tell("You can't modify this note.");
elseif (!dobjstr)
player:tell("You must tell me which line to delete.");
else
line = toint(dobjstr);
if (line < 0)
line = (line + length(this.text)) + 1;
endif
if ((line <= 0) || (line > length(this.text)))
player:tell("Line out of range.");
else
this:set_text(listdelete(this.text, line));
player:tell("Line deleted.");
endif
endif
-------------------------------------------------------------------------------
#9 generic note:encrypt this none any
set_task_perms(player);
key = $lock_utils:parse_keyexp(iobjstr, player);
if (typeof(key) == STR)
player:tell("That key expression is malformed:");
player:tell("  ", key);
else
try
this.encryption_key = key;
player:tell("Encrypted ", this.name, " with this key:");
player:tell("  ", $lock_utils:unparse_key(key));
except error (ANY)
player:tell(error[2], ".");
endtry
endif
-------------------------------------------------------------------------------
#9 generic note:decrypt this n/a none
set_task_perms(player);
try
dobj.encryption_key = 0;
player:tell("Decrypted ", dobj.name, ".");
except error (ANY)
player:tell(error[2], ".");
endtry
-------------------------------------------------------------------------------
#9 generic note:text this n/a this
cp = caller_perms();
if ($perm_utils:controls(cp, this) || this:is_readable_by(cp))
return this.text;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#9 generic note:is_readable_by this n/a this
key = this.encryption_key;
return (key == 0) || $lock_utils:eval_key(key, args[1]);
-------------------------------------------------------------------------------
#9 generic note:set_text this n/a this
cp = caller_perms();
newtext = args[1];
if ($perm_utils:controls(cp, this) || this:is_writable_by(cp))
if (typeof(newtext) == LIST)
this.text = newtext;
else
return E_TYPE;
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#9 generic note:is_writable_by this n/a this
who = args[1];
wr = this.writers;
if ($perm_utils:controls(who, this))
return 1;
elseif (typeof(wr) == LIST)
return who in wr;
else
return wr;
endif
-------------------------------------------------------------------------------
#9 generic note:mailme @mailme this n/a none
"Usage:  mailme <note>";
"  uses $network to sends the text of this note to your REAL internet email address.";
if (!this:is_readable_by(player))
return player:tell("Sorry, but it seems to be written in some code that you can't read.");
elseif (!(email = $wiz_utils:get_email_address(player)))
return player:tell("Sorry, you don't have a registered email address.");
elseif (!$network.active)
return player:tell("Sorry, internet mail is disabled.");
elseif (!(text = this:text()))
return player:tell($string_utils:pronoun_sub("%T is empty--there wouldn't be any point to mailing it."));
endif
player:tell("Mailing ", this:title(), " to ", email, ".");
player:tell("... ", length(text), " lines ...");
suspend(0);
$network:sendmail(email, this:titlec(), "", @text);
-------------------------------------------------------------------------------
================================#10 Login Commands===============================================
#10 Login Commands.graylist  = MOOList [ [ ], [ ] ]
#10 Login Commands.boot_process rc = MOONumber 0
#10 Login Commands.request_enabled rc = MOONumber 0
#10 Login Commands.connection_limit_msg r = MOOString "*** The MOO is too busy! The current lag is %l; there are %n connected.  WAIT FIVE MINUTES BEFORE TRYING AGAIN."
#10 Login Commands.temporary_spooflist  = MOOList [ [ ], [ ] ]
#10 Login Commands.newted  = MOOList [ ]
#10 Login Commands.current_connections rc = MOOList [ #-2 ]
#10 Login Commands.registration_string rc = MOOString "Character creation is disabled."
#10 Login Commands.current_lag r = MOONumber 0
#10 Login Commands.lag_sample_interval rc = MOONumber 15
#10 Login Commands.temporary_newts c = MOOList [ ]
#10 Login Commands.checkpoint_in_progress rc = MOONumber 0
#10 Login Commands.intercepted_players  = MOOList [ ]
#10 Login Commands.ignored rc = MOOList [ ]
#10 Login Commands.current_numcommands rc = MOOList [ 1 ]
#10 Login Commands.temporary_graylist  = MOOList [ [ ], [ ] ]
#10 Login Commands.max_player_name rc = MOONumber 40
#10 Login Commands.lag_cutoff rc = MOONumber 5
#10 Login Commands.lag_exemptions rc = MOOList [ ]
#10 Login Commands.create_enabled rc = MOONumber 1
#10 Login Commands.redlist  = MOOList [ [ ], [ ] ]
#10 Login Commands.intercepted_actions  = MOOList [ ]
#10 Login Commands.blank_command r = MOOString "welcome"
#10 Login Commands.help_message rc = MOOList [ "Sorry, but there's no help here yet.  Type `?' for a list of commands." ]
#10 Login Commands.downtimes rc = MOOList [ [ 1529543472, 0 ], [ 1529444307, 0 ] ]
#10 Login Commands.welcome_message rc = MOOList [ "Welcome to the LambdaCore database.", "", "Type 'connect wizard' to log in.", "", "You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively." ]
#10 Login Commands.last_lag_sample rc = MOONumber 0
#10 Login Commands.goaway_message rc = MOOList [ "                          ***************************", "                          *  Welcome to LagdaMOO!  *", "                          ***************************", "                                       ", "                      Running Version %v of LagdaMOO", "", "PLEASE NOTE:", "   LagdaMOO is a new kind of society, where thousands of people voluntarily", "come together from all over the world.  What these people say or do may not", "always be to your liking; as when visiting any international city, it is wise", "to be careful who you associate with and what you say.", "   The operators of LagdaMOO have provided the materials for the buildings of", "this community, but are not responsible for what is said or done in them.  In", "particular, you must assume responsibility if you permit minors or others to", "access LagdaMOO through your facilities.  The statements and viewpoints", "expressed here are not necessarily those of the wizards, Pavel Curtis, ", "Stanford University, or Placeware Inc., and those parties disclaim any ", "responsibility for them.", "", "NOTICE FOR JOURNALISTS AND RESEARCHERS:", "  The citizens of LagdaMOO request that you ask for permission from all", "direct participants before quoting any material collected here.", "", "For assistance either now or later, type `help'." ]
#10 Login Commands.lag_samples rc = MOOList [ 0, 0, 0, 0, 0 ]
#10 Login Commands.bogus_command r = MOOString "?"
#10 Login Commands.registration_address rc = MOOString ""
#10 Login Commands.max_connections rc = MOONumber 99999
#10 Login Commands.newt_registration_string rc = MOOString "Your character is temporarily hosed."
#10 Login Commands.spooflist  = MOOList [ [ ], [ ] ]
#10 Login Commands.max_numcommands rc = MOONumber 20
#10 Login Commands.blacklist  = MOOList [ [ ], [ ] ]
#10 Login Commands.print_lag rc = MOONumber 0
#10 Login Commands.temporary_blacklist  = MOOList [ [ ], [ ] ]
#10 Login Commands.who_masks_wizards  = MOONumber 0
#10 Login Commands.temporary_redlist  = MOOList [ [ ], [ ] ]
#10 Login Commands:? any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
else
clist = {};
for j in ({this, @$object_utils:ancestors(this)})
for i in [1..length(verbs(j))]
if ((verb_args(j, i) == {"any", "none", "any"}) && index((info = verb_info(j, i))[2], "x"))
vname = $string_utils:explode(info[3])[1];
star = index(vname + "*", "*");
clist = {@clist, $string_utils:uppercase(vname[1..star - 1]) + strsub(vname[star..$], "*", "")};
endif
endfor
endfor
notify(player, "I don't understand that.  Valid commands at this point are");
notify(player, "   " + $string_utils:english_list(setremove(clist, "?"), "", " or "));
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:wel*come @wel*come any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
else
msg = this.welcome_message;
version = server_version();
for line in ((typeof(msg) == LIST) ? msg | {msg})
if (typeof(line) == STR)
notify(player, strsub(line, "%v", version));
endif
endfor
this:check_player_db();
this:check_for_shutdown();
this:check_for_checkpoint();
this:maybe_print_lag();
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:w*ho @w*ho any n/a any
masked = $login.who_masks_wizards ? $wiz_utils:connected_wizards() | {};
if ((caller != #0) && (caller != this))
return E_PERM;
elseif (!args)
plyrs = connected_players();
if (length(plyrs) > 100)
this:notify(tostr("You have requested a listing of ", length(plyrs), " players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you."));
return 0;
else
$code_utils:show_who_listing($set_utils:difference(plyrs, masked)) || this:notify("No one logged in.");
endif
else
plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);
if (length(plyrs) > 100)
this:notify(tostr("You have requested a listing of ", length(plyrs), " players.  Please restrict the number of players in any single request to a smaller number.  The lag thanks you."));
return 0;
endif
$code_utils:show_who_listing(plyrs, $set_utils:intersection(plyrs, masked));
endif
return 0;
-------------------------------------------------------------------------------
#10 Login Commands:co*nnect @co*nnect any n/a any
"$login:connect(player-name [, password])";
" => 0 (for failed connections)";
" => objnum (for successful connections)";
((caller == #0) || (caller == this)) || raise(E_PERM);
"=================================================================";
"=== Check arguments, print usage notice if necessary";
try
{name, ?password = 0} = args;
name = strsub(name, " ", "_");
except (E_ARGS)
notify(player, tostr("Usage:  ", verb, " <existing-player-name> <password>"));
return 0;
endtry
try
"=================================================================";
"=== Is our candidate name invalid?";
if (!valid(candidate = orig_candidate = this:_match_player(name)))
raise(E_INVARG, tostr("`", name, "' matches no player name."));
endif
"=================================================================";
"=== Is our candidate unable to connect for generic security";
"=== reasons (ie clear password, non-player object)?";
if (`is_clear_property(candidate, "password") ! E_PROPNF' || (!$object_utils:isa(candidate, $player)))
server_log(tostr("FAILED CONNECT: ", name, " (", candidate, ") on ", connection_name(player), ($string_utils:connection_hostname(connection_name(player)) in candidate.all_connect_places) ? "" | "******"));
raise(E_INVARG);
endif
"=================================================================";
"=== Check password";
if (typeof(cp = candidate.password) == STR)
"=== Candidate requires a password";
if (password)
"=== Candidate requires a password, and one was provided";
if (strcmp(crypt(password, cp), cp))
"=== Candidate requires a password, and one was provided, which was wrong";
server_log(tostr("FAILED CONNECT: ", name, " (", candidate, ") on ", connection_name(player), ($string_utils:connection_hostname(connection_name(player)) in candidate.all_connect_places) ? "" | "******"));
raise(E_INVARG, "Invalid password.");
else
"=== Candidate requires a password, and one was provided, which was right";
endif
else
"=== Candidate requires a password, and none was provided";
set_connection_option(player, "binary", 1);
notify(player, "Password: ");
set_connection_option(player, "binary", 0);
set_connection_option(player, "client-echo", 0);
this:add_interception(player, "intercepted_password", candidate);
return 0;
endif
elseif (cp == 0)
"=== Candidate does not require a password";
else
"=== Candidate has a nonstandard password; something's wrong";
raise(E_INVARG);
endif
"=================================================================";
"=== Is the player locked out?";
if ($no_connect_message && (!candidate.wizard))
notify(player, $no_connect_message);
server_log(tostr("REJECTED CONNECT: ", name, " (", candidate, ") on ", connection_name(player)));
return 0;
endif
"=================================================================";
"=== Check guest connections";
if ($object_utils:isa(candidate, $guest) && (!valid(candidate = candidate:defer())))
if (candidate == #-2)
server_log(tostr("GUEST DENIED: ", connection_name(player)));
notify(player, "Sorry, guest characters are not allowed from your site at the current time.");
else
notify(player, "Sorry, all of our guest characters are in use right now.");
endif
return 0;
endif
"=================================================================";
"=== Check newts";
if (candidate in this.newted)
if (entry = $list_utils:assoc(candidate, this.temporary_newts))
if ((uptime = this:uptime_since(entry[2])) > entry[3])
"Temporary newting period is over.  Remove entry.  Oh, send mail, too.";
this.temporary_newts = setremove(this.temporary_newts, entry);
this.newted = setremove(this.newted, candidate);
fork (0)
player = this.owner;
$mail_agent:send_message(player, $newt_log, tostr("automatic @unnewt ", candidate.name, " (", candidate, ")"), {"message sent from $login:connect"});
endfork
else
notify(player, "");
notify(player, this:temp_newt_registration_string(entry[3] - uptime));
boot_player(player);
return 0;
endif
else
notify(player, "");
notify(player, this:newt_registration_string());
boot_player(player);
return 0;
endif
endif
"=================================================================";
"=== Connection limits based on lag";
if ((((!candidate.wizard) && (!(candidate in this.lag_exemptions))) && ((howmany = length(connected_players())) >= (max = this:max_connections()))) && (!$object_utils:connected(candidate)))
notify(player, $string_utils:subst(this.connection_limit_msg, {{"%n", tostr(howmany)}, {"%m", tostr(max)}, {"%l", tostr(this:current_lag())}, {"%t", candidate.last_connect_attempt ? ctime(candidate.last_connect_attempt) | "not recorded"}}));
if ($object_utils:has_property($local, "mudlist"))
notify(player, "You may wish to try another MUD while waiting for the MOO to unlag.  Here are a few that we know of:");
for l in ($local.mudlist:choose(3))
notify(player, l);
endfor
endif
candidate.last_connect_attempt = time();
server_log(tostr("CONNECTION LIMIT EXCEEDED: ", name, " (", candidate, ") on ", connection_name(player)));
boot_player(player);
return 0;
endif
"=================================================================";
"=== Log the player on!";
if (candidate != orig_candidate)
notify(player, tostr("Okay,... ", name, " is in use.  Logging you in as `", candidate.name, "'"));
endif
this:record_connection(candidate);
return candidate;
except (E_INVARG)
notify(player, "Either that player does not exist, or has a different password.");
return 0;
endtry
-------------------------------------------------------------------------------
#10 Login Commands:cr*eate @cr*eate any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
"... caller isn't :do_login_command()...";
elseif (!this:player_creation_enabled(player))
notify(player, this:registration_string());
"... we've disabled player creation ...";
elseif (length(args) != 2)
notify(player, tostr("Usage:  ", verb, " <new-player-name> <new-password>"));
elseif ($player_db.frozen)
notify(player, "Sorry, can't create any new players right now.  Try again in a few minutes.");
elseif ((!(name = args[1])) || (name == "<>"))
notify(player, "You can't have a blank name!");
if (name)
notify(player, "Also, don't use angle brackets (<>).");
endif
elseif ((name[1] == "<") && (name[$] == ">"))
notify(player, "Try that again but without the angle brackets, e.g.,");
notify(player, tostr(" ", verb, " ", name[2..$ - 1], " ", strsub(strsub(args[2], "<", ""), ">", "")));
notify(player, "This goes for other commands as well.");
elseif (index(name, " "))
notify(player, "Sorry, no spaces are allowed in player names.  Use dashes or underscores.");
"... lots of routines depend on there not being spaces in player names...";
elseif ((!$player_db:available(name)) || (this:_match_player(name) != $failed_match))
notify(player, "Sorry, that name is not available.  Please choose another.");
"... note the :_match_player call is not strictly necessary...";
"... it is merely there to handle the case that $player_db gets corrupted.";
elseif (!(password = args[2]))
notify(player, "You must set a password for your player.");
else
new = $quota_utils:bi_create($player_class, $nothing);
set_player_flag(new, 1);
new.name = name;
new.aliases = {name};
new.programmer = $player_class.programmer;
new.password = crypt(password);
new.last_password_time = time();
new.last_connect_time = $maxint;
"Last disconnect time is creation time, until they login.";
new.last_disconnect_time = time();
"make sure the owership quota isn't clear!";
$quota_utils:initialize_quota(new);
this:record_connection(new);
$player_db:insert(name, new);
`move(new, $player_start) ! ANY';
return new;
endif
return 0;
-------------------------------------------------------------------------------
#10 Login Commands:q*uit @q*uit any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
else
boot_player(player);
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:up*time @up*time any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
else
notify(player, tostr("The server has been up for ", $time_utils:english_time(time() - $last_restart_time), "."));
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:v*ersion @v*ersion any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
else
notify(player, tostr("The MOO is currently running version ", server_version(), " of the LambdaMOO server code."));
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:parse_command this n/a this
":parse_command(@args) => {verb, args}";
"Given the args from #0:do_login_command,";
"  returns the actual $login verb to call and the args to use.";
"Commands available to not-logged-in users should be located on this object and given the verb_args \"any none any\"";
if ((caller != #0) && (caller != this))
return E_PERM;
endif
if (li = this:interception(player))
return {@li, @args};
endif
if (!args)
return {this.blank_command, @args};
elseif ((verb = args[1]) && (!$string_utils:is_numeric(verb)))
for i in ({this, @$object_utils:ancestors(this)})
try
if ((verb_args(i, verb) == {"any", "none", "any"}) && index(verb_info(i, verb)[2], "x"))
return args;
endif
except (ANY)
continue i;
endtry
endfor
endif
return {this.bogus_command, @args};
-------------------------------------------------------------------------------
#10 Login Commands:check_for_shutdown this n/a this
when = $shutdown_time - time();
if (when >= 0)
line = "***************************************************************************";
notify(player, "");
notify(player, "");
notify(player, line);
notify(player, line);
notify(player, "****");
notify(player, ("****  WARNING:  The server will shut down in " + $time_utils:english_time(when - (when % 60))) + ".");
for piece in ($generic_editor:fill_string($shutdown_message, 60))
notify(player, "****            " + piece);
endfor
notify(player, "****");
notify(player, line);
notify(player, line);
notify(player, "");
notify(player, "");
endif
-------------------------------------------------------------------------------
#10 Login Commands:check_player_db this n/a this
if ($player_db.frozen)
line = "***************************************************************************";
notify(player, "");
notify(player, line);
notify(player, "***");
for piece in ($generic_editor:fill_string("The character-name matcher is currently being reloaded.  This means your character name might not be recognized even though it still exists.  Don't panic.  You can either wait for the reload to finish or you can connect using your object number if you remember it (e.g., `connect #1234 yourpassword').", 65))
notify(player, "***       " + piece);
endfor
notify(player, "***");
for piece in ($generic_editor:fill_string("Repeat:  Do not panic.  In particular, please do not send mail to any wizards or the registrar asking about this.  It will finish in time.  Thank you for your patience.", 65))
notify(player, "***       " + piece);
endfor
if (this:player_creation_enabled(player))
notify(player, "***       This also means that character creation is disabled.");
endif
notify(player, "***");
notify(player, line);
notify(player, "");
endif
-------------------------------------------------------------------------------
#10 Login Commands:_match_player this n/a this
":_match_player(name)";
"This is the matching routine used by @connect.";
"returns either a valid player corresponding to name or $failed_match.";
name = args[1];
if (valid(candidate = $string_utils:literal_object(name)) && is_player(candidate))
return candidate;
endif
".....uncomment this to trust $player_db and have `connect' recognize aliases";
if (valid(candidate = $player_db:find_exact(name)) && is_player(candidate))
return candidate;
endif
".....uncomment this if $player_db gets hosed and you want by-name login";
". for candidate in (players())";
".   if (candidate.name == name)";
".     return candidate; ";
".   endif ";
". endfor ";
".....";
return $failed_match;
-------------------------------------------------------------------------------
#10 Login Commands:notify this n/a this
set_task_perms(caller_perms());
`notify(player, args[1]) ! ANY';
-------------------------------------------------------------------------------
#10 Login Commands:tell this n/a this
"keeps bad things from happening if someone brings this object into a room and talks to it.";
return 0;
-------------------------------------------------------------------------------
#10 Login Commands:player_creation_enabled this n/a this
"Accepts a player object.  If player creation is enabled for that player object, then return true.  Otherwise, return false.";
"Default implementation checks the player's connecting host via $login:blacklisted to decide.";
if (caller_perms().wizard)
return this.create_enabled && (!this:blacklisted($string_utils:connection_hostname(connection_name(args[1]))));
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#10 Login Commands:newt_registration_string registration_string this n/a this
return $string_utils:subst(this.(verb), {{"%e", this.registration_address}, {"%%", "%"}});
-------------------------------------------------------------------------------
#10 Login Commands:init_for_core this n/a this
if (caller_perms().wizard)
this.current_lag = 0;
this.lag_exemptions = {};
this.max_connections = 99999;
this.lag_samples = {0, 0, 0, 0, 0};
this.print_lag = 0;
this.last_lag_sample = 0;
this.bogus_command = "?";
this.blank_command = "welcome";
this.create_enabled = 1;
this.registration_address = "";
this.registration_string = "Character creation is disabled.";
this.newt_registration_string = "Your character is temporarily hosed.";
this.welcome_message = {"Welcome to the LambdaCore database.", "", "Type 'connect wizard' to log in.", "", "You will probably want to change this text and the output of the `help' command, which are stored in $login.welcome_message and $login.help_message, respectively."};
this.help_message = {"Sorry, but there's no help here yet.  Type `?' for a list of commands."};
this.redlist = this.blacklist = this.graylist = this.spooflist = {{}, {}};
this.temporary_redlist = this.temporary_blacklist = this.temporary_graylist = this.temporary_spooflist = {{}, {}};
this.who_masks_wizards = 0;
this.newted = this.temporary_newts = {};
this.downtimes = {};
if ("monitor" in properties(this))
delete_property(this, "monitor");
endif
if ("monitor" in verbs(this))
delete_verb(this, "monitor");
endif
if ("special_action" in verbs(this))
set_verb_code(this, "special_action", {});
endif
pass(@args);
endif
-------------------------------------------------------------------------------
#10 Login Commands:special_action this n/a this
-------------------------------------------------------------------------------
#10 Login Commands:blacklisted graylisted redlisted spooflisted this n/a this
":blacklisted(hostname) => is hostname on the .blacklist";
":graylisted(hostname)  => is hostname on the .graylist";
":redlisted(hostname)   => is hostname on the .redlist";
sitelist = this.(this:listname(verb));
if (!caller_perms().wizard)
return E_PERM;
elseif (((hostname = args[1]) in sitelist[1]) || (hostname in sitelist[2]))
return 1;
elseif ($site_db:domain_literal(hostname))
for lit in (sitelist[1])
if ((index(hostname, lit) == 1) && ((hostname + ".")[length(lit) + 1] == "."))
return 1;
endif
endfor
else
for dom in (sitelist[2])
if (index(dom, "*"))
"...we have a wildcard; let :match_string deal with it...";
if ($string_utils:match_string(hostname, dom))
return 1;
endif
else
"...tail of hostname ...";
if ((r = rindex(hostname, dom)) && ((("." + hostname)[r] == ".") && (((r - 1) + length(dom)) == length(hostname))))
return 1;
endif
endif
endfor
endif
return this:(verb + "_temp")(hostname);
-------------------------------------------------------------------------------
#10 Login Commands:blacklist_add*_temp graylist_add*_temp redlist_add*_temp spooflist_add*_temp this n/a this
"To add a temporary entry, only call the `temp' version.";
"blacklist_add_temp(Site, start time, duration)";
if (!caller_perms().wizard)
return E_PERM;
endif
{where, ?start, ?duration} = args;
lname = this:listname(verb);
which = 1 + (!$site_db:domain_literal(where));
if (index(verb, "temp"))
lname = "temporary_" + lname;
this.(lname)[which] = setadd(this.(lname)[which], {where, start, duration});
else
this.(lname)[which] = setadd(this.(lname)[which], where);
endif
return 1;
-------------------------------------------------------------------------------
#10 Login Commands:blacklist_remove*_temp graylist_remove*_temp redlist_remove*_temp spooflist_remove*_temp this n/a this
"The temp version removes from the temporary property if it exists.";
if (!caller_perms().wizard)
return E_PERM;
endif
where = args[1];
lname = this:listname(verb);
which = 1 + (!$site_db:domain_literal(where));
if (index(verb, "temp"))
lname = "temporary_" + lname;
if (entry = $list_utils:assoc(where, this.(lname)[which]))
this.(lname)[which] = setremove(this.(lname)[which], entry);
return 1;
else
return E_INVARG;
endif
elseif (where in this.(lname)[which])
this.(lname)[which] = setremove(this.(lname)[which], where);
return 1;
else
return E_INVARG;
endif
-------------------------------------------------------------------------------
#10 Login Commands:listname this n/a this
return {"???", "blacklist", "graylist", "redlist", "spooflist"}[1 + index("bgrs", (args[1] || "?")[1])];
-------------------------------------------------------------------------------
#10 Login Commands:who(vanilla) this n/a this
if (caller != #0)
return E_PERM;
elseif (!args)
$code_utils:show_who_listing(connected_players()) || this:notify("No one logged in.");
else
plyrs = listdelete($command_utils:player_match_result($string_utils:match_player(args), args), 1);
$code_utils:show_who_listing(plyrs);
endif
return 0;
-------------------------------------------------------------------------------
#10 Login Commands:record_connection this n/a this
":record_connection(plyr) update plyr's connection information";
"to reflect impending login.";
if (!caller_perms().wizard)
return E_PERM;
else
plyr = args[1];
plyr.first_connect_time = min(time(), plyr.first_connect_time);
plyr.previous_connection = {plyr.last_connect_time, $string_utils:connection_hostname(plyr.last_connect_place)};
plyr.last_connect_time = time();
plyr.last_connect_place = cn = connection_name(player);
chost = $string_utils:connection_hostname(cn);
acp = setremove(plyr.all_connect_places, chost);
plyr.all_connect_places = {chost, @acp[1..min($, 15)]};
if (!$object_utils:isa(plyr, $guest))
$site_db:add(plyr, chost);
endif
endif
-------------------------------------------------------------------------------
#10 Login Commands:sample_lag this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
lag = (time() - this.last_lag_sample) - 15;
this.lag_samples = {lag, @this.lag_samples[1..3]};
"Now compute the current lag and store it in a property, instead of computing it in :current_lag, which is called a hundred times a second.";
thislag = max(0, (time() - this.last_lag_sample) - this.lag_sample_interval);
if (thislag > (60 * 60))
"more than an hour, probably the lag sampler stopped";
this.current_lag = 0;
else
samples = this.lag_samples;
sum = 0;
cnt = 0;
for x in (listdelete(samples, 1))
sum = sum + x;
cnt = cnt + 1;
endfor
this.current_lag = max(thislag, samples[1], samples[2], sum / cnt);
endif
fork (15)
this:sample_lag();
endfork
this.last_lag_sample = time();
-------------------------------------------------------------------------------
#10 Login Commands:is_lagging this n/a this
return this:current_lag() > this.lag_cutoff;
-------------------------------------------------------------------------------
#10 Login Commands:max_connections this n/a this
max = this.max_connections;
if (typeof(max) == LIST)
if (this:is_lagging())
max = max[1];
else
max = max[2];
endif
endif
return max;
-------------------------------------------------------------------------------
#10 Login Commands:request_character this n/a this
"request_character(player, name, address)";
"return true if succeeded";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, name, address} = args;
connection = $string_utils:connection_hostname(connection_name(who));
if (reason = $wiz_utils:check_player_request(name, address, connection))
prefix = "";
if (reason[1] == "-")
reason = reason[2..$];
prefix = "Please";
else
prefix = "Please try again, or, to register another way,";
endif
notify(who, reason);
msg = tostr(prefix, " send mail to ", $login.registration_address, ", with the character name you want.");
for l in ($generic_editor:fill_string(msg, 70))
notify(who, l);
endfor
return 0;
endif
if (lines = $no_one:eval_d("$local.help.(\"multiple-characters\")")[2])
notify(who, "Remember, in general, only one character per person is allowed.");
notify(who, tostr("Do you already have a ", $network.moo_name, " character? [enter `yes' or `no']"));
answer = read(who);
if (answer == "yes")
notify(who, "Process terminated *without* creating a character.");
return 0;
elseif (answer != "no")
return notify(who, tostr("Please try again; when you get this question, answer `yes' or `no'. You answered `", answer, "'"));
endif
notify(who, "For future reference, do you want to see the full policy (from `help multiple-characters'?");
notify(who, "[enter `yes' or `no']");
if (read(who) == "yes")
for x in (lines)
for y in ($generic_editor:fill_string(x, 70))
notify(who, y);
endfor
endfor
endif
endif
notify(who, tostr("A character named `", name, "' will be created."));
notify(who, tostr("A random password will be generated, and e-mailed along with"));
notify(who, tostr(" an explanatory message to: ", address));
notify(who, tostr(" [Please double-check your email address and answer `no' if it is incorrect.]"));
notify(who, "Is this OK? [enter `yes' or `no']");
if (read(who) != "yes")
notify(who, "Process terminated *without* creating a character.");
return 0;
endif
if (!$network.active)
$mail_agent:send_message(this.owner, $registration_db.registrar, "Player request", {"Player request from " + connection, ":", "", (("@make-player " + name) + " ") + address});
notify(who, tostr("Request for new character ", name, " email address '", address, "' accepted."));
notify(who, tostr("Please be patient until the registrar gets around to it."));
notify(who, tostr("If you don't get email within a week, please send regular"));
notify(who, tostr("  email to: ", $login.registration_address, "."));
elseif ($player_db.frozen)
notify(who, "Sorry, can't create any new players right now.  Try again in a few minutes.");
else
new = $wiz_utils:make_player(name, address);
password = new[2];
new = new[1];
notify(who, tostr("Character ", name, " (", new, ") created."));
notify(who, tostr("Mailing password to ", address, "; you should get the mail very soon."));
notify(who, tostr("If you do not get it, please do NOT request another character."));
notify(who, tostr("Instead, send regular email to ", $login.registration_address, ","));
notify(who, tostr("with the name of the character you requested."));
$mail_agent:send_message(this.owner, $new_player_log, tostr(name, " (", new, ")"), {address, tostr(" Automatically created at request of ", valid(player) ? player.name | "unconnected player", " from ", connection, ".")});
$wiz_utils:send_new_player_mail(tostr("Someone connected from ", connection, " at ", ctime(), " requested a character on ", $network.moo_name, " for email address ", address, "."), name, address, new, password);
return 1;
endif
-------------------------------------------------------------------------------
#10 Login Commands:req*uest @req*uest any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
endif
"must be #0:do_login_command";
if (!this.request_enabled)
for line in ($generic_editor:fill_string(this:registration_string(), 70))
notify(player, line);
endfor
elseif ((length(args) != 3) || (args[2] != "for"))
notify(player, tostr("Usage:  ", verb, " <new-player-name> for <email-address>"));
elseif ($login:request_character(player, args[1], args[3]))
boot_player(player);
endif
-------------------------------------------------------------------------------
#10 Login Commands:h*elp @h*elp any n/a any
if ((caller != #0) && (caller != this))
return E_PERM;
else
msg = this.help_message;
for line in ((typeof(msg) == LIST) ? msg | {msg})
if (typeof(line) == STR)
notify(player, line);
endif
endfor
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:maybe_print_lag this n/a this
if ((caller == this) || (caller_perms() == player))
if (this.print_lag)
lag = this:current_lag();
if (lag > 1)
lagstr = tostr("approximately ", lag, " seconds");
elseif (lag == 1)
lagstr = "approximately 1 second";
else
lagstr = "low";
endif
notify(player, tostr("The lag is ", lagstr, "; there ", ((l = length(connected_players())) == 1) ? "is " | "are ", l, " connected."));
endif
endif
-------------------------------------------------------------------------------
#10 Login Commands:current_lag this n/a this
return this.current_lag;
-------------------------------------------------------------------------------
#10 Login Commands:maybe_limit_commands this n/a this
"This limits the number of commands that can be issued from the login prompt to prevent haywire login programs from lagging the MOO.";
"$login.current_connections has the current player id's of people at the login prompt.";
"$login.current_numcommands has the number of commands they have issued at the prompt so far.";
"$login.max_numcommands has the maximum number of commands they may try before being booted.";
if (!caller_perms().wizard)
return E_PERM;
else
if (iconn = player in this.current_connections)
knocks = this.current_numcommands[iconn] = this.current_numcommands[iconn] + 1;
else
this.current_connections = {@this.current_connections, player};
this.current_numcommands = {@this.current_numcommands, 1};
knocks = 1;
"...sweep idle connections...";
for p in (this.current_connections)
if (typeof(`idle_seconds(p) ! ANY') == ERR)
n = p in this.current_connections;
this.current_connections = listdelete(this.current_connections, n);
this.current_numcommands = listdelete(this.current_numcommands, n);
endif
endfor
endif
if (knocks > this.max_numcommands)
notify(player, "Sorry, too many commands issued without connecting.");
boot_player(player);
return 1;
else
return 0;
endif
endif
-------------------------------------------------------------------------------
#10 Login Commands:server_started this n/a this
"Called by #0:server_started when the server restarts.";
if (caller_perms().wizard)
this.lag_samples = {0, 0, 0, 0, 0};
this.downtimes = {{time(), this.last_lag_sample}, @this.downtimes[1..min($, 100)]};
this.intercepted_players = this.intercepted_actions = {};
this.checkpoint_in_progress = 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:uptime_since this n/a this
"uptime_since(time): How much time has LambdaMOO been up since `time'";
since = args[1];
up = time() - since;
for x in (this.downtimes)
if (x[1] < since)
"downtime predates when we're asking about";
return up;
endif
"since the server was down between x[2] and x[1], don't count it as uptime";
up = up - (x[1] - max(x[2], since));
endfor
return up;
-------------------------------------------------------------------------------
#10 Login Commands:count_bg_players this n/a this
caller_perms().wizard || $error:raise(E_PERM);
now = time();
tasks = queued_tasks();
sum = 0;
for t in (tasks)
delay = t[2] - now;
interval = (delay <= 0) ? 1 | (delay * 2);
"SUM is measured in hundredths of a player for the moment...";
(delay <= 300) && (sum = sum + (2000 / interval));
endfor
count = sum / 100;
return count;
-------------------------------------------------------------------------------
#10 Login Commands:blacklisted_temp graylisted_temp redlisted_temp spooflisted_temp this n/a this
":blacklisted_temp(hostname) => is hostname on the .blacklist...";
":graylisted_temp(hostname)  => is hostname on the .graylist...";
":redlisted_temp(hostname)   => is hostname on the .redlist...";
":spooflisted_temp(hostname) => is hostname on the .spooflist...";
"";
"... and the time limit hasn't run out.";
lname = this:listname(verb);
sitelist = this.("temporary_" + lname);
if (!caller_perms().wizard)
return E_PERM;
elseif (entry = $list_utils:assoc(hostname = args[1], sitelist[1]))
return this:templist_expired(lname, @entry);
elseif (entry = $list_utils:assoc(hostname, sitelist[2]))
return this:templist_expired(lname, @entry);
elseif ($site_db:domain_literal(hostname))
for lit in (sitelist[1])
if ((index(hostname, lit[1]) == 1) && ((hostname + ".")[length(lit[1]) + 1] == "."))
return this:templist_expired(lname, @lit);
endif
endfor
else
for dom in (sitelist[2])
if (index(dom[1], "*"))
"...we have a wildcard; let :match_string deal with it...";
if ($string_utils:match_string(hostname, dom[1]))
return this:templist_expired(lname, @dom);
endif
else
"...tail of hostname ...";
if ((r = rindex(hostname, dom[1])) && ((("." + hostname)[r] == ".") && (((r - 1) + length(dom[1])) == length(hostname))))
return this:templist_expired(lname, @dom);
endif
endif
endfor
endif
return 0;
-------------------------------------------------------------------------------
#10 Login Commands:templist_expired this n/a this
"check to see if duration has expired on temporary_<colorlist>. Removes entry if so, returns true if still <colorlisted>";
":(listname, hostname, start time, duration)";
{lname, hname, start, duration} = args;
if (!caller_perms().wizard)
return E_PERM;
endif
if (this:uptime_since(start) > duration)
this:(lname + "_remove_temp")(hname);
return 0;
else
return 1;
endif
-------------------------------------------------------------------------------
#10 Login Commands:temp_newt_registration_string this n/a this
return ("Your character is unavailable for another " + $time_utils:english_time(args[1])) + ".";
-------------------------------------------------------------------------------
#10 Login Commands:add_interception this n/a this
(caller == this) || raise(E_PERM);
{who, verbname, @arguments} = args;
(who in this.intercepted_players) && raise(E_INVARG, "Player already has an interception set.");
this.intercepted_players = {@this.intercepted_players, who};
this.intercepted_actions = {@this.intercepted_actions, {verbname, @arguments}};
return 1;
-------------------------------------------------------------------------------
#10 Login Commands:delete_interception this n/a this
(caller == this) || raise(E_PERM);
{who} = args;
if (loc = who in this.intercepted_players)
this.intercepted_players = listdelete(this.intercepted_players, loc);
this.intercepted_actions = listdelete(this.intercepted_actions, loc);
return 1;
else
"raise an error?  nah.";
return 0;
endif
-------------------------------------------------------------------------------
#10 Login Commands:interception this n/a this
(caller == this) || raise(E_PERM);
{who} = args;
return (loc = who in this.intercepted_players) ? this.intercepted_actions[loc] | 0;
-------------------------------------------------------------------------------
#10 Login Commands:intercepted_password this n/a this
(caller == #0) || raise(E_PERM);
this:delete_interception(player);
set_connection_option(player, "client-echo", 1);
notify(player, "");
try
{candidate, ?password = ""} = args;
except (E_ARGS)
return 0;
endtry
return this:connect(tostr(candidate), password);
-------------------------------------------------------------------------------
#10 Login Commands:do_out_of_band_command doobc this n/a this
"This is where oob handlers need to be put to handle oob commands issued prior to assigning a connection to a player object.  Right now it simply returns.";
return;
-------------------------------------------------------------------------------
#10 Login Commands:check_for_checkpoint this n/a this
if (this.checkpoint_in_progress)
line = "***************************************************************************";
notify(player, "");
notify(player, "");
notify(player, line);
notify(player, line);
notify(player, "****");
notify(player, "****  NOTICE:  The server is very slow now.");
notify(player, "****           The database is being saved to disk.");
notify(player, "****");
notify(player, line);
notify(player, line);
notify(player, "");
notify(player, "");
endif
-------------------------------------------------------------------------------
================================#11 Player Last_huh Verbs===============================================
#11 Player Last_huh Verbs:@* this n/a this
"{last_huh}  @<msg_name> <object> is [<text>]";
"If <text> is given calls <object>:set_message(<msg_name>,<text>),";
"otherwise prints the value of the specified message property";
set_task_perms(caller_perms());
nargs = length(args);
pos = "is" in args;
if (pos == 1)
player:notify(tostr("Usage:  ", verb, " <object> is <message>"));
return;
endif
dobjstr = $string_utils:from_list(args[1..pos - 1], " ");
message = $string_utils:from_list(args[pos + 1..nargs], " ");
msg_name = verb[2..$];
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
"... oh well ...";
elseif (pos == nargs)
if (E_PROPNF == (get = `dobj.(msg_name + "_msg") ! ANY'))
player:notify(tostr(dobj.name, " (", dobj, ") has no \"", msg_name, "\" message."));
elseif (typeof(get) == ERR)
player:notify(tostr(get));
elseif (!get)
player:notify("Message is not set.");
else
player:notify(tostr("The \"", msg_name, "\" message of ", dobj.name, " (", dobj, "):"));
player:notify(tostr(get));
endif
else
set = dobj:set_message(msg_name, message);
if (set)
if (typeof(set) == STR)
player:notify(set);
else
player:notify(tostr("You set the \"", msg_name, "\" message of ", dobj.name, " (", dobj, ")."));
endif
elseif (set == E_PROPNF)
player:notify(tostr(dobj.name, " (", dobj, ") has no \"", msg_name, "\" message to set."));
elseif (typeof(set) == ERR)
player:notify(tostr(set));
else
player:notify(tostr("You clear the \"", msg_name, "\" message of ", dobj.name, " (", dobj, ")."));
endif
endif
-------------------------------------------------------------------------------
#11 Player Last_huh Verbs:give hand this n/a this
"{last_huh}  give any to any";
"a give \"verb\" that works for non-$things.";
set_task_perms(caller_perms());
if (((verb == "give") && (dobjstr == "up")) && (!prepstr))
player:tell("Try this instead: @quit");
elseif (dobj == $nothing)
player:tell("What do you want to give?");
elseif (iobj == $nothing)
player:tell("To whom/what do you want to give it?");
elseif ($command_utils:object_match_failed(dobj, dobjstr) || $command_utils:object_match_failed(iobj, iobjstr))
"...lose...";
elseif (dobj.location != player)
player:tell("You don't have that!");
elseif (iobj.location != player.location)
player:tell("I don't see ", iobj.name, " here.");
else
dobj:moveto(iobj);
if (dobj.location == iobj)
player:tell("You give ", dobj:title(), " to ", iobj.name, ".");
iobj:tell(player.name, " gives you ", dobj:title(), ".");
else
player:tell("Either that doesn't want to be given away or ", iobj.name, " doesn't want it.");
endif
endif
-------------------------------------------------------------------------------
#11 Player Last_huh Verbs:get take this n/a this
"{last_huh}  get/take any";
"a take \"verb\" that works for non-$things.";
set_task_perms(caller_perms());
if (dobj == $nothing)
player:tell(verb, " what?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
"...lose...";
elseif (dobj.location == player)
player:tell("You already have that!");
elseif (dobj.location != player.location)
player:tell("I don't see that here.");
else
dobj:moveto(player);
if (dobj.location == player)
player:tell("Taken.");
player.location:announce(player.name, " takes ", dobj.name, ".");
else
player:tell("You can't pick that up.");
endif
endif
-------------------------------------------------------------------------------
#11 Player Last_huh Verbs:drop throw this n/a this
"{last_huh}  drop/throw any";
"a drop \"verb\" that works for non-$things.";
set_task_perms(caller_perms());
if (dobj == $nothing)
player:tell(verb, " what?");
elseif ($command_utils:object_match_failed(dobj, dobjstr))
"...lose...";
elseif (dobj.location != player)
player:tell("You don't have that.");
elseif (!player.location:acceptable(dobj))
player:tell("You can't drop that here.");
else
dobj:moveto(player.location);
if (dobj.location == player.location)
player:tell_lines((verb[1] == "d") ? "Dropped." | "Thrown.");
player.location:announce(player.name, (verb[1] == "d") ? " dropped " | " threw away ", dobj.name, ".");
else
player:tell_lines("You can't seem to drop that here.");
endif
endif
-------------------------------------------------------------------------------
================================#12 Guest Log===============================================
#12 Guest Log.max_entries  = MOONumber 511
#12 Guest Log.connections  = MOOList [ ]
#12 Guest Log:enter this n/a this
":enter(who,islogin,time,site)";
"adds an entry to the connection log for a given guest (caller).";
if ($object_utils:isa(caller, $guest))
$guest_log.connections = {{caller, @args}, @$guest_log.connections[1..min($guest_log.max_entries, $)]};
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#12 Guest Log:last this n/a this
":last([n,[guest_list]])";
"print list of the last n entries in the guest log";
" (use n=0 if you want all entries)";
" optional second arg limits listing to the specified guest(s)";
set_task_perms(caller_perms());
{?howmany = 0, ?which = 0} = args;
howmany = min(howmany || $maxint, length($guest_log.connections));
if (!caller_perms().wizard)
player:notify("Sorry.");
else
current = {};
listing = {};
last = 0;
for c in ($guest_log.connections[1..howmany])
if (which && (!(c[1] in which)))
elseif (c[2])
"...login...";
if (a = $list_utils:assoc(c[1], current))
listing[a[2]][3] = c[3];
current = setremove(current, a);
else
listing = {@listing, {c[1], c[4], c[3], $object_utils:connected(c[1]) ? -idle_seconds(c[1]) | 1}};
last = last + 1;
endif
else
"...logout...";
listing = {@listing, {c[1], c[4], 0, c[3]}};
last = last + 1;
if (i = $list_utils:iassoc(c[1], current))
current[i][2] = last;
else
current = {@current, {c[1], last}};
endif
endif
$command_utils:suspend_if_needed(2);
endfor
su = $string_utils;
player:notify(su:left(su:left(su:left("Guest", 20) + "Connected", 36) + "Idle/Disconn.", 52) + "From");
player:notify(su:left(su:left(su:left("-----", 20) + "---------", 36) + "-------------", 52) + "----");
for l in (listing)
on = l[3] ? (ct = ctime(l[3]))[1..3] + ct[9..19] | "earlier";
off = (l[4] > 0) ? (ct = ctime(l[4]))[1..3] + ct[9..19] | ("  " + $string_utils:from_seconds(-l[4]));
player:notify(su:left(su:left(su:right(tostr(strsub(l[1].name, "uest", "."), " (", l[1], ")  "), -20) + on, 36) + off, 52) + l[2]);
$command_utils:suspend_if_needed(2);
endfor
endif
-------------------------------------------------------------------------------
#12 Guest Log:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.connections = {};
endif
-------------------------------------------------------------------------------
#12 Guest Log:find this n/a this
":find(guest_id,time)";
" => site name of guest logged in at that time";
" => 0 if not logged in";
" => E_NACC if this is earlier than the earliest guest recorded";
set_task_perms(caller_perms());
{who, when} = args;
if (!caller_perms().wizard)
raise(E_PERM);
else
found = (who in connected_players()) ? $string_utils:connection_hostname(who.last_connect_place) | 0;
for c in ($guest_log.connections)
if (c[3] < when)
return found;
elseif (c[1] != who)
"... different guest...";
elseif (c[2])
"...login...";
if (c[3] == when)
return found;
endif
found = 0;
else
"...logout...";
found = c[4];
endif
endfor
return E_NACC;
endif
-------------------------------------------------------------------------------
================================#13 Generic BigList Utilities===============================================
#13 Generic BigList Utilities.maxfanout rc = MOONumber 7
#13 Generic BigList Utilities.about rc = MOOList [ "Implementation notes", "--------------------", "Each biglist is actually a tree (a kind of B-tree, actually).", "The routines above pass around handles of the form", "", "    {root_node, size, leftmost_ord}", "", "where root_node is the (string) name of a property that holds the root of the tree, size is the number of leaves in the tree, and leftmost_ord is the :_ord value of the leftmost element of the list (i.e., the leftmost leaf).", "Each node property has a value of the form ", "", "    {height,list of subtrees}.", "", "where the each of the subtrees is itself a 3-element list as above unless", "the height is 0, in which case the subtrees are actually biglist elements of the arbitrary form determined by the home object.", "At every level, each node except the rightmost has between this.maxfanout/2 and this.maxfanout subtrees; the rightmost is allowed to have as few as 1 subtree." ]
#13 Generic BigList Utilities:length this n/a this
":length(tree) => number of leaves in tree.";
return args[1] ? args[1][2] | 0;
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:find_nth this n/a this
":find_nth(tree,n) => nth leaf of tree.  Assumes n in [1..tree[2]]";
return this:_find_nth(caller, @args);
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:find_ord this n/a this
":_find_ord(tree,n,comp) ";
" => index of rightmost leaf for which :(comp)(n,:_ord(leaf)) is false.";
"returns 0 if true for all leaves.";
return args[1] ? this:_find_ord(caller, @args) | 0;
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:set_nth this n/a this
":set_nth(tree,n,value) => tree";
"modifies tree so that nth leaf == value";
if (((n = args[2]) < 1) || ((!(tree = args[1])) || (tree[2] < n)))
return E_RANGE;
else
this:_set_nth(caller, @args);
return (n != 1) ? tree | listset(tree, caller:_ord(args[3]), 3);
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:kill this n/a this
":kill(tree[,leafverb]) deletes tree and _kills all of the nodes that it uses.";
"if leafverb is given, caller:leafverb is called on all leaves in tree.";
if (tree = args[1])
lverb = {@args, ""}[2];
this:_skill(caller, (typeof(tree) == LIST) ? tree[1] | tree, lverb);
endif
"... otherwise nothing to do...";
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:insert_after insert_before this n/a this
":insert_after(tree,subtree,n)";
":insert_before(tree,subtree,n)";
"  inserts subtree after (before) the nth leaf of tree,";
"  returning the resulting tree.";
subtree = args[2];
if (tree = args[1])
if (subtree)
where = args[3] - (verb == "insert_before");
if (where <= 0)
return this:_merge(caller, subtree, tree);
elseif (where >= tree[2])
return this:_merge(caller, tree, subtree);
else
s = this:_split(caller, caller:_get(tree[1])[1], where, tree);
return this:_merge(caller, this:_merge(caller, s[1], subtree), s[2]);
endif
else
return tree;
endif
else
return subtree;
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:extract_range this n/a this
":extract_range(tree,first,last) => {newtree,extraction}";
return this:_extract(caller, @args);
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:delete_range this n/a this
":delete_range(tree,first,last[,leafkill]) => newtree";
extract = this:_extract(caller, @args);
if (die = extract[2])
this:_skill(caller, die[1], {@args, ""}[4]);
endif
return extract[1];
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:keep_range this n/a this
":keep_range(tree,first,last[,leafkill]) => range";
extract = this:_extract(caller, @args);
if (die = extract[1])
this:_skill(caller, die[1], {@args, ""}[4]);
endif
return extract[2];
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:insert_last this n/a this
":insert_last(tree,insert) => newtree";
"insert a new leaf to be inserted at the righthand end of the tree";
tree = args[1];
insert = args[2];
if (!tree)
return {caller:_make(0, {insert}), 1, caller:_ord(insert)};
endif
hgt = caller:_get(tree[1]);
rspine = {{tree, plen = length(kids = hgt[2])}};
for i in [1..hgt[1]]
parent = kids[plen];
kids = caller:_get(parent[1])[2];
plen = length(kids);
rspine = {{parent, plen}, @rspine};
endfor
iord = caller:_ord(insert);
for h in [1..length(rspine)]
"... tree is the plen'th (rightmost) child of parent...";
if (rspine[h][2] < this.maxfanout)
parent = rspine[h][1];
hgp = caller:_get(parent[1]);
caller:_put(parent[1], @listset(hgp, {@hgp[2], insert}, 2));
for p in (rspine[h + 1..length(rspine)])
rkid = listset(parent, parent[2] + 1, 2);
parent = p[1];
hgp = caller:_get(parent[1]);
caller:_put(parent[1], @listset(hgp, listset(hgp[2], rkid, p[2]), 2));
endfor
return listset(tree, tree[2] + 1, 2);
endif
insert = {caller:_make(h - 1, {insert}), 1, iord};
endfor
return {caller:_make(length(rspine), {tree, insert}), tree[2] + 1, tree[3]};
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:start this n/a this
":start(tree,first,last) => {list of leaf nodes, @handle}";
"handle is of the form {{node,next,size}...}";
if (tree = args[1])
before = max(0, args[2] - 1);
howmany = min(args[3], tree[2]) - before;
if (howmany <= 0)
return {};
else
spine = {};
for h in [1..caller:_get(tree[1])[1]]
ik = this:_listfind_nth(kids = caller:_get(tree[1])[2], before);
newh = kids[ik[1]][2] - ik[2];
if (newh < howmany)
spine = {{tree[1], ik[1] + 1, howmany - newh}, @spine};
howmany = newh;
endif
tree = kids[ik[1]];
before = ik[2];
endfor
return {caller:_get(tree[1])[2][before + 1..before + howmany], @spine};
endif
else
return {};
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:next this n/a this
":next(@handle) => {list of more leaf nodes, @newhandle}";
if (args)
spine = listdelete(args, 1);
node = args[1][1];
n = args[1][2];
size = args[1][3];
for h in [1..caller:_get(node)[1]]
nnode = caller:_get(node)[2][n];
if (size > nnode[2])
spine = {{node, n + 1, size - nnode[2]}, @spine};
size = nnode[2];
endif
n = 1;
node = nnode[1];
endfor
test = caller:_get(node);
return {test[2][n..size], @spine};
else
return {};
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_find_nth this n/a this
":_find_nth(home,tree,n) => nth leaf of tree.";
"...Assumes n in [1..tree[2]]";
if (caller != this)
return E_PERM;
endif
{home, tree, n} = args;
if ((p = home:_get(tree[1]))[1])
for k in (p[2])
if (n > k[2])
n = n - k[2];
else
return this:_find_nth(home, k, n);
endif
endfor
return E_RANGE;
else
return p[2][n];
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_find_ord this n/a this
":_find_ord(home,tree,n,less_than) ";
" => index of rightmost leaf for which :(less_than)(n,:_ord(leaf)) is false.";
"returns 0 if true for all leaves.";
if (caller != this)
return E_PERM;
endif
{home, tree, n, less_than} = args;
if ((p = home:_get(tree[1]))[1])
sz = tree[2];
for i in [-length(p[2])..-1]
k = p[2][-i];
sz = sz - k[2];
if (!this:_call(home, less_than, n, k[3]))
return sz + this:_find_ord(home, k, n, less_than);
endif
endfor
return 0;
else
for i in [1..r = length(p[2])]
if (this:_call(home, less_than, n, home:_ord(p[2][i])))
return i - 1;
endif
endfor
return r;
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_set_nth this n/a this
":_set_nth(home,tree,n,value) => tree[n] = value";
"Assumes n in [1..tree[2]]";
if (caller != this)
return E_PERM;
endif
{home, tree, n, value} = args;
if ((p = home:_get(tree[1]))[1])
ik = this:_listfind_nth(p[2], n - 1);
this:_set_nth(home, p[2][ik[1]], ik[2] + 1, value);
if (!ik[2])
p[2][ik[1]][3] = home:_ord(value);
home:_put(tree[1], @p);
endif
else
p[2][n] = value;
home:_put(tree[1], @p);
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_skill this n/a this
":_skill(home,node,kill_leaf)";
"home:_kill's node and all descendants, home:(kill_leaf)'s all leaves";
if (caller != this)
return E_PERM;
endif
{home, node, kill_leaf} = args;
try
{height, subtrees} = home:_get(node) || {0, {}};
except (E_PROPNF)
return;
endtry
if (height)
for kid in (subtrees)
this:_skill(home, kid[1], kill_leaf);
endfor
elseif (kill_leaf)
for kid in (subtrees)
this:_call(home, kill_leaf, kid);
endfor
endif
home:_kill(node);
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_extract this n/a this
":_extract(home,tree,first,last) => {newtree,extraction}";
if (caller != this)
return E_PERM;
endif
home = args[1];
if (!(tree = args[2]))
return {{}, {}};
endif
before = max(0, args[3] - 1);
end = min(tree[2], args[4]);
if ((end <= 0) || (before >= end))
return {tree, {}};
endif
height = home:_get(tree[1])[1];
if (end < tree[2])
r = this:_split(home, height, end, tree);
if (before)
l = this:_split(home, height, before, r[1]);
extract = l[2];
newtree = this:_merge(home, l[1], r[2]);
else
extract = r[1];
newtree = r[2];
endif
elseif (before)
l = this:_split(home, height, before, tree);
extract = l[2];
newtree = l[1];
else
return {{}, tree};
endif
return {this:_scrunch(home, newtree), this:_scrunch(home, extract)};
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_merge this n/a this
"_merge(home,ltree,rtree) => newtree";
"assumes ltree and rtree to be nonempty.";
if (caller != this)
return E_PERM;
endif
{home, lnode, rnode} = args;
lh = home:_get(lnode[1])[1];
rh = home:_get(rnode[1])[1];
if (lh > rh)
return this:_rmerge(home, lnode, rnode);
endif
for h in [lh + 1..rh]
lnode[1] = home:_make(h, {lnode});
endfor
m = this:_smerge(home, rh, lnode, rnode);
return (length(m) <= 1) ? m[1] | {home:_make(rh + 1, m), m[1][2] + m[2][2], m[1][3]};
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_smerge this n/a this
"_smerge(home, height, ltree, rtree) =>{ltree[,rtree]}";
"assumes ltree and rtree are at the given height.";
"merges the trees if the combined number of children is <= maxfanout";
"otherwise returns two trees where ltree is guaranteed minfanout children and rtree is guaranteed the minimum of minfanout and however many children it started with.";
if (caller != this)
return E_PERM;
endif
{home, height, ltree, rtree} = args;
llen = length(lkids = home:_get(ltree[1])[2]);
rlen = length(rkids = home:_get(rtree[1])[2]);
if (height)
m = this:_smerge(home, height - 1, lkids[llen], rkids[1]);
mlen = length(mkids = {@listdelete(lkids, llen), @m, @listdelete(rkids, 1)});
if (mlen <= this.maxfanout)
home:_put(ltree[1], height, mkids);
home:_kill(rtree[1]);
ltree[2] = ltree[2] + rtree[2];
return {ltree};
else
S = max(llen - 1, (mlen + 1) / 2);
home:_put(ltree[1], height, mkids[1..S]);
home:_put(rtree[1], height, mkids[S + 1..$]);
xfer = -lkids[llen][2];
for k in (mkids[llen..S])
xfer = xfer + k[2];
endfor
ltree[2] = ltree[2] + xfer;
rtree[2] = rtree[2] - xfer;
rtree[3] = mkids[S + 1][3];
return {ltree, rtree};
endif
elseif ((llen * 2) >= this.maxfanout)
return {ltree, rtree};
elseif (this.maxfanout < (llen + rlen))
T = ((rlen - llen) + 1) / 2;
home:_put(ltree[1], 0, {@lkids, @rkids[1..T]});
home:_put(rtree[1], 0, rkids[T + 1..rlen]);
ltree[2] = ltree[2] + T;
rtree[2] = rtree[2] - T;
rtree[3] = home:_ord(rkids[T + 1]);
return {ltree, rtree};
else
home:_put(ltree[1], 0, {@lkids, @rkids});
home:_kill(rtree[1]);
ltree[2] = ltree[2] + rtree[2];
return {ltree};
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_split this n/a this
"_split(home, height,lmax,ltree[,@rtrees]}) => {ltree,[mtree,]@rtrees}";
"ltree is split after the lmax'th leaf, the righthand portion grafted onto the leftmost of the rtrees, if possible.  Otherwise we create a new tree mtree, stealing from rtrees[1] if necessary.";
"Assumes 1<=lmax<ltree[2]";
if (caller != this)
return E_PERM;
endif
{home, height, lmax, ltree, @rtrees} = args;
llen = length(lkids = home:_get(ltree[1])[2]);
rlen = length(rkids = rtrees ? home:_get(rtrees[1][1])[2] | {});
if (height)
ik = this:_listfind_nth(lkids, lmax);
if (ik[2])
llast = ik[1];
m = this:_split(home, height - 1, ik[2], lkids[llast], @lkids[llast + 1..llen], @rkids);
lkids[llast] = m[1];
mkids = listdelete(m, 1);
else
llast = ik[1] - 1;
mkids = {@lkids[ik[1]..llen], @rkids};
endif
home:_put(ltree[1], height, lkids[1..llast]);
mlen = length(mkids);
if ((((mlen - rlen) * 2) >= this.maxfanout) || (!rtrees))
"...residue left over from splitting ltree can stand by itself...";
return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen - rlen]), ltree[2] - lmax, mkids[1][3]}, @rtrees};
elseif (mlen <= this.maxfanout)
"...residue left over from splitting ltree fits in rtrees[1]...";
home:_put(rtrees[1][1], height, mkids);
rtrees[1][2] = (ltree[2] - lmax) + rtrees[1][2];
rtrees[1][3] = mkids[1][3];
return {listset(ltree, lmax, 2), @rtrees};
else
"...need to steal from rtrees[1]...";
if (llast < llen)
msize = ltree[2] - lmax;
R = (mlen - rlen) + 1;
else
msize = 0;
R = 1;
endif
for k in (mkids[R..mlen / 2])
msize = msize + k[2];
endfor
home:_put(rtrees[1][1], height, mkids[(mlen / 2) + 1..mlen]);
rtrees[1][2] = (rtrees[1][2] + ltree[2]) - (lmax + msize);
rtrees[1][3] = mkids[(mlen / 2) + 1][3];
return {listset(ltree, lmax, 2), {home:_make(height, mkids[1..mlen / 2]), msize, mkids[1][3]}, @rtrees};
endif
else
home:_put(ltree[1], 0, lkids[1..lmax]);
if ((((llen - lmax) * 2) >= this.maxfanout) || (!rtrees))
"...residue left over from splitting ltree can stand by itself...";
return {listset(ltree, lmax, 2), {home:_make(0, lkids[lmax + 1..llen]), llen - lmax, home:_ord(lkids[lmax + 1])}, @rtrees};
elseif ((mlen = (rlen + llen) - lmax) <= this.maxfanout)
"...residue left over from splitting ltree fits in rtrees[1]...";
home:_put(rtrees[1][1], 0, {@lkids[lmax + 1..llen], @rkids});
rtrees[1][2] = mlen;
rtrees[1][3] = home:_ord(lkids[lmax + 1]);
return {listset(ltree, lmax, 2), @rtrees};
else
"...need to steal from rtrees[1]...";
home:_put(rtrees[1][1], 0, rkids[(R = ((rlen - llen) + lmax) / 2) + 1..rlen]);
rtrees[1][2] = (mlen + 1) / 2;
rtrees[1][3] = home:_ord(rkids[R + 1]);
return {listset(ltree, lmax, 2), {home:_make(0, {@lkids[lmax + 1..llen], @rkids[1..R]}), mlen / 2, home:_ord(lkids[lmax + 1])}, @rtrees};
endif
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_rmerge this n/a this
":_rmerge(home, tree, insertree) => newtree ";
"(newtree is tree with insertree appended to the right)";
"insertree is assumed to be of height < tree";
if (caller != this)
return E_PERM;
endif
{home, tree, insert} = args;
if (!tree)
return insert;
elseif (!insert)
return tree;
endif
iheight = home:_get(insert[1])[1];
rspine = {};
for i in [iheight + 1..home:_get(tree[1])[1]]
kids = home:_get(tree[1])[2];
tlen = length(kids);
rspine = {{tree, tlen}, @rspine};
tree = kids[tlen];
endfor
isize = insert[2];
m = this:_smerge(home, iheight, tree, insert);
for h in [1..length(rspine)]
plen = rspine[h][2];
parent = rspine[h][1];
hgp = home:_get(parent[1]);
if (((length(m) - 1) + plen) > this.maxfanout)
home:_put(parent[1], @listset(hgp, listset(hgp[2], m[1], plen), 2));
parent[2] = (parent[2] + isize) - m[2][2];
m = {parent, listset(m[2], home:_make(h + iheight, {m[2]}), 1)};
else
home:_put(parent[1], @listset(hgp, {@hgp[2][1..plen - 1], @m}, 2));
for p in (rspine[h + 1..length(rspine)])
parent[2] = parent[2] + isize;
tree = parent;
parent = p[1];
hgp = home:_get(parent[1]);
home:_put(parent[1], @listset(hgp, listset(hgp[2], tree, p[2]), 2));
endfor
return listset(parent, parent[2] + isize, 2);
endif
endfor
return {home:_make((length(rspine) + iheight) + 1, m), m[1][2] + m[2][2], m[1][3]};
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_scrunch this n/a this
":_scrunch(home,tree) => newtree";
"decapitates single-child nodes from the top of the tree, returns new root.";
if (caller != this)
return E_PERM;
endif
if (tree = args[2])
home = args[1];
while ((n = home:_get(tree[1]))[1] && (length(n[2]) == 1))
home:_kill(tree[1]);
tree = n[2][1];
endwhile
endif
return tree;
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_listfind_nth this n/a this
"_listfind_nth(nodelist,key) => {i,k} where i is the smallest i such that the sum of the first i elements of intlist is > key, and k==key - sum(first i-1 elements).";
"1 <= i <= length(intlist)+1";
{lst, key} = args;
for i in [1..length(lst)]
key = key - lst[i][2];
if (0 > key)
return {i, key + lst[i][2]};
endif
endfor
return {length(lst) + 1, key};
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_insertfirst this n/a this
if (caller != this)
return E_PERM;
endif
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:debug this n/a this
return $perm_utils:controls(caller_perms(), this) ? this:(args[1])(@listdelete(args, 1)) | E_PERM;
-------------------------------------------------------------------------------
#13 Generic BigList Utilities:_call this n/a this
":_call(home,verb,@vargs) calls home:verb(@vargs) with $no_one's perms";
set_task_perms($no_one);
if (caller != this)
raise(E_PERM);
endif
{home, vb, @vargs} = args;
return home:(vb)(@vargs);
-------------------------------------------------------------------------------
================================#14 Generic Large-Capacity Mail Recipient===============================================
#14 Generic Large-Capacity Mail Recipient.summary_uses_body rc = MOONumber 0
#14 Generic Large-Capacity Mail Recipient.mowner r = MOOObjRef #36
#14 Generic Large-Capacity Mail Recipient._mgr rc = MOOObjRef #13
#14 Generic Large-Capacity Mail Recipient._genprop r = MOOString ""
#14 Generic Large-Capacity Mail Recipient:_genprop this n/a this
gp = this._genprop;
ngp = "";
for i in [1..length(gp)]
if (gp[i] != "z")
ngp = (ngp + "bcdefghijklmnopqrstuvwxyz"[index("abcdefghijklmnopqrstuvwxy", gp[i])]) + gp[i + 1..length(gp)];
return " " + (this._genprop = ngp);
endif
ngp = ngp + "a";
endfor
return " " + (this._genprop = ngp + "a");
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_make this n/a this
":_make(...) => new node with value {...}";
if (!(caller in {this._mgr, this}))
return E_PERM;
endif
prop = this:_genprop();
`add_property(this, prop, args, {this.mowner, ""}) ! ANY';
return prop;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_kill this n/a this
":_kill(node) destroys the given node.";
if (!(caller in {this, this._mgr}))
return E_PERM;
endif
`delete_property(this, args[1]) ! ANY';
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_get this n/a this
return (caller == this._mgr) ? `this.(args[1]) ! ANY' | E_PERM;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_put this n/a this
return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_ord this n/a this
return args[1][2..3];
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_makemsg this n/a this
":_makemsg(ord,msg) => leafnode for msg";
"msg = $mail_agent:__convert_new(@args[2])";
msg = args[2];
if (caller != this)
return E_PERM;
elseif (h = "" in msg)
return {this:_make(@msg[h + 1..$]), args[1], @msg[1..h - 1]};
else
return {0, args[1], @msg};
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_killmsg this n/a this
if (caller != this._mgr)
return E_PERM;
elseif (node = args[1][1])
this:_kill(node);
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_message_num this n/a this
return args[2];
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_message_date this n/a this
return args[3];
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_message_hdr this n/a this
return args[3..$];
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_message_text this n/a this
if ((caller == this) || this:is_readable_by(caller_perms()))
"perms check added HTC 16 Feb 1999";
return {@args[3..$], @args[1] ? {"", @this.(args[1])} | {}};
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_lt_msgnum this n/a this
return args[1] < args[2][1];
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_lt_msgdate this n/a this
return args[1] < args[2][2];
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:receive_batch this n/a this
if (!this:is_writable_by(caller_perms()))
return E_PERM;
else
new = this:new_message_num();
msgtree = this.messages;
for m in (args)
msgtree = this._mgr:insert_last(msgtree, this:_makemsg(new, m[2]));
new = new + 1;
if ($command_utils:running_out_of_time())
this.messages = msgtree;
player:tell("... ", new);
suspend(0);
msgtree = this.messages;
new = this:new_message_num();
endif
endfor
this.messages = msgtree;
this.last_used_time = time();
return 1;
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:receive_message this n/a this
if (!this:is_writable_by(caller_perms()))
return E_PERM;
else
this.messages = this._mgr:insert_last(this.messages, msg = this:_makemsg(new = this:new_message_num(), args[1]));
this.last_msg_date = this:_message_date(@msg);
this.last_used_time = time();
return new;
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:messages_in_seq this n/a this
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (typeof(seq = args[1]) != LIST)
x = this._mgr:find_nth(this.messages, seq);
return {this:_message_num(@x), this:_message_text(@x)};
else
msgs = {};
while (seq)
handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);
while (handle)
for x in (handle[1])
msgs = {@msgs, {this:_message_num(@x), this:_message_text(@x)}};
endfor
handle = this._mgr:next(@listdelete(handle, 1));
$command_utils:suspend_if_needed(0);
endwhile
seq = seq[3..$];
endwhile
return msgs;
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:display_seq_headers this n/a this
":display_seq_headers(msg_seq[,cur[,last_read_date]])";
"This is the default header display routine.";
"Prints a list of headers of messages on this to player.  msg_seq is the handle returned by this:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
getmsg = this.summary_uses_body ? "_message_text" | "_message_hdr";
{seq, ?cur = 0, ?last_old = $maxint} = args;
keep_seq = {@$seq_utils:contract(this:kept_msg_seq(), $seq_utils:complement(seq, 1, this:length_all_msgs())), $maxint};
k = 1;
mcount = 0;
width = player:linelen();
while (seq)
handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);
while (handle)
for x in (handle[1])
$command_utils:suspend_if_needed(0);
if (keep_seq[k] <= (mcount = mcount + 1))
k = k + 1;
endif
annot = (x[3] > last_old) ? "+" | ((k % 2) ? " " | "=");
line = tostr($string_utils:right(x[2], 5, (cur == x[2]) ? ">" | " "), ":", annot, " ", this:msg_summary_line(@this:(getmsg)(@x)));
player:tell(line[1..min(width, $)]);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
seq = seq[3..$];
endwhile
player:tell("-----+");
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:display_seq_full this n/a this
":display_seq_full(msg_seq[,preamble]) => {cur}";
"This is the default message display routine.";
"Prints the indicated messages on folder to player.  msg_seq is the handle returned by folder:parse_message_seq(...).  Returns the number of the final message in the sequence (to be the new current message number).";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{seq, ?preamble = ""} = args;
cur = date = 0;
while (seq)
handle = this._mgr:start(this.messages, seq[1], seq[2] - 1);
while (handle)
for x in (handle[1])
cur = this:_message_num(@x);
date = this:_message_date(@x);
player:display_message(preamble ? strsub(preamble, "%d", tostr(cur)) | {}, this:msg_full_text(@this:_message_text(@x)));
endfor
handle = this._mgr:next(@listdelete(handle, 1));
$command_utils:suspend_if_needed(0);
endwhile
seq = seq[3..$];
endwhile
return {cur, date};
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:list_rmm this n/a this
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
len = 0;
getmsg = this.summary_uses_body ? "_message_text" | "_message_hdr";
going = this.messages_going;
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
kept = {@going[1], $maxint};
going = going[2];
else
kept = {$maxint};
endif
k = 1;
mcount = 0;
for s in (going)
if (kept[k] <= (mcount = mcount + s[1]))
k = k + 1;
endif
len = len + s[2][2];
handle = this._mgr:start(s[2], 1, s[2][2]);
while (handle)
for x in (handle[1])
if (kept[k] <= (mcount = mcount + 1))
k = k + 1;
endif
player:tell($string_utils:right(this:_message_num(@x), 4), (k % 2) ? ":  " | ":= ", this:msg_summary_line(@this:(getmsg)(@x)));
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
if (len)
player:tell("----+");
endif
return len;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:undo_rmm this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
msgtree = this.messages;
seq = {};
last = 0;
"there are two possible formats here:";
"OLD: {{n,msgs},{n,msgs},...}";
"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}";
going = this.messages_going;
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
kept = going[1];
going = going[2];
else
kept = {};
endif
for s in (going)
msgtree = this._mgr:insert_after(msgtree, s[2], last + s[1]);
seq = {@seq, (last + s[1]) + 1, (last = (last + s[1]) + s[2][2]) + 1};
endfor
this.messages = msgtree;
this.messages_going = {};
this.messages_kept = $seq_utils:union(kept, $seq_utils:expand(this.messages_kept, seq));
this:_fix_last_msg_date();
return seq;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:expunge_rmm this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
len = 0;
going = this.messages_going;
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
going = going[2];
endif
for s in (going)
len = len + s[2][2];
this._mgr:kill(s[2], "_killmsg");
endfor
this.messages_going = {};
return len;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:rm_message_seq this n/a this
seq = args[1];
if (!(this:ok_write(caller, caller_perms()) || (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))))
return E_PERM;
endif
msgtree = this.messages;
save = nums = {};
onext = 1;
rmmed = 0;
for i in [1..length(seq) / 2]
if ($command_utils:suspend_if_needed(0))
player:tell("... rmm ", onext);
suspend(0);
endif
start = seq[(2 * i) - 1];
next = seq[2 * i];
{msgtree, zmsgs} = this._mgr:extract_range(msgtree, start - rmmed, (next - 1) - rmmed);
save = {@save, {start - onext, zmsgs}};
nums = {@nums, this:_message_num(@this._mgr:find_nth(zmsgs, 1)), this:_message_num(@this._mgr:find_nth(zmsgs, zmsgs[2])) + 1};
onext = next;
rmmed = (rmmed + next) - start;
endfor
tmg = this.messages_going;
save_kept = $seq_utils:intersection(this.messages_kept, seq);
this.messages_kept = $seq_utils:contract(this.messages_kept, seq);
this.messages_going = save_kept ? {save_kept, save} | save;
fork (0)
for s in (tmg)
this._mgr:kill(s[2], "_killmsg");
endfor
endfork
this.messages = msgtree;
this:_fix_last_msg_date();
return $seq_utils:tostr(nums);
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:renumber this n/a this
":renumber([cur]) renumbers caller.messages, doing a suspend() if necessary.";
"  => {number of messages,new cur}.";
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
{?cur = 0} = args;
this:expunge_rmm();
"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...";
if (!(msgtree = this.messages))
return {0, 0};
endif
if (cur)
cur = this._mgr:find_ord(msgtree, cur - 1, "_lt_msgnum") + 1;
endif
while (1)
"...find first out-of-sequence message...";
n = 1;
subtree = msgtree;
if (msgtree[3][1] == 1)
while ((node = this.(subtree[1]))[1])
"...subtree[3][1]==n...";
kids = node[2];
n = n + subtree[2];
i = length(kids);
while ((n = n - kids[i][2]) != kids[i][3][1])
i = i - 1;
endwhile
subtree = kids[i];
endwhile
leaves = node[2];
n = ((firstn = n) + length(leaves)) - 1;
while (n != leaves[(n - firstn) + 1][2])
n = n - 1;
endwhile
n = n + 1;
endif
"... n == first out-of-sequence ...";
"...renumber as many messages as we have time for...";
while ((n <= msgtree[2]) && (!$command_utils:running_out_of_time()))
msg = this._mgr:find_nth(msgtree, n);
msgtree = this._mgr:set_nth(msgtree, n, listset(msg, n, 2));
n = n + 1;
endwhile
this.messages = msgtree;
if (n > msgtree[2])
return {n - 1, cur};
endif
player:tell("...(renumbering to ", n - 1, ")");
suspend(0);
"...start over... may have received new mail, rmm'ed stuff, etc...";
"...so who knows what's there now?...";
if (this.messages_going)
player:tell("Renumber aborted.");
return;
endif
msgtree = this.messages;
endwhile
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:length_all_msgs this n/a this
return this:ok(caller, caller_perms()) ? this.messages ? this.messages[2] | 0 | E_PERM;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:length_num_le this n/a this
return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], "_lt_msgnum") | E_PERM;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:length_date_le this n/a this
return this:ok(caller, caller_perms()) ? this._mgr:find_ord(this.messages, args[1], "_lt_msgdate") | E_PERM;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:exists_num_eq this n/a this
return this:ok(caller, caller_perms()) ? (i = this._mgr:find_ord(this.messages, args[1], "_lt_msgnum")) && ((this:_message_num(@this._mgr:find_nth(this.messages, i)) == args[1]) && i) | E_PERM;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:new_message_num this n/a this
if (this:ok(caller, caller_perms()))
new = (msgtree = this.messages) ? this:_message_num(@this._mgr:find_nth(msgtree, msgtree[2])) + 1 | 1;
if (rmsgs = this.messages_going)
lbrm = rmsgs[$][2];
return max(new, this:_message_num(@this._mgr:find_nth(lbrm, lbrm[2])) + 1);
else
return new;
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:from_msg_seq this n/a this
":from_msg_seq(object or list)";
" => msg_seq of messages from any of these senders";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{plist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
fseq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
fromline = msg[4];
for f in ($mail_agent:parse_address_field(fromline))
if (f in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:%from_msg_seq this n/a this
":%from_msg_seq(string or list of strings)";
" => msg_seq of messages with one of these strings in the from line";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{nlist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
fseq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
fromline = " " + msg[4];
for n in (nlist)
if (index(fromline, n))
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:to_msg_seq this n/a this
":to_msg_seq(object or list) => msg_seq of messages to those people";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{plist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
toline = msg[5];
for r in ($mail_agent:parse_address_field(toline))
if (r in plist)
seq = $seq_utils:add(seq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:%to_msg_seq this n/a this
":%to_msg_seq(string or list of strings)";
" => msg_seq of messages containing one of strings in the to line";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{nlist, ?mask = {1, this.messages[2] + 1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
toline = " " + msg[5];
for n in (nlist)
if (index(toline, n))
seq = $seq_utils:add(seq, i, i);
endif
endfor
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:subject_msg_seq this n/a this
":subject_msg_seq(target) => msg_seq of messages with target in the Subject:";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{target, ?mask = {1, this.messages[2] + 1}} = args;
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
if (((subject = msg[6]) != " ") && index(subject, target))
seq = $seq_utils:add(seq, i, i);
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || (("%f %<has> no messages with subjects containing `" + target) + "'");
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:body_msg_seq this n/a this
":body_msg_seq(target) => msg_seq of messages with target in the body";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!this.messages)
return {};
endif
{target, ?mask = {1, this.messages[2] + 1}} = args;
seq = {};
for m in [1..length(mask) / 2]
handle = this._mgr:start(this.messages, i = mask[(2 * m) - 1], mask[2 * m] - 1);
while (handle)
for msg in (handle[1])
if ((msg[1] && (body = this.(msg[1]))) && index(tostr(@body), target))
seq = $seq_utils:add(seq, i, i);
"Above saves ticks. Munges the whole message into one string and indexes it. Old code follows.";
"l = length(body);";
"while (!index(body[l], target) && (l = l - 1))";
"$command_utils:suspend_if_needed(0);";
"endwhile";
"if (l)";
"seq = $seq_utils:add(seq, i, i);";
"endif";
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
handle = this._mgr:next(@listdelete(handle, 1));
endwhile
endfor
return seq || tostr("%f %<has> no messages containing `", target, "' in the body.");
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:date_sort this n/a this
return E_VERBNF;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_fix_last_msg_date this n/a this
msgtree = this.messages;
this.last_msg_date = (msgtree && this:_message_hdr(@this._mgr:find_nth(msgtree, msgtree[2]))[1]) || 0;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:__fix this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
{?doit = 0} = args;
msgtree = this.messages;
for n in [1..msgtree[2]]
msg = this._mgr:find_nth(msgtree, n);
msg = {@msg[1..2], @$mail_agent:__convert_new(@msg[3..$])};
if (doit)
msgtree = this._mgr:set_nth(msgtree, n, msg);
endif
if ($command_utils:running_out_of_time())
suspend(0);
if (this.messages != msgtree)
player:notify("urk.  someone played with this folder.");
return 0;
endif
endif
endfor
return 1;
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:init_for_core this n/a this
if (caller_perms().wizard)
this._mgr = $biglist;
this.mowner = $mail_recipient.owner;
for p in (properties(this))
$command_utils:suspend_if_needed(0);
if (p && (p[1] == " "))
delete_property(this, p);
endif
endfor
this.messages = this.messages_going = {};
this:_fix_last_msg_date();
this._genprop = "";
pass(@args);
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:length_date_gt this n/a this
if (this:ok(caller, caller_perms()))
date = args[1];
return (this.last_msg_date <= date) ? 0 | (this.messages[2] - this._mgr:find_ord(this.messages, args[1], "_lt_msgdate"));
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:_repair this n/a this
c = callers();
if ((caller != this) && (!((((length(c) > 1) && (c[1][1] == $list_utils)) && (c[1][2] == "map_arg")) && (c[2][1] == this))))
raise(E_PERM);
endif
$command_utils:suspend_if_needed(0);
biglist = this;
propname = args[1];
if (!propname)
bestlevel = -1;
best = {};
for prop in (properties(biglist))
$command_utils:suspend_if_needed(0);
if (index(prop, " ") == 1)
val = biglist.(prop);
if (typeof(val[1]) == INT)
if (bestlevel < val[1])
bestlevel = val[1];
best = {prop};
elseif (bestlevel == val[1])
best = {@best, prop};
endif
endif
endif
endfor
if (!best)
player:notify("Can't find a root.");
raise(E_INVARG);
elseif (length(best) == 1)
propname = best[1];
else
propname = best[1];
val = biglist.(propname);
for prop in (best[2..$])
$command_utils:suspend_if_needed(0);
val[2] = {@val[2], @biglist.(prop)[2]};
endfor
biglist.(propname) = val;
"Now that the new value is safely stored, delete old values.";
for prop in (best[2..$])
$command_utils:suspend_if_needed(0);
player:notify(tostr("Removing property ", toliteral(prop), ".  Its value, ", toliteral(biglist.(prop)), ", has been merged with property ", toliteral(propname), "."));
delete_property(biglist, prop);
endfor
endif
maxlevel = biglist.(propname)[1];
player:notify(tostr("Maximum level is ", maxlevel, "."));
items = $list_utils:make(maxlevel, {});
"Arrgh.  Even after finding the root, some nodes might be detached!";
player:notify("Checking for orphans...");
for prop in (properties(biglist))
$command_utils:suspend_if_needed(0);
if (prop && (prop[1] == " "))
val = biglist.(prop);
if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level < maxlevel))
items[level + 1] = {@items[level + 1], prop};
endif
endif
endfor
for prop in (properties(biglist))
$command_utils:suspend_if_needed(0);
if (prop && (prop[1] == " "))
val = biglist.(prop);
if (((typeof(val) == LIST) && (typeof(level = val[1]) == INT)) && (level > 0))
for item in (val[2])
items[level] = setremove(items[level], item[1]);
endfor
endif
endif
endfor
player:notify(tostr("Orphans: ", toliteral(items)));
backbone_prop = propname;
level = maxlevel;
while (level)
backbone = biglist.(backbone_prop);
lastkid = backbone_prop;
for prop in (props = items[level])
backbone[2] = {@backbone[2], {lastkid = prop, 0, {0, 0}}};
endfor
player:notify(tostr("Attaching ", nn = length(props), " propert", (nn == 1) ? "y" | "ies", " to property ", toliteral(backbone_prop), "..."));
biglist.(backbone_prop) = backbone;
backbone_prop = lastkid;
level = level - 1;
endwhile
player:notify(tostr("Orphans repatriated."));
endif
toplevel = "(top level)";
context = args[2] || toplevel;
"This stuff is just paranoia in case something unexpected is in the data structure.  Normally there should be no blowouts here. --Minnie";
if (typeof(propname) != STR)
player:notify(tostr("Context=", context, " Prop Name=", toliteral(propname), " -- bad property name."));
raise(E_INVARG);
endif
val = biglist.(propname);
if (typeof(val) != LIST)
player:notify(tostr("Context=", context, " Prop Name=", toliteral(propname), " -- contents invalid."));
raise(E_INVARG);
endif
if (typeof(level = val[1]) != INT)
player:notify(tostr("Context=", context, " Prop Name=", toliteral(propname), " -- contents invalid (bad first argument)."));
raise(E_INVARG);
endif
"This is where the real work starts. --Minnie";
"First check that the properties referred to really exist.  This must be done for all levels.";
for item in (val[2])
try
biglist.(item[1]);
except (E_PROPNF)
player:notify(tostr("Item ", toliteral(item), " is invalid in property ", toliteral(propname), ".  It is being removed."));
val[2] = setremove(val[2], item);
continue item;
endtry
endfor
"Next, only for upper levels, check that the message count for inferior levels is correct, but only after recursing into those levels and making repairs.";
if (level > 0)
new = $list_utils:map_arg(this, verb, $list_utils:slice(val[2]), propname);
if (val[2] != new)
player:notify(tostr("Changing ", toliteral(val[2]), " to ", toliteral(new), "."));
val[2] = new;
endif
"Now that everything is correct, count size of inferiors.";
endif
"Bravely stuff the result back into place.";
biglist.(propname) = val;
"The result will be of the form:                               ";
"  {propname, inferior_msgcount, {first_msgnum, first_time}}  ";
if (level == 0)
"Count the messages for message count.";
"Use first message number and time for first_msgnum and first_time.";
result = {propname, length(val[2]), val[2][1][2..3]};
else
"Use message count that is sum of inferior counts.";
"Just propagate first node's first_msgnum and first_time upward literally.";
n = 0;
for subnode in (val[2])
n = n + subnode[2];
endfor
result = {propname, n, val[2][1][3]};
endif
if (context == toplevel)
if (result != biglist.messages)
biglist.messages = result;
player:notify(tostr("Property ", biglist, ".messages updated."));
endif
player:tell(biglist.messages[2], " messages repaired in ", $mail_agent:name(biglist), ".");
endif
return result;
"Last modified Thu Feb 15 23:13:44 1996 MST by Minnie (#123).";
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:repair this n/a none
"Syntax: repair <biglist>";
"";
"This tool makes a last-resort attempt to repair broken biglists (ones whose data structures are out of alignment due to an error such as \"out of ticks\" during some update operation leaving the b-tree in an inconsistent state).  This tool comes with no warranty of any kind.  You should only use it when you have no other choice, and you should make an attempt to @dump or fully copy or otherwise checkpoint your object before attempting to repair it so that you can recover from any failures this might produce.  This operation is NOT undoable.";
if (!$perm_utils:controls(player, this))
player:tell("You do not control that.");
elseif (!$command_utils:yes_or_no("This tool can be used to repair some (but maybe not all) situations involving generic biglists that have had an error (usually \"out of ticks\") during an update operation and were left inconsistent.  Is this list really and truly broken in such a way?"))
player:tell("No action taken.  PLEASE don't use this except in extreme cases.");
elseif (!$command_utils:yes_or_no("Have you made a best effort to @dump or otherwise save the contents in case this make things worse?"))
player:tell("No action taken.  PLEASE do any saving you can before proceeding.");
elseif (!$command_utils:yes_or_no("This tool comes with no warranty of any kind.  Is this really your last resort and are you prepared to accept the consequences of utter failure?  There is no undoing the actions this takes.  Do you understand and accept the risks?"))
player:tell("No action taken.  I'm not taking any responsibility for this failing.  It's gotta be your choice.");
else
player:tell("OK!  Going ahead with repair attempts...");
this:_repair();
player:tell("All done.  If this worked, you can thank Mickey.  If not, remember the promises you made above about accepting responsibility for failure.");
endif
"Last modified Fri Feb 16 08:36:27 1996 MST by Minnie (#123).";
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:restore_from this n/a this
":restore_from(OLD_MAIL_RECIPIENT, LOST_STRING)";
"This clears all biglist properties from this object, then";
"scans the properties of OLD_MAIL_RECIPIENT, which must be a descendant";
"of $big_mail_recipient, looking for those corresponding to mail messages,";
"and then rebuilds the message tree entirely from scratch.";
"";
"No attempt is made to preserve the original tree structure.";
"The live/deleted state of any given message is lost;";
"all messages, including formerly rmm-ed ones, are restored to .messages";
"";
"In the (unlikely) event that message-body properties have been lost, the";
"affected messages are given a one-line body consisting of LOST_STRING";
"";
{old, ?lost_body = "###BODY-LOST###"} = args;
if (!($perm_utils:controls(caller_perms(), this) && $perm_utils:controls(caller_perms(), old)))
raise(E_PERM);
elseif (!$object_utils:isa(old, $big_mail_recipient))
raise(E_TYPE, "First argument must be a $big_mail_recipient.");
elseif (typeof(lost_body) != STR)
raise(E_TYPE, "Second argument, if given, must be a string.");
endif
mgr = this._mgr;
"...";
"... destroy everything...";
for p in (properties(this))
delete_property(this, p);
endfor
this.messages = this.messages_going = {};
"...";
"... look at all properties...";
msgcount = lostcount = 0;
for p in (properties(old))
if (index(p, " ") == 1)
pvalue = old.(p);
"... ignore everything except level-0 nodes...";
if (pvalue[1..min(1, $)] == {0})
for msg in (pvalue[2])
if ((ticks_left() < 6000) || (seconds_left() < 2))
player:tell("...", msgcount, " copied.");
suspend(0);
endif
try
body = old.(msg[1]);
except e (E_PROPNF)
body = {lost_body};
lostcount = lostcount + 1;
endtry
msg[1] = this:_make(@body);
msgtree = mgr:insert_last(this.messages, msg);
msgcount = msgcount + 1;
n = mgr:find_ord(msgtree, this:_message_num(@msg), "_lt_msgnum");
if (n < msgcount)
{msgtree, singleton} = mgr:extract_range(msgtree, msgcount, msgcount);
msgtree = mgr:insert_after(msgtree, singleton, n);
endif
this.messages = msgtree;
endfor
endif
endif
endfor
player:tell(msgcount, " messages installed on ", this.name, "(", this, ")");
if (lostcount)
player:tell(lostcount, " messages have missing bodies (indicated by ", toliteral(lost_body), ").");
else
player:tell("No message bodies were missing.");
endif
-------------------------------------------------------------------------------
#14 Generic Large-Capacity Mail Recipient:set_message_body_by_index this n/a this
{i, body} = args;
if (!this:ok_write(caller, caller_perms()))
"... maybe someday let people edit messages they've sent?";
"... && !(this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args))) ???";
return E_PERM;
endif
{bodyprop, @rest} = this._mgr:find_nth(this.messages, i);
if (!body)
if (bodyprop)
this:_kill(bodyprop);
this._mgr:set_nth(this.messages, i, {0, @rest});
endif
elseif (bodyprop)
if (typeof(body) != LIST)
raise(E_TYPE);
endif
this.(bodyprop) = body;
else
bodyprop = this:_make(@body);
this._mgr:set_nth(this.messages, i, {bodyprop, @rest});
endif
-------------------------------------------------------------------------------
================================#15 Limbo===============================================
#15 Limbo:acceptable this n/a this
what = args[1];
return is_player(what) && (!(what in connected_players()));
-------------------------------------------------------------------------------
#15 Limbo:confunc this n/a this
(caller == #0) || raise(E_PERM);
{who} = args;
"this:eject(who)";
if (!$recycler:valid(home = who.home))
clear_property(who, "home");
home = who.home;
if (!$recycler:valid(home))
home = who.home = $player_start;
endif
endif
"Modified 08-22-98 by TheCat to foil people who manually set their home to places they shouldn't.";
if ((!home:acceptable(who)) || (!home:accept_for_abode(who)))
home = $player_start;
endif
try
move(who, home);
except (ANY)
move(who, $player_start);
endtry
who.location:announce_all_but({who}, who.name, " has connected.");
-------------------------------------------------------------------------------
#15 Limbo:who_location_msg this n/a this
return $player_start:who_location_msg(@args);
-------------------------------------------------------------------------------
#15 Limbo:moveto this n/a this
"Don't go anywhere.";
-------------------------------------------------------------------------------
#15 Limbo:eject this n/a this
if ($perm_utils:controls(caller_perms(), this))
if ((what = args[1]).wizard && (what.location == this))
move(what, what.home);
else
return pass(@args);
endif
endif
-------------------------------------------------------------------------------
================================#16 Registration Database===============================================
#16 Registration Database.total_pruned_people rc = MOONumber 0
#16 Registration Database.registrar rc = MOOObjRef #2
#16 Registration Database.prune_task rc = MOONumber 0
#16 Registration Database.prune_progress rc = MOOString "aaa"
#16 Registration Database.prune_stop rc = MOOString "zzz"
#16 Registration Database.alphabet rc = MOOString "abcdefghijklmnopqrstuvwxy0123456789_.@+z"
#16 Registration Database.total_pruned_characters rc = MOONumber 0
#16 Registration Database:find* _only* _every* this n/a this
return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;
-------------------------------------------------------------------------------
#16 Registration Database:add this n/a this
":add(player,email[,comment])";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, email, @comment} = args;
l = this:find_exact(email);
if (l == $failed_match)
this:insert(email, {{who, @comment}});
elseif (i = $list_utils:iassoc(who, l))
this:insert(email, listset(l, {who, @comment}, i));
else
this:insert(email, {@l, {who, @comment}});
endif
-------------------------------------------------------------------------------
#16 Registration Database:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this:clearall();
this.registrar = #2;
this:prune_reset();
endif
-------------------------------------------------------------------------------
#16 Registration Database:suspicious_address this n/a this
"suspicious(address [,who])";
"Determine whether an address appears to be another player in disguise.";
"returns a list of similar addresses.";
"If second argument given, then if all similar addresses are held by that";
"person, let it pass---they're just switching departments at the same school";
"or something.";
"";
"at the moment,";
"  foo@bar.baz.bing.boo";
"is considered 'similar' to anything matching";
"  foo@*.bing.boo";
if (!caller_perms().wizard)
return E_PERM;
endif
{address, ?allowed = #-1} = args;
{userid, site} = $network:parse_address(address);
exact = (!site) && this:find_exact(address);
if (!site)
site = $network.site;
endif
site = $network:local_domain(site);
sitelen = length(site);
others = this:find_all_keys(userid + "@");
for other in (others)
if (other[max(1, ($ - sitelen) + 1)..$] != site)
others = setremove(others, other);
endif
endfor
if (exact)
others = listinsert(others, address);
endif
for x in (others)
allzapped = 1;
for y in (this:find_exact(x))
if ((((length(y) == 2) && ((y[2] == "zapped due to inactivity") || (y[2] == "toaded due to inactivity"))) || (y[1] == allowed)) || (($object_utils:has_property($local, "second_char_registry") && (typeof(them = $local.second_char_registry:other_chars(y[1])) == LIST)) && (allowed in them)))
"let them change to the address if it is them, or if it is a registered char of theirs.";
"Hrm. Need typeof==LIST check because returns E_INVARG for shared characters. bleah Ho_Yan 5/8/95";
else
allzapped = 0;
endif
endfor
if (allzapped)
others = setremove(others, x);
endif
endfor
return others;
-------------------------------------------------------------------------------
#16 Registration Database:suspicious_userid this n/a this
"suspicious_userid(userid)";
"Return yes if userid is root or postmaster or something like that.";
if ($object_utils:has_property(#0, "local") && $object_utils:has_property($local, "suspicious_userids"))
extra = $local.suspicious_userids;
else
extra = {};
endif
return ((((args[1] in {@$network.suspicious_userids, @extra}) || match(args[1], "^guest")) || match(args[1], "^help")) || index(args[1], "-owner")) || index(args[1], "owner-");
"Thinking about ruling out hyphenated names, on the grounds that they're probably mailing lists.";
-------------------------------------------------------------------------------
#16 Registration Database:describe_registration this n/a this
"Returns a list of strings describing the registration data for an email address.  Args[1] should be the result of this:find.";
set_task_perms(caller_perms());
result = {};
for x in (args[1])
name = (valid(x[1]) && is_player(x[1])) ? x[1].name | "<recycled>";
email = (valid(x[1]) && is_player(x[1])) ? $wiz_utils:get_email_address(x[1]) | "<???>";
result = {@result, tostr("  ", name, " (", x[1], ") current email: ", email, (length(x) > 1) ? (" [" + x[2]) + "]" | "")};
endfor
return result;
-------------------------------------------------------------------------------
#16 Registration Database:prune this n/a this
"Carefully loop through the db and delete items associated with reaped objects.  If that results in no objects remaining for a username, delete that username.";
"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.";
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.prune_task = task_id();
probe = this.prune_progress;
while (probe < this.prune_stop)
for username in (this:find_all_keys(probe))
items = this:find_exact(username);
orig = items;
for y in (items)
{who, @whys} = y;
if ((!valid(who)) || (!is_player(who)))
nuke = 1;
for why in (whys)
if (((why && (why != "zapped due to inactivity")) && (why != "toaded due to inactivity")) && (why != "Additional email address"))
nuke = 0;
endif
endfor
if (nuke)
items = setremove(items, y);
endif
endif
$command_utils:suspend_if_needed(0);
endfor
if (!items)
this:delete(username);
this.total_pruned_people = this.total_pruned_people + 1;
elseif (items != orig)
this:insert(username, items);
this.total_pruned_characters = (this.total_pruned_characters + length(orig)) - length(items);
endif
$command_utils:suspend_if_needed(0);
endfor
probe = $string_utils:incr_alpha(probe, this.alphabet);
this.prune_progress = probe;
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endwhile
player:tell("Prune stopped at ", toliteral(this.prune_progress));
-------------------------------------------------------------------------------
#16 Registration Database:report_prune_progress this n/a this
player:tell("Prune is up to ", toliteral(this.prune_progress), ".");
mine = 0;
alphalen = length(this.alphabet);
if (typeof(this.prune_progress) == STR)
total = (alphalen * alphalen) * alphalen;
for x in [1..3]
mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;
endfor
else
total = 256 * 256;
mine = (this.prune_progress[1] * 256) + this.prune_progress[2];
endif
percent = (100.0 * tofloat(mine)) / tofloat(total);
player:tell("We have processed ", mine, " entries out of ", total, ", or ", toint(percent), ".", toint(10.0 * percent) % 10, "%.");
player:tell("There were ", this.total_pruned_characters, " individual list entries removed, and ", this.total_pruned_people, " whole email addresses removed.");
if ($code_utils:task_valid(this.prune_task))
player:tell("Prune task is ", this.prune_task, ".  Stacktrace:");
for x in (task_stack(this.prune_task, 1))
if (valid(x[4]))
player:tell(x[4], ":", x[2], " [", x[1], "]  ", x[3].name, "  (", x[6], ")");
endif
endfor
else
player:tell("The recorded task_id is no longer valid.");
endif
-------------------------------------------------------------------------------
#16 Registration Database:prune_reset this n/a this
this:report_prune_progress();
player:tell("Resetting...");
this.prune_progress = "aaa";
this.prune_stop = "zzz";
this.total_pruned_people = 0;
this.total_pruned_characters = 0;
this.prune_task = 0;
-------------------------------------------------------------------------------
#16 Registration Database:search this behind any
who = caller_perms();
if (((who != #-1) && (!((who == player) || (caller == this)))) || (!(who.wizard || (who in $local.registrar_pet_core.members))))
raise(E_PERM);
endif
total = 0;
player:tell("Searching...");
for k in ($registration_db:find_all_keys(""))
$command_utils:suspend_if_needed(0);
line = (k + " ") + toliteral($registration_db:find_exact(k));
if (index(line, iobjstr))
player:tell(line);
total = total + 1;
endif
endfor
player:tell("Search over.  ", total, " matches found.");
-------------------------------------------------------------------------------
================================#17 Player-Creation-Log===============================================
#17 Player-Creation-Log:display_seq_headers this n/a this
":display_seq_headers(msg_seq[,cur])";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
player:tell("       WHEN    BY        WHO                 EMAIL-ADDRESS");
pass(@args);
-------------------------------------------------------------------------------
#17 Player-Creation-Log:msg_summary_line this n/a this
when = ctime(args[1])[5..10];
from = args[2];
by = $string_utils:left(from[1..index(from, " (") - 1], -9);
subject = args[4];
who = subject[1..(open = index(subject, " (")) - 1];
if ((close = rindex(subject, ")")) > open)
who = who[1..min(9, $)] + subject[open..close];
endif
who = $string_utils:left(who, 18);
line = args[("" in args) + 1];
email = line[1..index(line + " ", " ") - 1];
if (!index(email, "@"))
email = "??";
endif
return tostr(when, "  ", by, " ", who, "  ", email);
-------------------------------------------------------------------------------
#17 Player-Creation-Log:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = {this};
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#17 Player-Creation-Log:is_usable_by this n/a this
"Copied from Generic Mail Recipient (#6419):is_usable_by by Rog (#4292) Tue Mar  2 10:02:32 1993 PST";
return (!this.moderated) || ((this:is_writable_by(who = args[1]) || (who in this.moderated)) || who.wizard);
-------------------------------------------------------------------------------
#17 Player-Creation-Log:expire_old_messages none n/a none
"Stop breaking the expire task completely with out of seconds/ticks.";
if (this:ok_write(caller, caller_perms()))
fork (0)
pass(@args);
endfork
else
return E_PERM;
endif
-------------------------------------------------------------------------------
================================#18 Verb Help DB===============================================
#18 Verb Help DB.help_msg rc = MOOList [ "This is not a help database in the same way that children of $generic_help are. This object does the work when someone calls help in this way:", "", "    help <object>:<verb>", "", "It parses out the object and verb reference, pulls out the comments at the beginning of the verb, and returns them to the help system for nice display.", "", "    :find_topics(string)", "       tries to pull out an object:verb reference from string", "       returns {string} if successful", "       returns {} if not", "", "    :get_topic(string)", "       tries to pull out an object:verb reference from string (returns 0 if", "          it fails to do so)", "       tries to match the object", "       checks the object to see if the verb exists", "       pulls out the initial comments from the verb if they exist", "       returns a meaningful list of strings to be displayed to the player", "", "    :dump_topic(string)", "       does the same as :get_topic above, but returns the verb documentation", "          in dump form.", "----" ]
#18 Verb Help DB:find_topics this n/a this
if ($code_utils:parse_verbref(what = args[1]))
"... hey wow, I found it!...";
return {what};
else
return {};
endif
-------------------------------------------------------------------------------
#18 Verb Help DB:get_topic this n/a this
"Help facility for verbs that people have bothered to document.  If the argument is a verb specification, this retrieves the code and prints any documentation lines that might be at the beginning.  Returns true if the arg can actually be interpreted as a verb specification, whether or not it is a correct one.";
set_task_perms(caller_perms());
if (!(spec = $code_utils:parse_verbref(args[1])))
return 0;
elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))
return 1;
elseif (!(hv = $object_utils:has_verb(object, spec[2])))
return "That object does not define that verb.";
elseif (typeof(verbdoc = $code_utils:verb_documentation(object = hv[1], spec[2])) == ERR)
return tostr(verbdoc);
elseif (typeof(info = `verb_info(object, spec[2]) ! ANY') == ERR)
return tostr(info);
else
objverb = tostr(object.name, "(", object, "):", strsub(info[3], " ", "/"));
if (verbdoc)
return {tostr("Information about ", objverb), "----", @verbdoc};
else
return tostr("No information about ", objverb);
endif
endif
-------------------------------------------------------------------------------
#18 Verb Help DB:dump_topic this n/a this
set_task_perms(caller_perms());
if (!(spec = $code_utils:parse_verbref(args[1])))
return E_INVARG;
elseif ($command_utils:object_match_failed(object = $string_utils:match_object(spec[1], player.location), spec[1]))
return E_INVARG;
elseif (!(hv = $object_utils:has_verb(object, spec[2])))
return E_VERBNF;
elseif (typeof(vd = $code_utils:verb_documentation(hv[1], spec[2])) != LIST)
return vd;
else
return {tostr(";$code_utils:set_verb_documentation(", $code_utils:corify_object(hv[1]), ",", $string_utils:print(spec[2]), ",$command_utils:read_lines())"), @$command_utils:dump_lines(vd)};
endif
-------------------------------------------------------------------------------
================================#19 Core Utility Help===============================================
#19 Core Utility Help.MR-searching rc = MOOList [ "Search verbs", "------------", "The following verbs can be used on a readable mail-recipient/player to search for messages with fields matching a given pattern.", "", "from_msg_seq (objectid or list [,mask])", "  => message sequence: messages from (one of) the given objectid(s)", "", "%from_msg_seq (string or list [,mask])", "  => message sequence: messages with (one of) the given string(s)", "     in the From: line", "", "to_msg_seq (objectid or list [,mask])", "  => message sequence: messages to (one of) the given objectid(s)", "", "%to_msg_seq (string or list [,mask])", "  => message sequence: messages with (one of) the given string(s)", "     in the To: line", "", "subject_msg_seq (string [,mask])", "  => message sequence: messages with given string occurring in Subject:", "", "body_msg_seq (string [,mask])", "  => message sequence: messages with given string occurring in body of message", "", "In all cases `mask' is a message sequence which one may supply to limit the range of the search.  One way of looking at it is that the message sequence to be returned is first intersected with mask." ]
#19 Core Utility Help.include_for_core rc = MOOList [ "*forward*", "$core_objects" ]
#19 Core Utility Help.$container rc = MOOList [ "The Generic Container (for programmers)", "", "In addition to the command verbs described under `help containers'", "and the _msg properties described in `help container-messages',", "the following verbs and properties are available for use within programs", "", ".opened == TRUE iff the container is open", ".dark   == TRUE iff the contents of the container may be seen", ".opaque -- describes the correlation between .open and .dark", "   == 0  container is always !dark", "   == 1  container is dark iff it is closed", "   == 2  container is always dark              ", "", ":set_opaque(newvalue)   ", "  changes the .opaque value for the container", "  => newvalue or E_PERM or E_INVARG", "", ":set_opened(newvalue)   ", "  opens/closes the container (updates .open and .dark) according to newvalue", "  => newvalue or E_PERM", "", ":is_openable_by(player) ", " what the :open command uses to test whether the player should be able to open", " the container.  By default this refers to .open_key  (set by", " @(un)lock_for_open), but the object owner is free to customize this.", "", "N.B.:  There is no way to directly set .dark; .dark can be changed only by ", "changing one of .opaque or .opened.  Use :set_opaque(0) and :set_opaque(2)", "to have .dark change independently of the value of .opened." ]
#19 Core Utility Help.mail-resolve rc = MOOList [ "Resolving Mail Forwarding & Notification", "----------------------------------------", "For each recipient of a given mail message, the following two verbs are called to determine where the message should actually go and who should be notified about it:", "", ":mail_forward([from])", "    should return either", "     . a list of objects (either players or $mail_recipients)", "         to which mail for this recipient will be redirected.", "     . a string error message to be printed to the player sending the message.", "         If this recipient is one of the original destinations (i.e., not the", "         result of a previous forwarding), no mail is actually sent.", "", "    If :mail_forward returns a nonempty list, the recipient itself will *not*", "    actually receive the mail message unless it is included in the list.", "    #-1 is allowed to be on the list; it is ignored but does make the list ", "    nonempty.  Thus, having :mail_forward() return {#-1} is the canonical way", "    to have arriving mail disappear without being kept or forwarded.", "", ":mail_notify([from]) ", "    should return a list of objects that are to be told about any mail sent ", "    to this recipient (whether or not the recipient actually receives it).", "    Said objects must have a :notify_mail verb, but other from that, there ", "    is no restriction on what these can be.", "", "    object:notify_mail is called with the arguments ", "    (sender,recipients,msgnumbers) where ", "      recipients  == list of recipients including object in .mail_notify", "      msgsnumbers == corresponding list of :receive_message return values", "                 (or 0 if :receive_message is not actually called, which", "                  will be the case if the recipient forwards without keeping)", "", "When called as part of a mail send, the `from' argument is the immediate predecessor on the forwarding chain.  The default versions of these verbs return the values of .mail_forward and .mail_notify respectively (pronoun_subbing if the value is a string), unless this is a moderated mailing list and `from' is an unapproved sender (see `help MR-access') in which case the following verbs are called instead:", "", ":moderator_forward(from) ", "    what :mail_forward should return for mail coming from unapproved senders", "    This returns .moderator_forward (pronoun_subbed if a string) by default.", "", ":moderator_notify(from)", "    what :mail_notify should return for mail coming from unapproved senders", "    This returns .moderator_notify (pronoun_subbed if a string) by default.", "", "Since the :mail_forward verbs only see the previous sender in the forwarding chain, if, e.g, B is moderated but A can send to B (i.e., B:mail_forward(A) returns an actual list), then any mail sent to A goes to B even if the original sender isn't normally allowed to send to B directly.", "", "These verbs should all allow `from' to be omitted in which case they should return as if `from' were a generic approved sender (e.g., wizard).", "", "It should rarely be necessary to actually modify any of :*_forward/*_notify verbs, since one has a fair amount of control over their behavior via the following properties", "", "  .mail_forward", "  .mail_notify", "  .moderated          (see `help MR-access')", "  .moderator_forward", "  .moderator_notify" ]
#19 Core Utility Help.MR-writing rc = MOOList [ "Write verbs", "-----------", "The following verbs can be used to manipulate writable mail recipients/players:", "", ":rm_message_seq (message sequence)", "  Does an @rmmail.  Messages in message sequence are removed from this ", "  recipient's saved .messages and written to .messages_going.", "", ":undo_rmm ()", "  Does an @unrmm.  Messages in .messages_going are copied back to .messages.", "", ":expunge_rmm ()", "  Does an @unrmm expunge.  Blows away .messages_going.", "", ":renumber ()", "  Does a @renumber.", "" ]
#19 Core Utility Help.object-matching rc = MOOList [ "", "Which :match...() Verb Do I Call?", "---------------------------------", "There are many situations where one wishes to obtain an object from a room or a player's .contents whose name/aliases matches a particular string.  There are four main verbs available for this and it is important to understand the distinctions between them and how they are supposed to be used.", "", "(*)  LOC:match("X")", "     -- what you get looking for something that is inside LOC and named "X".", "        By default, this looks through LOC.contents to find a unique object ", "        having a name or alias that has "X" as a prefix.", "", "Essentially, you can think of :match as a contents-matching verb, though, e.g., for rooms you also get matches on exits as well.", "", "(*)  LOC:match_object("X", YOU)           [YOU defaults to player]", "(*)  YOU:my_match_object("X", LOC)        [LOC defaults to player.location]", "     -- what YOU get being located at LOC and looking for something named "X".", "        By default these both return $string_utils:match_object("X",LOC,YOU)", "", "(*)  $string_utils:match_object("X", LOC, YOU) ", "   -- what you *would* get *if* YOU were a typical player, YOU were inside LOC,", "      YOU were looking for something named "X", *and* LOC were a typical place.", "", "In other words, $string_utils:match_object describes the :match_object() algorithm for "typical places" and the :my_match_object for "typical players":", "", "    (1)  check for "X" being one of "", "me", "here", "$something", or "#n"", "    (2)  try YOU:match("X") i.e., something in your inventory (maybe)", "    (3)  try LOC:match("X") i.e., some object in the room (maybe)", "", "The distinction between these location:match_object and player:my_match_object has to do with whether the player or the location should determine what the matching algorithm is.  Which one you should use depends on the command that you are writing.  If you are writing a command with a virtual-reality flavor, then you should be respecting the room owner's idea of which objects you can "see" and thus the command should be calling the location's :match_object verb.  If you are writing a building/programming command where it is appropriate for the player to determine the matching algorithm  --- whether because the current location is irrelevant, not to be trusted, or both --- then the player's :my_match_object verb should be called.", "", "Examples:", "", "  `look diamond in box'", "      calls box:match("diamond").  This is a match on the contents of box.", "", "  `take ball', ", "      calls player.location:match_object("ball")", "      to determine which "ball" to take.  Note that if the room is dark, ", "      we might not be able to find any "ball".", "", "  `@program widget:foo', ", "      calls player:my_match_object("widget") to get the player's own idea", "      of what "widget" should be.  Note that if I were carrying something ", "      named "widget" and expecting to be programming a :foo() verb on it,", "      it would be potentially disastrous should the room where I am decide", "      for me to be programming something else (not even necessarily ", "      called "widget").", "", "Object Matching Failures", "------------------------", "As with other matching routines, one gets back ", "", "  $failed_match in the case of no matching object", "  $ambiguous_match in the case of more than one matching object", "  $nothing in the case of a blank string argument", "", "or an object-id.  In these first 3 cases, one usually wants to translate these nonresults to the player; this is what $command_utils:object_match_failed.  The standard idiom to mimic what the builtin parser does, say, with the direct object is", "", "  dobj = foo:match_???(dobjstr);", "  if($command_utils:object_match_failed(dobj, dobjstr))", "    "...give up.  nothing to do.   error message has already printed...";", "  else", "    "...dobj is something useful.  Continue...";", "    ...", "  endif" ]
#19 Core Utility Help.MR-reading rc = MOOList [ "Read verbs", "----------", "The following verbs may be used to extract headers/messages from readable mail recipients/players;", "", ":display_seq_headers (message sequence, current message number, last_read_date)", "  Does a @mail listing of the given message sequence.  If current message", "  number is given and the sequence includes it, we mark it with a `>'.", "  Likewise if the sequence includes any new messages (i.e., dated after ", "  last_read_date), these are also indicated as such.", "", "display_seq_full (message sequence, preamble)", "  Does a @read listing of the given message sequence.  Each message is preceded", "  by preamble.", "  => {new current message number, new last_read_date}", "", ":messages_in_seq (index)", "  => {n, msg}", ":messages_in_seq (message sequence)", "  => {{n_1,msg_1},{n_2,msg_2},...}", "  where the n_i are message numbers and the msg_i are messages in transmission", "  format (see `help mail-format')", "", ":list_rmm ()", "  Does an `@unrmm list' listing of messages in .messages_going" ]
#19 Core Utility Help.MR-sequences rc = MOOList [ "Message Sequences", "-----------------", "A "message sequence" is a handle by which one may refer to a particular subset of a mail recipient's (player or $mail_recipient-descendant) saved messages.  Routines like rcpt:display_seq_headers or rcpt:display_seq_full need to be supplied with message-sequence arguments to deterimine which headers or full-messages to display.", "", "Message sequences can in turn be obtained from routines like rcpt:parse_message_seq, which takes a command-line description of a message sequence on that particular recipient and returns the corresponding message sequence handle.", "", "The actual form of a message sequence (though you shouldn't actually need to make use of this) is that of a set of integers in the format used by $seq_utils (see `help $seq_utils').  It should however be noted that these integers are *not* themselves message numbers, but rather indices into the list of saved messages.  For example, if a particular recipient holds 5 messages numbered 1,3,5,7,9.  Then the message sequence handle representing messages 3,5,7 collectively, would be {2,5} which is $seq_utils-ese for the range 2..4, namely the second, third and fourth messages saved on that recipient.", "", "The following verbs are available for obtaining indices to use in message sequences", "", "  :length_all_msgs()    => total number of messages, or equivalently,", "                        => index of last message", "  :length_num_le(n)     => number of messages numbered <= n, or equivalently,", "                        => index of highest numbered message <= n", "  :exists_num_eq(n)     => 0 unless there exists a message numbered n in which", "                           case we return the index of that message.", "  :length_date_le(date) => number of messages dated <= date, or equivalently,", "                        => index of most recent message dated <= date", "", "  :length_date_gt(date) => number of messages dated > date", "", "Note that r:length_date_gt(date) == r:length_all_msgs()-r:length_date_le(date).", "The only reason :length_date_gt is provided as a separate routine is in order ", "to do quick checks for the existence of new mail (as @rn needs to do)." ]
#19 Core Utility Help.$generic_options rc = MOOList [ "Generic Option Package", "----------------------", "It occasionally happens that one has a command or set of commands for which one wishes to provide several options/flags that a player can set to customize the command's behavior for him/herself.  Making each option a separate property is a bit expensive, especially when the option in question is merely a boolean flag that gets set to false in most cases.  This package provides an alternative, as well as providing a uniform set of commands for setting these flags/options and checking that the values given are of appropriate types.", "", "Instead of needing several properties, only one is required to store a list containing values for all of the options.  An "option package" (pkg, below) is then an object of this class, which provides routines for manipulating such lists.", "", "The set of option names is divided into a set of "real" options, those whose names will actually appear in a given list, and "extras" which are either synonyms for or represent combinations of real options.", "", " pkg:add_name(name)      adds name to .names  (remove it from .extras if there)", " pkg:add_name(name,1)    adds name to .extras (remove it from .names if there)", "    => 1 - ok, 0 - already added, E_INVARG - illegal name, E_PERM", "", " pkg:remove_name(name)   remove name from either .names or .extras", "    => 1 - ok, 0 - not present, E_PERM", "", "For setting or retrieving values we have", "", " pkg:get(options,name) ", "    => value (or 0 if name isn't a real option)", " pkg:set(options,name,value)", "    => revised options (or string error message if something goes wrong)", "", "By default, a given option can only be a boolean flag, having one of the values 0 (absent from the list), or 1 (present in the list).  :set translates 0/""/{} to 0 and any other non-object value to 1.", "", "One may however designate a wider range of possible values for an option "foo" by either installing one of", "", "  pkg.type_foo", "    -- list of allowed types, ", "       e.g., {NUM,STR}   => must be a number or a string", "       e.g., {OBJ,{OBJ}} => must be an object or a list of objects", "    for anything fancier use:", "", "  pkg:check_foo(value)", "    => string error message or {value munged as desired}", "", "In general, the only restriction on option values is that 0 is the only false value; setting an option to "" or {} sets it to 0.  Every option defaults to 0, and no matter what you install as .type_foo or :check_foo(), 0 will always be a legal value for option "foo".", "", "When presented with an option that is in .extras, :set will typecheck the value as described, however, then :actual(name, value) will be called to obtain a list of {name-of-real-option, value} pairs indicating which combination of real options should be set.", "", "Other verbs", "  pkg:parse(args,...)", "    parses the command line arguments of a @whatever_option command", "    => {optionname, value}  if the player wants to set an option", "    => {optionname}         if the player wants to view an option", "    => string error message  otherwise", "", "  one may install pkg:parse_foo to parse arguments for option "foo" ", "    !foo     => {"foo",0}  (:parse_foo not called)", "    foo=     => {"foo",0}  (:parse_foo not called)", "    -foo     => {"foo",0}  (:parse_foo not called)", "    +foo     => pkg:parse_foo("foo",1)", "    foo=word => pkg:parse_foo("foo","word")", "    foo word1 word2    => pkg:parse_foo("foo",{"word1","word2"})", "    foo is word1 word2 => pkg:parse_foo("foo",{"word1","word2"})", "", " pkg:show(options,name|list of names)", "    => list of strings describing the current value of the named option(s).", "       calls     pkg:show_foo(options,list of names) or", "       refers to pkg.show_foo", "       to describe option "foo"", "", "(see sources for details...  at some point I'll finish writing this... --Rog)" ]
#19 Core Utility Help.$biglist r = MOOList [ "Generic BigList Utilities", "----------------------------", "$biglist is a collection of routines for maintaining huge persistent (sorted) lists in a format that is less likely to spam the server (which runs into a certain amount of trouble dealing with long ordinary lists --- btw we use `biglist' to refer to the huge data structure we're about to describe and `list' to refer to ordinary MOO lists {...}).  The biglist in question lives on a particular object, to which we will refer in the discussion below as the `home' object, and its various elements appear as leaves of a tree whose nodes are kept in properties of the home object.  It should be noted that the home object does not need to be (and in fact should *not* be) a descendant of $biglist one; $biglist merely provides utilities for manipulating the properties on the home object that are used in a particular biglist manipulation.  ", "", "All of the utilities below refer to `caller' to locate the home object.  Thus verbs to manipulate a given biglist must be located on or inherited by its home object itself.  The home object needs to define the following verbs", "", "  :_make(@args)     => new property on home object with value args", "  :_kill(prop)      delete a given property that was created by :_make", "  :_get(prop)       => home.prop", "  :_put(prop,@args) set home.prop = args", "  :_ord(element)    given something that is of the form of a biglist element", "                    return the corresponding ordinal (for sorting purposes).", "                    If you never intend to use :find_ord, then this can be a ", "                    routine that always returns 0 or some other random value.", "", "See $generic_biglist_home or $big_mail_recipient for examples.", "", "Those of the following routines that take a biglist argument are expecting", "either {} (empty biglist) or some biglist returned by one of the other routines", "", "  :length(biglist)          => length(biglist) (i.e., number of elements)", "  :find_nth(biglist,n)      => biglist[n]", "  :find_ord(biglist,k,comp) => n where n is", "     the largest such that home:(comp)(k,home:_ord(biglist[n])) is false, or", "     the smallest such that home:(comp)(k,home:_ord(biglist[n+1])) is true.", "     Always returns a value between 0 and length(biglist) inclusive.", "     This assumes biglist to be sorted in order of increasing :_ord values ", "     with respect to home:(comp)().", "     Standard situation is :_ord returns a number and comp is a < verb.", "", "  :start(biglist,s,e)  => {biglist[s..?],@handle} or {}", "  :next(@handle)       => {biglist[?+1..??],@newhandle} or {}", "     These two are used for iterating over a range of elements of a biglist", "     The canonical incantation for doing", "        for elt in (biglist[first..last])", "          ...", "        endfor", "     is", "        handle = :start(biglist,first,last);", "        while(handle)", "          for elt in (handle[1])", "            ...", "          endfor", "          handle = :next(@listdelete(handle,1));", "        endwhile", "", "The following all destructively modify their biglist argument(s) L (and M).", "", "  :set_nth(L,n,value)  =>  L[n] = value", "     replaces the indicated element", "", "  :insert_before(L,M,n) => {@L[1..n-1],@M,@L[n..length(L)]}", "  :insert_after (L,M,n) => {@L[1..n],  @M,@L[n+1..length(L)]}", "     takes two distinct biglists, inserts one into the other at the given point", "     returns the resulting consolidated biglist", "", "  :extract_range(L,m,n) => {{@L[1..m-1],@L[n+1..]}, L[m..n]} ", "     breaks the given biglist into two distinct biglists.", "", "  :delete_range(L,m,n[,leafkiller]) => {@L[1..m-1],@L[n+1..]}", "  :keep_range  (L,m,n[,leafkiller]) => L[m..n]", "     like extract_range only we destroy what we don't want.", "", "  :insertlast(L,value)  => {@L,value}", "     inserts a new element at the end of biglist.  ", "     If find_ord is to continue to work properly, it is assumed that the ", "     home:_ord(elt) is greater (comp-wise) than all of the :_ord values", "     of elements currently in the biglist.", "", "  :kill(L[,leafkiller]) ", "     destroys all nodes used by biglist.  ", "     Calls home:leafkiller on each element." ]
#19 Core Utility Help.init_for_core rc = MOOList [ "", "OBJECT:init_for_core([CORE_VARIANT_SPEC])", "", "This verb is called in the final stage of core extraction (see $wiz:make-core-database), which occurs after all non-core objects have been recycled, the remaining ones have been renumbered and moved to #-1.  This verbcall then performs any final cleanups to establish the initial state of the object and is (pretty much) the last thing to happen to the object before the new core database is saved.", "", "What exactly goes in an :init_for_core verb varies hugely.  Some considerations:", "", "(1)  The :init_for_core verbs are invoked from the top down, i.e., a given object's :init_for_core call verb precedes that of any of its children.  Thus, when a given object's init_for_core() runs, you can safely assume that its entire ancestor chain has already been initialized in this way, and likewise that NONE of the descendants have been initialized yet.", "", "(2)  For non-ancestral objects, all bets are off --- with a few exceptions, you should not assume that they will be in working order, i.e., only invoke verbs that you know aren't being changed, and don't mess with their properties.   Or if you must, make sure whatever you do works in BOTH the case where the other object's init_for_core has already run AND the case where it has not.", "", "(3)  The object's own properties, where they contain references to other objects, will be GARBAGE; renumber() does not update object values within properties or lists.  That's your job (i.e., you qua author of :init_for_core).", "", "(4)  The root object's :init_for_core will copy code from any verb whose name ends in "(core)" to the corresponding verbname obtained by dropping that suffix.  So, for example, if you find yourself writing 'set_verb_code(this, "verbname", {...})', you should instead create a (non-executable) "verbname(core)" verb, so as to have the verbcode in a place where you can edit it in a more readable form.  This means...", "", "  (4a)  For non-root objects, it is very important that pass(@args) be called.", "        And yes the @args need to be there, too, since while the ", "        CORE_VARIANT_SPEC argument is currently unspecified and ignored", "        by all existing init_for_core verbs, it is intended to mean", "        mean something someday.", "", "  (4b)  A given object's init_for_core will be applied to every descendant.", "        Bracket the parts that only apply to the object itself with ", "", "	   if ($code_utils:verb_location() == this)", "	     ... ", "	   endif", "", "(5) Oddly enough, init_for_core verbs by default become part of the core database.  You can arrange for them to remove themselves, but in the cases where they're performing generic sorts of initializations that are likely to be applicable to other MOOs, it's best to leave them in place.  This is for the sake of other MOO admins who may, after some amount of their own development, want to (re)extract their own cores.  While they will most likely be modifying the various init_for_core verbs as needed, if they do NOT make such modifications then (ideally) a core extraction should produce the same core they started with.", "", "Thus,", "", "   (5a) init_for_core should be IDEMPOTENT; i.e., running it a second time on the", "        same object should achieve the same result.  So, e.g., rather than", "", "          player.current_message = {@player.current_message, {this, 0, 0}};", "", "        which will create a duplicate entry the second time around, do", "", "          player:set_current_message(this, 0, 0, 1);", "", "   (5b) init_for_core should not depend on any non-core verbs/properties.  ", "        In particular, if your init_for_core deletes a LambdaMOO-specific ", "        verb/property and you don't arrange to delete the init_for_core as well,", "        then you should bracket that call (e.g., with `... ! E_PROPNF,E_VERBNF')", "        so that it will work elsewhere even after said verb/property is long gone.", "", "   (5c) if your init_for_core has a large amount of LambdaMOO-specific material, ", "        consider splitting the verb into ", "", "        (*) an :init_for_core that eliminates the LambdaMOO-specific material,", "            and ", "", "        (*) an :init_for_core(core) that accomplishes the generic initialization", "            (and will be copied into place by $root_object:init_for_core so that", "            ONLY the generic stuff escapes to the outside world.).  ", "", "        You can arrange for BOTH verbs to be called as follows:", "", "	#foo:init_for_core", "	if (caller_perms().wizard)", "	  pass(@args);  // copies :init_for_core(core) to this", "", "	  if ($code_utils:verb_location() == this)", "	     // wipe LambdaMOO-specific properties/verbs from this object", "	     ...", "	     // call init_for_core(core) code", "	     this:init_for_core()", "	  endif", "	endif", "", "        though again, this depends on the various parent verbs being idempotent", "        since in this case they will be invoked twice." ]
#19 Core Utility Help.proxy_for_core rc = MOOList [ "*forward*", "$core_objects" ]
#19 Core Utility Help.$core_objects rc = MOOList [ "", "    $core_objects           ([CORE_VARIANT_SPEC])         => object list", "    OBJECT:proxy_for_core   ([CORE_VARIANT_SPEC, IN_MCD]) => object", "    OBJECT:include_for_core ([CORE_VARIANT_SPEC])         => property list", "", "$core_objects() returns a list of those objects currently considered to be part of the core database.  ", "See help 'make-core-database' for a description of the overall core database extraction process.", "", "The list of core objects is determined by a traversal of properties starting with #0.sysobj (normally == #0).", "", "If a given property being traversed is not object-valued or the object id is invalid we are done with that property.", "", "Otherwise the property's value is a valid object and we call its 'proxy_for_core' verb, if one exists.  Any such verb is expected to return an object id which will then be used to update this property and any others encountered in the traversal that likewise were pointing to the same object.  If the verb does not exist we use the original property value (i.e., exactly as if the verbcode had been "return this;").", "", "If the object thus obtained is valid, we add it to the list of core objects.", "", "For each object added, we call its 'include_for_core' verb if one exists.  Any such verb is expected to return a list of properties on that object, which are then recursively traversed as above.  If the verb does not exist, no additional properties are traversed (i.e., exactly as if the verb had returned an empty list).", "", "The traversal ends when there are no further properties to visit.", "", "The CORE_VARIANT_SPEC argument is reserved for future use.  For now, the value provided to $core_objects() is passed straight through to the various hook verbs (proxy/include) and otherwise ignored.", "", "Note that the verb '$core_objects()' can be called at any time to see the full list of objects to be included in the core as per the above algorithm.", "", "Note that proxy_for_core is only called once for any given object during the traversal.  The IN_MCD parameter will be true for calls coming from within an actual run of make-core-database and false in all other invocations of $core_objects().  Thus, provided IN_MCD is true, it is safe for proxy_for_core to create an object to return." ]
#19 Core Utility Help.$housekeeper rc = MOOList [ "The housekeeper is an object that can help keep other objects where they belong.  New MOOs may want to add their own user interface for the housekeeper; here is some information that may be helpful.", "", "To indicate what objects should be cleaned:", "", "  :add_cleanup(object[, requestor[, where]])", "    Ask the housekeeper to clean 'object' for 'requestor' to 'where'.", "    Requestor defaults to 'player'.", "    Where defaults to object.location.", "", "  :remove_cleanup(what[, requestor])", "    Remove 'what' from the cleanup list at 'requestor's request.", "    Will remove it only if 'requestor' made the original request and owns", "    the object or the destination.", "", "To actually get the housekeeper to clean stuff up:", "", "  :cleanup([insist])", "    Clean up player's objects.  Argument is 'up' or 'up!' for manually", "    requested cleanups.  'up!' means to clean things even if it's against", "    the housekeeper's better judgement.", "", "  :replace(object[, insist])", "    Clean up the indicated object.  'insist' is as in :cleanup.", "", "  :continuous()", "    Starts the housekeeper cleaning continuously, killing any previous", "    continuous task.  This should be called only when starting up a new MOO,", "    or if something has gone wrong, as normally it will just keep going", "    without any help.", "", "  :litterbug()", "    Clean up all the places in housekeeper.public_places by getting rid of", "    all contents not in their .residents lists.  This is called by", "    :continuous, so it doesn't need to be called directly.", "", "To find out what's being cleaned to where for whom:", "", "  :cleanup_list([whom])", "    Show 'player' the personal cleanup list for 'whom', or the housekeeper's", "    complete list if no argument is given.", "", "  :clean_status()", "    Show 'player' a brief summary of eir personal cleanup list." ]
#19 Core Utility Help.sending-mail rc = MOOList [ "Sending Mail", "------------", "$mail_agent:send_message(from,recipients,headers,body)", "  from:        sender of the message ", "               (this must be you or something you own; otherwise => E_PERM)", "  recipients:  object or list of objects (must all be players or ", "               $mail_recipient descendants)", "  headers:     either a string (contents of the Subject: line) ", "               or a list {subject,replytos} replytos is a list ", "               of objects designated to receive replies.", "               Use {"",replytos} to have a Reply-to: without a Subject:", "", "This is the canonical way to send a mail message from a program.", "This calls $mail_agent:make_message to format the arguments into an actual message (see `help mail-format') and then $mail_agent:raw_send to do the actual sending which goes as follows:", "", "  (1) Call :mail_forward on all recipients add any new recipients thus obtained to final recipient list, keep calling mail:forward on the new recipients until we obtain no additional recipients.  If one of the initial recipients is invalid, is not a player or $mail_recipient, or has its mail_forward return a string error, then we print the error message and abort at this point with no mail being sent.  If one of the later recipients bombs similarly, error messages are printed, but in this case mail still goes out to the other recipients.", "", "  (2) Call :mail_notify on all recipients encountered in stage (1) to get a list of objects to notify.", "", "  (3) All final recipients receive the message (see `help receive-mail')", "  (4) All notifications are delivered (using :notify_mail())", "", "We return {0, @failed_recipients} if we bombed out at step 1.", "Otherwise return {1, @actual_rcpts} indicating what mail was sent." ]
#19 Core Utility Help.$generic_db rc = MOOList [ "Generic Database", "----------------", "This holds a collection of {string key, datum} pairs, where datum can be anything.  At most one datum may be associated with any given string.  Data may be anything (lists, strings, numbers, objectids).  If you like, you can think of this as an array indexed by strings.", "Verbs supplied include", "", "  :find(string)          => datum, $ambiguous_match or $failed_match", "  :find_key(string)      => full string key,  $ambiguous_match or $failed_match", "  :find_exact(string)    => datum or $failed_match (no partial matches)", "  :find_all(string)      => list of all data corresponding to matching strings", "  :find_all_keys(string) => list of all matching strings", "", "  :insert(string,datum)  ", "       if the string is already present in the db, ", "       changes the associated datum and returns {old_datum};", "       otherwise enters a new {string,datum} pair and return 0.", "  :delete(string)", "       if there is a datum associated with string, ", "       remove this association and return {datum}; otherwise return 0.", "  :delete2(string,datum)", "       if the given datum is associated with string, ", "       removes that association and return {datum}, ", "       if some other datum is associated with string, just return {other datum}", "       otherwise return 0.", "  :clearall([4|3])", "       removes all associations from the database.", "       optional argument changes the type of the database ", "       (4 is normal, 3 is a kludge for when the data are simply boolean flags", "        i.e., this is a set of strings rather than a string-indexed array;", "        more on this below)", "", "  count [entries|chars] in this", "        provide some vague statistics about how big this thing is.", "", "N.B.  As entries get made, properties belonging to $generic_db.owner will be created on the db object itself.  These properties will be created having flags as specified by .node_perms, which by default is "r", but can be changed to "" should you want to ensure that randoms don't have access to the raw information.", "", "Implementation notes", " - - - - - - - - - -", "The representation is as a `trie', a tree in which each internal node corresponds to a prefix shared by two or more strings in the db.", "Each internal node is kept in a property named " "+<prefix>, where <prefix> is a prefix shared by all strings in the subtree under this node.", "The property value is a 4 element list", "", "this.(" "+<prefix>)[1] = <common>", "   maximal continuation shared by all strings beginning with prefix", "   i.e., all these names actually begin with <prefix>+<common>", "", "this.(" "+<prefix>)[2] = <continuations>", "   string of all characters <c> that can follow <prefix>+<common> for which", "   there is more than one string in the db beginning with <prefix>+<common>+<c>", "", "this.(" "+<prefix>)[3] = <exact_matches>", "   list of all strings in this subtree for which ", "   the character (or lack thereof) following the <prefix>+<common> substring ", "   suffices to determine the string.", "", "this.(" "+<prefix>)[4] = <data>", "   list of data corresponding to the strings in [3].", "", "Child nodes are       this.(" "+<prefix>+<common>+<c>) ", "       for all <c> in this.(" "+<prefix>)[2].", "The root node is this.(" ").", "If, e.g., there are 2 or more strings in the db beginning with a, ", "there will be a node this.(" a").  ", "If all of these strings actually begin with "ani", then this.(" a")[1]=="ni".", "The db consisting of the 5 correspondences", "", "  {"animal", #1}", "  {"anime",  #2}", "  {"anil",   #3}", "  {"anile",  #4}", "  {"banal",  #5}", "", "would be represented", "", "this.(" ")    =={"",  "a",  {"banal"},         {#5}}", "this.(" a")   =={"ni","lm", {},                {}}", "this.(" anim")=={"",  "",   {"animal","anime"},{#1,#2}}", "this.(" anil")=={"",  "",   {"anil","anile"},  {#3,#4}}", "", "In some cases one may merely wish to hold a collection of strings without trying to associate a particular datum with each string.  One may then instead set up a db without the fourth field on each of the properties.  In this case the datum is taken to be the found string itself and that is what gets returned by :find*() in the event of a successful search.   :find and :find_key are then equivalent as are :find_all and :find_all_keys.  To setup the db this way, do a :clearall(3).  :clearall(4) reverts to the above described type of db with a separately kept datum.  Note that you can't change the type without emptying the db.  3 and 4 are currently the only db types allowed." ]
#19 Core Utility Help.receiving-mail rc = MOOList [ "Receiving Mail", "--------------", "By definition a recipient "receives" a mail message when its :receive_message verb is called with that message as an argument.", "", ":new_message_num()", "=> number that will be assigned to the next incoming message.", "By default this returns the maximum of the message numbers appearing in ", "messages or .messages_going, incremented by 1.  If the recipient is a player", "then the value returned will be 1 higher if it conflicts with the player's ", "current message number for him/herself.", "", ":receive_message(msg,sender)", "By default this first calls this:new_message_num to obtain a message number to assign to the incoming message and then appends {num,msg} to this.messages.  ", "`sender', the original sender, is supplied in case one wants different ", "action depending on who is sending the message (e.g., mail-gagging).", "The return value should be an error or string if :receive_message is considered to have failed in some way.  Otherwise, a number should be returned --- this number is given to any :notify_mail routines that are called and is expected to either be 0 or the number assigned to the incoming message.", "", "Note that :receive_message can do arbitrary things, including resending the same message to a new destination.  Hacking :receive_message to resend messages is different from using .mail_forward in the following respects", "  (1) the resent message is considered to be a distinct message having this ", "      object as its "author" --- i.e., the From: line will necessarily be ", "      different.", "  (2) since this "forwarding" is invisible to the mailsystem, ", "      there is no protection against loops and multiple copies.", "" ]
#19 Core Utility Help.$player_db rc = MOOList [ "", "Database of Players", "-------------------", "This is an instance of the Generic Database ($generic_db) that", "holds the {name/alias,#objectid} pairs for every ", "name and alias of every player in the MOO.", "", "Verbs supplied include", "", "  :find(string)        => player or $ambiguous_match or $failed_match", "  :find_exact(string)  => player or $failed_match (does not do partial matches)", "  :find_all(string)    => list of all matching players", "", "  :insert(string,player) ", "       records that string is now a name or alias of player", "  :delete(string) ", "       removes string from the db", "  :available(string)", "       returns 1 if string is available as a player name or alias,", "       an object if string is in use, or 0 if string is otherwise unavailable.", "  :load()", "       resets the db, inserting all current player names and aliases.", "", "The internal representation and all of the above verbs (except :load() and", ":available()) are as described for $generic_db.", "", "It should be noted that for any application that involves resolving a player name from a command line, you should be using $string_utils:match_player() rather than $player_db:find(), since the former will deal correctly with other ways of referring to players apart from their names and aliases (e.g., literal object numbers, "me", "$no_one"...).", "", ":load() needs to be done periodically as it is possible for the player db ", "to get out of synch with reality.  In particular, there is currently no way", "to block someone writing his own player :recycle() verb that neglects to ", "remove his names from the player db.", "", "While a :load() is in progress the .frozen property is set to 1 to indicate that any results of :find*() are not to be trusted." ]
#19 Core Utility Help.$help rc = MOOList [ "*forward*", "$generic_help" ]
#19 Core Utility Help.MR-subscribing rc = MOOList [ "Subscribing to Mail Recipients", "------------------------------", "There are two notions of being "subscribed" to a mailing list/recipient.", "", "(1) Hard subscribed == being on the recipient's .mail_forward list so that mail sent to this list is forwarded to one's own .messages as well (see `help mail-forwarding').", "", "(2) Soft subscribed == keeping track of a current message for this recipient and (optionally) being on the recipient's .mail_notify list.", "", "", "Each player has a .current_message property that contains, for each recipient the player cares to keep track of, a current message number and a last read date.", "", "player:current_message(rcpt)                 (somewhat obsolete)", " => player's current message number for rcpt ", "", "player:get_current_message(rcpt) ", " => player's {current message number for rcpt, last-read-date for rcpt}", "", "player:make_current_message(rcpt)", " => adds a current_message entry for rcpt  (NOOP if rcpt == player)", "", "player:set_current_message(rcpt,n|E_NONE,[,date])", " => sets player's current message number for rcpt to n iff n!=E_NONE", "    updates the last-read-date for rcpt to date iff date > last-read-date", "", "player:kill_current_message(rcpt)", " => removes current-message info for rcpt  (NOOP if rcpt == player)", "", "", "On $mail_recipient, .mail_forward and .mail_notify are -c so one needs to use the following verbs to actually modify them.", "", "    :add_forward(@new_recipients)", "    :delete_forward(@recpients)", "    :add_notify(@new_notifiees)", "    :delete_notify(@notifiees)", "", "A recipient's owner is, of course, allowed to make arbitrary changes to .mail_forward and .mail_notify.  However, the default versions of these verbs also allow any player to add him/herself to a recipient's .mail_forward or .mail_notify if the recipient is readable (see `help MR-access') by him/her.", "", "Likewise any player may use the :delete* verbs to delete him/herself from any .mail_forward/.mail_notify list, regardless of his actual access to the list." ]
#19 Core Utility Help.$room rc = MOOList [ "The Generic Room ($room)", "----------------", "", "(1)  Announcements", "", ":announce         (@text)         => broadcasts to all except player", ":announce_all     (@text)         => broadcasts to all", ":announce_all_but (objects,@text) => broadcasts to all except those in objects", "", "say, emote", "", "", "(2)  Command recovery", "", ":huh            (verb,args) - server hook: last chance to make sense of verb", ":here_huh       (verb,args) - room's last attempt to parse something", ":here_explain_syntax (this,verb,args) - attempts to explain usage of verb", "", "", "(3)  Residency", "", "free_home  - true => @sethome allows anyone to set his .home to be here", "residents  - objects on this list may teleport in and/or set their homes here.", "", ":accept_for_abode(player) ", "            => true iff player should be allowed to set .home to this room.", "", "@resident*s", "", "", "(4)  Looking", "", "dark  - true => contents are not visible", "ctype - 0..3 for four different styles of .contents lists", "", ":match         (string)        => exit or object in room's .contents", ":tell_contents (objects,ctype) - format objects according to ctype, tell player", "", "l*ook", "", "", "(5)  Entrance and exit.", "", ":accept (object) - Called by move() and :moveto() before an object enters a room, if false is returned, movement is prevented.  Protocol permits this verb to make noise (though this is discouraged) as this is the only place the room will learn the object's original location.", "", ":acceptable (object) - Called by verbs which wish to check whether movement will be possible.  Protocol prohibits this verb from making noise and requires it to return the same value as :accept would for the same arguments.", "", ":is_unlocked_for (object) - interface with the @lock protocol.  Returns true or false depending on the state of locks for the object with the room.  Other things may prevent entrance even if this returns true.  Protocol prohibits this verb from making noise. ", "", ":enterfunc (object) - called after entrance has succeeded.  Noise is fine.", "", ":exitfunc (object) - called after an object has successfully left.  Noisemaking is fine.", "", "(6)  Topology and Movement via Exits", "", "See `help $exit' for an explanation of how the generic $exit works.", "", "free_entry     - true  => `teleporting' in is allowed", "                  false => only residents may teleport in", "exits          - list of invokable exits leading from this room", "entrances      - list of recognized exits leading to this room", "blessed_object - object currently entering via an exit", "blessed_task   - task_id for entering object", "", ":match_exit      (string) => exit whose name matches string", ":bless_for_entry (object) - set up room to accept object arriving from entrance", ":add_exit        (exit)", ":add_entrance    (exit)", ":remove_exit     (exit)", ":remove_entrance (exit)", "", "e/east/w/west/s/south/n/north/ne/northeast/nw/northwest/se/southeast/sw/southwest/u/up/d/down, go, @add-exit, @add-entrance, @remove-exit, @remove-entrance, @exits, @entrances ", "", "", "(7)  Ejection", "", "victim_ejection_msg/oejection_msg/ejection_msg", ":*_msg()  messages", "", "@eject", "" ]
#19 Core Utility Help.matching rc = MOOList [ "*forward*", "object-matching" ]
#19 Core Utility Help.MR-expiration rc = MOOList [ "The mail messages stored in mail recipients may be removed automatically by a weekly expiration task. New core owners who wish to turn this feature on and cut down on the db space used by mail recipients (Remember, players are mail recipients too) should start this task:", "", "    $wiz_utils:expire_mail_weekly", "", "When this task runs, it searches through all mail recipients and checks their .expire_period property. This property contains a time, in seconds, that messages should expire after. If this property is set to 0, then no expiration will take place from that recipient. The task, then, will compile a list of messages that are older than the expire period (e.g., if the property is set to 30 days, messages older than 30 days from the current date will expire). The default expiration period for mail recipients is 30 days.", "", "Normally, when the mail messages are expired from the recipient they are deleted. However, the owner of the recipient may elect to have the messages mailed to an email address prior to their erasure. There are two methods for doing this, one for players and one for children of $mail_recipient.", "", "Players:", "", "  Players may completely turn off mail expiration by setting the mail option `expire' off. If it is on, then $mail_agent.player_expire_time is the expire period used for mail on players. ", "  If a player has a registered email address, he may simply turn the mail option `no_auto_forward' off in order to have the expired messages sent to his email address before they are deleted. (The reversed logic saves on db space). See `help mail-options' and `help @registerme'.", "", "Mail Recipients:", "", "  The command to set the expiration period of a mail recipient is:", "", "    @set_expire <recipient> to <time>", "", "The <time> specified can be in english format (30 days, 60 days, etc.). If left off (the owner types `@set_expire <recipient> to'), the command will print out the current expiration information for that recipient. A list owner may set the expiration period up to a maximum of 180 days.", "", "  Similar to players, the owner of a mail recipient may have the mail sent to either his registered email address or to any other address he specifies before it expires. To prevent unsolicited email from going to a random address, confirmation must be made before the owner may set the address to something other than his registered address.", "", "  The command is:", "", "    @register <recipient> to <address>", "", "If the owner leaves off the <address>, the current registered address (if any) and expiration period will be returned. Again, if the address specified is the player's registered address, nothing more need be done. If it is not, then an email message will be sent to that address containing a password. Presumably, the owner can retrieve that password and then log back into the MOO and type:", "", "   @validate <recipient> with <password>", "", "which will enable the mail forwarding before expiration." ]
#19 Core Utility Help.$login rc = MOOList [ "$login", "------", "This object manages command parsing for unconnected players and governs the initiation of an actual connection.  There are verbs pertaining to registration, controlling player creation, and doing site-locks (see `help blacklist' on $wiz_help).", "", "COMMANDS FOR UNCONNECTED PLAYERS", "", "Recall that for each line that an unconnected player types, the server parses that line into words (the same way normal commands are parsed into a list of words that is then assigned to `args') and then #0:do_login_command is called.", "", "  :parse_command (@args) => {verb, @args}", "    given the sequence of arguments that were fed to #0:do_login_command", "    this returns the name of a verb on $login to be called together with a ", "    list of arguments to be passed to it.", "", "By default this just returns args iff args[1] names an actual verb on $login that is +x and has args {"any","none","any"}.  Otherwise, it returns one of", "", "  .blank_command   -- verb to call if command line is empty", "  .bogus_command   -- verb to call if command line otherwise unintelligible", "", "In both cases :parse_command returns a verbname followed by the entire args list passed to it (including the would-be verb at the beginning if any).", "", "Currently the following verbs are available to non-connected players", "", "  h*elp @h*elp       -- print .welcome_message", "  ?                  -- print a short list of available commands", "  w*ho @w*ho         -- print a list of logged in players (excluding wizards)", "  co*nnect @co*nnect -- connect to an existing player", "  cr*eate @cr*eate   -- create a new player", "  up*time @up*time   -- tell how long the server has been running", "  version @version   -- tell which version of the server is running", "  q*uit @q*uit       -- logoff", "", "Adding a new command is fairly straightforward; just create a verb on $login, making sure a previous verb doesn't already match the name you want to give it.  Then give it args of "any" "none "any" and make sure it is +x.  Such a verb should begin with `if (caller != #0) return E_PERM; ...' so as to prevent anyone other from a not-logged-in player from making use of it.", "", "CUSTOMIZATIONS", "", "  .welcome_message ", "    -- the message for "help" to print.", "  .create_enabled ", "    == 0 => @create prints .registration_string if one tries to use it", "    == 1 => anyone from a non-blacklisted site (see `help blacklist')", "            may use @create to make a new player", "", "  .registration_address", "    -- an email address for character creation requests", "  .registration_string  ", "    -- string to print to players to give them information about how to get ", "       a character created for them, .registration_address is substituted ", "       for %e, % for %%", "  .newt_registration_string", "    -- string to print to @newted players (see `help @newt').", "       same substitutions as for .registration_string.", "", "  .max_connections", "    -- integer representing the maximum connected players permitted on this moo.", "  .connection_limit_msg", "    -- string printed out when this is reached.", "  .lag_exemptions", "    -- list of non-wizard players who may login anyway.", "", "Other verbs", "   :registration_string()      => .registration_string with substitutions", "   :newt_registration_string() => .newt_registration_string with substitutions", "   :player_creation_enabled(connection) ", "       decides whether someone on connection should be allowed to create ", "       a player.  If you decide this shouldn't depend strictly on the blacklist", "       and on the value of .create_enabled, here's where the extra code can go.", "   :check_for_shutdown()", "       prints a warning message to append to the login banner in the event ", "       that the server will be going down soon.", "   :check_player_db()", "       prints a warning message to append to the login banner in the event ", "       that $player_db is being reloaded to warn players that their character", "       names might not be recognized.", "", "SITE LOCKS", "see `help blacklist'", "" ]
#19 Core Utility Help.mail-format rc = MOOList [ "Mail Transmission Format", "------------------------", "There is a standard message format used for transmitting messages.  This is the format that $mail_editor:make_message produces, and that :receive_message verbs on players and $mail_recipients expect to see.  The (currently experimental) @refile and @copym commands also use this format to transfer messages.", "", "This *transmission* format is distinct from the *storage* format, though, for convenience this same format is often used as well for storing messages in player collections and ordinary $mail_recipient children though, in general, there is no requirement that this be the case.", "", "A transmitted message is a list in the following form", "", "   date (number),", "     the time() value at the time the message was sent.", "   from (string),", "     the sending object (address list form)", "     if this is not a player, an additional header will indicate the ", "     current ownership of the object.", "   to  (string),", "     recipients (address list form) which can either be players ", "     or $mail_recipient descendents.", "   subject (string),", "     subject of the message, or " " if there is no subject,", "  @additional optional headers (list of strings),", "     each header has the form "<header-name>: text" where <header-name>: ", "     is padded out to a width of 10 columns for the convenience of ", "     :display_message.  Currently "Reply-to: <address list>" is the only ", "     additional header in use,", "   "",", "  @body of message (list of strings)", "", "Note that the from, to and subject lines do *not* include a header name like "From:", "To:", or "Subject:".  The @'s indicate that the lists in question get spliced in (as usual), thus the entire message is a list whose first element is a number and the rest are strings.", "", "The address lists that appear in the from and to lines is a string in the form a sequence of object ids, each enclosed in parentheses and preceded by optional text, e.g.,", "", "  "*Core-DB-Issues (#8175), Rog (#4292), and Haakon (#2)"", "", "The text is intended to give the current name of each object for the benefit of human readers, but is actually ignored by all header parsing routines.  The convention is that the text is either a player name or a * followed by a mailing list name." ]
#19 Core Utility Help.$guest_log rc = MOOList [ "$guest_log", "", "records guest connect/disconnect events.", "", ".max_events  -- maximum number of connect/disconnect events kept", ".connections -- actual list of events, the most recent ones first", "    each element is of the form", "      {object, is_connect, time, site}", "    object is the particular guest that (dis)connected", "    is_connect 1 or 0 according as this is a connect or not.", "", ":find(who,when)", "  => site name of WHO at the particular time", "     (or 0 if WHO was not logged in then)", "", ":last(n) ", "  prints a listing of the last n events" ]
#19 Core Utility Help.$no_one rc = MOOList [ "$no_one", "-------", "... is a powerless player.  He owns no objects, not even himself; nor does he own any verbs.  He is, however, a programmer and thus may use eval().  In fact his sole purpose is to evaluate questionable code.  `questionable' could be in either or both of the following senses ", "", "(1) Its origin is sufficiently uncertain so that there is no obvious way of deciding whose permissions it should run under.", "(2) The code itself is potentially malicious, i.e., to the extent that one does not want to be evaluating it using one's own permissions.", "", "set_task_perms($no_one);  is thus the canonical idiom in wizard code for rendering anything that follows mostly harmless.  For use by ordinary programmers, we have:", "", "    $no_one:eval(string)", "", "which attempts to evaluate an arbitrary string using $no_one's permissions.", "string is either an expression or ";" followed by one or more statements, of which the final semicolon may be omitted.  return values are what eval() would return (either {1,value} or {0,@error_messages}).", "", "Similarly, we have", "", "    $no_one:eval_d(string)", "", "which attempts to evaluate the specified string, but does it without the debug flag turned on (so that, for example, you'll get an error as opposed to terminating by traceback).", "", "And, as a helpful utility for calling verbs whose behavior may be unpredictable, there is", "", "    $no_one:call_verb(object, verb name, args)", "", "which calls the specified verb with $no_one's permissions." ]
#19 Core Utility Help.core-index rc = MOOList [ "*index*", "Core Utility Help Topics" ]
#19 Core Utility Help.$generic_editor rc = MOOList [ "The Generic Editor enables a player to edit a list of strings.  While one might contrive to use it directly, it is rather intended as a parent for some actual editor.  It supplies the following commands:", "", "say         <text>                      w*hat       ", "emote       <text>                      abort       ", "lis*t       [<range>] [nonum]           q*uit,done,pause ", "ins*ert     [<ins>] ["<text>]           ", "n*ext,p*rev [n] ["<text>]               ", "del*ete     [<range>]                   ", "f*ind       /<str>[/[c][<range>]]       ", "s*ubst      /<str1>/<str2>[/[g][c][<range>]]", "m*ove,c*opy [<range>] to <ins>          ", "join*l      [<range>]                   ", "fill        [<range>] [@<col>]          ", "", "$editor_help.(cmdname) descrbes cmdname", "$editor_help.insert    descrbes insertion points (<ins>)", "$editor_help.ranges    descrbes range specifications (<range>)", "", "You'll notice that nowhere does it say how to load in a given list of strings or how and where one may save said list away when one is done editing.  These commands are supplied by the child editor object.  The generic editor contains only the code for editing lines, though it defines additional functions for use by the children:", "", "  :loaded(player)", "     returns the index (player in this.active) iff text has been loaded", "     from somewhere, otherwise returns 0.", "", "     Note that, by default, there is a difference between ", "", "        having nothing loaded                (:text(who)==0) and ", "        having loaded something with no text (:text(who)=={}).", "", "     If you don't care about this distinction in a particular case,", "     just do (player in this.active) instead of this:loaded(player).  ", "     If you don't want your editor to make this distinction at all, do", "", "        @stateprop texts={} for <youreditor>", "", "     which changes the initial value of :text() to {} ", "", "In all functions below, 'who' is the index returned by :loaded(player) ", "", "BTW, be careful about using 'player' in non-user (i.e., +x this-none-this) verbs --- much better to have the user verb get the index with :loaded() and then pass that around.  ", "", "Also be careful about suspend() and verbs that call suspend().  In particular, the player's index in the .active list can change during the suspend interval, so you must be sure to obtain the index (e.g., using :loaded()) again after the suspend() returns.", "", "For your non-user verbs, we have", "", "  :ok(who)", "     returns E_PERM if the caller is not an editor verb and E_RANGE", "     if 'who' does not point to a valid session.", "", "which should take care of the more egregious security holes (but maybe not the less egregious ones).  For getting and loading text, we have", "", "  :text(who)    ", "     the current text string list or 0 if nothing loaded yet.", "  :load(who,text)", "     loads the given list of strings as the text to be edited.", "     this also resets the 'changed' flag and pushes the insertion ", "     point to the end.", "", "and various flags and properties (all of the set_* routines return E_PERM when not called from an editor verb, E_RANGE if who is out of bounds, E_INVARG if something is wrong with the 2nd arg, or the new value, which may not necessarily be the same as the 2nd arg (e.g., set_insertion(..,37) on a 5 line text buffer returns 6).", "", "  :changed(who)", "     has the text been altered since the last save/load?", "     (the child editor gets to define what "save" means).", "  :set_changed(who,value)", "     Any child editor command that is considered to save the text should do a ", "     :set_changed(who,0).  ", "     Note that if the changed flag is 0, the session will be flushed when ", "     the player leaves the editor, so you may also want certain commands to", "     do set_changed(who,1)...", "", "  :origin(who)", "     room where the player came from.  ", "  :set_origin(who,room)", "     can be used to change the room the player will return to when finished", "     editing.  Since origin gets set even in cases where the player teleports", "     into the editor you probably won't usually need to do this.", "", "  :insertion(who)", "     current insertion point.", "  :set_insertion(who,linenumber)", "     linenumber needs to be a positive integer and will get ", "", "  :readable(who)", "     whether the current editing session has been made globally readable.", "  :set_readable(who,boolean)", "     change the readability of the current editing session.", "     This is used by the publish/perish verbs.", "", "We also provide", "", "  :invoke(...)", "      If the player has a previous unsaved (i.e., :changed()!=0)", "      session, we return to it, moving the player to the editor.  ", "      If the player is already in the editor, this has no effect other", "      than to print a few nasty messages.  In any case a :changed()", "      session must be aborted or set_changed(,0) before anything else ", "      can be started", "", "      Otherwise, we pass the arguments (which are assumed to be the", "      result of some munging of the command line) to :parse_invoke(),", "      move the player to the editor and load whatever parse_invoke()", "      specified.  The only interpretation the generic editor makes on", "      the arguments is that if the boolean value of the first is true,", "      this indicates that the player wanted to load something as", "      opposed to resume a previous session.  Usually a command calling", "      :invoke will have a true (i.e., nonzero number, nonempty list or", "      string) first arg iff the command line is nonempty, in which case ", "      'args' works fine for this purpose.", "", "      If the command parses sucessfully (:parse_invoke() returns a list),", "      we move the player to the editor if necessary and then call ", "      :init_session() to set things up.", "", "The child editor is assumed to provide", "", "  :parse_invoke(...)", "     given :invoke()'s arguments, determines what the player wants to edit.", "     It either returns 0 and reports syntax errors to player,", "     or it returns some list that :init_session() will understand.", "", "  :init_session(who,@spec)", "     where spec is something that was returned by :parse_invoke().", "     Loads the text and sets the stateprops (below) to indicate that ", "     we are working on whatever it is we're suppose to be working on.", "", "  :working_on(who)   ", "     returns a string X as in "You are working on X."", "     This is called by the 'w*hat' command, among other things.", "", "Child editors may have their own properties giving state information for the various editing sessions.  The value of each such property will be a list giving a value for each player in the editor.  For each such property, you should, once the editor object has been created, initialize the property to {} and do one of", "", "    @stateprop <propname>                 for <editor>", "    @stateprop <propname>=<default-value> for <editor>", "               (0 is the default <default-value>)", "", "Henceforth, adding and deleting new editing sessions will amend the list held by the given property.  The value of the property for a given session can be obtained via this.<propname>[player in this.active] and can be changed with a corresponding listset() call.  The usual idiom for an editor command is", "", "   if(!(who=this:loaded(player)))", "     player:tell(nothing_loaded_msg());", "   else", "      ... various references to  this.<propname>[who] ...", "   endif", "", "To remove such a property from the list of such state properties:", "", "    @rmstateprop <propname> from <editor>", "", "Note that you can only do this with properties defined on the child editor itself.  ", "", "Sometimes you may wish to @stateprop a new property on an editor where active editing sessions exist.  @stateprop will fail if the property in question does not hold a list of the correct length (== length(editor.active); one value for each editing session).  You need to either give the @flush command to clear out all sessions and boot all players currently in the editor or somehow manually initialize the property to a list of appropriate values and pray that nobody enters/exits the editor between the property initialization and the @stateprop command --- this problem can be avoided by doing an eval() that does all of the initializations (beware of suspends()) and calls :set_stateprops directly.", "", "Incidentally, the @flush command may be used at any time to clean out the editor or to remove all sessions older than a given date.", "", "There are also numerous _msg properties that may be customized", "", "    @depart          announced at the origin when :invoke() is called. ", "    @return          announced at the origin the player is returned there.", "    @nothing_loaded  printed when user attempts editing ", "                     before anything has been loaded.", "    @no_text         response to 'list' when :text()=={}", "    @no_change       printed by 'what' when :changed()==0", "    @change          printed by 'what' when :changed()==1", "    @no_littering    printed upon leaving the editor with :changed()==1.", "    @previous_session  printed by :invoke() when player tries to start a ", "                     new session without aborting or saving the old one", "", "The general procedure for creating a child editor:", "", ". @create $generic_editor named <editor>", "", ". define additional <editor> verbs/properties", "    At the very least you need 'edit' and 'save' commands.", "    Usually you can get away with just having 'edit' call :invoke();", "    Presumably, you'll need at least a command to load text from somewhere", "    as well as a command to save it back out.", "", ". define a verb (somewhere) to invoke the editor ", "    This could be just a one-liner that calls <editor>:invoke(args,verb).", "    Either that or", "      .  you have to set up an exit somewhere whose destination is <editor>", "      .  you have to advertise the object number so that people can ", "         teleport to it.", "  ", ". @stateprop x for <editor>", "", ". if you want the 'abort' command to boot the player from the editor do", "    <editor>.exit_on_abort = 1;", "", ". set <editor>.commands to be the list of additional commands defined", "    by <editor>.  ", "    Each element of the list is itself a list of the form {name,args}.", "  set <editor>.commands2 to be the list of commands that should appear", "    in the `look' listing, and should be a list of strings appearing ", "    as names in .commands on either <editor> or some editor ancestor.", "  look at $verb_editor or $note_editor for an example.", "", ". If you want to have help text for new verbs you define, create a child of ", "    $generic_help and add properties to this object for each of the topics ", "    that you want to provide help text.", "    Finally, set <editor>.help = {this object} so that the help system", "    knows to consult this object." ]
#19 Core Utility Help.$error r = MOOList [ "$error", "======", "", "The Error Generator, $error, may be used to automatically generate errors. This is particularly useful if you are working in a !d verb but have occasion to -want- to crash with traceback. To raise a specific error, use $error:raise(error type) -- for example, $error:raise(E_PERM) will produce traceback resulting from a Permission Denied error.", "", "Random notes about $error:", "", "+ The complete list of errors is stored in $error.names.", "+ The seemingly useless :accept() verb on $error is so that $error:E_RECMOVE and $error:E_NACC will be guaranteed success (success meaning, of course, a termination by traceback).", "+ There is, unfortunately, no way to raise the error E_NONE." ]
#19 Core Utility Help.MR-access rc = MOOList [ "Controlling Access to Mail Recipients", "-------------------------------------", ":is_writable_by(one) - one may alter/add/remove saved messages", ":is_readable_by(one) - one may read messages.", ":is_usable_by(one)   - one may send to this list", "", "By default, these verbs refer to the following properties:", "", "writers   - list of players other from the owner who can do anything", "readers   - if == 1, indicates a public mailing list.", "            list of additional readers (by default anyone who receives mail ", "            sent to the list can read the saved messages).", "moderated - if false, indicates a normal mail recipient everyone can send to.", "            otherwise this should be a list of approved senders.", "", "Terminology:", "  A mailing list is "public" if everyone can read it.", "  A mailing list is "moderated" if not everyone can send to it.", "", "Note that while being able to write to a recipient implies being able to read from it or send to it, neither of read-ability or send-ability implies the other.", "", "It is highly recommended that if you are creating custom mail recipients with variable reader/sender lists, i.e., you find you need to write your own :is_readable/usable/writabe_by verbs, you are best off if such verbs are of the form", "", "  return pass(@args) || << your_test(args[1]) >>", "", "and have .writers == .readers == {} and .moderated == 1.  This will ensure", " (1) wizards having write access", "     --- necessary in order for :receive_message to work", " (2) writers being able to read and send (the converse being a ludicrous ", "     situation), ", " (3) persons on the mail_forward list of someone with reader access will also", "     have read access (convenient)." ]
#19 Core Utility Help.$news rc = MOOList [ "*subst*", "$news", "-----", "This object is a mail_recipient like any other (see `help $mail_recipient').  One may send messages to it and use the usual recipient manipulation commands (@mail, @read, @rmm,...).  ", "", "Selected messages on this recipient are ordered in reverse date order (i.e., most recent first) and concatenated to produce the "news" that is printed in response to the player `news' command.  Each news item is thus a distinct message.  The default $player:confunc checks to see if any new messages have been selected for inclusion in the "news" since the player last read the news.", "", "The property $news.current_news holds the message sequence of messages currently considered as comprising "the news".  The following commands are used to change .current_news:", "", "  @addnews <message-seq> to %[$news]", "  @rmnews <message-seq> from %[$news]", "  @setnews %[$news] to <message-seq>", "", "@addnews includes the specified messages, @rmnews excludes the specified messages, and @setnews changes .current_news to be the given message sequence.  Note that these ONLY change whether a given message is marked as being "in the news" and do not actually add or remove messages from the mail recipient $news.", "", "The procedure for adding a news article is", "", "  Send a mail message to %[$mail_agent:name($news)]", "  @addnews last to %[$news]", "    This marks the message as belonging to the current newspaper.", "    This also announces to any player who have not yet read this message ", "    that there is a new version of the newspaper.", "", "The preferred method for updating a news items is to send a new version of the item, @rmnews the old version and @addnews the new one.", "", "The following ordinary mail commands behave differently", "  @rmm   removes any reference to message from .current_news ", "         in addition to removing the message itself from .messages", "  @unrmm completely undoes the effect of the previous @rmm; ", "         this includes restoring .current_news.", "", "By default, the newspaper is moderated, however there is the possibility of unmoderating it (see `help MR-access'), letting arbitrary players send mail to it; administrators could then @addnews those items deemed worthy." ]
#19 Core Utility Help.$mail_recipient rc = MOOList [ "Generic Mail Recipient", "----------------------", "A "mail recipient" is, by definition, an object that can be sent mail.", "Mail recipients must either be players or descendants of $mail_recipient.", "", "One source of confusion is that the terms "mail recipient", "mail folder", "mailing list", and "mail collection" really all refer to the same kind of object.  It so happens that $mail_recipient serve several distinct functions and we tend to use whatever term happens to best match the application under discussion, e.g., it's a "mailing list" if we're playing with its .mail_forward property but it's also a "mail folder" if we're examining the messages that have been saved in it.", "", "Note that, by default, a freshly created recipient is accessibly only by you.  If you wish to make a publically accessible recipient, set .readers=1.  Furthermore, if you want to allow a message on your recipient to be removed by its sender without your intervention, set .rmm_own_msgs=1.  Finally, in order for other players to be able to refer to your recipient by name, the object must reside in $mail_agent.  $mail_agent will not accept the object unless it has an actual description and a name distinct from all other mail recipient names/aliases.", "", "Topics:", "", "  MR-access       -- controlling read, write and send access to a recipient", "  MR-naming       -- naming conventions and how to match on recipient names", "  MR-sequences    -- message sequence arguments to $mail_recipient verbs", "  MR-reading      -- reading messages/headers on recipients", "  MR-searching    -- searching message lists for patterns in certain fields", "  MR-writing      -- removing and renumbering messages", "  MR-subscribing  -- updating .mail_forward, .mail_notify ", "                       and the story of .current_message", "  MR-expiration   -- expiring and netmailing messages from recipients" ]
#19 Core Utility Help.mail-system rc = MOOList [ "Mail System", "-----------", "The following topics describe the guts of the LambdaCore mail system", "", "sending-mail     -- how to send mail from a program; what happens.", "mail-forwarding  -- how to do mail forwarding/notification (the simple version)", "mail-resolve     -- how mail forwarding/notification works, in gory detail", "receiving-mail   -- what :receive_message should do", "mail-format      -- format of transmitted messages", "mail-command-parsing   (TODO) -- routines for parsing mail commands", "", "$mail_recipient  -- generic non-player mail recipient", "$mail_agent      -- mail utility object" ]
#19 Core Utility Help.$mail_agent rc = MOOList [ "$mail_agent", "", "This object contains a two distinct sets of routines:", "", "  1.  utilities for performing basic mailsystem functions, e.g.,", "      matching on recipient names, resolving mail forwarding, ", "      formatting messages, sending messages", "", "Recipient Matching", "", "match           - match on a $mail_recipient", "match_recipient - match on either a $mail_recipient or a player", "match_failed    - print angry messages to the user for $failed/ambiguous_match", "", "look_self  - provides a list of available $mail_recipients", "check_names", "touch", "accept", "", "Message Format", "", "make_message        - produces a message in the canonical transmission format", "name                - single recipient     => string for address field", "name_list           - list of recipients   => string for address field", "parse_address_field - address field string => object list", "", "Sending Messages", "", "send_message  - advertised message sending routine.", "raw_send      - raw message sending routine ", "                (only called by $mail_editor:send and this:send_message)", "resolve_addr  - converts a given list recipients into a list of actual ", "                recipients and objects to be notified.", "sends_to      - Does X forward (transitively) to Y", "", "Mail Options", "", "option         ", "option_verbose", "", "  2.  canonical versions of mail_recipient verbs", "", "Ideally, the verbs to perform operations on a given mail recipient would be located on the recipient itself, except for the fact that these verbs also need to be located on players, which for various reasons, shouldn't be children of $mail_recipient.  Multiple inheritance would solve our problems, but we don't have it yet.  Ergo, both $mail_recipient and $player refer to the following verbs here:", "", "display_seq_full     print entire text of messages  (@read)", "display_seq_headers  print headers of messages      (@mail)", "rm_message_seq       remove messages                (@rmm)", "undo_rmm             undo last rm_message_seq       (@unrmm)", "expunge_rmm          flush removed messages         (@unrmm expunge)", "list_rmm             list removed messages          (@unrmm list)", "renumber             renumber messages              (@renumber)", "msg_summary_line     msg header => display_seq_headers/list_rmm summary line", "", "parse_message_seq    command line msg sequence spec => message sequence", "new_message_num      => message number of next new message", "length_all_msgs      => number of messages (total)", "length_num_le        => number of messages numbered <= some number", "length_date_le       => number of messages dated <= some date", "exists_num_eq        => true iff there exists a messsage with the given number", "from_msg_seq         => message sequence of msgs from given sender(s)", "to_msg_seq           => message sequence of msgs to given recipient(s)", "subject_msg_seq      => message sequence of msgs with subjects containing text", "body_msg_seq         => message sequence of msgs with bodies containing text", "messages_in_seq      => list of {message number, message} pairs", "", "messages             == :messages_in_seq(1,:length_all_msgs()+1)   (obsolete)", "", "The $mail_agent versions of these verbs are set_task_perms(caller_perms()) and perform their operations on caller, which in turn is assumed to have done any necessary security checks." ]
#19 Core Utility Help.MR-naming rc = MOOList [ "One may always refer to a list by its object number.  In order to refer to it by name, it must be contained in $mail_agent, which holds all mailing lists, i.e., those that you want others to be able to refer to by name.", "", "The .aliases field holds the names by which one may refer to the list, but only those names not containing spaces actually count for anything.  As with certain other types of objects (e.g., players), set_aliases() needs to be called in order to change the .aliases field.", "", "$mail_agent:match(name) ", "    is the canonical way to obtain the objectid of a mailing list ", "    given the name ("*" is assumed; an initial "*" will be dropped).", "", "$mail_agent:match_recipient(name) ", "    is the canonical way to obtain the objectid of a list or player", "    matching the given name.  An initial "*" indicates that this is ", "    supposed to be a list.", "", "$mail_agent:match_failed(objid,name) ", "    is the mail_recipient counterpart to $command_utils:object_match_failed" ]
#19 Core Utility Help.$recycler r = MOOList [ "$recycler", "=========", "", "Rather than having the server built-in recycle() and create() functions handle the creation and destruction of objects, a recycling center has been created to simulate these actions by  changing objects that would have been recycled into children of $garbage (The Generic Garbage Object) and making them owned by Hacker, and then when they're needed again, to avoid a raw create() command, those objects are given to whoever's asking for them.", "", "Most Useful Verbs", "-----------------", "", "$recycler:_recycle( object )", "  This will effectively recycle an object. (As a point of fact, it changes ownership of the object to Hacker and makes the object a child of $garbage.)  It handles .ownership_quota and .owned_objects properly.  Generally, use this instead of a recycle() in your verbs.", "", "$recycler:_create( parent object [ , new owner object ] )", "  This effectively creates an object (with the specified parent, if possible, and with the specified owner, if possible; these are the same restrictions as on the server create() builtin).  This is what should generally be used instead of create() in your programming.", "", "$recycler:valid ( object )", "  This is a variant of the server built-in valid() except that it handles the $garbage objects as well.  It returns a 1 if the object specified -is- valid and is -not- a $garbage object.", "", "Other Notes", "-----------", "", "request <object> from <recycler>", "  This is not an internal verb (it's !x).  It is, however, a command-line verb that can be used to request a specific object from the recycler.  It's also useful for the creation of objects like a Magic Number Repository.  When the object is removed from the recycler, the .announce_removal_msg is announced to the room if it's set (it's piped through $string_utils for pronoun substitution).", "", "show-history <recycler>", "  This is a wizardly verb which allows wizards to check the `history list' of the recycler. The history maintains the latest ($recycler.nhist) entries.", "", "$recycler.orphans", "  This maintains a list of objects for which the recreation process got mangled. It ought to be checked every once in a while to see what's up." ]
#19 Core Utility Help.mail-expiration rc = MOOList [ "*forward*", "MR-expiration" ]
#19 Core Utility Help.$exit rc = MOOList [ "Exits", "-----", "An exit can be renamed by either the owner of the exit or the owner of its source.", "", "The standard verbs that are called in exit movement are:", "", ":move(object)  - moves the object via this exit", ":invoke()      - equivalent to :move(player)", "", "When an exit is invoked on a particular object (via exit:move(object)), the following occurs.", "", "(1) The exit may be locked against the object, in which case we print the ", "   nogo messages and quit.", "", "(2) (room=exit.dest):bless_for_entry(object) is called.  Assuming that exit is recognized by room as being a legitimate entrance (i.e., is in room.entrances), this will enable room:accept(object) to return true.", "", "(3) object:moveto(room) is called and the various messages (see `help exit-messages') are :announced/:told.  Note that this, in accordance with the way the builtin move() (and hence the default :moveto()) works, we get a call to room:accept(object) which checks for the room itself being locked against the object, and otherwise returns true if the blessing in the previous step worked.  The move is performed, here:exitfunc(object) and room:enterfunc(object) are called.  In particular, room:enterfunc clears the blessing bestowed in (2) now that it is no longer needed.", "", "In general, the move may fail, in which case we :announce the (o)nogo_msgs." ]
#19 Core Utility Help.$big_mail_recipient rc = MOOList [ "Generic Large Capacity Mail Recipient", "-------------------------------------", "Since any modifications to large lists entail copying the entire list over, operations on ordinary mail recipients having large numbers of messages, that actually change the content of .messages will take inordinately long.  Thus we have this version which makes use of the $biglist package, scattering the messages onto numerous properties so that write operations involving only a few messages will not require recopying of the entire list.", "", "In nearly all respects it behaves as the ordinary Mail Recipient, except that it is faster for certain kinds of operations.", "", "Certain unimplemented verbs, like :date_sort(), and :messages() currently return E_VERBNF.", "", "To convert an existing $mail_recipient-child (call it #MR) into a $big_mail_recipient-child the basic procedure is", "", "    ;;something.foo= #MR:messages();", "    @rmm 1-$ from #MR", "    @unrmm expunge", "    @chparent #MR to $big_mail_recipient", "    ;#MR:receive_batch(@something.foo);", "", "Reconstructing Damaged Big Mail Recipients", "------------------------------------------", "On rare occasions, the tree structure created by $biglist can be corrupted (this can happen on lists sufficiently large that a list-modification operation (e.g., @rmm, @renumber) runs out of ticks/seconds).  In the vast majority of such cases, your messages are all still there; it's simply that the tree we use for finding/searching them is messed up.", "", "To recover messages from a damaged big mail recipient (#DBMR)", " --- read to the end before you start typing any commands ---", "", "create a fresh $big_mail_recipient (#NEWBMR) and then do the following:", "", "   ;#NEWBMR:restore_from(#DBMR)", "", "When this finishes, #NEWBMR will contain all of the mail messages we were able to find.  (note that this will include messages that you had deleted from #DBMR but not expunged).  #NEWMBR should thenceforth be useable in place of #DBMR, however if #DBMR contains custom verbs and non-clear properties, these will also need to be copied over.", "", "Alternatively, one may do", "", "   @copyobject #DBMR to #TEMPBMR", "   ;#DBMR:restore_from(#TEMPBMR)", "", "to rebuild #DBMR in place.  This, however, will take about twice as long.", "", "oooooooooooooooooooooooooooooooo", "WARNING!!! WARNING!!! WARNING!!!", "oooooooooooooooooooooooooooooooo", "", "Calling #OBJ:restore_from(...) COMPLETELY AND IRREVOCABLY REMOVES ALL MESSAGES from the object that it is run on (#OBJ); you MUST be sure to EITHER have made a copy of #OBJ OR be doing the restore to a DIFFERENT object." ]
#19 Core Utility Help.$generic_help rc = MOOList [ "The Help System", "---------------", "When a player types help, the following list of objects is consulted for .help properties:  the player itself, all ancestors of player up to and including $player, and, if the current location is a room, the current location together with all ancestors of the current location back to and including $room.  Each help property should have as value either an object or a list of objects (otherwise we just ignore it).  These objects are then strung together as a list of `help databases' to be searched in order for the requested topic.", "", "A help database (in the sense of anything that is usable by $player:help()) is any object having the following three verbs:", "", "  :find_topics([string])", "     where string is a supposed help topic, returns a list of strings,", "     i.e., actual help topics that this db knows about, or some boolean ", "     false value in the event that this db is clueless...", "     If no arguments are given, this should return a list of all topics", "     in the db", "", "  :get_topic(string)", "     given one of the strings returned by :find_topics this either", "     returns a list of strings (text to be spewed to the player) or", "     returns 1 to indicate that it has already taken care of printing", "     information to the player.", "", "  :dump_topic(string)", "     like get_topic, but instead returns the raw text of a help topic", "     as a (download/upload) script", "", "In short if :find_topic reports that a particular db knows about a given topic", "it returns the full topic name, so that :get_topic may be called on it later.", ":dump_topic is used by maintainers (see $wiz:@gethelp) to edit help topics.", "", "$generic_help and $help", "-----------------------", "The Generic Help Database, $generic_help, is the parent class of a particular kind of help database of which $help is an instance.  On help databases of this type, every help topic has a corresponding property, interpreted as follows:", "", "  this.(topic) = string             ", "      one-line help text.", "", "  this.(topic) = {"*<verb>*",@args}", "      call this:<verb>(args,dblist) to get text where dblist is the list of ", "      help objects that would have been consulted had the topic not been found ", "      on this object.", "", "  this.(topic) = other list of strings ", "      multi-line help text", "", "For the {"*<verb>*",...} form, the current verbs available are", "", "  {"*forward*", topic, @rest}   ", "     - get help text for topic and then append the lines of `rest'.  ", "       rest may, in turn, begin with a "*<verb>*"...", "", "  {"*pass*", topic, @rest}   ", "     - get help text for topic from the first help database after this one", "       that actually has help text for topic, and then append lines of `rest'.", "       As with "*forward*" rest may, in turn, begin with a "*<verb>*"...", "", "  {"*subst*", @lines} ", "     - All occurences of %[exp] in lines are replaced with the value of exp", "         which is assumed to evaluate to a string.  ", "       All lines beginning with %;exp are replaced with the value of exp ", "         which is assumed to evaluate to a list of strings.", "       Evaluation is done using $no_one's permissions so exp in either case", "       can only refer to public information.", "", "  {"*index*", title}", "     - returns a list of all topics in this database, arranged in columns.", "       title is used as a heading for this index.", "", "       In order for your help database to appear in the list presented", "       by 'help index', your db object must be set to +r.", "", "  {"*objectdoc*", object}", "     - gets the documentation for the given object (i.e., object:help_msg())", "       N.B. as with all other *verb* arguments, object must be a string.", "", "  {"*verbdoc*", object, verbname}", "     - gets the documentation for the named verb on the given object", "       (i.e., any strings at the beginning of said verbcode)", "", "Individual help dbs are free to define additional verbs that may be used in this context.  $help itself defines the following additional such verbs:", "", "  {"*index_list*"}", "     - returns a list of all index topics in all databases in the search list.", "       An index topic is one whose actual text is {"*index*", something}.", "       When creating a help db, you should be sure to make an index topic.", "", "  {"*full_index*"}", "     - prints indices for all help databases in the search list.", "", "It should be noted (once again) that help databases need not be children of $generic_help, so long as they have :find_topics/:get_topic/:dump_topic working as specified above." ]
#19 Core Utility Help.make-core-database rc = MOOList [ "Syntax:  make-core-database", "", "!!! NOTE:", "!!! ", "!!! This is, by design, an extraordinarily destructive command, ", "!!! one NOT INTENDED to be run in the live instance of your MOO.", "!!! ", "!!! While there are various safeguards to keep it from being run in", "!!! situations where it looks like this might be the live instance of", "!!! the MOO (e.g., >1 player connected), there are limits on how", "!!! idiot-proof we can be.", "!!!", "!!! You have been warned.", "", "The correct use of this command is in a separate process.  ", "That is, once you have identified a database/checkpoint file from which you wish to extract a core, you", "", "(*) Run a LOCAL moo process reading from that database file,", "    ", "(*) Connect as $owner (usually $owner == #2).", "", "(*) Invoke ($wiz:)make-core-database", "", "Here "LOCAL" means you have open_network_connection() disabled (so that, e.g., spurious registration email doesn't go out) and you either run the moo on a port that is not accessible from the outside world or use one of the single-user/local configurations of the server (e.g., NETWORK_PROTOCOL = NP_SINGLE or -a 127.0.0.1 on the command line) so that no one else can connect while you're destroying the world (and perhaps mess with what eventually gets saved).", "", "Once you type 'make-core-database', the actual extraction process then goes as follows:", "", "(1) A particular set of objects, the "core objects" as determined by,", "    oddly enough, $core_objects(), is identified.  ", "    ", "    See 'help $core_objects' for details on the algorithm used.", "    ", "(2) Any core object and any property/verb thereon that has a non-core owner", "    is chowned either to the (assumed wizardly) player or $hacker ", "    according as the item in question is wizard-owned.", "", "(3) All non-core objects are mercilessly recycled.", "", "(4) Core objects are renumbered and max_object is reset,", "    so as to produce a contiguous array [#0..max_object()] of objects.", "", "(5) All objects are moved to #-1.", "", "(6) OBJECT:init_for_core is called on all objects having such verbs.", "    The sequence of calls is unspecified except in that an object ", "    is initialized prior to any of its children.", "    ", "    See 'help init_for_core' for more on what these verbs should look like.", "", "(7) The byte-quota statistics are redone", "", "(8) The moo is shut down and the database is saved." ]
#19 Core Utility Help.mail-resolution rc = MOOList [ "*forward*", "mail-resolve" ]
#19 Core Utility Help:find_topics this n/a this
if (!args)
l = {};
for p in (properties(#0))
if ((p[max(1, $ - 5)..$] == "_utils") && `#0.(p):help_msg() ! ANY')
l = {@l, "$" + p};
endif
endfor
return {@pass(@args), @l};
elseif (ts = pass(@args))
return ts;
elseif ((what = args[1])[1] != "$")
return {};
elseif (ts = pass("$generic_" + what[2..$]))
return ts;
elseif ((r = rindex(w = strsub(what[2..$], "-", "_"), "_utils")) && ((r == (length(w) - 5)) && (`valid(#0.(w)) ! ANY' && `#0.(w):help_msg() ! ANY')))
return {what};
else
return {};
endif
-------------------------------------------------------------------------------
#19 Core Utility Help:get_topic this n/a this
topic = args[1];
if ((topic == (("$" + topic[2..$ - 5]) + "utils")) && (valid(#0.(w = strsub(topic[2..$], "-", "_"))) && (uhelp = #0.(w):description())))
return {tostr("General information on $", w, ":"), "----", @(typeof(uhelp) == STR) ? {uhelp} | uhelp};
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#19 Core Utility Help:dump_topic this n/a this
if ((E_PROPNF != (text = pass(@args))) || ((args[1][1] != "$") || ((!((uprop = args[1][2..$]) in properties(#0))) || (typeof(uobj = #0.(uprop)) != OBJ))))
return text;
else
udesc = uobj.description;
return {tostr(";;$", uprop, ".description = $command_utils:read_lines()"), @$command_utils:dump_lines((typeof(udesc) == LIST) ? udesc | {udesc})};
endif
-------------------------------------------------------------------------------
================================#20 string utilities===============================================
#20 string utilities.use_article_a r = MOOList [ "unit", "unix", "one", "once", "utility" ]
#20 string utilities.alphabet rc = MOOString "abcdefghijklmnopqrstuvwxyz"
#20 string utilities.use_article_an r = MOOList [ ]
#20 string utilities.tab rc = MOOString "	"
#20 string utilities.digits rc = MOOString "0123456789"
#20 string utilities.ascii rc = MOOString " !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
#20 string utilities:space this n/a this
"space(len,fill) returns a string of length abs(len) consisting of copies of fill.  If len is negative, fill is anchored on the right instead of the left.";
{n, ?fill = " "} = args;
if (typeof(n) == STR)
n = length(n);
endif
if (n > 1000)
"Prevent someone from crashing the moo with $string_utils:space($maxint)";
return E_INVARG;
endif
if (" " != fill)
fill = fill + fill;
fill = fill + fill;
fill = fill + fill;
elseif ((n = abs(n)) < 70)
return "                                                                      "[1..n];
else
fill = "                                                                      ";
endif
m = (n - 1) / length(fill);
while (m)
fill = fill + fill;
m = m / 2;
endwhile
return (n > 0) ? fill[1..n] | fill[($ + 1) + n..$];
-------------------------------------------------------------------------------
#20 string utilities:left this n/a this
"$string_utils:left(string,width[,filler])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> followed by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.";
"";
"The <filler> is optional and defaults to \" \"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.";
{text, len, ?fill = " "} = args;
abslen = abs(len);
out = tostr(text);
if (length(out) < abslen)
return out + this:space(length(out) - abslen, fill);
else
return (len > 0) ? out | out[1..abslen];
endif
-------------------------------------------------------------------------------
#20 string utilities:right this n/a this
"$string_utils:right(string,width[,filler])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded by enough filler to make it that wide. If <width> is negative and the length of <string> is greater than the absolute value of <width>, then <string> is cut off at <width> from the right.";
"";
"The <filler> is optional and defaults to \" \"; it controls what is used to fill the resulting string when it is too short.  The <filler> is replicated as many times as is necessary to fill the space in question.";
{text, len, ?fill = " "} = args;
abslen = abs(len);
out = tostr(text);
if ((lenout = length(out)) < abslen)
return this:space(abslen - lenout, fill) + out;
else
return (len > 0) ? out | out[($ - abslen) + 1..$];
endif
-------------------------------------------------------------------------------
#20 string utilities:centre center this n/a this
"$string_utils:center(string,width[,lfiller[,rfiller]])";
"";
"Assures that <string> is at least <width> characters wide.  Returns <string> if it is at least that long, or else <string> preceded and followed by enough filler to make it that wide.  If <width> is negative and the length of <string> is greater than the absolute value of <width>, then the <string> is cut off at <width>.";
"";
"The <lfiller> is optional and defaults to \" \"; it controls what is used to fill the left part of the resulting string when it is too short.  The <rfiller> is optional and defaults to the value of <lfiller>; it controls what is used to fill the right part of the resulting string when it is too short.  In both cases, the filler is replicated as many times as is necessary to fill the space in question.";
{text, len, ?lfill = " ", ?rfill = lfill} = args;
out = tostr(text);
abslen = abs(len);
if (length(out) < abslen)
return (this:space((abslen - length(out)) / 2, lfill) + out) + this:space(((abslen - length(out)) + 1) / -2, rfill);
else
return (len > 0) ? out | out[1..abslen];
endif
-------------------------------------------------------------------------------
#20 string utilities:columnize columnise this n/a this
"columnize (items, n [, width]) - Turn a one-column list of items into an n-column list. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize ({1, 2, 3, 4, 5, 6, 7}, 3));'.";
{items, n, ?width = 79} = args;
height = ((length(items) + n) - 1) / n;
items = {@items, @$list_utils:make((height * n) - length(items), "")};
colwidths = {};
for col in [1..n - 1]
colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));
endfor
result = {};
for row in [1..height]
line = tostr(items[row]);
for col in [1..n - 1]
line = tostr(this:left(line, colwidths[col]), " ", items[row + (col * height)]);
endfor
result = listappend(result, line[1..min($, width)]);
endfor
return result;
-------------------------------------------------------------------------------
#20 string utilities:from_list this n/a this
"$string_utils:from_list(list [, separator])";
"Return a string being the concatenation of the string representations of the elements of LIST, each pair separated by the string SEPARATOR, which defaults to the empty string.";
{thelist, ?separator = ""} = args;
if (separator == "")
return tostr(@thelist);
elseif (thelist)
result = tostr(thelist[1]);
for elt in (listdelete(thelist, 1))
result = tostr(result, separator, elt);
endfor
return result;
else
return "";
endif
-------------------------------------------------------------------------------
#20 string utilities:english_list this n/a this
"Prints the argument (must be a list) as an english list, e.g. {1, 2, 3} is printed as \"1, 2, and 3\", and {1, 2} is printed as \"1 and 2\".";
"Optional arguments are treated as follows:";
"  Second argument is the string to use when the empty list is given.  The default is \"nothing\".";
"  Third argument is the string to use in place of \" and \".  A typical application might be to use \" or \" instead.";
"  Fourth argument is the string to use instead of a comma (and space).  Gary_Severn's deranged mind actually came up with an application for this.  You can ask him.";
"  Fifth argument is a string to use after the penultimate element before the \" and \".  The default is to have a comma without a space.";
{things, ?nothingstr = "nothing", ?andstr = " and ", ?commastr = ", ", ?finalcommastr = ","} = args;
nthings = length(things);
if (nthings == 0)
return nothingstr;
elseif (nthings == 1)
return tostr(things[1]);
elseif (nthings == 2)
return tostr(things[1], andstr, things[2]);
else
ret = "";
for k in [1..nthings - 1]
if (k == (nthings - 1))
commastr = finalcommastr;
endif
ret = tostr(ret, things[k], commastr);
endfor
return tostr(ret, andstr, things[nthings]);
endif
-------------------------------------------------------------------------------
#20 string utilities:names_of this n/a this
"Return a string of the names and object numbers of the objects in a list.";
line = "";
for item in (args[1])
if ((typeof(item) == OBJ) && valid(item))
line = (((line + item.name) + "(") + tostr(item)) + ")   ";
endif
endfor
return $string_utils:trimr(line);
-------------------------------------------------------------------------------
#20 string utilities:from_seconds this n/a this
":from_seconds(number of seconds) => returns a string containing the rough increment of days, or hours if less than a day, or minutes if less than an hour, or lastly in seconds.";
":from_seconds(86400) => \"a day\"";
":from_seconds(7200)  => \"two hours\"";
minute = 60;
hour = 60 * minute;
day = 24 * hour;
secs = args[1];
if (secs > day)
count = secs / day;
unit = "day";
article = "a";
elseif (secs > hour)
count = secs / hour;
unit = "hour";
article = "an";
elseif (secs > minute)
count = secs / minute;
unit = "minute";
article = "a";
else
count = secs;
unit = "second";
article = "a";
endif
if (count == 1)
time = tostr(article, " ", unit);
else
time = tostr(count, " ", unit, "s");
endif
return time;
-------------------------------------------------------------------------------
#20 string utilities:trim this n/a this
":trim (string [, space]) -- remove leading and trailing spaces";
"";
"`space' should be a character (single-character string); it defaults to \" \".  Returns a copy of string with all leading and trailing copies of that character removed.  For example, $string_utils:trim(\"***foo***\", \"*\") => \"foo\".";
{string, ?space = " "} = args;
m = match(string, tostr("[^", space, "]%(.*[^", space, "]%)?%|$"));
return string[m[1]..m[2]];
-------------------------------------------------------------------------------
#20 string utilities:triml this n/a this
":triml(string [, space]) -- remove leading spaces";
"";
"`space' should be a character (single-character string); it defaults to \" \".  Returns a copy of string with all leading copies of that character removed.  For example, $string_utils:triml(\"***foo***\", \"*\") => \"foo***\".";
{string, ?what = " "} = args;
m = match(string, tostr("[^", what, "]%|$"));
return string[m[1]..$];
-------------------------------------------------------------------------------
#20 string utilities:trimr this n/a this
":trimr(string [, space]) -- remove trailing spaces";
"";
"`space' should be a character (single-character string); it defaults to \" \".  Returns a copy of string with all trailing copies of that character removed.  For example, $string_utils:trimr(\"***foo***\", \"*\") => \"***foo\".";
{string, ?what = " "} = args;
return string[1..rmatch(string, tostr("[^", what, "]%|^"))[2]];
-------------------------------------------------------------------------------
#20 string utilities:strip_chars this n/a this
":strip_chars(string,chars) => string with chars removed";
{subject, stripped} = args;
for i in [1..length(stripped)]
subject = strsub(subject, stripped[i], "");
endfor
return subject;
-------------------------------------------------------------------------------
#20 string utilities:strip_all_but this n/a this
":strip_all_but(string,keep) => string with chars not in `keep' removed.";
"`keep' is used in match() so if it includes ], ^, or -,";
"] should be first, ^ should be other from first, and - should be last.";
string = args[1];
wanted = ("[" + args[2]) + "]+";
output = "";
while (m = match(string, wanted))
output = output + string[m[1]..m[2]];
string = string[m[2] + 1..$];
endwhile
return output;
-------------------------------------------------------------------------------
#20 string utilities:uppercase lowercase this n/a this
"lowercase(string) -- returns a lowercase version of the string.";
"uppercase(string) -- returns the uppercase version of the string.";
string = args[1];
from = caps = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
to = lower = "abcdefghijklmnopqrstuvwxyz";
if (verb == "uppercase")
from = lower;
to = caps;
endif
for i in [1..26]
string = strsub(string, from[i], to[i], 1);
endfor
return string;
-------------------------------------------------------------------------------
#20 string utilities:capitalize capitalise this n/a this
"capitalizes its argument.";
if ((string = args[1]) && (i = index("abcdefghijklmnopqrstuvwxyz", string[1], 1)))
string[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i];
endif
return string;
-------------------------------------------------------------------------------
#20 string utilities:literal_object this n/a this
"Matches args[1] against literal objects: #xxxxx, $variables, *mailing-lists, and username.  Returns the object if successful, $failed_match else.";
string = args[1];
if (!string)
return $nothing;
elseif ((string[1] == "#") && (E_TYPE != (object = $code_utils:toobj(string))))
return object;
elseif (string[1] == "~")
return this:match_player(string[2..$], #0);
elseif ((string[1] == "*") && (length(string) > 1))
return $mail_agent:match_recipient(string);
elseif (string[1] == "$")
string[1..1] = "";
object = #0;
while (pn = string[1..(dot = index(string, ".")) ? dot - 1 | $])
if ((!$object_utils:has_property(object, pn)) || (typeof(object = object.(pn)) != OBJ))
return $failed_match;
endif
string = string[length(pn) + 2..$];
endwhile
if ((object == #0) || (typeof(object) == ERR))
return $failed_match;
else
return object;
endif
else
return $failed_match;
endif
-------------------------------------------------------------------------------
#20 string utilities:match this n/a this
"$string_utils:match(string [, obj-list, prop-name]*)";
"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.";
"The argument string is matched against all of the strings in the property values.";
"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.";
"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.";
"Finally, if there are no exact or partial matches, then $failed_match is returned.";
subject = args[1];
if (subject == "")
return $nothing;
endif
no_exact_match = no_partial_match = 1;
for i in [1..length(args) / 2]
prop_name = args[(2 * i) + 1];
for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})
if (valid(object))
if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)
str_list = {str_list};
endif
if (subject in str_list)
if (no_exact_match)
no_exact_match = object;
elseif (no_exact_match != object)
return $ambiguous_match;
endif
else
for string in (str_list)
if (index(string, subject) != 1)
elseif (no_partial_match)
no_partial_match = object;
elseif (no_partial_match != object)
no_partial_match = $ambiguous_match;
endif
endfor
endif
endif
endfor
endfor
return no_exact_match && (no_partial_match && $failed_match);
-------------------------------------------------------------------------------
#20 string utilities:match_str*ing this n/a this
"* wildcard matching. Returns a list of what the *s actually matched. Won't cath every match, if there are several ways to parse it.";
"Example: $string_utils:match_string(\"Jack waves to Jill\",\"* waves to *\") returns {\"Jack\", \"Jill\"}";
"Optional arguments: numbers are interpreted as case-sensitivity, strings as alternative wildcards.";
{what, targ, @rest} = args;
wild = "*";
case = ret = {};
what = what + "&^%$";
targ = targ + "&^%$";
for y in (rest)
if (typeof(y) == STR)
wild = y;
elseif (typeof(y) == INT)
case = {y};
endif
endfor
while (targ != "")
if (z = index(targ, wild))
part = targ[1..z - 1];
else
z = length(targ);
part = targ;
endif
n = (part == "") ? 1 | index(what, part, @case);
if (n)
ret = listappend(ret, what[1..n - 1]);
what = what[(z + n) - 1..$];
targ = targ[z + 1..$];
else
return 0;
endif
endwhile
if (ret == {})
return what == "";
elseif (ret == {""})
return 1;
elseif (ret[1] == "")
return ret[2..$];
else
return 0;
endif
-------------------------------------------------------------------------------
#20 string utilities:match_object this n/a this
":match_object(string,location[,someone])";
"Returns the object matching the given string for someone, on the assumption that s/he is in the given location.  `someone' defaults to player.";
"This first tries :literal_object(string), \"me\"=>someone,\"here\"=>location, then player:match(string) and finally location:match(string) if location is valid.";
"This is the default algorithm for use by room :match_object() and player :my_match_object() verbs.  Player verbs that are calling this directly should probably be calling :my_match_object instead.";
{string, here, ?who = player} = args;
if ($failed_match != (object = this:literal_object(string)))
return object;
elseif (string == "me")
return who;
elseif (string == "here")
return here;
elseif ((valid(pobject = who:match(string)) && (string in {@pobject.aliases, pobject.name})) || (!valid(here)))
"...exact match in player or room is bogus...";
return pobject;
elseif ((valid(hobject = here:match(string)) && (string in {@hobject.aliases, hobject.name})) || (pobject == $failed_match))
"...exact match in room or match in player failed completely...";
return hobject;
else
return pobject;
endif
-------------------------------------------------------------------------------
#20 string utilities:match_player this n/a this
"match_player(name,name,...)      => {obj,obj,...}";
"match_player(name[,meobj])       => obj";
"match_player({name,...}[,meobj]) => {obj,...}";
"objs returned are either players, $failed_match, $ambiguous_match, or $nothing in the case of an empty string.";
"meobj (what to return for instances of `me') defaults to player; if given and isn't actually a player, `me' => $failed_match";
retstr = 0;
me = player;
if ((length(args) < 2) || (typeof(me = args[2]) == OBJ))
me = (valid(me) && is_player(me)) ? me | $failed_match;
if (typeof(args[1]) == STR)
strings = {args[1]};
retstr = 1;
"return a string, not a list";
else
strings = args[1];
endif
else
strings = args;
me = player;
endif
found = {};
for astr in (strings)
if (!astr)
aobj = $nothing;
elseif (astr == "me")
aobj = me;
elseif (valid(aobj = $string_utils:literal_object(astr)) && is_player(aobj))
"astr is a valid literal object number of some player, so we are done.";
else
aobj = $player_db:find(astr);
endif
found = {@found, aobj};
endfor
return retstr ? found[1] | found;
-------------------------------------------------------------------------------
#20 string utilities:match_player_or_object this n/a this
"Accepts any number of strings, attempts to match those strings first against objects in the room, and if no objects by those names exist, matches against player names (and \"#xxxx\" style strings regardless of location).  Returns a list of valid objects so found.";
"Unlike $string_utils:match_player, does not include in the list the failed and ambiguous matches; instead has built-in error messages for such objects.  This should probably be improved.  Volunteers?";
if (!args)
return;
endif
unknowns = {};
objs = {};
"We have to do something icky here.  Parallel walk the victims and args lists.  When it's a valid object, then it's a player.  If it's an invalid object, try to get an object match from the room.  If *that* fails, complain.";
for i in [1..length(args)]
if (valid(o = player.location:match_object(args[i])))
objs = {@objs, o};
else
unknowns = {@unknowns, args[i]};
endif
endfor
victims = $string_utils:match_player(unknowns);
for i in [1..length(victims)]
if (!valid(victims[i]))
player:tell("Could not find ", unknowns[i], " as either an object or a player.");
else
objs = {@objs, victims[i]};
endif
endfor
return objs;
-------------------------------------------------------------------------------
#20 string utilities:find_prefix this n/a this
"find_prefix(prefix, string-list) => list index of something starting with prefix, or 0 or $ambiguous_match.";
{subject, choices} = args;
answer = 0;
for i in [1..length(choices)]
if (index(choices[i], subject) == 1)
if (answer == 0)
answer = i;
else
answer = $ambiguous_match;
endif
endif
endfor
return answer;
-------------------------------------------------------------------------------
#20 string utilities:index_d*elimited this n/a this
"index_delimited(string,target[,case_matters]) is just like the corresponding call to the builtin index() but instead only matches on occurences of target delimited by word boundaries (i.e., not preceded or followed by an alphanumeric)";
args[2] = ("%(%W%|^%)" + $string_utils:regexp_quote(args[2])) + "%(%W%|$%)";
return (m = match(@args)) ? m[3][1][2] + 1 | 0;
-------------------------------------------------------------------------------
#20 string utilities:is_integer is_numeric this n/a this
"Usage:  is_numeric(string)";
"        is_integer(string)";
"Is string numeric (composed of one or more digits possibly preceded by a minus sign)? This won't catch floating points.";
"Return true or false";
return match(args[1], "^ *[-+]?[0-9]+ *$");
digits = "1234567890";
if (!(string = args[1]))
return 0;
endif
if (string[1] == "-")
string = string[2..length(string)];
endif
for i in [1..length(string)]
if (!index(digits, string[i]))
return 0;
endif
endfor
return 1;
-------------------------------------------------------------------------------
#20 string utilities:ordinal this n/a this
":short_ordinal(1) => \"1st\",:short_ordinal(2) => \"2nd\",etc...";
string = tostr(n = args[1]);
n = abs(n) % 100;
if (((n / 10) != 1) && ((n % 10) in {1, 2, 3}))
return string + {"st", "nd", "rd"}[n % 10];
else
return string + "th";
endif
-------------------------------------------------------------------------------
#20 string utilities:group_number this n/a this
"$string_utils:group_number(INT n [, sep_char])";
"$string_utils:group_number(FLOAT n, [INT precision [, scientific [, sep_char]]])";
"";
"Converts N to a string, inserting commas (or copies of SEP_CHAR, if given) every three digits, counting from the right.  For example, $string_utils:group_number(1234567890) returns the string \"1,234,567,890\".";
"For floats, the arguements precision (defaulting to 4 in this verb) and scientific are the same as given in floatstr().";
if (typeof(args[1]) == INT)
{n, ?comma = ","} = args;
result = "";
sign = (n < 0) ? "-" | "";
n = tostr(abs(n));
elseif (typeof(args[1]) == FLOAT)
{n, ?prec = 4, ?scien = 0, ?comma = ","} = args;
sign = (n < 0.0) ? "-" | "";
n = floatstr(abs(n), prec, scien);
i = index(n, ".");
result = n[i..$];
n = n[1..i - 1];
else
return E_INVARG;
endif
while ((len = length(n)) > 3)
result = (comma + n[len - 2..len]) + result;
n = n[1..len - 3];
endwhile
return (sign + n) + result;
"Code contributed by SunRay";
-------------------------------------------------------------------------------
#20 string utilities:english_number this n/a this
"$string_utils:english_number(n) -- convert the integer N into English";
"";
"Produces a string containing the English phrase naming the given integer.  For example, $string_utils:english_number(-1234) returns the string `negative one thousand two hundred thirty-four'.";
numb = toint(args[1]);
if (numb == 0)
return "zero";
endif
labels = {"", " thousand", " million", " billion"};
numstr = "";
mod = abs(numb);
for n in [1..4]
div = mod % 1000;
if (div)
hun = div / 100;
ten = div % 100;
outstr = this:english_tens(ten) + labels[n];
if (hun)
outstr = ((this:english_ones(hun) + " hundred") + (ten ? " " | "")) + outstr;
endif
if (numstr)
numstr = (outstr + " ") + numstr;
else
numstr = outstr;
endif
endif
mod = mod / 1000;
endfor
return ((numb < 0) ? "negative " | "") + numstr;
-------------------------------------------------------------------------------
#20 string utilities:english_ordinal this n/a this
"$string_utils:english_ordinal(n) -- convert the integer N into an english ordinal (1 => \"first\", etc...)";
numb = toint(args[1]);
if (numb == 0)
return "zeroth";
elseif (numb % 100)
hundreds = (abs(numb) > 100) ? this:english_number((numb / 100) * 100) + " " | ((numb < 0) ? "negative " | "");
numb = abs(numb) % 100;
specials = {1, 2, 3, 5, 8, 9, 12, 20, 30, 40, 50, 60, 70, 80, 90};
ordinals = {"first", "second", "third", "fifth", "eighth", "ninth", "twelfth", "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth", "seventieth", "eightieth", "ninetieth"};
if (i = numb in specials)
return hundreds + ordinals[i];
elseif ((numb > 20) && (i = (numb % 10) in specials))
return ((hundreds + this:english_tens((numb / 10) * 10)) + "-") + ordinals[i];
else
return (hundreds + this:english_number(numb)) + "th";
endif
else
return this:english_number(numb) + "th";
endif
-------------------------------------------------------------------------------
#20 string utilities:english_ones this n/a this
numb = args[1];
ones = {"", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
return ones[numb + 1];
-------------------------------------------------------------------------------
#20 string utilities:english_tens this n/a this
numb = args[1];
teens = {"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
others = {"twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
if (numb < 10)
return this:english_ones(numb);
elseif (numb < 20)
return teens[numb - 9];
else
return (others[(numb / 10) - 1] + ((numb % 10) ? "-" | "")) + this:english_ones(numb % 10);
endif
-------------------------------------------------------------------------------
#20 string utilities:subst*itute this n/a this
"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])";
"  => returns string with all instances of the strings redex<n> replaced respectively by the strings repl<n>.  If the optional argument `case' is given and nonzero, the search for instances of redex<n> is case sensitive.";
"  Substitutions are done in parallel, i.e., instances of redex<n> that appear in any of the replacement strings are ignored.  In the event that two redexes overlap, whichever is leftmost in `string' takes precedence.  For two redexes beginning at the same position, the longer one takes precedence.";
"";
"subst(\"hoahooaho\",{{\"ho\",\"XhooX\"},{\"hoo\",\"mama\"}}) => \"XhooXamamaaXhooX\"";
"subst(\"Cc: banana\",{{\"a\",\"b\"},{\"b\",\"c\"},{\"c\",\"a\"}},1) => \"Ca: cbnbnb\"";
{ostr, subs, ?case = 0} = args;
if (typeof(ostr) != STR)
return ostr;
endif
len = length(ostr);
" - - - find the first instance of each substitution - -";
indices = {};
substs = {};
for s in (subs)
if (i = index(ostr, s[1], case))
fi = $list_utils:find_insert(indices, i = i - len) - 1;
while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, i, fi);
substs = listappend(substs, s, fi);
endif
endfor
"- - - - - perform substitutions - ";
nstr = "";
while (substs)
ind = len + indices[1];
sub = substs[1];
indices = listdelete(indices, 1);
substs = listdelete(substs, 1);
if (ind > 0)
nstr = (nstr + ostr[1..ind - 1]) + sub[2];
ostr = ostr[ind + length(sub[1])..len];
len = length(ostr);
endif
if (next = index(ostr, sub[1], case))
fi = $list_utils:find_insert(indices, next = next - len) - 1;
while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, next, fi);
substs = listappend(substs, sub, fi);
endif
endwhile
return nstr + ostr;
-------------------------------------------------------------------------------
#20 string utilities:substitute_d*elimited none n/a none
"subst(string,{{redex1,repl1},{redex2,repl2},{redex3,repl3}...}[,case])";
"Just like :substitute() but it uses index_delimited() instead of index()";
{ostr, subs, ?case = 0} = args;
if (typeof(ostr) != STR)
return ostr;
endif
len = length(ostr);
" - - - find the first instance of each substitution - -";
indices = {};
substs = {};
for s in (subs)
if (i = this:index_delimited(ostr, s[1], case))
fi = $list_utils:find_insert(indices, i = i - len) - 1;
while (fi && ((indices[fi] == i) && (length(substs[fi][1]) < length(s[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, i, fi);
substs = listappend(substs, s, fi);
endif
endfor
"- - - - - perform substitutions - ";
nstr = "";
while (substs)
ind = len + indices[1];
sub = substs[1];
indices = listdelete(indices, 1);
substs = listdelete(substs, 1);
if (ind > 0)
nstr = (nstr + ostr[1..ind - 1]) + sub[2];
ostr = ostr[ind + length(sub[1])..len];
len = length(ostr);
endif
if (next = this:index_delimited(ostr, sub[1], case))
fi = $list_utils:find_insert(indices, next = next - len) - 1;
while (fi && ((indices[fi] == next) && (length(substs[fi][1]) < length(sub[1]))))
"...give preference to longer redexes...";
fi = fi - 1;
endwhile
indices = listappend(indices, next, fi);
substs = listappend(substs, sub, fi);
endif
endwhile
return nstr + ostr;
-------------------------------------------------------------------------------
#20 string utilities:_cap_property this n/a this
"cap_property(what,prop[,ucase]) returns what.(prop) but capitalized if either ucase is true or the prop name specified is capitalized.";
"If prop is blank, returns what:title().";
"If prop is bogus or otherwise irretrievable, returns the error.";
"If capitalization is indicated, we return what.(prop+\"c\") if that exists, else we capitalize what.(prop) in the usual fashion.  There is a special exception for is_player(what)&&prop==\"name\" where we just return what.name if no .namec is provided --- ie., a player's .name is never capitalized in the usual fashion.";
"If args[1] is a list, calls itself on each element of the list and returns $string_utils:english_list(those results).";
{what, prop, ?ucase = 0} = args;
set_task_perms(caller_perms());
if (typeof(what) == LIST)
result = {};
for who in (what)
result = {@result, this:_cap_property(who, prop, ucase)};
endfor
return $string_utils:english_list(result);
endif
ucase = (prop && (strcmp(prop, "a") < 0)) || ucase;
if (!prop)
return valid(what) ? ucase ? what:titlec() | what:title() | ((ucase ? "N" | "n") + "othing");
elseif ((!ucase) || (typeof(s = `what.(prop + "c") ! ANY') == ERR))
if (prop == "name")
s = valid(what) ? what.name | "nothing";
ucase = ucase && (!is_player(what));
else
s = `$object_utils:has_property(what, prop) ? what.(prop) | $player.(prop) ! ANY';
endif
if (ucase && (s && ((typeof(s) == STR) && (((z = index(this.alphabet, s[1], 1)) < 27) && (z > 0)))))
s[1] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[z];
endif
endif
return (typeof(s) == ERR) ? s | tostr(s);
-------------------------------------------------------------------------------
#20 string utilities:pronoun_sub this n/a this
"Pronoun (and other things) substitution. See 'help pronouns' for details.";
"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location[,dobj[,iobj]]]]])";
"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.";
"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, <thing>, location and %";
"<thing> defaults to caller; <location> defaults to who.location";
"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.";
" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number";
"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..";
"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.";
"%<d:foo> -> whatever <dobj> does when normal people foo.";
{string, ?who = player, ?thing = caller, ?where = $nothing, ?dobject = dobj, ?iobject = iobj} = args;
where = valid(where) ? where | (valid(who) ? who.location | where);
set_task_perms($no_one);
if (typeof(string) == LIST)
plines = {};
for line in (string)
plines = {@plines, this:(verb)(line, who, thing, where)};
endfor
return plines;
endif
old = tostr(string);
new = "";
objspec = "nditl";
objects = {who, dobject, iobject, thing, where};
prnspec = "sopqrSOPQR";
prprops = {"ps", "po", "pp", "pq", "pr", "Ps", "Po", "Pp", "Pq", "Pr"};
oldlen = length(old);
while ((prcnt = index(old, "%")) && (prcnt < oldlen))
s = old[k = prcnt + 1];
if ((s == "<") && (gt = index(old[k + 2..$], ">")))
"handling %<verb> ";
gt = (gt + k) + 1;
vb = old[k + 1..gt - 1];
vbs = who;
if ((length(vb) > 2) && (vb[2] == ":"))
" %<d:verb>";
vbs = objects[index(objspec, vb[1]) || 1];
vb = vb[3..$];
endif
vb = $object_utils:has_callable_verb(vbs, "verb_sub") ? vbs:verb_sub(vb) | $gender_utils:get_conj(vb, vbs);
new = (new + old[1..prcnt - 1]) + vb;
k = gt;
else
cp_args = {};
if (brace = index("([", s))
if (!(w = index(old[k + 1..oldlen], ")]"[brace])))
return new + old;
else
p = old[prcnt + 2..(k = k + w) - 1];
if (brace == 1)
"%(property)";
cp_args = {who, p};
elseif (p[1] == "#")
"%[#n] => object number";
s = (o = index(objspec, p[2])) ? tostr(objects[o]) | (("[" + p) + "]");
elseif (!(o = index(objspec, p[1])))
s = ("[" + p) + "]";
else
" %[dproperty] ";
cp_args = {objects[o], p[2..w - 1], strcmp(p[1], "a") < 0};
endif
endif
elseif (o = index(objspec, s))
cp_args = {objects[o], "", strcmp(s, "a") < 0};
elseif (w = index(prnspec, s, 1))
cp_args = {who, prprops[w]};
elseif (s == "#")
s = tostr(who);
elseif (s != "%")
s = "%" + s;
endif
new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | (("%(" + tostr(sub)) + ")")));
endif
old = old[k + 1..oldlen];
oldlen = oldlen - k;
endwhile
return new + old;
-------------------------------------------------------------------------------
#20 string utilities:pronoun_sub_secure this n/a this
"$string_utils:pronoun_sub_secure(string[,who[,thing[,location]]], default)";
"Do pronoun_sub on string with the arguments given (see help";
"string_utils:pronoun_sub for more information).  Return pronoun_subbed";
"<default> if the subbed string does not contain <who>.name (<who>";
"defaults to player).";
who = (length(args) > 2) ? args[2] | player;
default = args[$];
result = this:pronoun_sub(@args[1..$ - 1]);
return this:index_delimited(result, who.name) ? result | this:pronoun_sub(@{default, @args[2..$ - 1]});
-------------------------------------------------------------------------------
#20 string utilities:pronoun_quote this n/a this
" pronoun_quote(string) => quoted_string";
" pronoun_quote(list of strings) => list of quoted_strings";
" pronoun_quote(list of {key,string} pairs) => list of {key,quoted_string} pairs";
"";
"Here `quoted' means quoted in the sense of $string_utils:pronoun_sub, i.e., given a string X, the corresponding `quoted' string Y is such that pronoun_sub(Y) => X.  For example, pronoun_quote(\"--%Spam%--\") => \"--%%Spam%%--\".  This is for including literal text into a string that will eventually be pronoun_sub'ed, i.e., including it in such a way that the pronoun_sub will not expand anything in the included text.";
"";
"The 3rd form above (with {key,string} pairs) is for use with $string_utils:substitute().  If you have your own set of substitutions to be done in parallel with the pronoun substitutions, do";
"";
"  msg=$string_utils:substitute(msg,$string_utils:pronoun_quote(your_substs));";
"  msg=$string_utils:pronoun_sub(msg);";
if (typeof(what = args[1]) == STR)
return strsub(what, "%", "%%");
else
ret = {};
for w in (what)
if (typeof(w) == LIST)
ret = listappend(ret, listset(w, strsub(w[2], "%", "%%"), 2));
else
ret = listappend(ret, strsub(w, "%", "%%"));
endif
endfor
return ret;
endif
-------------------------------------------------------------------------------
#20 string utilities:alt_pronoun_sub none n/a none
"Pronoun (and other things) substitution. See 'help pronouns' for details.";
"syntax:  $string_utils:pronoun_sub(text[,who[,thing[,location]]])";
"%s,%o,%p,%q,%r    => <who>'s pronouns.  <who> defaults to player.";
"%n,%d,%i,%t,%l,%% => <who>, dobj, iobj, this, <who>.location and %";
"%S,%O,%P,%Q,%R, %N,%D,%I,%T,%L have corresponding capitalized substitutions.";
" %[#n], %[#d], ...  =>  <who>, dobj, etc.'s object number";
"%(foo) => <who>.foo and %(Foo) => <who>.foo capitalized. %[dfoo] => dobj.foo, etc..";
"%<foo> -> whatever <who> does when normal people foo. This is determined by calling :verb_sub() on the <who>.";
"%<d:foo> -> whatever <dobj> does when normal people foo.";
set_task_perms($no_one);
{string, ?who = player, ?thing = caller, ?where = $nothing} = args;
where = valid(who) ? who.location | where;
if (typeof(string) == LIST)
plines = {};
for line in (string)
plines = {@plines, this:(verb)(line, who, thing, where)};
endfor
return plines;
endif
old = tostr(string);
new = "";
objspec = "nditl";
objects = {who, dobj, iobj, thing, where};
prnspec = "sopqrSOPQR";
prprops = {"ps", "po", "pp", "pq", "pr", "Ps", "Po", "Pp", "Pq", "Pr"};
oldlen = length(old);
while ((prcnt = index(old, "%")) && (prcnt < oldlen))
s = old[k = prcnt + 1];
if ((s == "<") && (gt = index(old[k + 2..$], ">")))
"handling %<verb> ";
gt = (gt + k) + 1;
vb = old[k + 1..gt - 1];
vbs = who;
if ((length(vb) > 2) && (vb[2] == ":"))
" %<d:verb>";
vbs = objects[index(objspec, vb[1]) || 1];
vb = vb[3..$];
endif
vb = $object_utils:has_verb(vbs, "verb_sub") ? vbs:verb_sub(vb) | this:(verb)(vb, vbs);
new = (new + old[1..prcnt - 1]) + vb;
k = gt;
else
cp_args = {};
if (brace = index("([", s))
if (!(w = index(old[k + 1..oldlen], ")]"[brace])))
return new + old;
else
p = old[prcnt + 2..(k = k + w) - 1];
if (brace == 1)
"%(property)";
cp_args = {who, p};
elseif (p[1] == "#")
"%[#n] => object number";
s = (o = index(objspec, p[2])) ? tostr(objects[o]) | (("[" + p) + "]");
elseif (!(o = index(objspec, p[1])))
s = ("[" + p) + "]";
else
" %[dproperty] ";
cp_args = {objects[o], p[2..w - 1], strcmp(p[1], "a") < 0};
endif
endif
elseif (o = index(objspec, s))
cp_args = {objects[o], "", strcmp(s, "a") < 0};
elseif (w = index(prnspec, s, 1))
cp_args = {who, prprops[w]};
elseif (s == "#")
s = tostr(who);
elseif (s != "%")
s = "%" + s;
endif
new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | (("%(" + tostr(sub)) + ")")));
endif
old = old[k + 1..oldlen];
oldlen = oldlen - k;
endwhile
return new + old;
-------------------------------------------------------------------------------
#20 string utilities:explode this n/a this
"$string_utils:explode(subject [, break])";
"Return a list of those substrings of subject separated by runs of break[1].";
"break defaults to space.";
{subject, ?breakit = {" "}} = args;
breakit = breakit[1];
subject = subject + breakit;
parts = {};
while (subject)
if ((i = index(subject, breakit)) > 1)
parts = {@parts, subject[1..i - 1]};
endif
subject = subject[i + 1..$];
endwhile
return parts;
-------------------------------------------------------------------------------
#20 string utilities:words this n/a this
"This breaks up the argument string into words, the resulting list being obtained exactly the way the command line parser obtains `args' from `argstr'.";
rest = args[1];
"...trim leading blanks...";
if (0)
rest[1..match(rest, "^ *")[2]] = "";
endif
rest = $string_utils:triml(rest);
if (!rest)
return {};
endif
quote = 0;
toklist = {};
token = "";
pattern = " +%|\\.?%|\"";
while (m = match(rest, pattern))
"... find the next occurence of a special character, either";
"... a block of spaces, a quote or a backslash escape sequence...";
char = rest[m[1]];
token = token + rest[1..m[1] - 1];
if (char == " ")
toklist = {@toklist, token};
token = "";
elseif (char == "\"")
"... beginning or end of quoted string...";
"... within a quoted string spaces aren't special...";
pattern = (quote = !quote) ? "\\.?%|\"" | " +%|\\.?%|\"";
elseif (m[1] < m[2])
"... char has to be a backslash...";
"... include next char literally if there is one";
token = token + rest[m[2]];
endif
rest[1..m[2]] = "";
endwhile
return (rest || (char != " ")) ? {@toklist, token + rest} | toklist;
-------------------------------------------------------------------------------
#20 string utilities:word_start this n/a this
"This breaks up the argument string into words, returning a list of indices into argstr corresponding to the starting points of each of the arguments.";
rest = args[1];
"... find first nonspace...";
wstart = match(rest, "[^ ]%|$")[1];
wbefore = wstart - 1;
rest[1..wbefore] = "";
if (!rest)
return {};
endif
quote = 0;
wslist = {};
pattern = " +%|\\.?%|\"";
while (m = match(rest, pattern))
"... find the next occurence of a special character, either";
"... a block of spaces, a quote or a backslash escape sequence...";
char = rest[m[1]];
if (char == " ")
wslist = {@wslist, {wstart, (wbefore + m[1]) - 1}};
wstart = (wbefore + m[2]) + 1;
elseif (char == "\"")
"... beginning or end of quoted string...";
"... within a quoted string spaces aren't special...";
pattern = (quote = !quote) ? "\\.?%|\"" | " +%|\\.?%|\"";
endif
rest[1..m[2]] = "";
wbefore = wbefore + m[2];
endwhile
return (rest || (char != " ")) ? {@wslist, {wstart, wbefore + length(rest)}} | wslist;
-------------------------------------------------------------------------------
#20 string utilities:to_value this n/a this
":to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).";
"Returns {1,value} or {0,error_message} according as the attempt was successful or not.";
result = this:_tolist(string = args[1] + "}");
if (result[1] && (result[1] != $string_utils:space(result[1])))
return {0, tostr("after char ", length(string) - result[1], ":  ", result[2])};
elseif (typeof(result[1]) == INT)
return {0, "missing } or \""};
elseif (length(result[2]) > 1)
return {0, "comma unexpected."};
elseif (result[2])
return {1, result[2][1]};
else
return {0, "missing expression"};
endif
-------------------------------------------------------------------------------
#20 string utilities:prefix_to_value this n/a this
":prefix_to_value(string) tries to parse string as a value (i.e., object, number, string, error, or list thereof).";
"Returns {rest-of-string,value} or {0,error_message} according as the attempt was successful or not.";
alen = length(args[1]);
slen = length(string = this:triml(args[1]));
if (!string)
return {0, "empty string"};
elseif (w = index("{\"", string[1]))
result = this:({"_tolist", "_unquote"}[w])(string[2..slen]);
if (typeof(result[1]) != INT)
return result;
elseif (result[1] == 0)
return {0, "missing } or \""};
else
return {0, result[2], (alen - result[1]) + 1};
endif
else
thing = string[1..tlen = index(string + " ", " ") - 1];
if (typeof(s = this:_toscalar(thing)) != STR)
return {string[tlen + 1..slen], s};
else
return {0, s, (alen - slen) + 1};
endif
endif
-------------------------------------------------------------------------------
#20 string utilities:_tolist this n/a this
"_tolist(string) --- auxiliary for :to_value()";
rest = this:triml(args[1]);
vlist = {};
if (!rest)
return {0, {}};
elseif (rest[1] == "}")
return {rest[2..$], {}};
endif
while (1)
rlen = length(rest);
if (w = index("{\"", rest[1]))
result = this:({"_tolist", "_unquote"}[w])(rest[2..rlen]);
if (typeof(result[1]) == INT)
return result;
endif
vlist = {@vlist, result[2]};
rest = result[1];
else
thing = rest[1..tlen = min(index(rest + ",", ","), index(rest + "}", "}")) - 1];
if (typeof(s = this:_toscalar(thing)) == STR)
return {rlen, s};
endif
vlist = {@vlist, s};
rest = rest[tlen + 1..rlen];
endif
if (!rest)
return {0, vlist};
elseif (rest[1] == "}")
return {rest[2..$], vlist};
elseif (rest[1] == ",")
rest = this:triml(rest[2..$]);
else
return {length(rest), ", or } expected"};
endif
endwhile
-------------------------------------------------------------------------------
#20 string utilities:_unquote this n/a this
"_unquote(string)   (auxiliary for :to_value())";
"reads string as if it were preceded by a quote, reading up to the closing quote if any, then returns the corresponding unquoted string.";
" => {0, string unquoted}  if there is no closing quote";
" => {original string beyond closing quote, string unquoted}  otherwise";
rest = args[1];
result = "";
while (m = match(rest, "\\.?%|\""))
"Find the next special character";
if (rest[pos = m[1]] == "\"")
return {rest[pos + 1..$], result + rest[1..pos - 1]};
endif
result = (result + rest[1..pos - 1]) + rest[pos + 1..m[2]];
rest = rest[m[2] + 1..$];
endwhile
return {0, result + rest};
-------------------------------------------------------------------------------
#20 string utilities:_toscalar this n/a this
":_toscalar(string)  --- auxiliary for :tovalue";
" => value if string represents a number, object or error";
" => string error message otherwise";
thing = args[1];
if (!thing)
return "missing value";
elseif (match(thing, "^#?[-+]?[0-9]+ *$"))
return (thing[1] == "#") ? toobj(thing) | toint(thing);
elseif (match(thing, "^[-+]?%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)? *$"))
"matches 2. .2 3.2 3.2e3 .2e-3 3.e3";
return `tofloat(thing) ! E_INVARG => tostr("Bad floating point value: ", thing)';
elseif (match(thing, "^[-+]?[0-9]+e[-+]?[0-9]+ *$"))
"matches 345e4. No decimal, but has an e so still a float";
return `tofloat(thing) ! E_INVARG => tostr("Bad floating point value: ", thing)';
elseif (thing[1] == "E")
return (e = $code_utils:toerr(thing)) ? tostr("unknown error code `", thing, "'") | e;
elseif (thing[1] == "#")
return tostr("bogus objectid `", thing, "'");
else
return tostr("`", thing[1], "' unexpected");
endif
-------------------------------------------------------------------------------
#20 string utilities:parse_command this n/a this
":parse_command(cmd_line[,player])";
" => {verb, {dobj, dobjstr}, {prep, prepstr}, {iobj, iobjstr}, {args, argstr},";
"     {dobjset, prepset, iobjset}}";
"This mimics the action of the builtin parser, returning what the values of the builtin variables `verb', `dobj', `dobjstr', `prepstr', `iobj', `iobjstr', `args', and `argstr' would be if `player' had typed `cmd_line'.  ";
"`prep' is the shortened version of the preposition found.";
"";
"`dobjset' and `iobjset' are subsets of {\"any\",\"none\"} and are used to determine possible matching verbs, i.e., the matching verb must either be on `dobj' and have verb_args[1]==\"this\" or else it has verb_args[1] in `dobjset'; likewise for `iobjset' and verb_args[3]; similarly we must have verb_args[2] in `prepset'.";
{c, ?who = player} = args;
y = $string_utils:words(c);
if (y == {})
return {};
endif
vrb = y[1];
y = y[2..$];
as = (y == {}) ? "" | c[length(vrb) + 2..$];
n = 1;
while ((!(gp = $code_utils:get_prep(@y[n..$]))[1]) && (n < length(y)))
n = n + 1;
endwhile
"....";
really = player;
player = who;
loc = who.location;
if (ps = gp[1])
ds = $string_utils:from_list(y[1..n - 1], " ");
is = $string_utils:from_list(listdelete(gp, 1), " ");
io = valid(loc) ? loc:match_object(is) | $string_utils:match_object(is, loc);
else
ds = $string_utils:from_list(y, " ");
is = "";
io = $nothing;
endif
do = valid(loc) ? loc:match_object(ds) | $string_utils:match_object(ds, loc);
player = really;
"....";
dset = {"any", @(ds == "") ? {"none"} | {}};
"\"this\" must be handled manually.";
pset = {"any", @ps ? {$code_utils:full_prep(ps)} | {"none"}};
iset = {"any", @(is == "") ? {"none"} | {}};
return {vrb, {do, ds}, {$code_utils:short_prep(ps), ps}, {io, is}, {y, as}, {dset, pset, iset}};
-------------------------------------------------------------------------------
#20 string utilities:from_value this n/a this
"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])";
"Print the given value into a string.";
{value, ?quote_strings = 0, ?list_depth = 1} = args;
if (typeof(value) == LIST)
if (value)
if (list_depth)
result = "{" + this:from_value(value[1], quote_strings, list_depth - 1);
for v in (listdelete(value, 1))
result = tostr(result, ", ", this:from_value(v, quote_strings, list_depth - 1));
endfor
return result + "}";
else
return "{...}";
endif
else
return "{}";
endif
elseif (quote_strings)
if (typeof(value) == STR)
result = "\"";
while (q = index(value, "\"") || index(value, "\\"))
if (value[q] == "\"")
q = min(q, index(value + "\\", "\\"));
endif
result = ((result + value[1..q - 1]) + "\\") + value[q];
value = value[q + 1..$];
endwhile
return (result + value) + "\"";
elseif (typeof(value) == ERR)
return $code_utils:error_name(value);
else
return tostr(value);
endif
else
return tostr(value);
endif
-------------------------------------------------------------------------------
#20 string utilities:print print_suspended this n/a this
"$string_utils:print(value)";
"Print the given value into a string. == from_value(value,1,-1)";
return toliteral(args[1]);
value = args[1];
if (typeof(value) == LIST)
if (value)
result = "{" + this:print(value[1]);
for val in (listdelete(value, 1))
result = tostr(result, ", ", this:print(val));
endfor
return result + "}";
else
return "{}";
endif
elseif (typeof(value) == STR)
return tostr("\"", strsub(strsub(value, "\\", "\\\\"), "\"", "\\\""), "\"");
elseif (typeof(value) == ERR)
return $code_utils:error_name(value);
else
return tostr(value);
endif
-------------------------------------------------------------------------------
#20 string utilities:reverse this n/a this
":reverse(string) => \"gnirts\"";
"An example: :reverse(\"This is a test.\") => \".tset a si sihT\"";
string = args[1];
if ((len = length(string)) > 50)
return this:reverse(string[($ / 2) + 1..$]) + this:reverse(string[1..$ / 2]);
endif
index = len;
result = "";
while (index > 0)
result = result + string[index];
index = index - 1;
endwhile
return result;
-------------------------------------------------------------------------------
#20 string utilities:char_list this n/a this
":char_list(string) => string as a list of characters.";
"   e.g., :char_list(\"abad\") => {\"a\",\"b\",\"a\",\"d\"}";
if (30 < (len = length(string = args[1])))
return {@this:char_list(string[1..$ / 2]), @this:char_list(string[($ / 2) + 1..$])};
else
l = {};
for c in [1..len]
l = {@l, string[c]};
endfor
return l;
endif
-------------------------------------------------------------------------------
#20 string utilities:regexp_quote this n/a this
":regexp_quote(string)";
" => string with all of the regular expression special characters quoted with %";
string = args[1];
quoted = "";
while (m = rmatch(string, "[][$^.*+?%].*"))
quoted = ("%" + string[m[1]..m[2]]) + quoted;
string = string[1..m[1] - 1];
endwhile
return string + quoted;
-------------------------------------------------------------------------------
#20 string utilities:connection_hostname_bsd this n/a this
"Takes the output from connection_name() and returns just the host string portion of it.  Assumes you are using bsd_network style connection names.";
s = args[1];
return (m = `match(args[1], "^.* %(from%|to%) %([^, ]+%)") ! ANY') ? substitute("%2", m) | "";
-------------------------------------------------------------------------------
#20 string utilities:connection_hostname this n/a this
"This is the function that should actually be called to get the host name from a connection name.  The archwizard should change _bsd so as to be calling the verb appropriate for his/her network interface.";
return this:connection_hostname_bsd(@args);
-------------------------------------------------------------------------------
#20 string utilities:from_value_suspended this n/a this
"$string_utils:from_value(value [, quote_strings = 0 [, list_depth = 1]])";
"Print the given value into a string.";
"This verb suspends as necessary for large values.";
set_task_perms(caller_perms());
{value, ?quote_strings = 0, ?list_depth = 1} = args;
if (typeof(value) == LIST)
if (value)
if (list_depth)
result = "{" + this:from_value(value[1], quote_strings, list_depth - 1);
for v in (listdelete(value, 1))
$command_utils:suspend_if_needed(0);
result = tostr(result, ", ", this:from_value(v, quote_strings, list_depth - 1));
endfor
return result + "}";
else
return "{...}";
endif
else
return "{}";
endif
elseif (quote_strings)
if (typeof(value) == STR)
result = "\"";
while (q = index(value, "\"") || index(value, "\\"))
$command_utils:suspend_if_needed(0);
if (value[q] == "\"")
q = min(q, index(value + "\\", "\\"));
endif
result = ((result + value[1..q - 1]) + "\\") + value[q];
value = value[q + 1..$];
endwhile
return (result + value) + "\"";
elseif (typeof(value) == ERR)
return $code_utils:error_name(value);
else
return tostr(value);
endif
else
return tostr(value);
endif
-------------------------------------------------------------------------------
#20 string utilities:end_expression this n/a this
":end_expression(string[,stop_at])";
"  assumes string starts with an expression; returns the index of the last char in expression or 0 if string appears not to be an expression.  Expression ends at any character from stop_at which occurs at top level.";
{string, ?stop_at = " "} = args;
gone = 0;
paren_stack = "";
inquote = 0;
search = top_level_search = ("[][{}()\"" + strsub(stop_at, "]", "")) + "]";
paren_search = "[][{}()\"]";
while (m = match(string, search))
char = string[m[1]];
string[1..m[2]] = "";
gone = gone + m[2];
if (char == "\"")
"...skip over quoted string...";
char = "\\";
while (char == "\\")
if (!(m = match(string, "%(\\.?%|\"%)")))
return 0;
endif
char = string[m[1]];
string[1..m[2]] = "";
gone = gone + m[2];
endwhile
elseif (index("([{", char))
"... push parenthesis...";
paren_stack[1..0] = char;
search = paren_search;
elseif (i = index(")]}", char))
if (paren_stack && ("([{"[i] == paren_stack[1]))
"... pop parenthesis...";
paren_stack[1..1] = "";
search = paren_stack ? paren_search | top_level_search;
else
"...parenthesis mismatch...";
return 0;
endif
else
"... stop character ...";
return gone - 1;
endif
endwhile
return (!paren_stack) && (gone + length(string));
-------------------------------------------------------------------------------
#20 string utilities:first_word this n/a this
":first_word(string) => {first word, rest of string} or {}";
rest = args[1];
"...trim leading blanks...";
rest[1..match(rest, "^ *")[2]] = "";
if (!rest)
return {};
endif
quote = 0;
token = "";
pattern = " +%|\\.?%|\"";
while (m = match(rest, pattern))
"... find the next occurence of a special character, either";
"... a block of spaces, a quote or a backslash escape sequence...";
char = rest[m[1]];
token = token + rest[1..m[1] - 1];
if (char == " ")
rest[1..m[2]] = "";
return {token, rest};
elseif (char == "\"")
"... beginning or end of quoted string...";
"... within a quoted string spaces aren't special...";
pattern = (quote = !quote) ? "\\.?%|\"" | " +%|\\.?%|\"";
elseif (m[1] < m[2])
"... char has to be a backslash...";
"... include next char literally if there is one";
token = token + rest[m[2]];
endif
rest[1..m[2]] = "";
endwhile
return {token + rest, ""};
-------------------------------------------------------------------------------
#20 string utilities:common this n/a this
":common(first,second) => length of longest common prefix";
{first, second} = args;
r = min(length(first), length(second));
l = 1;
while (r >= l)
h = (r + l) / 2;
if (first[l..h] == second[l..h])
l = h + 1;
else
r = h - 1;
endif
endwhile
return r;
-------------------------------------------------------------------------------
#20 string utilities:title_list*c list_title*c this n/a this
"wr_utils:title_list/title_listc(<obj-list>[, @<args>)";
"Creates an english list out of the titles of the objects in <obj-list>.  Optional <args> are passed on to $string_utils:english_list.";
"title_listc uses :titlec() for the first item.";
titles = $list_utils:map_verb(args[1], "title");
if (verb[length(verb)] == "c")
if (titles)
titles[1] = args[1][1]:titlec();
elseif (length(args) > 1)
args[2] = $string_utils:capitalize(args[2]);
else
args = listappend(args, "Nothing");
endif
endif
return $string_utils:english_list(titles, @args[2..$]);
-------------------------------------------------------------------------------
#20 string utilities:name_and_number nn name_and_number_list nn_list this n/a this
"name_and_number(object [,sepr] [,english_list_args]) => \"ObjectName (#object)\"";
"Return name and number for OBJECT.  Second argument is optional separator (for those who want no space, use \"\").  If OBJECT is a list of objects, this maps the above function over the list and then passes it to $string_utils:english_list.";
"The third through nth arguments to nn_list corresponds to the second through nth arguments to English_list, and are passed along untouched.";
{objs, ?sepr = " ", @eng_args} = args;
if (typeof(objs) != LIST)
objs = {objs};
endif
name_list = {};
for what in (objs)
name = valid(what) ? what.name | {"<invalid>", "$nothing", "$ambiguous_match", "$failed_match"}[1 + (what in {#-1, #-2, #-3})];
name = tostr(name, sepr, "(", what, ")");
name_list = {@name_list, name};
endfor
return this:english_list(name_list, @eng_args);
-------------------------------------------------------------------------------
#20 string utilities:columnize_suspended columnise_suspended this n/a this
"columnize_suspended (interval, items, n [, width]) - Turn a one-column list of items into an n-column list, suspending for `interval' seconds as necessary. 'width' is the last character position that may be occupied; it defaults to a standard screen width. Example: To tell the player a list of numbers in three columns, do 'player:tell_lines ($string_utils:columnize_suspended(0, {1, 2, 3, 4, 5, 6, 7}, 3));'.";
{interval, items, n, ?width = 79} = args;
height = ((length(items) + n) - 1) / n;
items = {@items, @$list_utils:make((height * n) - length(items), "")};
colwidths = {};
for col in [1..n - 1]
colwidths = listappend(colwidths, 1 - (((width + 1) * col) / n));
endfor
result = {};
for row in [1..height]
line = tostr(items[row]);
for col in [1..n - 1]
$command_utils:suspend_if_needed(interval);
line = tostr(this:left(line, colwidths[col]), " ", items[row + (col * height)]);
endfor
result = listappend(result, line[1..min($, width)]);
endfor
return result;
-------------------------------------------------------------------------------
#20 string utilities:a_or_an this n/a this
":a_or_an(<noun>) => \"a\" or \"an\"";
"To accomodate personal variation (e.g., \"an historical book\"), a player can override this by having a personal a_or_an verb.  If that verb returns 0 instead of a string, the standard algorithm is used.";
noun = args[1];
if ($object_utils:has_verb(player, "a_or_an") && ((custom_result = player:a_or_an(noun)) != 0))
return custom_result;
endif
if (noun in this.use_article_a)
return "a";
endif
if (noun in this.use_article_an)
return "an";
endif
a_or_an = "a";
if (noun != "")
if (index("aeiou", noun[1]))
a_or_an = "an";
"unicycle, unimplemented, union, united, unimpressed, unique";
if ((((noun[1] == "u") && (length(noun) > 2)) && (noun[2] == "n")) && ((index("aeiou", noun[3]) == 0) || (((noun[3] == "i") && (length(noun) > 3)) && (index("aeioubcghqwyz", noun[4]) || ((length(noun) > 4) && index("eiy", noun[5]))))))
a_or_an = "a";
endif
endif
endif
return a_or_an;
"Ported by Mickey with minor tweaks from a Moo far far away.";
"Last modified Sun Aug  1 22:53:07 1993 EDT by BabyBriar (#2).";
-------------------------------------------------------------------------------
#20 string utilities:index_all this n/a this
"index_all(string,target) -- returns list of positions of target in string.";
"Usage: $string_utils:index_all(<string,pattern>)";
"       $string_utils:index_all(\"aaabacadae\",\"a\")";
{line, pattern} = args;
if ((typeof(line) != STR) || (typeof(pattern) != STR))
return E_TYPE;
else
where = {};
place = -1;
next = 0;
while ((place = index(line[next + 1..$], pattern)) != 0)
where = {@where, place + next};
next = ((place + next) + length(pattern)) - 1;
endwhile
return where;
endif
-------------------------------------------------------------------------------
#20 string utilities:match_stringlist match_string_list this n/a this
"Copied from Puff (#1449):match_stringlist Tue Oct 19 08:18:13 1993 PDT";
"$string_utils:match_stringlist(string, {list of strings})";
"The list of strings should be just that, a list of strings.  The first string is matched against the list of strings.";
"If it exactly matches exactly one of them, the index of the match is returned. If it exactly matches more than one of them, $ambiguous_match is returned.";
"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of one of the strings.";
"Again, if exactly one match is found, the index of that string is returned, and if more than one match is found, $ambiguous match is returned.";
"Finally, if there are no exact or partial matches, then $failed_match is returned.";
{subject, stringlist} = args;
if ((subject == "") || (length(stringlist) < 1))
return $nothing;
endif
matches = {};
"First check for exact matches.";
for i in [1..length(stringlist)]
if (subject == stringlist[i])
matches = {@matches, i};
endif
endfor
"Now return a match, or $ambiguous, or check for partial matches.";
if (length(matches) == 1)
return matches[1];
elseif (length(matches) > 1)
return $ambiguous_match;
elseif (length(matches) == 0)
"Checking for partial matches is almost identical to checking for exact matches, but we use index(list[i], target) instead of list[i] == target to see if they match.";
for i in [1..length(stringlist)]
if (index(stringlist[i], subject) == 1)
matches = {@matches, i};
endif
endfor
if (length(matches) == 1)
return matches[1];
elseif (length(matches) > 1)
return $ambiguous_match;
elseif (length(matches) == 0)
return $failed_match;
endif
endif
-------------------------------------------------------------------------------
#20 string utilities:from_ASCII this n/a this
"This converts a ASCII character code in the range [32..126] into the ASCII character with that code, represented as a one-character string.";
"";
"Example:   $string_utils:from_ASCII(65) => \"A\"";
code = args[1];
return this.ascii[code - 31];
-------------------------------------------------------------------------------
#20 string utilities:to_ASCII this n/a this
"Convert a one-character string into the ASCII character code for that character.";
"";
"Example:  $string_utils:to_ASCII(\"A\") => 65";
return (index(this.ascii, args[1], 1) || raise(E_INVARG)) + 31;
-------------------------------------------------------------------------------
#20 string utilities:abbreviated_value this n/a this
"Copied from Mickey (#52413):abbreviated_value Fri Sep  9 08:52:41 1994 PDT";
":abbreviated_value(value,max_reslen,max_lstlev,max_lstlen,max_strlen,max_toklen)";
"";
"Gets the printed representation of value, subject to these parameters:";
" max_reslen = Maximum desired result string length.";
" max_lstlev = Maximum list level to show.";
" max_lstlen = Maximum list length to show.";
" max_strlen = Maximum string length to show.";
" max_toklen = Maximum token length (e.g., numbers and errors) to show.";
"";
"A best attempt is made to get the exact target size, but in some cases the result is not exact.";
{value, ?max_reslen = $maxint, ?max_lstlev = $maxint, ?max_lstlen = $maxint, ?max_strlen = $maxint, ?max_toklen = $maxint} = args;
return this:_abbreviated_value(value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen);
"Originally written by Mickey.";
-------------------------------------------------------------------------------
#20 string utilities:_abbreviated_value this n/a this
"Copied from Mickey (#52413):_abbreviated_value Fri Sep  9 08:52:44 1994 PDT";
"Internal to :abbreviated_value.  Do not call this directly.";
{value, max_reslen, max_lstlev, max_lstlen, max_strlen, max_toklen} = args;
if ((type = typeof(value)) == LIST)
if (!value)
return "{}";
elseif (max_lstlev == 0)
return "{...}";
else
n = length(value);
result = "{";
r = max_reslen - 2;
i = 1;
eltstr = "";
while (((i <= n) && (i <= max_lstlen)) && (r > (x = (i == 1) ? 0 | 2)))
eltlen = length(eltstr = this:(verb)(value[i], r, max_lstlev - 1, max_lstlen, max_strlen, max_toklen));
lastpos = 1;
if (r >= (eltlen + x))
comma = (i == 1) ? "" | ", ";
result = tostr(result, comma);
if (r > 4)
lastpos = length(result);
endif
result = tostr(result, eltstr);
r = (r - eltlen) - x;
elseif (i == 1)
return "{...}";
elseif (r > 4)
return tostr(result, ", ...}");
else
return tostr(result[1..lastpos], "...}");
endif
i = i + 1;
endwhile
if (i <= n)
if (i == 1)
return "{...}";
elseif (r > 4)
return tostr(result, ", ...}");
else
return tostr(result[1..lastpos], "...}");
endif
else
return tostr(result, "}");
endif
endif
elseif (type == STR)
result = "\"";
while ((q = index(value, "\"")) ? q = min(q, index(value, "\\")) | (q = index(value, "\\")))
result = ((result + value[1..q - 1]) + "\\") + value[q];
value = value[q + 1..$];
endwhile
result = result + value;
if ((length(result) + 1) > (z = max(min(max_reslen, max(max_strlen, max_strlen + 2)), 6)))
z = z - 5;
k = 0;
while ((k < z) && (result[z - k] == "\\"))
k = k + 1;
endwhile
return tostr(result[1..z - (k % 2)], "\"+...");
else
return tostr(result, "\"");
endif
else
v = (type == ERR) ? $code_utils:error_name(value) | tostr(value);
len = max(4, min(max_reslen, max_toklen));
return (length(v) > len) ? v[1..len - 3] + "..." | v;
endif
"Originally written by Mickey.";
-------------------------------------------------------------------------------
#20 string utilities:match_suspended this n/a this
"$string_utils:match_suspended(string [, obj-list, prop-name]*)";
"Each obj-list should be a list of objects or a single object, which is treated as if it were a list of that object.  Each prop-name should be string naming a property on every object in the corresponding obj-list.  The value of that property in each case should be either a string or a list of strings.";
"The argument string is matched against all of the strings in the property values.";
"If it exactly matches exactly one of them, the object containing that property is returned.  If it exactly matches more than one of them, $ambiguous_match is returned.";
"If there are no exact matches, then partial matches are considered, ones in which the given string is a prefix of some property string.  Again, if exactly one match is found, the object with that property is returned, and if there is more than one match, $ambiguous_match is returned.";
"Finally, if there are no exact or partial matches, then $failed_match is returned.";
"This verb will suspend as needed, and should be used if obj-list is very large.";
subject = args[1];
if (subject == "")
return $nothing;
endif
no_exact_match = no_partial_match = 1;
for i in [1..length(args) / 2]
prop_name = args[(2 * i) + 1];
for object in ((typeof(olist = args[2 * i]) == LIST) ? olist | {olist})
if (valid(object))
if (typeof(str_list = `object.(prop_name) ! E_PERM, E_PROPNF => {}') != LIST)
str_list = {str_list};
endif
if (subject in str_list)
if (no_exact_match)
no_exact_match = object;
elseif (no_exact_match != object)
return $ambiguous_match;
endif
else
for string in (str_list)
if (index(string, subject) != 1)
elseif (no_partial_match)
no_partial_match = object;
elseif (no_partial_match != object)
no_partial_match = $ambiguous_match;
endif
endfor
endif
endif
$command_utils:suspend_if_needed(5);
endfor
endfor
return no_exact_match && (no_partial_match && $failed_match);
-------------------------------------------------------------------------------
#20 string utilities:incr_alpha this n/a this
"args[1] is a string.  'increments' the string by one. E.g., aaa => aab, aaz => aba.  empty string => a, zzz => aaaa.";
"args[2] is optional alphabet to use instead of $string_utils.alphabet.";
{s, ?alphabet = this.alphabet} = args;
index = length(s);
if (!s)
return alphabet[1];
elseif (s[$] == alphabet[$])
return this:incr_alpha(s[1..index - 1], alphabet) + alphabet[1];
else
t = index(alphabet, s[index]);
return s[1..index - 1] + alphabet[t + 1];
endif
-------------------------------------------------------------------------------
#20 string utilities:is_float this n/a this
"Usage:  is_float(string)";
"Is string composed of one or more digits possibly preceded by a minus sign either followed by a decimal or by an exponent?";
"Return true or false";
return match(args[1], "^ *[-+]?%(%([0-9]+%.[0-9]*%|[0-9]*%.[0-9]+%)%(e[-+]?[0-9]+%)?%)%|%([0-9]+e[-+]?[0-9]+%) *$");
-------------------------------------------------------------------------------
#20 string utilities:inside_quotes this n/a this
"Copied from Moo_tilities (#332):inside_quotes by Mooshie (#106469) Tue Dec 23 10:26:49 1997 PST";
"Usage: inside_quotes(STR)";
"Is the  end of the given string `inside' a doublequote?";
"Called from $code_utils:substitute.";
{string} = args;
quoted = 0;
while (i = index(string, "\""))
if ((!quoted) || (string[i - 1] != "\\"))
quoted = !quoted;
endif
string = string[i + 1..$];
endwhile
return quoted;
-------------------------------------------------------------------------------
#20 string utilities:strip_all_but_seq this n/a this
":strip_all_but_seq(string, keep) => chars in string not in exact sequence of keep removed.";
":strip_all_but() works similarly, only it does not concern itself with the sequence, just the specified chars.";
string = args[1];
wanted = args[2];
output = "";
while (m = match(string, wanted))
output = output + string[m[1]..m[2]];
string = string[m[2] + 1..length(string)];
endwhile
return output;
-------------------------------------------------------------------------------
================================#21 building utilities===============================================
#21 building utilities.classes rc = MOOList [ #6, #3, #7, #9, #8, #5, #74, #45, #30, #37, #78, #68 ]
#21 building utilities.class_string rc = MOOList [ "p", "R", "E", "N", "C", "T", "F", "M", "H", "D", "U", "O" ]
#21 building utilities:make_exit this n/a this
"make_exit(spec, source, dest[, use-$recycler-pool [, kind]])";
"";
"Uses $recycler by default; supplying fourth arg as 0 suppresses this.";
"Optional 5th arg gives a parent for the object to be created";
"(i.e., distinct from $exit)";
"Returns the object number as a list if successful, 0 if not.";
set_task_perms(caller_perms());
{spec, source, dest, ?use_recycler, ?exit_kind = $exit} = args;
exit = player:_create(exit_kind);
if (typeof(exit) == ERR)
player:notify(tostr("Cannot create new exit as a child of ", $string_utils:nn(exit_kind), ": ", exit, ".  See `help @build-options' for information on how to specify the kind of exit this command tries to create."));
return;
endif
for f in ($string_utils:char_list(player:build_option("create_flags") || ""))
exit.(f) = 1;
endfor
$building_utils:set_names(exit, spec);
exit.source = source;
exit.dest = dest;
source_ok = source:add_exit(exit);
dest_ok = dest:add_entrance(exit);
move(exit, $nothing);
via = $string_utils:from_value(setadd(exit.aliases, exit.name), 1);
if (source_ok)
player:tell("Exit from ", source.name, " (", source, ") to ", dest.name, " (", dest, ") via ", via, " created with id ", exit, ".");
if (!dest_ok)
player:tell("However, I couldn't add ", exit, " as a legal entrance to ", dest.name, ".  You may have to get its owner, ", dest.owner.name, " to add it for you.");
endif
return {exit};
elseif (dest_ok)
player:tell("Exit to ", dest.name, " (", dest, ") via ", via, " created with id ", exit, ".  However, I couldn't add ", exit, " as a legal exit from ", source.name, ".  Get its owner, ", source.owner.name, " to add it for you.");
return {exit};
else
player:_recycle(exit);
player:tell("I couldn't add a new exit as EITHER a legal exit from ", source.name, " OR as a legal entrance to ", dest.name, ".  Get their owners, ", source.owner.name, " and ", dest.owner.name, ", respectively, to add it for you.");
return 0;
endif
-------------------------------------------------------------------------------
#21 building utilities:set_names this n/a this
"$building_utils:set_names(object, spec)";
set_task_perms(caller_perms());
object = args[1];
names = this:parse_names(args[2]);
name = names[1] || object.name;
return object:set_name(name) && object:set_aliases(names[2]);
-------------------------------------------------------------------------------
#21 building utilities:recreate this n/a this
":recreate(object,newparent) -- effectively recycle and recreate the specified object as a child of parent.  Returns true if successful.";
{object, parent} = args;
who = caller_perms();
if (!(valid(object) && valid(parent)))
return E_INVARG;
elseif (who.wizard)
"no problemo";
elseif ((who != object.owner) || ((who != parent.owner) && (!parent.f)))
return E_PERM;
endif
"Chparent any children to their grandparent instead of orphaning them horribly.  Have to do the chparent with wizperms, in case the children are owned by others, so do this before set_task_perms.";
"Because this is done before set_task_perms() -- thus with wizard perms -- we save ticks and use chparent() instead of #0:chparent().  This will save many more ticks, if this is an object with many children.";
grandpa = parent(object);
for c in (children(object))
chparent(c, grandpa);
endfor
for item in (object.contents)
if (!is_player(item))
move(item, #-1);
else
move(item, $player_start);
endif
endfor
set_task_perms(who);
if ($object_utils:has_callable_verb(object, "recycle"))
object:recycle();
endif
chparent(object, #-1);
for p in (properties(object))
delete_property(object, p);
endfor
for v in (verbs(object))
delete_verb(object, 1);
endfor
chparent(object, parent);
object.name = "";
object.r = 0;
object.f = 0;
object.w = 0;
if ($object_utils:has_callable_verb(parent, "initialize"))
object:initialize();
endif
return 1;
-------------------------------------------------------------------------------
#21 building utilities:parse_names this n/a this
"$building_utils:parse_names(spec)";
"Return {name, {alias, alias, ...}} from name,alias,alias or name:alias,alias";
spec = args[1];
if (!(colon = index(spec, ":")))
aliases = $string_utils:explode(spec, ",");
if (!aliases)
aliases = {spec};
endif
name = aliases[1];
else
aliases = $string_utils:explode(spec[colon + 1..$], ",");
name = spec[1..colon - 1];
endif
return {name, $list_utils:map_arg($string_utils, "trim", aliases)};
-------------------------------------------------------------------------------
#21 building utilities:audit_object_category this n/a this
if (is_player(what = args[1]))
return "P";
endif
while (valid(what))
if (i = what in this.classes)
return this.class_string[i];
endif
what = parent(what);
endwhile
return " ";
-------------------------------------------------------------------------------
#21 building utilities:object_audit_string this n/a this
":object_audit_string(object [,prospectus-style])";
{o, ?prospectus = 0} = args;
olen = length(tostr(max_object()));
if (!$recycler:valid(o))
return tostr(prospectus ? "          " | "", $quota_utils.byte_based ? "    " | "", $string_utils:right(o, olen), " Invalid Object!");
endif
if (prospectus)
kids = 0;
for k in (children(o))
$command_utils:suspend_if_needed(0);
if (k.owner != o.owner)
kids = 2;
break k;
elseif (kids == 0)
kids = 1;
endif
endfor
"The verbs() call below might fail, but that's OK";
"Well, actually it won't cuz we seem to be a wizard.  Since you can get the number of verbs information from @verbs anyway, it seems kind of pointless to hide it here.";
v = verbs(o);
if (v)
vstr = tostr("[", $string_utils:right(length(v), 3), "] ");
else
vstr = "      ";
endif
if (o.r && o.f)
r = "f";
elseif (o.r)
r = "r";
elseif (o.f)
r = "F";
else
r = " ";
endif
vstr = tostr(" kK"[kids + 1], r, $building_utils:audit_object_category(o), vstr);
else
vstr = "";
endif
if ($quota_utils.byte_based)
vstr = tostr(this:size_string(`o.object_size[1] ! ANY => 0'), " ", vstr);
name_field_len = 26;
else
name_field_len = 30;
endif
if (valid(o.location))
loc = ((((o.location.owner == o.owner) ? " " | "*") + "[") + o.location.name) + "]";
elseif ($object_utils:has_property(o, "dest") && $object_utils:has_property(o, "source"))
if (typeof(o.source) != OBJ)
source = " <non-object> ";
elseif (!valid(o.source))
source = "<invalid>";
else
source = o.source.name;
if (o.source.owner != o.owner)
source = "*" + source;
endif
endif
if (typeof(o.dest) != OBJ)
destin = " <non-object> ";
elseif (!valid(o.dest))
destin = "<invalid>";
else
destin = o.dest.name;
if (o.dest.owner != o.owner)
destin = "*" + destin;
endif
endif
srclen = min(length(source), 19);
destlen = min(length(destin), 19);
loc = ((" " + source[1..srclen]) + "->") + destin[1..destlen];
elseif ($object_utils:isa(o, $room))
loc = "";
try
for x in (o.entrances)
if (((((typeof(x) == OBJ) && valid(x)) && (x.owner != o.owner)) && $object_utils:has_property(x, "dest")) && (x.dest == o))
loc = ((loc + (loc ? ", " | "")) + "<-*") + x.name;
endif
endfor
except (ANY)
if ($perm_utils:controls(player, o))
loc = " BROKEN PROPERTY: .entrances";
endif
endtry
else
loc = " [Nowhere]";
endif
if (length(loc) > 41)
loc = loc[1..37] + "..]";
endif
namelen = min(length(o.name), name_field_len - 1);
return tostr(vstr, $string_utils:right(o, olen), " ", $string_utils:left(o.name[1..namelen], name_field_len), loc);
-------------------------------------------------------------------------------
#21 building utilities:do_audit do_prospectus this n/a this
":do_audit(who, start, end, match)";
"audit who, with objects from start to end that match 'match'";
":do_prospectus(...)";
"same, but with verb counts";
{who, start, end, match} = args;
pros = verb == "do_prospectus";
"the set_task_perms is to make the task owned by the player. There are no other security aspects";
set_task_perms(caller_perms());
if ((((((start == 0) && (end == toint(max_object()))) && (!match)) && (typeof(who.owned_objects) == LIST)) && (length(who.owned_objects) > 100)) && (!$command_utils:yes_or_no(tostr(who.name, " has ", length(who.owned_objects), " objects.  This will be a very long list.  Do you wish to proceed?"))))
v = pros ? "@prospectus" | "@audit";
return player:tell(v, " aborted.  Usage:  ", v, " [player] [from <start>] [to <end>] [for <match>]");
endif
player:tell(tostr("Objects owned by ", who.name, " (from #", start, " to #", end, match ? " matching " + match | "", ")", ":"));
count = bytes = 0;
if (typeof(who.owned_objects) == LIST)
for o in (who.owned_objects)
$command_utils:suspend_if_needed(0);
if (!player:is_listening())
return;
endif
if ((toint(o) >= start) && (toint(o) <= end))
didit = this:do_audit_item(o, match, pros);
count = count + didit;
if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, "object_size"))
bytes = bytes + o.object_size[1];
endif
endif
endfor
else
for i in [start..end]
$command_utils:suspend_if_needed(0);
o = toobj(i);
if ($recycler:valid(o) && (o.owner == who))
didit = this:do_audit_item(o, match, pros);
count = count + didit;
if ((didit && $quota_utils.byte_based) && $object_utils:has_property(o, "object_size"))
bytes = bytes + o.object_size[1];
endif
endif
endfor
endif
player:tell($string_utils:left(tostr("-- ", count, " object", (count == 1) ? "." | "s.", $quota_utils.byte_based ? tostr("  Total bytes: ", $string_utils:group_number(bytes), ".") | ""), player:linelen() - 1, "-"));
-------------------------------------------------------------------------------
#21 building utilities:do_audit_item this n/a this
":do_audit_item(object, match-name-string, prospectus-flag)";
{o, match, pros} = args;
found = match ? 0 | 1;
names = `{o.name, @o.aliases} ! ANY => {o.name}';
"Above to get rid of screwed up aliases";
while (names && (!found))
if (index(names[1], match) == 1)
found = 1;
endif
names = listdelete(names, 1);
endwhile
if (found)
"From Dred---don't wrap long lines.";
line = $building_utils:object_audit_string(o, pros);
player:tell(line[1..min($, player:linelen())]);
return 1;
endif
return 0;
-------------------------------------------------------------------------------
#21 building utilities:size_string this n/a this
"Copied from Roebare (#109000):size_string at Sat Nov 26 18:41:12 2005 PST";
size = args[1];
if (typeof(size) != INT)
return E_INVARG;
endif
if (`!player:build_option("audit_float") ! ANY')
"...use integers to determine a four-char string...";
factor = 1000;
threshold = {{1000, "B"}, {1000000, "K"}, {1000000000, "M"}};
if (!size)
return " ???";
elseif ((size < 0) || (size > threshold[$][1]))
if ((size < 0) || (size > $maxint))
return " >2G";
else
"...floats still required to factor over $maxint...";
return tostr($string_utils:right(floatstr(tofloat(size) / 1000000000.0, 0), 3), "G");
endif
elseif ((size < threshold[1][1]) && `!player:build_option("audit_bytes") ! ANY')
return " <1K";
endif
for entry in ($list_utils:slice(threshold, 1))
$command_utils:suspend_if_needed(0);
i = $list_utils:iassoc(entry, threshold);
if (size == entry)
size = "1";
try
unit = threshold[i + 1][2];
except error (E_RANGE)
unit = "G";
endtry
break;
elseif (size < entry)
size = tostr(size / (entry / factor));
unit = threshold[i][2];
break;
endif
endfor
return tostr($string_utils:right(size, 3), unit);
else
"...use floats to determine a six-char string...";
size = tofloat(size);
factor = 1024.0;
"...be precise, `((1024.00 * 1024.00) * 1024.00) * 1024.00'...";
threshold = {{1048576.0, "K"}, {1073741824.0, "M"}, {1099511627776.0, "G"}};
if (!size)
return "   ???";
elseif ((size < 0.0) || (size > threshold[$][1]))
"...special handling for bad conversions & big numbers...";
if ((size < 0.0) || (size > tofloat($maxint)))
return "   >2G";
else
return tostr($string_utils:right(floatstr(size / 1000000000.0, 1), 3), "G");
endif
endif
for entry in ($list_utils:slice(threshold, 1))
$command_utils:suspend_if_needed(0);
i = $list_utils:iassoc(entry, threshold);
if (size == entry)
size = "1";
try
unit = threshold[i + 1][2];
except error (E_RANGE)
"...in another decade, maybe...";
unit = "T";
endtry
break;
elseif (size < entry)
size = floatstr(size / (entry / factor), 1);
unit = threshold[i][2];
break;
endif
endfor
return tostr($string_utils:right(size, 5), unit);
endif
"Rewritten by Roebare (#109000), 051119-26";
"With inspiration from Miral (#107983) and assistance from Diopter (#98842)";
"Byte & float display optional, per Nosredna (#2487), 051120-24";
-------------------------------------------------------------------------------
#21 building utilities:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.classes = {$player, $room, $exit, $note, $container, $thing, $feature, $mail_recipient, $generic_help, $generic_db, $generic_utils, $generic_options};
endif
-------------------------------------------------------------------------------
================================#22 Programmer Help===============================================
#22 Programmer Help.@copy rc = MOOList [ "Syntax:  @copy <object>:<verb> to [<newobject>][:<newverb>]", "         @copy-move <object>:<verb> to [<newobject>][:<newverb>]", "", "Copies the code of the named verb to the new object and verbname.  Permissions, and arguments of the new verb are set to match those of the old verb in the event that the new verb does not already exist.  One of <newobject> or :<newverb> must be supplied.  If no new verbname is given, the old name is retained.  Likewise, <newobject> defaults to <object> if not given.", "", "@copy-move will delete the old verb after it has copied.  Useful for restructuring code/object hierarchies.", "", "Examples:", "  @copy me:verbname to myobject", "  @copy me:test_verb to myobject:real_verb", "", "In general, @copy'ing verbs is a bad idea.  In the vast majority of cases, the desired effect can be accomplished with parenting (i.e., having <object> be an ancestor of <newobject>), which has the advantage that if a verb is updated or fixed, this immediately becomes available to child objects that inherit this verb.  In such a case, copies that were made using @copy have to be tracked down and fixed by hand.", "", "This facility is provided for those rare occasions where one has no choice but to actually copy the verb." ]
#22 Programmer Help.@rmproperty rc = MOOList [ "Syntax:  @rmproperty <object>.<prop-name>", "", "Removes the named property from the named object.  '@rmproperty' may be abbreviated as '@rmprop'." ]
#22 Programmer Help.@rename# rc = MOOList [ "*pass*", "@rename" ]
#22 Programmer Help.functions r = MOOList [ "There are many, many built-in functions available to MOO programmers.  The following list gives a brief summary of the arguments and purpose of each function; for more information, see the LambdaMOO Programmer's Manual.  ", "", "pass(arg, ...)   -- calling a verb defined on this object's parent", "", "time()           -- current time in seconds since midnight GMT, 1 Jan 70", "ctime([time])    -- time (or current time) converted to a human-readable string", "", "eval(string)     -- parsing and executing strings as MOO code", "", "typeof(value)      -- determining the data type of a value", " tostr(value, ...) -- converting any set of values into a string", " toint(value)      -- converting any non-list value into an integer", " tonum(value)      -- converting any non-list value into an integer (obsolete)", " tofloat(value)    -- converting any non-list value into a floating-point", " toobj(value)      -- converting any non-list value into an object", " toliteral(value)  -- converting any value into a literal string", "length(value)      -- returns the length of a string or list", "", "equal(val1, val2)          -- is val1 indistinguishable from val2", "min(n1, n2, ...)           -- minimum of n1,n2,...", "max(n1, n2, ...)           -- maximum of n1,n2,...", "abs(n)                     -- absolute value of n", "sin(n), cos(n), tan(n)     -- sine, cosine, tangent of n", "asin(n), acos(n), atan(n)  -- arc-sine, arc-cosine, arc-tangent of n", "sinh(n), cosh(n), tanh(n)  -- hyperbolic sine, cosine, tangent of n", "exp(n)                     -- `e' raised to the power of n", "log(n), log10(n)           -- natural or base 10 logarithm of n (n > 0)", "sqrt(n)                    -- square root of n, rounded down", "random(n)                  -- random integer between 1 and n inclusive", "floatstr(float, precision, sci) -- format a floating-point into string", "ceil(f)          -- smallest integer > float f as a floating-point", "floor(f)         -- largest integer < float f as floating-point", "trunc(f)         -- truncate f at the decimal point, as floating-point", "", "index(str1, str2 [, case-matters])  -- index of first str2 in str1", "rindex(str1, str2 [, case-matters]) -- index of last  str2 in str1", "strcmp(str1, str2) -- case-sensitive string comparison", "strsub(subject, what, with [, case-matters]) -- substitution in a string", "match(str1, str2 [, case-matters])  -- match first regular expr str2 in str1", "rmatch(str1, str2 [, case-matters]) -- match last regular expr str2 in str1", "substitute(template, subs)          -- perform substitutions on template", "", "decode_binary(bin-string [, fully]) -- convert from a binary string", "encode_binary(arg, ...)             -- convert to a binary string", "      crypt(string [, salt])        -- one-way string encryption", "string_hash(text)                 -- MD5 cryptographically secure hash of text", "binary_hash(bin-string)           -- same but for a binary string", " value_hash(value)                -- string_hash(toliteral(value))", "", " is_member(value, list)           -- is exact value (case sensitive) in list", "listappend(list, value [, index]) -- adding an element at the end of a list", "listinsert(list, value [, index]) -- adding an element at the head of a list", "   listset(list, value, index)    -- updating a list at some index", "listdelete(list, index)           -- removing an element from a list", "    setadd(list, element) -- adding an element to a set represented as a list", " setremove(list, element) -- removing an element from such a set", "", "   valid(object)             -- testing whether an object exists", "  create(parent [, owner(*)])-- creating a new MOO object", " recycle(object)             -- destroying a MOO object", "    move(object, where)      -- altering the object-containment hierarchy", "chparent(object, new-parent) -- altering the object-inheritance hierarchy", "  parent(object)             -- object's parent   in the inheritance hierarchy", "children(object)             -- object's children in the inheritance hierarchy", "max_object()       -- the highest-numbered object in the MOO", "renumber(obj)      -- changes an object's number to lowest available one (*)", "reset_max_object() -- resets max_object() to the largest valid object (*)", "", "     properties(object) -- a list of the properties defined on an object", "   add_property(object, prop-name, value, info) -- add a new property", "delete_property(object, prop-name)              -- remove a property", "    property_info(object, prop-name)       -- {owner, perms} info on a property", "set_property_info(object, prop-name, info) -- setting same", "is_clear_property(object, prop-name) -- find out if a property is "clear"", "   clear_property(object, prop-name) -- make a property "clear"", "", "      verbs(object) -- a list of the verbs defined on an object", "   add_verb(object, info, args)  -- add a verb to an object", "delete_verb(object, verb-name)   -- remove a verb from an object", "    verb_info(object, verb-name) -- {owner, perms, names} info for a verb defn.", "    verb_args(object, verb-name) -- {dobj, prep, iobj} argument info for a verb", "    verb_code(object, verb-name [, fully-paren [, indent]]) -- program listing", "set_verb_info(object, verb-name, {owner, perms, names})", "set_verb_args(object, verb-name, {dobj, prep, iobj})   ", "set_verb_code(object, verb-name, {line, line, ...})", "disassemble(object, verb-desc)   -- listing of server's internal `compile' ", "", "        is_player(object) -- testing whether or not object is a player", "          players()       -- a list of all players, active or not", "connected_players()       -- a list of all currently-connected players", "     idle_seconds(player) -- seconds since given player typed anything", "connected_seconds(player) -- seconds given player has been logged in", "    boot_player(player)        -- disconnect player from the MOO immediately(*)", "set_player_flag(player, value) -- set/clear player bit; boot player if clear(*)", "connection_name(player)   -- a server-assigned name for player's connection", "", "open_network_connection(@args) -- open a connection to another network site (*)", "notify(player, string)    -- sending text to a player's terminal", "read()                    -- reading a line of input from the player (*)", "buffered_output_length([player])      -- how much output pending", "force_input(player, str [, at-front]) -- put str in player's output queue", "flush_input(player [, show-messages]) -- clear a player's output queue", "output_delimiters(player) -- return {prefix,suffix} set by PREFIX/SUFFIX cmds", "set_connection_option(player, option, value) -- set I/O options for player", "   connection_options(player) -- list current I/O options for player", "    connection_option(player, option) -- return setting of option for player", "", "   listen(conn, point [, print-messages]) -- create server listening point (*)", "u nlisten(canon) -- close the server listening point described by canon (*)", "listeners() -- list of all listening points", "", "        raise(code [, message [, value]]) -- raise code just like an error", "call_function(func-name, arg, ...)        -- call func-name", "function_info([name])   -- descriptions of available built-in functions", "", "caller_perms()         -- the player whose permissions your caller was using", "set_task_perms(player) -- changing permissions of the running task (*)", "callers()      -- list of {obj, verb, owner, vloc, player}: this task's stack", "suspend([secs])  -- suspending the current task for a number of seconds", "resume(task [, value]) -- resume the given task with value returned", "seconds_left() -- number of seconds left in the current task", "ticks_left()   -- number of ticks   left in the current task", "task_id()      -- a random number representing the currently-running task", "queue_info([player]) -- who has tasks, or how many player has", "queued_tasks() -- list of {id,start,0,20000,owner,obj,verb,line,this}", "kill_task(id)  -- delete one of your tasks from the queue", "task_stack(task-id [, include-line-numbers]) -- info about suspended task", "", "server_log(string) -- add a comment to the server log file", "server_version() -- a string of three numbers "major.minor.release"", "memory_usage()   -- {{blocksize, nused, nfree}, ...}, the server's memory stats", "shutdown(msg)    -- print msg and kill the server (*)", "dump_database()  -- what it says (*)", "db_disk_size()   -- size in bytes of recent full database", "", " value_bytes(value)  -- memory required to store value", "object_bytes(object) -- memory required to store object", "", "(*) => as you might have expected, these usually require wizard permissions." ]
#22 Programmer Help.mail rc = MOOList [ "*pass*", "mail", " - - - - -", "See `help mail-system' for a description of the programming interface to the mail system.", "In particular, see `help $mail_recipient' for information on creating new mail collections." ]
#22 Programmer Help.@show rc = MOOList [ "Syntax:  @show <object>", "         @show <object>.<prop-name>", "         @show <object>:<verb-name>", "", "Displays quite detailed information about an object, property or verb, including its name, owner, permission bits, etc.  The information displayed for an object can be quite long.", "", "See also @display, which displays different information and is controlled differently." ]
#22 Programmer Help.@clearproperty rc = MOOList [ "Syntax:   @clearproperty <object>.<prop-name>", "", "This clears <object>'s <prop-name> property.  That is the property value becomes `clear' and all further references to this property will use the value of the same property on the parent object.  Note that you can only clear inherited properties.  Nor is this the same as removing a property; the property continues to exist.", "", "`@clearproperty' can be abbreviated as `@clearp'.", "", "Example:", "", "  @create #1 named foo", "  You now have foo with object number #42 and parent Root Class (#1).", "    [foo, as a child of #1 has a .description property which starts out clear]", "  ;#1.description", "  => """, "  ;#1.description = "You see nothing special"", "  => "You see nothing special"", "  ;#42.description  ", "  => "You see nothing special"", "  ;#42.description = "Something special"", "  => "Something special"", "   [foo.description is now no longer clear; it has a value of its own]", "  ;#1.description = "Boring"", "  => "Boring"", "  ;#42.description  ", "  => "Something special"", "   ", "  @clearp foo.description", "  Property #42.description cleared; value is now "Boring".", "   [foo.description is now clear again]", "  ;#1.description = """, "  => """, "  ;#42.description", "  => """ ]
#22 Programmer Help.@properties r = MOOList [ "*verbdoc*", "$prog", "@properties" ]
#22 Programmer Help.language r = MOOList [ "The MOO programming language is described in excruciating detail in the LambdaMOO Programmer's Manual, available for download at http://lambda.moo.mud.org/pub/MOO/html/ProgrammersManual_toc.html.  The online help consists of a few quick reference guides here in the help system under the following topics:", "", "statements -- the syntax and semantics of the various kinds of MOO statements", "expressions -- the same for the various kinds of MOO expressions", "functions -- a list of the primitive functions available to MOO programs" ]
#22 Programmer Help.utilities rc = MOOList [ "The core database has a number of objects serving as libraries of useful verbs.", "More detailed information can be obtained for (some of) these, via `help $whatever_utils'", "", "$building_utils -- ", "$code_utils     -- parsing and manipulating verb code", "$command_utils  -- reporting matching errors to the player", "$gender_utils   -- managing gendered objects", "$list_utils     -- list manipulation", "$set_utils      -- set manipulation", "$lock_utils     -- key expression manipulation", "$match_utils    -- ", "$object_utils   -- object information ", "                  (inheritance/location hierarchy, verb/property lists)", "$perm_utils     -- permissions", "$string_utils   -- string manipulation", "$time_utils     -- time (numeric and verbal) manipulation", "$trig_utils     -- trigonometric and other numerical utilities" ]
#22 Programmer Help.@egrep rc = MOOList [ "*forward*", "@grep" ]
#22 Programmer Help.precedence r = MOOList [ "The table below gives the relative precedence of all of the MOO operators; operators on higher lines in the table have higher precedence and those on the same line have identical precedence:", "", "        !       - (without a left operand)", "        ^", "        *       /       %", "        +       -", "        ==      !=      <       <=      >       >=      in", "        &&      ||", "        ... ? ... | ... (the conditional expression)", "        =", "", "Thus, the horrendous expression", "", "        x = a < b && c > d + e * f ? w in y | - q - r", "", "would be grouped as follows:", "", "        x = (((a < b) && (c > (d + (e * f)))) ? (w in y) | ((- q) - r))" ]
#22 Programmer Help.features rc = MOOList [ "*pass*", "features", "", "Note to programmers: In order to be available for general use as a feature, an object must have a verb or property named "feature_ok" which returns a true value.", "", "When a feature is added to a player's features list, feature:feature_add is called, if it exists, with the player in question as its argument.  Likewise, when a feature is removed, feature:feature_remove is called." ]
#22 Programmer Help..program r = MOOList [ "Syntax:  .program <object>:<verb-name>", "              :", "              :", "              <lines of MOO code>", "              :", "              :", "         .", "", "Provides or changes the MOO program associated with the named verb on the named object.", "", "This command is mostly obsolete.  Use @program instead.  The only reason this command still exists is that it is a server builtin command that will continue to work in the (unlikely) event that @program gets trashed ...", "", "This command works differently from most other MOO commands, in that it actually changes how the server will interpret later lines that you type to it.  After typing the '.program' line, you are in 'programming mode'.  All lines that you type in this mode are simply saved away in the server until you type a line containing only a single period ('.').  At that point, those lines are interpreted as a MOO program and are checked for syntax errors.  If none are found, a message to that effect is printed and the code you typed is installed as the program for the verb in question.  In any case, after typing the '.' line, you are returned to the normal input-handling mode." ]
#22 Programmer Help.@kids rc = MOOList [ "Syntax:  @kids object", "", "A quick way to find out the children of an object.  Prints out the names and object numbers of the found children.  Note: this is not a list of all descendents, just direct children.", "", "Example:", "  @kids #3107", "  Generic Body of Chlorinated Water(#3107) has 3 kids.", "  The Pool(#1428)   The Hot Tub(#388)   Deep Blue Underground Pool(#17340)" ]
#22 Programmer Help.utils rc = MOOList [ "*forward*", "utilities" ]
#22 Programmer Help.options rc = MOOList [ "*pass*", "options", "", "  @prog-options    --- programming commands (@list, @verb, ...)", "  @display-options --- @display (*)" ]
#22 Programmer Help.@setenv r = MOOList [ "Syntax:  @setenv <environment string>", "", "Defines the environment for eval (property player.eval_env).  See "help eval"", "for more information.", "", "Example:", "", "  @setenv me=player;here=player.location;" ]
#22 Programmer Help.@rmalias# rc = MOOList [ "*pass*", "@rmalias" ]
#22 Programmer Help.tasks r = MOOList [ "*subst*", "A task is an execution of a MOO program.  There are five ways for tasks to be created in LambdaMOO:", "   + Every time a player types a command, a task is created to execute that command; we call these 'command tasks'.", "   + Whenever a player connects or disconnects from the MOO, the server starts a task to do whatever processing is necessary, such as printing out 'Munchkin has connected' to all of the players in the same room; these are called 'server tasks'.", "   + The FORK statement in the programming language creates a task whose execution is delayed for at least some given number of seconds; these are 'forked tasks'.", "   + The suspend() function suspends the execution of the current task.  A snapshot is taken of whole state of the execution, and the execution will be resumed later.  These are called `suspended tasks'.", "   + The read() function also suspends the execution of the current task, in this case waiting for the player to type a line of input.  When the line is received, the task resumes with the read() function returning the input line as result.  These are called `reading tasks'.", "", "The last three kinds of tasks above are collectively known as `queued tasks' or `waiting tasks', since they may not run immediately.", "", "To prevent a maliciously- or incorrectly-written MOO program from running forever and monopolizing the server, limits are placed on the running time of every task. One limit is on the length of time that tasks are allowed to run: queued tasks are given %[tostr(typeof(bgs = $server_options.bg_seconds) == ERR ? 3 | bgs)], and all other tasks, %[tostr(typeof(fgs = $server_options.fg_seconds) == ERR ? 5 | fgs)] seconds to run, after which they will - if they don't suspend() or end first - raise a 'Task ran out of seconds' traceback and die. But there is a second limit which is on the number of operations a task may execute.", "", "The server counts down 'ticks' as any task executes.  Roughly speaking, it counts one tick for every expression evaluation (other than variables and literals), one for every `if', `fork' or `return' statement, and one for every iteration of a loop.  If the count gets all the way down to zero, a 'Task ran out of ticks' traceback is raised and the task is immediately and unceremoniously aborted.  Queued tasks begin with %[$string_utils:group_number(typeof(bgt = $server_options.bg_ticks) == ERR ? 10000 | bgt)], and all other tasks with %[$string_utils:group_number(typeof(fgt = $server_options.fg_ticks) == ERR ? 30000 | fgt)] ticks.", "", "Because queued tasks may exist for long periods of time before they begin execution, there are commands to list the ones that you own and to kill them before they execute.  These commands are covered in the following help topics:", "", "@forked -- listing the forked tasks that you own", "@kill -- killing a particular forked task" ]
#22 Programmer Help.programming r = MOOList [ "MOO contains a rich programming language for the creation of interesting rooms, exits, and other objects.  Help is available on the following topics concerning programming in MOO:", "", "language -- a brief reference for the syntax and semantics of the MOO language", "tasks -- a brief description of MOO tasks and their resource limits", "", "@property -- adding a property to an object", "@rmproperty -- removing a property from an object", "", "@verb   -- adding a verb to an object", "@rmverb -- removing a verb from an object", "@args   -- changing the syntax of a verb", "@copy   -- copying a verb from one object to another", "", ".program/@program -- entering the program for a verb", "@list -- printing a listing of the program for a verb", "@edit -- editing verb code", "", "@show     -- looking at all the details of an object, a property, or a verb", "@parents  -- listing the ancestors of an object", "@kids     -- listing the children of an object", "@contents -- listing the contents of an object", "@chmod    -- changing the permissions on an object, a property, or a verb", "@chparent -- changing the parent of an object", "@rename   -- changing the name of a verb or object", "", "eval -- executing MOO statements and expressions without writing a verb" ]
#22 Programmer Help.@program rc = MOOList [ "Syntax:  @program <object>:<verb-name>", "         @program <object>:<verb-name> <dobj> <preposition> <iobj>", "         @program# <object>:<verb-number>", "", "Changes the MOO program associated with the named verb on the named object.", "If you provide <dobj> <preposition> and <iobj> as in the second form of this command, then it is the first verb with matching direct object, preposition and indirect object specifiers that is the one getting the new program.  This is useful if you have several verbs matching the same name.", "", "Or, you can use @program# if you know the verb's number. This is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list.", "", "Typing the @program command always puts the server into a line-reading mode, in which each line you type is saved away without any action unless said line is one of the following:", "", "  .", "  @abort", "  .<text>", "", "A period on a line by itself ends the line-reading mode and continues with the command, in this case, the saved lines are considered as a program, checked for syntax errors and, if no errors are found, installed as the new program for the specified verb.  ", "", "@abort causes the command to terminate immediately with no change to any verb's program.  .<text> enters <text> literally as one of the lines to be saved, which is used for when, e.g., you want to enter the line `.' or the line `@abort'.", "", "Note that this command *always* enters the line-reading mode, even if the indicated verb is not found.  In this case, lines of text are still read but they are ignored.  After any @program command, you always need to type a period or `@abort' to get back into the normal command-reading mode." ]
#22 Programmer Help.@grep rc = MOOList [ "Syntax:  @grep     <string> in <object>|{<objectlist>}", "         @egrep    <regexp> in <object>|{<objectlist>}", "         @grepall  <string> in <object>|{<objectlist>}", "         @egrepall <regexp> in <object>|{<objectlist>}", "", "@grep (@grepall) searches the given object(s) for verbs whose verbcode contains the given string as a substring of one of its lines.  ", "@egrep (@egrepall) searches the given object(s) for verbs whose verbcode contains a substring matching the given regular expression (see `help regular-expressions').", "", "@grep and @egrep print just the first matching line in each verb found.", "@grepall and @egrepall printed every matching line.", "" ]
#22 Programmer Help.# rc = MOOList [ "#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.", "If neither .<property>|.parent nor <code> is specified, just return <thing>.", "If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).", "If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.", "For example, the command", "  #JoeFeedback.parent player for tonum(%#)", "will return 26026 (unless Joe has chparented since writing this)." ]
#22 Programmer Help.@props r = MOOList [ "*forward*", "@properties" ]
#22 Programmer Help.@kill r = MOOList [ "Syntax:  @kill task_id", "         @kill [object]:[verb]", "         @kill soon [number-of-seconds]", "         @kill all", "         @kill %trailing_id", "", "", "Immediately kills one or more forked tasks.  The '@forked' command is useful for finding out what tasks you have pending; see 'help @forked' for details.  Only the owner of a task may kill it.", "", "@kill task_id kills only the task with that id.", "", "@kill object:verb kills all tasks which were scheduled by the object running the verb named.  Both object and verb are optional:  @kill object: kills all tasks scheduled by that object, and @kill :verb kills all tasks which were scheduled by any object running that verb.  This can be useful if you have several similar objects which are running tasks from similarly named verbs.  (Perversely, @kill : kills all tasks...  Any object running any task.)", "", "@kill soon kills all tasks scheduled within the next minute.  @kill soon number kills all tasks scheduled within that number of seconds, e.g. @kill soon 300 would kill all tasks scheduled within the next five minutes.  This can be useful if you have a runaway task you want to quickly remove, but don't want to kill you later tasks.", "", "@kill all kills all tasks.  Like @kill soon, but more dramatic.", "", "@kill %trailing_id expects you to specify the last few digits of a task id.  It then kills all tasks that end with those digits.", "", "@killq*uiet does all of the above without the pretty printout if more than one task is being killed.  It tells you the number of tasks that have been killed when it's finished.", "", "Example:", "  @forked", "  1359083655  Sep 16 21:45:00 1991  yduJ          #5803:heartbeat (10) [#68]", "  @kill %655", "  Killed:   task 1359083655, verb #5803:heartbeat, line 10, this==#68" ]
#22 Programmer Help.@prog-options rc = MOOList [ "Syntax:  @prog-option", "         @prog-option <option>", "", "Synonyms:  @progoption, @programmer-option @programmeroption", "", "The first form displays all of your programmer options", "The second displays just that one option, which may be one of the flags listed below.  The programmer options control various annoying details of your programming commands (e.g., @list, eval, @copy, ...)", "", "The remaining forms of this command are for setting your programmer options:", "", "         @prog-option +<flag>", "         @prog-option -<flag>", "         @prog-option !<flag>           (equivalent to -<flag>)", "", "These respectively set and reset the specified flag", "", " -list_all_parens    @list shows only necessary parentheses by default", " +list_all_parens    @list shows all parentheses by default", " -list_no_numbers    @list gives line numbers by default", " +list_no_numbers    @list does not give line numbers by default", " -eval_time          eval does not show ticks/seconds consumed.", " +eval_time          eval shows ticks/seconds consumed.", " -copy_expert        @copy prints warning message.", " +copy_expert        @copy prints no warning message.", " -list_show_permissions  @list does not display permissions in header", " +list_show_permissions  @list displays permissions in header", "", "All flags default to the `-' settings.  ", "Finally, we have", "", "         @prog-option verb_args [is] <dobj> <prep> <iobj>", "         @prog-option verb_args="<dobj> <prep> <iobj>"", "         @prog-option -verb_args", "                      (equivalent to verb_args="none none none")", "         @prog-option +verb_args", "                      (equivalent to verb_args="this none this")", "", "which all serve to specify the (direct/indirect)-object and preposition to use in a @verb command for which these are not given at all." ]
#22 Programmer Help.@egrepall rc = MOOList [ "*forward*", "@grep" ]
#22 Programmer Help.@displayoptions rc = MOOList [ "*forward*", "@display-options" ]
#22 Programmer Help.@addalias# rc = MOOList [ "*pass*", "@addalias" ]
#22 Programmer Help.expressions r = MOOList [ "The following kinds of expressions exist in the MOO programming language:", "", "        number", "        # integer", "        # - integer", "        "character string"", "        error-name", "Literal expressions return the obvious values: numbers (floating-point or integers), object numbers, strings, and errors.", "", "        { expression , expression , ... , expression }", "The list-construction expression evaluates the each of the expressions in turn and returns a list whose elements are the results of those expressions.  Any of the expressions may be prefixed with an at-sign ('@'); in this case, that expression must return a list and, rather than that list becoming an element of the final list, its elements are spliced into the final list.", "", "        name", "Variable expressions return the current value of the named variable.  Variable names must start with a letter or underscore ('_') and contain only letters, digits, and underscores.  The following variables are predefined:", "            OBJ, STR, LIST, ERR, INT, FLOAT, NUM (same as INT)", "            player, caller, this, verb, args", "            argstr, dobj, dobjstr, prepstr, iobj, iobjstr", "Their initial values are described in detail in the LambdaMOO Programmer's Manual.", "", "        expression . name", "        expression . ( expression )", "        $ name", "Property-reading expressions return the current value of a named property on the object that is the value of the first subexpression.  In the second form, the second subexpression must return a string, the name of the property to be read.  The third form is an abbreviation for '#0.name'.", "", "        expression : name ( arguments )", "        expression : ( expression ) ( arguments )", "Verb-call expressions invoke a named verb on the object that is the value of the first subexpression, passing the given arguments.  In the second form, the second subexpression must return a string, the name of the verb to invoke.  The syntax and semantics of arguments is exactly as in the list-construction expression but no initial or final curly-braces ('{' or '}') are used.", "", "        function ( arguments )", "The function-call expression invokes one of the MOO primitive functions, as listed in 'help functions', passing the given arguments.", "", "        expression [ expression ]", "The indexing expression first evaluates the two subexpressions; call their values S and N, respectively.  S must be a string or a list and N must be a integer between 1 and the length of S, inclusive.  The Nth element of S is returned.  The elements of a string are themselves one-character strings. The special character `$' maybe used for N as shorthand for the length of the string or list S.", "", "        expression [ expression .. expression ]", "The subsequence expression first evaluates the three subexpressions; call their values S, N1, and N2, respecitively.  S must be a string or a list and N1 and N2 must be integers.  If N1 <= N2, then both must be between 1 and the length of S, inclusive (the shorthand character `$' may be used); the subsequence of S beginning at index N1 and continuing through index N2 is returned.  If N1 > N2, the empty sequence of the same type as S is returned, either "" or {}.", "", "        name = expression", "        expression . name = expression", "        expression . ( expression ) = expression", "        $ name = expression", "Assignment expressions give new values to variables and object properties.  For the second and third forms, the expressions on the left-hand side of the '=' are evaluated first.  Then the right-hand side expression is evaluated and result is stored in the indicated variable or object property.", "There is a special kind of assignment involving lists on the left hand side. See `help scattering' for details.", "", "        expression + expression", "        expression - expression", "        expression * expression", "        expression / expression", "        expression % expression", "        - expression", "        expression ^ expression", "The arithmetic expressions evaluate the subexpressions, all of which must return numbers of the same type (integer or floating-point), and then perform addition, subtraction, multiplication, division, remaindering, negation, or raising to a power, respectively.  For addition, the subexpressions may both return strings as well; in this case, the result is the concatenation of the two strings. For the last operation, raising to a power, if the first expression is an integer, the second must also be an integer. But if it is floating-point, then the second can be either floating point or an integer. This is the only type mixing permitted. You must do explicit type conversions with built-in functions (toint(), tofloat()) before evaluation mixed expressions on the other operations.", "", "        expression == expression", "        expression != expression", "        expression < expression", "        expression <= expression", "        expression > expression", "        expression >= expression", "The comparison expressions evaluate the subexpressions and then test whether or not the first result is equal to, unequal to, less than, less than or equal to, greater than, or greater than or equal to the second result, respectively.  If the indicated relation holds then they return 1 and otherwise they return 0.  Comparisons of strings are performed case-insensitively, those of lists are performed on an element-by-element basis, objects are compared by their object numbers, and errors by an ordering given in the LambdaMOO Programmer's Manual.", "", "        expression ? expression | expression", "        expression && expression", "        expression || expression", "        ! expression", "The logical expressions each return results based upon the truth value of their first subexpression; call the value of this expression X.  The first of these returns the value of the second subexpression if X is a true value and that of the third expression if X is a false value; the unused subexpression is not evaluated.  The definitions of 'true value' and 'false value' are given in 'help truth'.  The expression 'E1 && E2' is an abbreviation for 'E1 ? E2 | E1' except that E1 is only evaluated once.  The expression 'E1 || E2' is an abbreviation for 'E1 ? E1 | E2' except that E1 is only evaluated once.  The expression '! E' is an abbreviation for 'E ? 0 | 1'.", "", "        expression IN expression", "The list-membership expression first evaluates both subexpressions; call their values E and L, respectively.  L must be a list.  If E is an element of L, then the index of the first occurence of E in L is returned.  If E is not an element of L, then 0 is returned.", "", "        `expression-1 ! codes => expression-2'", "NOTE: the open- and close-quotation marks are really part of the syntax; they must be typed in. `Codes' is either the keywoard ANY or a comma-separated list of expressions that when evaluated should yield a list of error codes to be caught if they're raised. If `expression-1' is evaluated without raising an error, then its value is the value of the entire expresion. If it raises an error that is listed in `codes', it is caught. If the `=> expression-2' part was included (it is optional), then it is evaluated and its value is the result of the entire expression. If `expression-2' was omitted, then the error is the value of the expression. If the error was not listed and caught, then the error contines to be raised.", "", "The method for disambiguating the meaning of a complex MOO expression in the absence of sufficient parentheses is described in 'help precedence'.", "" ]
#22 Programmer Help.@args r = MOOList [ "Syntax:  @args <object>:<verb-name> <dobj>", "         @args <object>:<verb-name> <dobj> <prep>", "         @args <object>:<verb-name> <dobj> <prep> <iobj>", "         @args# <object>:<verb-number> [any above combinations]", "", "Changes the direct object, preposition, and/or indirect object specifiers for the named verb on the named object.  Any specifiers not provided on the command line are not changed.  The direct and indirect object specifiers (<dobj> and <iobj>) must be either 'none', 'this', or 'any'.  The preposition specifier (<prep>) must be either 'none', 'any', or one of the prepositional phrases listed in `help prepositions'.", "", "To unambiguously refer to the verb on the object, in case there are more than one with the same name, use @args#. This takes the 1-based index of the verb as it appears in the verbs() (or @verbs()) output list.", "" ]
#22 Programmer Help.@display-options rc = MOOList [ "Syntax:  @display-option", "         @display-option <option>", "", "Synonym:  @displayoption", "", "The display options customize the behavior of the @display command to your particular taste.  The first form of this command displays all of your display options.  The second form displays just that one option, one of the flags listed below.", "", "The remaining forms of this command are for setting your display options:", "", "         @display-option +<flag>", "         @display-option -<flag>", "         @display-option !<flag>           (equivalent to -<flag>)", "", "These respectively set and reset the specified flag", "", "-blank_tnt     Show the verb args on all verbs.", "+blank_tnt     Don't show the verb args on `this none this' verbs.", "-shortprep     Use full prepositions  (e.g., "on top of/on/onto/upon")", "+shortprep     Use short prepositions (e.g., "on")", "-thisonly      Specifying . (:) to retrieve all properties (verbs) will go", "               up the ancestor chain until it finds a readable object with", "               properties (verbs) defined on it.", "+thisonly      Specifying . (:) to retrieve all properties (verbs) will only", "               display properties (verbs) defined on the object itself." ]
#22 Programmer Help.@program# rc = MOOList [ "*forward*", "@program" ]
#22 Programmer Help.@rm-alias# rc = MOOList [ "*pass*", "@rmalias" ]
#22 Programmer Help.eval r = MOOList [ "Syntax:  eval <MOO-code>", "         ; <MOO-code>", "         eval-d <MOO-code>", "", "Evaluates the given piece of MOO code and prints the resulting value.  If the MOO code begins with one of the MOO language keywords ('if', 'for', 'while', 'fork', or 'return') or with the character ';', then the entire piece of code is treated as the program for a verb, with ';' appended to the end.  Otherwise, 'return' is appended to the front and ';' is appended to the end and that string is treated as the code for a verb.  In either case, the resulting verb is invoked and whatever value it returns is printed.", "", "For programmers, this is such a mind-bogglingly useful thing to do that there is a simple abbreviation for this command; any command beginning with a semicolon (';') is treated as a use of 'eval'.", "", "Eval treats specially a duplicated semicolon at the beginning.  It enables you to make multi-statement programs within eval (but does not by default print the return value).", "", "Eval-d (no ";" abbreviation for this) evaluates the following text exactly as eval, except that the "d" debug flag (see programmer's manual for explanation) is turned off.  Thus errors will cause an error return value rather than a traceback.", "", "If you set the programmer option `eval_time' to 1 (see `help @prog-options'), then eval will print out how many ticks and seconds the program required.", "", "Examples:", "   eval 3 + 4", "   =>  7", "   ;3+4", "   =>  7", "   ;for x in (player.aliases) player:tell(x); endfor", "   Haakon", "   Wizard", "   ArchWizard", "   =>  0", "   ;;l = {}; for i in [1..10] l = {@l, i}; endfor return l", "   =>  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}", "   eval-d 8 + "foo"", "   => E_TYPE  (Type mismatch)", "", "You may customize your evaluation environment.  The player property .eval_env may contain statements to be executed prior to any evaluated program.  Two caveats:  This will throw off the tick count.  You can account for additional ticks inserted by your environment with the .eval_ticks property; just set it to the number of ticks you'd like subtracted from the total.  Additionally, if you make a syntax error in your program, the line reported will be wrong (it will count those initial statements), and if you make an error in the eval_env itself, you can be in deep trouble.  Despite these drawbacks, the eval_env property can be quite useful.  The following is a sample:", "", "Eval_env:    "me=player;here=player.location;"", "eval_ticks:  3", "", "See also @setenv.", "", "You can also define textual substitutions in a separate property, called eval_subs.  These are discouraged, however, for anything that can be done with variable assignments, because the overhead of replacing the strings in the evaluated program is significant.  However, some things, such as substituting characters which can't be typed easily on one keyboard (e.g. "[]" is difficult to type on some IBM keyboards), can only be done by textual substitutions.  Note that the eval substitutions are also interpreted by the verb editor when "eval_subs" is selected in your .edit_options property (see `help editors').  This adds to their overhead, but again, makes it possible for people to program who otherwise can't type the full character set.  Remember:  Don't use eval_subs unless you really have to!" ]
#22 Programmer Help.@progoptions rc = MOOList [ "*forward*", "@prog-options" ]
#22 Programmer Help.scattering rc = MOOList [ "It is often the case in MOO programming that you will want to access the elements of a list individually, with each element stored in a separate variables.  This desire arises, for example, at the beginning of almost every MOO verb, since the arguments to all verbs are delivered all bunched together in a single list.  In such circumstances, you could write statements like these:", "", "first = args[1];", "second = args[2];", "if (length(args) > 2)", "  third = args[3];", "else", "  third = 0;", "endif", "", "This approach gets pretty tedious, both to read and to write, and it's prone to errors if you mistype one of the indices. Also, you often want to check whether or not any extra list elements were present, adding to the tedium.", "", "MOO provides a special kind of assignment expression, called `scattering assignment' made just for cases such as these. A scattering assignment expression looks like this:", "", "{<target>, ...} = <expr>", "", "where each <target> describes a place to store elements of the list that results from evaluating <expr>. A <target> has one of the following forms:", "", "`variable'", "   This is the simplest target, just a simple variable; the list element in the corresponding position is assigned to the variable.  This is called a `required' target, since the assignment is required to put one of the list elements into the variable.", "", "`?variable'", "   This is called an `optional' target, since it doesn't always get assigned an element. If there are any list elements left over after all of the required targets have been accounted for (along with all of the other optionals to the left of this one), then this variable is treated like a required one and the list element in the corresponding position is assigned to the variable. If there aren't enough elements to assign one to this target, then no assignment is made to this variable, leaving it with whatever its previous value was.", "", "`?variable' = `default-expr'", "   This is also an optional target, but if there aren't enough list elements available to assign one to this target, the result of evaluating `default-expr' is assigned to it instead. Thus, `default-expr' provides a default value for the variable. The default value expressions are evaluated and assigned working from left to right -after- all of the other assignments have been performed.", "", "`@variable'", "   By analogy with the @ syntax in list construction, this variable is assigned a list of all of the `leftover' list elements in this part of the list after all of the other targets have been filled in. It is assigned the empty list if there aren't any elements left over. This is called a `rest' target, since it gets the rest of the elements. There may be at most one rest target in each scattering assignment expression.", "", "If there aren't enough list elements to fill all of the required targets, or if there are more than enough to fill all of the required and optional targets but there isn't a rest target to take the leftover ones, then E_ARGS is raised.", "", "Here are some examples of how this works.  Assume first that the verb me:foo() contains the following code:", "", "b = c = e = 17;", "{a, ?b, ?c = 8, @d, ?e = 9, f} = args;", "return {a, b, c, d, e, f};", "", "Then the following calls return the given values:", "", "me:foo(1)                        error-->   E_ARGS", "me:foo(1, 2)                     =>   {1, 17, 8, {}, 9, 2}", "me:foo(1, 2, 3)                  =>   {1, 2, 8, {}, 9, 3}", "me:foo(1, 2, 3, 4)               =>   {1, 2, 3, {}, 9, 4}", "me:foo(1, 2, 3, 4, 5)            =>   {1, 2, 3, {}, 4, 5}", "me:foo(1, 2, 3, 4, 5, 6)         =>   {1, 2, 3, {4}, 5, 6}", "me:foo(1, 2, 3, 4, 5, 6, 7)      =>   {1, 2, 3, {4, 5}, 6, 7}", "me:foo(1, 2, 3, 4, 5, 6, 7, 8)   =>   {1, 2, 3, {4, 5, 6}, 7, 8}", "", "Using scattering assignment, the example at the begining of this section could be rewritten more simply, reliably, and readably:", "", "{first, second, ?third = 0} = args;", "", "It is good MOO programming style to use a scattering assignment at the top of nearly every verb, since it shows so clearly just what kinds of arguments the verb expects." ]
#22 Programmer Help.@add-feature rc = MOOList [ "*pass*", "@add-feature", "", "Note to programmers: @add-feature and @remove-feature are front-ends for player:add_feature and :remove_feature.", "", ":add_feature returns", "", " * E_PERM unless caller == this || $perm_utils:controls(caller_perms())", "", " * E_INVARG if feature is not an object or is invalid", "", " * E_PERM if the object is not feature_ok", "", " * a true value otherwise", "", "and calls feature:feature_add, if the verb exists.", "", ":remove_feature returns", "", " * E_PERM unless caller == this || $perm_utils:controls(caller_perms()) || caller_perms() == feature.owner", "", " * a true value otherwise", "", "and calls feature:feature_remove, if the verb exists." ]
#22 Programmer Help.prog-index rc = MOOList [ "*index*", "Programmer Help Topics" ]
#22 Programmer Help.; r = MOOList [ "*forward*", "eval" ]
#22 Programmer Help.regular-expressions rc = MOOList [ "Regular expression matching allows you to test whether a string fits into a specific syntactic shape.  You can also search a string for a substring that fits a pattern.  See also the built-in function match()/rmatch().", "", "A regular expression describes a set of strings.  The simplest case is one that describes a particular string; for example, the string `foo' when regarded as a regular expression matches `foo' and nothing else.  Nontrivial regular expressions use certain special constructs so that they can match more than one string.  For example, the regular expression `foo%|bar' matches either the string `foo' or the string `bar'; the regular expression `c[ad]*r' matches any of the strings `cr', `car', `cdr', `caar', `cadddar' and all other such strings with any number of `a''s and `d''s.", "", "Regular expressions have a syntax in which a few characters are special constructs and the rest are "ordinary".  An ordinary character is a simple regular expression that matches that character and nothing else.  The special characters are `$', `^', `.', `*', `+', `?', `[', `]' and `%'.  Any other character appearing in a regular expression is ordinary, unless a `%' precedes it.", "", "For example, `f' is not a special character, so it is ordinary, and therefore `f' is a regular expression that matches the string `f' and no other string.  (It does *not*, for example, match the string `ff'.)  Likewise, `o' is a regular expression that matches only `o'.", "", "Any two regular expressions A and B can be concatenated.  The result is a regular expression which matches a string if A matches some amount of the beginning of that string and B matches the rest of the string.", "", "As a simple example, we can concatenate the regular expressions `f' and `o' to get the regular expression `fo', which matches only the string `fo'.  Still trivial.", "", "The following are the characters and character sequences that have special meaning within regular expressions.  Any character not mentioned here is not special; it stands for exactly itself for the purposes of searching and matching.", "", "`.'  is a special character that matches any single character.  Using", "     concatenation, we can make regular expressions like `a.b', which matches", "     any three-character string that begins with `a' and ends with `b'.", "", "`*'  is not a construct by itself; it is a suffix that means that the preceding", "     regular expression is to be repeated as many times as possible.  In `fo*',", "     the `*' applies to the `o', so `fo*' matches `f' followed by any number of", "     `o''s.", "", "     The case of zero `o''s is allowed: `fo*' does match `f'.", "", "     `*' always applies to the *smallest* possible preceding expression.  Thus,", "     `fo*' has a repeating `o', not a repeating `fo'.", "", "     The matcher processes a `*' construct by matching, immediately, as many", "     repetitions as can be found.  Then it continues with the rest of the", "     pattern.  If that fails, it backtracks, discarding some of the matches of", "     the `*''d construct in case that makes it possible to match the rest of", "     the pattern.  For example, matching `c[ad]*ar' against the string", "     `caddaar', the `[ad]*' first matches `addaa', but this does not allow the", "     next `a' in the pattern to match.  So the last of the matches of `[ad]' is", "     undone and the following `a' is tried again.  Now it succeeds.", "", "`+'  is like `*' except that at least one match for the preceding pattern is", "     required for `+'.  Thus, `c[ad]+r' does not match `cr' but does match", "     anything else that `c[ad]*r' would match.", "", "`?'  is like `*' except that it allows either zero or one match for the", "     preceding pattern.  Thus, `c[ad]?r' matches `cr' or `car' or `cdr', and", "     nothing else.", "", "`[ ... ]'", "     `[' begins a "character set", which is terminated by a `]'.  In the", "     simplest case, the characters between the two brackets form the set.", "     Thus, `[ad]' matches either `a' or `d', and `[ad]*' matches any string of", "     `a''s and `d''s (including the empty string), from which it follows that", "     `c[ad]*r' matches `car', etc.", "", "     Character ranges can also be included in a character set, by writing two", "     characters with a `-' between them.  Thus, `[a-z]' matches any lower-case", "     letter.  Ranges may be intermixed freely with individual characters, as in", "     `[a-z$%.]', which matches any lower case letter or `$', `%' or period.", "", "     Note that the usual special characters are not special any more inside a", "     character set.  A completely different set of special characters exists", "     inside character sets: `]', `-' and `^'.", "", "     To include a `]' in a character set, you must make it the first character.", "     For example, `[]a]' matches `]' or `a'.  To include a `-', you must use it", "     in a context where it cannot possibly indicate a range: that is, as the", "     first character, or immediately after a range.", "", "`[^ ... ]'", "     `[^' begins a "complement character set", which matches any character", "     except the ones specified.  Thus, `[^a-z0-9A-Z]' matches all characters", "     *except* letters and digits.", "", "     `^' is not special in a character set unless it is the first character.", "     The character following the `^' is treated as if it were first (it may be", "     a `-' or a `]').", "", "`^'  is a special character that matches the empty string -- but only if at the", "     beginning of the string being matched.  Otherwise it fails to match", "     anything.  Thus, `^foo' matches a `foo' which occurs at the beginning of", "     the string.", "", "`$'  is similar to `^' but matches only at the *end* of the string.  Thus,", "     `xx*$' matches a string of one or more `x''s at the end of the string.", "", "`%'  has two functions: it quotes the above special characters (including `%'),", "     and it introduces additional special constructs.", "", "     Because `%' quotes special characters, `%$' is a regular expression that", "     matches only `$', and `%[' is a regular expression that matches only `[',", "     and so on.", "", "     For the most part, `%' followed by any character matches only that", "     character.  However, there are several exceptions: characters that, when", "     preceded by `%', are special constructs.  Such characters are always", "     ordinary when encountered on their own.", "", "     No new special characters will ever be defined.  All extensions to the", "     regular expression syntax are made by defining new two-character", "     constructs that begin with `%'.", "", "`%|' specifies an alternative.  Two regular expressions A and B with `%|' in", "     between form an expression that matches anything that either A or B will", "     match.", "", "     Thus, `foo%|bar' matches either `foo' or `bar' but no other string.", "", "     `%|' applies to the largest possible surrounding expressions.  Only a", "     surrounding `%( ... %)' grouping can limit the grouping power of `%|'.", "", "     Full backtracking capability exists for when multiple `%|''s are used.", "", "`%( ... %)'", "     is a grouping construct that serves three purposes:", "", "       1. To enclose a set of `%|' alternatives for other operations.  Thus,", "          `%(foo%|bar%)x' matches either `foox' or `barx'.", "", "       2. To enclose a complicated expression for a following `*', `+', or `?'", "          to operate on.  Thus, `ba%(na%)*' matches `bananana', etc., with any", "          number of `na''s, including none.", "", "       3. To mark a matched substring for future reference.", "", "     This last application is not a consequence of the idea of a parenthetical", "     grouping; it is a separate feature that happens to be assigned as a second", "     meaning to the same `%( ... %)' construct because there is no conflict in", "     practice between the two meanings.  Here is an explanation of this", "     feature:", "", "`%DIGIT'", "     After the end of a `%( ... %)' construct, the matcher remembers the", "     beginning and end of the text matched by that construct.  Then, later on", "     in the regular expression, you can use `%' followed by DIGIT to mean", "     "match the same text matched by the DIGIT'th `%( ... %)' construct in the", "     pattern."  The `%( ... %)' constructs are numbered in the order that their", "     `%(''s appear in the pattern.", "", "     The strings matching the first nine `%( ... %)' constructs appearing in a", "     regular expression are assigned numbers 1 through 9 in order of their", "     beginnings.  `%1' through `%9' may be used to refer to the text matched by", "     the corresponding `%( ... %)' construct.", "", "     For example, `%(.*%)%1' matches any string that is composed of two", "     identical halves.  The `%(.*%)' matches the first half, which may be", "     anything, but the `%1' that follows must match the same exact text.", "", "`%b' matches the empty string, but only if it is at the beginning or end of a", "     word.  Thus, `%bfoo%b' matches any occurrence of `foo' as a separate word.", "     `%bball%(s%|%)%b' matches `ball' or `balls' as a separate word.", "", "     For the purposes of this construct and the five that follow, a word is", "     defined to be a sequence of letters and/or digits.", "", "`%B' matches the empty string, provided it is *not* at the beginning or end of", "     a word.", "", "`%<' matches the empty string, but only if it is at the beginning of a word.", "", "`%>' matches the empty string, but only if it is at the end of a word.", "", "`%w' matches any word-constituent character (i.e., any letter or digit).", "", "`%W' matches any character that is not a word constituent." ]
#22 Programmer Help.errors rc = MOOList [ "*errors*", "The complete list of error codes:", "" ]
#22 Programmer Help.@remove-feature rc = MOOList [ "*forward*", "@add-feature" ]
#22 Programmer Help.examine rc = MOOList [ "*pass*", "examine", "", "[Note to programmers: the 'obvious' verbs are those that can be invoked as commands and are not specified by the :hidden_verbs verb.  The default definition of "hidden" is "not readable".  You can override this definition with a :hidden_verbs verb that gets the default list with pass(@args) and then alters that list.]" ]
#22 Programmer Help.@disown rc = MOOList [ "*forward*", "@disinherit" ]
#22 Programmer Help.@rmverb# rc = MOOList [ "*forward*", "@rmverb" ]
#22 Programmer Help.statements r = MOOList [ "The following kinds of statements exist in the MOO programming language:", "", "        ;", "The null statement does nothing.", "", "        expression ;", "The expression statement evaluates the expression and then discards the value.", "", "        IF ( expression ) statements ENDIF", "        IF ( expression ) statements ELSE statements ENDIF", "        IF ( expression )", "          statements", "        ELSEIF ( expression )", "          statements", "        ...", "        ELSE", "          statements", "        ENDIF", "The conditional statement evaluates each expression in turn and executes the statements associated with the first one to return a true value; the ELSE statements are executed if none of the expressions returns a true value.  There can be any number of ELSEIF clauses and the ELSE part is optional.  See 'help truth' for the definition of 'true value'.", "", "        FOR name IN ( expression ) statements ENDFOR", "The list iteration statement first evaluates the expression, which must return a list.  It then executes the statements once for each element of that list, each time with the named variable having the value of the corresponding list element.", "", "        FOR name IN [ expression .. expression ] statements ENDFOR", "The numeric iteration statement first evaluates the two expressions, both of which must return numbers; call those numbers N1 and N2, respectively.  The statements are then executed once for each integer I such that N1 <= I <= N2, in increasing order; each time, the named variable has the corresponding value of I.", "", "        WHILE ( expression ) statements ENDWHILE", "        WHILE name ( expression ) statements ENDWHILE", "The indefinite iteration statement repeatedly evaluates the expression and, each time it returns a true value, executes the statements.  The loop stops the first time that the expression returns a false value.  The definitions of 'true' and 'false' values is in 'help truth'.", "", "        BREAK ;", "        BREAK name ;", "Each `break' statement indicates a specific surrounding loop; if <name> is not given, the statement refers to the innermost one. If it is given, <name> must be the name appearing right after the `for' or `while' keyword of the desired enclosing loop. When the `break' statement is executed, the indicated loop is immediately terminated and executing continues just as if the loop had completed its iterations normally.", "", "        CONTINUE ;", "        CONTINUE name ;", "Allows you to terminate just the current iteration of a loop, making it immediately go on to the next one if any. ", "", "        RETURN ;", "        RETURN expression ;", "The return statement evaluates the expression, if any, and returns the resulting value (or 0 if there is no expression) to the verb that called the current one.  Execution of the current verb is immediately terminated.", "", "        TRY", "          statements-0 ;", "        EXCEPT variable-1 (codes-1)", "          statements-1 ;", "        EXCEPT variable-2 (codes-2)", "          statements-2 ;", "        ... (up to 255)", "        ENDTRY", "Each of the `statements-x' may be any number or combination of MOO statements and function calls. Each of the `codes-x' may be either the keyword `ANY' or else a comma-separated list of expressions that yield error codes. If the execution of `statements-0' raises an error listed in the `codes-x', then the statements associated in that EXCEPT clause where the code was listed are executed. When this occurs, `variable-x' is assigned this information about the error being raised:  {<error code>, <error message>, <value>, <traceback>}. If the error raised is not listed in any EXCEPT clause (which means the `ANY' keyword was not used), then the error continues to be raised. ", "", "        TRY", "          statements-0 ;", "        FINALLY", "          statements-last ;", "        ENDTRY", "In this construct, `statements-0' are executed. Then, whether an error was raised by their execution or not, `statements-last' are executed. If `statements-0' transfers control somewhere else, that transfer is interrupted so that `statements-last' can be run. If `statements-last' transfers control, then that overrides the first transfer. (Transfers include raising an error, returning from this verb, terminating the current iteration of a surrounding loop). `Statements-last' will always be executed, providing a good place for necessary cleanup code that will run even if `statements-0' doesn't simply run normally to completion.", "", "        FORK ( expression ) statements ENDFORK", "        FORK name ( expression ) statements ENDFORK", "The fork statement first executes the expression, which must return a number; call that number N.  It then creates a new MOO task that will, after at least N seconds, execute the statements.  When the new task begins, all variables will have the values they had at the time the FORK statement was executed.  The task executing the FORK statement immediately continues execution.  If a variable name is given after the FORK keyword, then it is assigned the 'queue ID' of the newly-created task.  The value of this variable is visible both to the task executing the fork statement and to the statements in the newly-created task.  See 'help tasks' for more information about forked tasks." ]
#22 Programmer Help.@forked r = MOOList [ "Syntax:  @forked[-v*erbose] [all wizards]", "", "Gives a list of all of the forked tasks you own, along with detailed information about each one.  Wizardly characters may specify `all wizards' and see the queued tasks which are owned by a player with .wizard=1. This is useful to find a task that $wiz_utils:random_wizard has put in various queues, and to also find code which is running with wizardly permissions that shouldn't be.", "", "The information displayed includes the following:", "", "Queue ID:", "   A numeric identifier for the task, for use in killing it (see 'help @kill').", "", "Start Time:", "   The time after which the task will begin execution.", "", "Owner:", "   The player whose permissions under which the task is running.", "   Unless you are a wizard, @forked will show only your tasks.", "", "Verb:", "   The object and verb-name of the code that forked the task.", "", "Line:", "   The line number of the first statement that the task will execute when it starts.  Note that the code for the verb in question may have changed since the task was forked; the forked task will use the version that was being executed when it was forked.", "", "This:", "   The value of `this' for the forked task, in the case that it is different from (i.e., is a descendant of) the object on which the verb code lives.", "", "For a more verbose output, use `@forked-v*erbose'. This will display the same information as the above, but for any task which is not a fresh fork or foreground task, a callers()-style listing of the stack trace will be displayed." ]
#22 Programmer Help.@disinherit rc = MOOList [ "Syntax:   @disinherit <object> ", "          @disinherit <object> [from <parent>]", "", "Synonym:  @disown", "", "This command is used to remove an unwanted child from an object you own.  If you owned said child, you could use @chparent; this command is to cover the other case, namely where you don't own the child.  ", "", "Both forms of this command chparent <object> to its grandparent, provided you own the parent.  The second form matches the string you supply for <object> against the list of children of the given <parent>.", "", "Turning off the fertile bit (.f) for a particular object prevents others from creating children of it or chparenting to it (see `help @chmod').", "Note also that, though the name might seem to indicate otherwise, this command does not change the ownership of any object." ]
#22 Programmer Help.@check-property rc = MOOList [ "*forward*", "@check-chparent" ]
#22 Programmer Help.@rmverb rc = MOOList [ "Syntax:  @rmverb <object>:<verb-name>", "         @rmverb <object>:<verb-name>  <dobj> <prep> <iobj>", "         @rmverb# <object>:<verb-number>", "", "Removes the named verb from the named object.", "If there is more than one verb matching the given verb-name, this removes the most recently defined one.", "", "With the 2nd form of the command the verb removed is the most recent one matching both the given verb-name *and* the given dobj/prep/iobj specifiers.", "", "To remove the ambiguity in verbs with the same name, @rmverb# is provided where you can specify the verb by its 1-based index in the verbs() list output. Use of this form is strongly encouraged." ]
#22 Programmer Help.@check-chparent rc = MOOList [ "Syntax:  @check-property <object>.<propname>", "         @check-chparent <object> to <newparent>", "         ", "You cannot add a new property to an object if an ancestor or a descendant already defines a property with the same name.  @check-property will give you the list of all descendants of <object> that that define .<propname>.  ", "", "Likewise you cannot chparent an object to a new parent if the new parent has a property that is also defined on the object or some descendant.  Use @check-chparent to find out all instances of conflicting properties that would interfere with @chparent in this manner.", "", "Note that @check-property requires either that you own the object or that it be writeable, the same conditions that need to hold if you are to create new properties on the object.  Similarly, @check-chparent requires that you own the object and that the new parent is either fertile or likewise owned by you.", "", "For objects with large numbers of descendants, these commands can be time-consuming." ]
#22 Programmer Help.@prospectus rc = MOOList [ "Usage:  @prospectus player [from number] [to number]", "", "Like @audit, but displays more information.  The optional from and to arguments are for restricting the display to specific object numbers, if you happen to know the player only owns objects in the included range.", "", "Example:", "   Objects owned by Frand (from #0 to #54949):", "     P[ 23]    #47 Frand                          [Hyperspace Hovel]", "     T        #152 Frand's trio of shoes          [Frand]", "   KfT[ 10]   #391 Frand's notifier class         [Nowhere]", "     T[  8]   #393 Frand's chessboard             [The Dining Room]", "   KfT[ 11]   #775 Frand's generic game board     [Nowhere]", "     T[  6]   #893 Ghost game                     [The Dining Room]", "     T[ 16]   #894 Frand's mind bender            [The Dining Room]", "     C        #997 polka-dot hole                 [Hyperspace Hovel]", "     R[  1]  #1002 Hyperspace Hovel              ", "     E      #11958 out                            Monster Cage->*Dr. Empirico's Lab", "      ...", "", "The K in the first column indicates that the object has children owned by other players.  A lowercase k indicates the object has children but owned only by the player.  The second column indicates whether the object is publicly readable or publicly parentable.  An r indicates readability.  A lowercase f indicates the object is both readable and allows children (is fertile).  An uppercase F indicates the object is not readable, yet allows children to be created.  (This is usually an error.)  If the object is readable by the issuer of the @prospectus command (that is, publicly readable or owned by the issuer), then the number in brackets indicates the number of verbs which have been defined on this object (not including any verbs from any parents).", "", "The third column indicates what type of object this is.", "        T       Thing", "        E       Exit", "        R       Room", "        C       Container", "        N       Note", "        P       Player", "        F       Feature", "        M       Mail Recipient", "        H       Help Database", "        D       Database", "        U       Utilities Package", "        O       Options Package", "        p       Parent object appropriate for players ("Player class")", "        blank   Other" ]
#22 Programmer Help..flush rc = MOOList [ "Syntax:  .flush", "", "Clear out all recent lines of input that haven't been processed yet by the server. Useful when you change your mind about lines you have typed that haven't run yet.", "", "This command name can be changed by the `set_connection_option()' built-in function, or if $server_options.default_flush_command exists and is non-empty, that value is used. If it exists and -is- empty, then no flush command exists at all." ]
#22 Programmer Help.checkpoint-programming r = MOOList [ "The MOO checkpoint is created by a UNIX system fork() call, which creates a separate process but with the same memory image as the running the MOO.  That process then writes that information into a database.", "", "The act of calling this separate-but-equal process is intrinsically laggy because the MOO server memory is already saturated by the running version of the MOO.  Adding an equal size process to the mix results in heavy swapping between memory and harddrive.  It would therefore be considered wise not to run any processor or memory intensive MOOcode during checkpoint.", "", "If you wish to alter any of your code to avoid executing during a checkpoint, you can check the value of $login.checkpoint_in_progress, which returns 1 during checkpoint and 0 otherwise.  This value is itself toggled by the verbs $sysobj:checkpoint_started and $sysobj:checkpoint_finished.", "", "Also see help on:   dump_database()   @dump-database   checkpoint" ]
#22 Programmer Help.@list# rc = MOOList [ "*forward*", "@list" ]
#22 Programmer Help.@verb r = MOOList [ "Syntax:  @verb <object>:<verb-name(s)>", "         @verb <object>:<verb-name(s)> <dobj> [<prep> [<iobj>]]", "", "Adds a new verb with the given name(s) to the named object.  If there are multiple names, they should be separated by spaces and all enclosed in quotes:", "", "        @verb foo:"bar baz mum*ble"", "", "The direct and indirect object specifiers (<dobj> and <iobj>) must be either 'none', 'this', or 'any'; their meaning is discussed in the LambdaMOO Programmer's Manual.  The preposition specifier (<prep>) must be either 'none', 'any', or one of the prepositional phrases listed in `help prepositions' (a prepositional phrase with more than one word must be enclosed in quotes ("")).  All three specifiers default to 'none'.", "", "It is also possible to specify the new verb's permissions and owner as part of the same command (rather than having to issue separate @chmod/@chown commands)", "", "     @verb <object>:<verb-name(s)> <dobj> <prep> <iobj> <permissions>", "     @verb <object>:<verb-name(s)> <dobj> <prep> <iobj> <permissions> <owner>", "", "<permissions> are as with @chmod, i.e., must be some subset of "rwxd".  They default to "rd" (specifying "w" for a verb is highly inadvisable).  The owner defaults to the player typing the command; only wizards can create verbs with owners other than themselves.", "", "You may also use "tnt" in place of "this none this" for the dobj prep iobj arguments.  "this none this" is used to indicate non-command verbs, since the parser can't possibly interpret a command as "this none this".  For these verbs, the permissions default to "rxd"; the "x" bit is set so that they can be called from other programs.  (If they couldn't be used as commands, and they couldn't be called from programs, they wouldn't be good for anything!)" ]
#22 Programmer Help.@args# rc = MOOList [ "*forward*", "@args" ]
#22 Programmer Help.@list r = MOOList [ "Syntax:  @list <object>:<verb>", "         @list <object>:<verb> [with|without parentheses|numbers] [all]", "         @list <object>:<verb> <dobj> <prep> <iobj>", "         @list <object>:<verb> <start>..<end>", "         @list# <object>:<verb-number> [any of the above]", "", "Prints out the code for the MOO program associated with the named verb on the named object.  ", "", "Normally, the code is shown with each line numbered and with only those parentheses that are necessary to show the meaning of the program.  You can e.g., specify `without numbers' to have the numbers omitted or `with parentheses' to include all parentheses or even `with parentheses without numbers' to do both.  You can change the default behavior of this command via @prog-options (which see).", "", "Normally, the @list command only shows the code for the named verb on the object itself or on the nearest ancestor that defines it; if you give the `all' option, it shows the code for the named verb on every ancestor that defines it, as well as on the object itself.", "", "The 3rd form of the verb lists the verb matching the given dobj/prep/iobj specification if such exists.  ", "The 4th form prints only those lines in the specified range.", "", "Example:", "  Type `@list $room:say' to see the code for the `say' command, or even `@list $prog:@list' to see the code implementing @list itself...", "", "The 2nd-4th forms may be combined, e.g.,", "", "  @list frobule:burfle this in front of any without numbers 1..10", "", "which would be useful if `frobule' had more than one `burfle' verb and we wanted to see the first 10 lines of the one having `this' `in front of' `any' as its respective dobj/prep/iobj specifiers.", "", "Or, if you know the verb's number, you can use @list# to unambiguously refer to the verb. The number comes from the 1-based index of the verb as it appears in the verbs() (or @verbs) output list." ]
#22 Programmer Help.@chmod rc = MOOList [ "Syntax:  @chmod <object> <object-permissions>", "         @chmod <object>.<prop-name> <property-permissions>", "         @chmod <object>:<verb-name> <verb-permissions>", "         @chmod# <object>:<verb-number> <verb-permissions>", "", "Changes the permissions of an object, property or verb, to those given.  The following table shows what permission bits are allowed for each form of the command:", "        <object-permissions>        r, w, f", "        <property-permissions>      r, w, c", "        <verb-permissions>          r, w, x, d", "", "See the LambdaMOO Programmer's Manual for their meanings.", "", "The form @chmod# is used to unambiguously refer to a verb by its 1-based index as it appears in the verbs() (or @verbs()) output list.", "", "To clear all of the permissions for an object, verb, or property, use "" as the second argument.", "", "@chmod also accepts +, !, and - as modifiers for a single permission to add or subtract that permission from the current set.  (! and - are the same.)", "", "Examples:", "", "Set a verb to be Readable and Callable:", "  @chmod chair:sit rx", "", "Set a verb to be not Callable, without changing its other permissions:", "  @chmod cookies:eat !x", "", "Set an object to be Fertile in addition to any current bits:", "  @chmod table +f" ]
#22 Programmer Help.@chparent rc = MOOList [ "Syntax:  @chparent <object> to <new parent>", "", "Changes the parent of the named object to be the named parent.  The object acquires all the verb and property definitions of its parent.  Newly acquired properties are initilialized with `clear' values so that they inherit whatever values are currently assigned to the parent's corresponding properties (see `help @clearproperty').", "", "If the player does not own <new parent>, it must have been set `fertile'.  <object> must be owned by the player.  Neither <object> nor any descendant can define any property which already exist on <new parent>.  Use @check-chparent (see `help @check-chparent') to list such property conflicts.", "", "It is also sometimes the case that you will own some object and want to @chparent some child of that object that you do not own.  Use @disinherit (see `help @disinherit') in such situations." ]
#22 Programmer Help.@add-alias# rc = MOOList [ "*pass*", "@addalias" ]
#22 Programmer Help.prepositions rc = MOOList [ "*prepositions*", "The complete list of prepositions recognized by the command-line parser:", "" ]
#22 Programmer Help.@chmod# rc = MOOList [ "*forward*", "@chmod" ]
#22 Programmer Help.help rc = MOOList [ "*pass*", "help", "", "For programmers, the help system provides the following additional forms:", "", "  help object:verbname   -- prints any documentation strings that are present", "                            at the beginning of the program for that verb.", "  help $<whatever>_utils -- prints general information about one of the ", "                            $..._utils objects (e.g., $string_utils, ", "                            $list_utils, etc...), which are all libraries ", "                            of generally used verbs.", "  help builtin()         -- prints documentation from the programmers manual", "                            about the named primitive, for example length()", "", "For information about how the help system itself works and about how to associate local help databases with specific rooms or player classes, see `help $help'." ]
#22 Programmer Help.@dbsize rc = MOOList [ "Syntax:  @dbsize", "", "@dbsize goes through the entire database, counting the valid and invalid objects, giving a summary at the end.  This information can be useful, but because this command is cpu intensive, it should be used sparingly." ]
#22 Programmer Help.@display rc = MOOList [ "Syntax: @display <object>.[property]", "                         ,[inherited_property]", "                         :[verb]", "                         ;[inherited_verb]", "", "@display is a fancy version of @show.  As @show, it can select individual verbs or properties to display.  In addition, it can display all the verbs or properties defined on an object, or all the verbs or properties defined on any of the object's ancestors.  Don't specify a property or verbname after the punctuation mark to get the "all" feature.  Its display is more compact than that of @show (it uses a one-line format, and truncates values that don't fit in the value field).", "", "You may mix properties and verbs on the command line, but the parser may become confused.  (E.g. @display object,: displays all properties including inherited ones plus all locally defined verbs on the object.)", "", "Examples:", "Individual property:", "  @display poolsweep.count", "  .count                   yduJ (#68)            r c    8", "", "Individual verb:", "  @display poolsweep:tell", "  #3560:tell                     yduJ (#68)           rxd    this none this", "", "All properties, including one truncated value:", "  @display poolsweep.", "  poolsweep (#3560) [ readable ]", "    Owned by yduJ (#68).", "    Child of generic thing (#5).", "    Location The Pool (#1428).", "  .gagged                  yduJ (#68)            r c    0", "  .count                   yduJ (#68)            r c    8", "  .messages                yduJ (#68)            r c    {"The poolsweep stir..", "  .index                   yduJ (#68)            r c    2", "  .quantum                 yduJ (#68)            r c    20", "", "Inherited verbs, edited for brevity, showing verbs from various parents, with owners, permissions, and argument lists.", "  @d poolsweep;", "  poolsweep (#3560) [ readable ]", "   #3560:tell                     yduJ (#68)           rxd    this none this", "   #3560:description              yduJ (#68)           rxd    this none this", "      #5:"g*et t*ake"             Haakon (#2)          rxd    this none none", "      #5:"d*rop th*row"           Haakon (#2)          rxd    this none none", "      #5:moveto                   Haakon (#2)          rxd    this none this", "      #1:description              Haakon (#2)          rxd    this none this", "      #1:look_self                Haakon (#2)          rxd    this none this", "", "Some aspects of @display can be customized (see `help @display-options')." ]
#22 Programmer Help.@grepall rc = MOOList [ "*forward*", "@grep" ]
#22 Programmer Help.truth r = MOOList [ "Several kinds of statements, expressions, and functions in the MOO programming language use a notion that some MOO values are 'true' and others 'false'.", "", "The only values that are considered true are non-zero numbers, non-empty strings, and non-empty lists.", "", "All other values (i.e., 0, "", {}, objects, and errors) are considered false." ]
#22 Programmer Help.@programmer-options rc = MOOList [ "*forward*", "@prog-options" ]
#22 Programmer Help.@killquiet rc = MOOList [ "*forward*", "@kill" ]
#22 Programmer Help.@property r = MOOList [ "Syntax:  @property <object>.<prop-name>", "         @property <object>.<prop-name> <initial-value>", "", "Adds a new property named <prop-name> to the named object.  The initial value is given by the second argument, if present; it defaults to 0.  ", "", "Normally, a property is created with permissions 'rc' and owned by whoever types the command.  However, you may also specify these explicitly", "", "         @property <object>.<prop-name> <initial-value> <permissions>", "         @property <object>.<prop-name> <initial-value> <permissions> <owner>", "", "Only wizards can create properties with owners other than themselves.", "", "'@property' can be abbreviated as '@prop'." ]
#22 Programmer Help.@programmeroptions rc = MOOList [ "*forward*", "@prog-options" ]
#22 Programmer Help:errors this n/a this
text = args[1];
for i in [1..length($code_utils.error_list)]
text = {@text, tostr("    ", $string_utils:left($code_utils.error_names[i], 15), $code_utils.error_list[i])};
endfor
return text;
-------------------------------------------------------------------------------
#22 Programmer Help:prepositions this n/a this
text = args[1];
for p in ($code_utils:prepositions())
text = {@text, tostr($string_utils:space(4), p)};
endfor
return text;
-------------------------------------------------------------------------------
================================#23 Wizard Help===============================================
#23 Wizard Help.graylist rc = MOOList [ "*forward*", "blacklist" ]
#23 Wizard Help.@recycle rc = MOOList [ "*pass*", "@recycle", "", "Of course, wizards are allowed to @recycle anything at all.", "", "There is, however, a block (in $player:recycle) against recycling actual players, i.e., descendants of $player that have the player flag set.  This is mainly to prevent stupid mistakes.  If, for some reason, you want to recycle a player, you need to @toad it first." ]
#23 Wizard Help.wiz-index rc = MOOList [ "*index*", "Wizard Help Topics" ]
#23 Wizard Help.@deprogrammer rc = MOOList [ "Information about $wiz:@deprog*rammer", "----", "@deprogrammer victim [for <duration>] [reason]", "", "Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'." ]
#23 Wizard Help.site-info rc = MOOList [ "To look at where a player is currently connecting from, use @netwho.  To see previous connect sites, look at <player>.all_connect_places." ]
#23 Wizard Help.@make-guest rc = MOOList [ "Syntax:  @make-guest <adjective>", "", "This creates a new guest character.  For example,", "  @make-guest Loud", "creates a child of $guest, owned by $hacker, named Loud_Guest and with aliases Loud and Loud_Guest.", "", "Note that in order to have `connect guest' connect to a guest character, there needs to exist some guest character having "Guest" as a name or alias.", "", "See also `help @make-player'." ]
#23 Wizard Help.$site_db rc = MOOList [ "Database of places", "------------------", "i.e., places people have connected from.", "", "  :add(sitename,player)", "      records the fact that player connected from sitename.", "  :load()", "      clears the db and reloads all of the player connection info.", "", "  .domain", "      default domain for unqualified sitenames given to :add.", "      ", "For each domain we keep a list of players and subdomains. ", "For example, :add("doc.ic.ac.uk",#666) enters #666 on the lists for "doc.ic.ac.uk", and, if we have to create an entry for "doc.ic.ac.uk", we enter "doc" on the list for "ic.ac.uk", "ic" on the list for "ac.uk", etc....  In this case, :find("ic") will return the "ic.ac.uk" list if there is no other domain in $site_db starting with "ic".  Note that the "ic.ac.uk" list may contain both objects, i.e., namely players that have connected from the site "ic.ac.uk", and strings, i.e., subdomains of "ic.ac.uk" like "doc".", "", "  :find_exact(string)    => player/subdomain list or $failed_match", "  :find_all_keys(string) => list of all domains that begin with string", "  :find_key     (string) => unique domain that begins with string, ", "                            $ambiguous_match or $failed_match", "", "The other $generic_db functions (:find, :find_all) are also available, though admittedly less useful." ]
#23 Wizard Help.@programmer rc = MOOList [ "*subst*", "Syntax:  @programmer <player>", "", "Sets the programmer flag on the indicated player and sends mail to $new_prog_log.  ", "", "If the player is not already a descendant of $prog, we @chparent him/her to $prog.  In this case, if $prog has a larger .ownership_quota than its ancestors, then we raise the player's quota by the difference between $prog.ownership_quota and the .ownership_quota of the common ancestor of player and $prog, be this $player or some intermediate class.", "", "There are messages that one may set to customize how the granting of a programmer bit looks to the victim and to any onlookers.  After all, this is a seminal event in a MOOer's life...  Thus we have", "", "@programmer  [%[$wiz.programmer_msg]]", "  Printed to everyone in the room with the victim being @programmer'ed.", "", "@programmer_victim  [%[$wiz.programmer_victim_msg]]", "  Printed to the victim.", "", "These are pronoun subbed with victim == dobj." ]
#23 Wizard Help.@blacklist rc = MOOList [ "Syntax:  @redlist   [<domain or subnet> [for <duration>] [commentary]]", "         @blacklist [<domain or subnet> [for <duration>] [commentary]]", "         @graylist  [<domain or subnet> [for <duration>] [commentary]]", "         @spooflist [<domain or subnet> [for <duration>] [commentary]]", "", "Syntax:  @unredlist   [<domain or subnet> [commentary]]", "         @unblacklist [<domain or subnet> [commentary]]", "         @ungraylist  [<domain or subnet> [commentary]]", "         @unspooflist [<domain or subnet> [commentary]]", "", "With no argument, the current contents of the corresponding list are printed.", "Otherwise, the specified domain or subnet is added to or removed from the list and mail will be sent to $site_log.", "", "To add a domain or subnet to a *list only temporarily, include a `for <duration>' statement before any commentary.  The <duration> should be in english form such as 1 day or 1 month 2 weeks or 1 year 3 months 2 weeks 4 days.  No commas should separate increments in the duration.  See `help $time_utils:parse_english_time_interval' for more details.  If you are not temporarily *listing a domain or subnet, but are including a commentary, be sure that the commentary does not start with the word `for'.", "", "If the given domain or subnet has subdomains/subsubnets that are already on the list, you will be prompted as to whether you want to remove them.  Note that adding an entry for a particular domain or subnet effectively adds all subdomains/subsubnets, so unless there's some reason for keeping an explicit entry for a particular subdomain, chances are you will indeed want to remove them.  One reason to keep an explicit entry for a subdomain would be if you intended to unlist the full domain later but wanted to be sure you didn't unlist the subdomain in the process.", "", "See `help blacklist' for a description of the functions of these lists." ]
#23 Wizard Help.@egrep rc = MOOList [ "*forward*", "@grep" ]
#23 Wizard Help.@register rc = MOOList [ "Information about $wizard:@register", "----", "Registers a player.", "Syntax:  @register name email-address [additional commentary]", "Email-address is stored in $registration_db and on the player object." ]
#23 Wizard Help.further-reading rc = MOOList [ "Other topics of interest to wizards:", "", "$login", "$guest_log", "$no_one", "$recycler", "$help" ]
#23 Wizard Help.@shutdown rc = MOOList [ "Syntax:  @shutdown [in <m>] [<text>]", "", "This is the friendly way to do a server shutdown; it arranges for the actual shutdown to take place `m' minutes hence (default two).  Shutdown is preceded by a sequence of warnings to all connected players.  Warnings are likewise given to all players who connect during this time.  <text>, if given is included in these warning messages, perhaps as an explanation for why the server is being shut down.", "", "Shutdown may be aborted at any time by using @abort-shutdown." ]
#23 Wizard Help.@log rc = MOOList [ "Syntax:  @log <message>", "         @log", "", "The first form enters <message> as a one-line comment in the server log.", "The second form prompts for a sequence of lines to be collectively entered as an extended comment.  This uses $command_utils:read_lines so all of those conventions apply, i.e., a period on a line by itself ends the text, `@abort' aborts the command, etc...).  Example:  If Wizard (#2) types", "", "    @log I did $dump_interval=3600", "", "the following line appears in the server log", "", "    Aug 19 22:36:52:  COMMENT:  from Wizard (#2):  I did $dump_interval=3600" ]
#23 Wizard Help.@@who rc = MOOList [ "*forward*", "@net-who" ]
#23 Wizard Help.@chown rc = MOOList [ "Syntax:  @chown <object>            [to] <owner>", "         @chown <object>.<propname> [to] <owner>", "         @chown <object>:<verbname> [to] <owner>", "         @chown# <object>:<verbnumber> [to] <owner>", "", "Changes the ownership of the indicated object, property or verb.", "", "Verb ownership changes are fairly straightforward, being merely a matter of changing the verb_info() on a single verb. Referring to a verb isn't as straightforward since two verbs on the same object can have the same name. So, @chown# is provided where you can refer to a verb by it's 1-based index in the output of the verbs() builtin.", "", "Changing an object ownership includes changing the ownership on all +c properties on that object.  Note that @chown will not change the ownership of any other properties, nor will it change verb ownerships.  Use @grant if you need to do a more complete ownership change.  The quota of the former owner is increased by one, as is the quota of the new owner decreased by one.", "", "Changing a property ownership is truly hairy.  If the property is +c one shouldnot be doing this, unless it is to correct a past injustice which caused the property to be owned by the wrong player.  In the case of -c properties, the property ownership is changed on all descendent objects (currently, if +c instances of a -c property are found in the traversal of all of the descendants, these are not changed, being deemed sufficiently weird that they should be handled on a case-by-case basis...).", "", "If there's any justice, a future version of the server will prevent occurrences of (1) +c properties being owned by someone other than the object owner (2) -c properties with different owners on descendant objects (3) -c properties that are +c on some descendants." ]
#23 Wizard Help.@quota rc = MOOList [ "*pass*", "@quota", "", " - - - - - - - - - - - - - - - - - - - - - - - - - -", "Syntax:  @quota <player> is [public] [+]<number> [<reason>]", "", "This second and more interesting form of the verb is used to set a player's quota.  Mail will be sent to $quota_log, and also $local.public_quota_log if there is one and if the "public" argument is given; if a reason is supplied, it will be included in the message.  If the number is prefixed with a +, it's taken as an amount to add to the player's current quota; if not, it's an absolute amount." ]
#23 Wizard Help.@grep rc = MOOList [ "*pass*", "@grep", "", "For wizards, the following forms are also available for doing full-db searches", "", "         @grep  <pattern>", "         @grep  <pattern> from [#]<n>", "", "and likewise for @egrep, @grepall, and @egrepall.", "The first searches all objects in the database while the second searches the range [#<n>..max_object()]", "", "See also:  @grepcore, @who-calls." ]
#23 Wizard Help.@toad rc = MOOList [ "*subst*", "Syntax:  @toad   <player>  [graylist|blacklist|redlist]", "         @toad!  <player>", "         @toad!! <player>", "", "Resets the player flag of <player> (thus causing <player> to be booted), resets the .programmer and .wizard flags, chowns the player object to $hacker, and removes all of its names and aliases from $player_db.", "", "You must give either the player's full name or its object number.", "Also, this command does not let you @toad yourself.", "", "In some cases you may wish to add the player's last connected site to the site graylist, blacklist or redlist --- see `help blacklist' --- in order to invoke various kinds of blocking on that site (e.g., if player creation is enabled, you may want to enter the player on the blacklist to keep him from immediately creating a new character).  Specifying one of the listnames `graylist', `blacklist' or `redlist' will do this.", "", "@toad!  <player>  is synonymous with  @toad <player> blacklist", "@toad!! <player>  is synonymous with  @toad <player> redlist", "", "There are messages that one may set to customize toading.  After all, a toading is (supposed to be) a rare event and you will doubtless want to put on a good show.  Thus we have", "", "@toad  [%[$wiz.toad_msg]]", "  Printed to everyone in the room in which the victim is being @toaded.", "  If you're worried about accidentally toading yourself in the process of", "  setting this message, see above.", "", "@toad_victim  [%[$wiz.toad_victim_msg]]", "  Printed to the victim.", "", "These are pronoun_subbed with victim == dobj." ]
#23 Wizard Help.@who-calls rc = MOOList [ "*forward*", "@grepcore" ]
#23 Wizard Help.@shout rc = MOOList [ "Syntax:  @shout <text>", "", "Broadcasts the given text to all connected players." ]
#23 Wizard Help.@make-player rc = MOOList [ "@make-player name [email-address [commentary]]", "Creates a player.", "Generates a random password for the player.", "Email-address is stored in $registration_db and on the player object.", "Comments should be enclosed in quotes.", "", "Example: @make-player George sanford@frobozz.com "George shares email with Fred Sanford (Fred #5461)"", "", "If the email address is already in use, prompts for confirmation.  If the name is already in use, prompts for confirmation.  (Say no, this is a bug: it will break if you say yes.)  If you say no at one of the confirming prompts, character is not made.", "", "If network is enabled (via $network.active) then asks if you want to mail the password to the user after character is made." ]
#23 Wizard Help.@egrepall rc = MOOList [ "*forward*", "@grep" ]
#23 Wizard Help.news-items rc = MOOList [ "*subst*", "To add a news item:", "", "Send regular mail to *news with the message you want in the news.  Then:", "", "  @addnews <message-number> to %[tostr($news)]", "", "To remove a news item:", "", "  @rmnews <message-number> from %[tostr($news)]", "", "Note, the message date doesn't show up, so you might consider adding a date to the message body itself." ]
#23 Wizard Help.@guests rc = MOOList [ "", "@guests now  [shows information about currently connected guests]", "@guests all  [shows all entries in $guest_log]", "@guests <n>  [shows the last <n> entries of $guest_log]", "", "Note, some wizards prefer to use verbs on $guest_log manually, particularly :last()." ]
#23 Wizard Help.@newt rc = MOOList [ "*subst*", "Syntax:  @newt <player> [commentary]", "         @temp-newt <player> for <period>", "", "The @newt command temporarily prevents logins on a given player.", "It works by adding the player to $login.newted, and for @temp-newt, also adding the player and an end time to $login.temporary_newts.  $login will deny connection to any player in $login.newted, unless they are temporarily newted and their time has expired, in which case it will clean up---denewt them---and allow the connection attempt.  Use @denewt to reverse this.", "", "You must give either the player's full name or its object number.", "Also, this command does not let you @newt yourself.", "", "Mail will be sent to $newt_log, listing the player's .all_connect_places and including any commentary you provide.  E.g.,", "", "  @newt Twit  did real annoying things.", "", "As with @toad and @programmer, there are messages that one may set", "", "@newt  [%[$wiz.newt_msg]]", "  Printed to everyone in the room in which the victim is being @newted.", "  If you're worried about accidentally newting yourself in the process of", "  setting this message, you can't (see above).", "", "@newt_victim  [%[$wiz.newt_victim_msg]]", "  Printed to the victim.  ", "  This is followed by $login:newt_registration_string().", "", "See `help @toad' if you need something more drastic.", "", "The @temp-newt variant of @newt permits you to specify a time period during which this player may not use the MOO.  Time units must be acceptable to $time_utils:parse_english_time_interval." ]
#23 Wizard Help.@players rc = MOOList [ "Syntax:  @players [with objects]", "", "Hmmm... what *does* this do, anyway?" ]
#23 Wizard Help.@redlist rc = MOOList [ "*forward*", "@blacklist" ]
#23 Wizard Help.@abort-shutdown rc = MOOList [ "Syntax:  @abort-sh*utdown [<text>]", "", "This aborts any shutdown currently in progress (i.e., set in motion by @shutdown).  All players are notified that no shutdown will actually occur; <text>, if given will be included in this notification." ]
#23 Wizard Help.redlist rc = MOOList [ "*forward*", "blacklist" ]
#23 Wizard Help.adding-help-text rc = MOOList [ "For information about how the help system itself works and about how to associate local help databases with specific rooms or player classes, see `help $help'.", "", "To get a list of the object numbers associated with various $help databases, type 'help index'.", "", "If you need to modify existing help text, and need to find which help database the relevant property is defined on, use 'help full-index'.  (Note, it's spammy, but tells you what you need to know.)" ]
#23 Wizard Help.forked-tasks rc = MOOList [ "If you are a wizard, '@forked' with no arguments will spam you with all the forked tasks that there are (this is useful sometimes, but it's nice to know ahead of time).", "", "To see just your own, type '@forked me'.  To see just one player's, type '@forked <player>'." ]
#23 Wizard Help.@net-who rc = MOOList [ "Syntax:  @net-who [<player>...]", "         @net-who from [<domain>]", "", "Synonym: @@who", "", "@net-who without any arguments prints all connected users and hosts.  If one or more <player> arguments are given, the specified users are printed along with their current or most recent connected hosts.  If any of these hosts are mentioned on $login.blacklist or $login.graylist (see `help blacklist'), ", "an annotation appears.", "", "With a `from...' argument, this command consults $site_db and prints all players who have ever connected from the given domain." ]
#23 Wizard Help.@grant rc = MOOList [ "Information about generic wizard(#218):@grant/@grants*/@transfer", "----", "@grant <object> to <player>", "@grants <object> to <player>   --- same as @grant but may suspend.", "@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer.", "", "Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).", "", "This verb does the transfer whether the recipient has enough quota for it or not." ]
#23 Wizard Help.@spooflist rc = MOOList [ "*forward*", "@blacklist" ]
#23 Wizard Help.@untoad rc = MOOList [ "Syntax:  @untoad <object> [as <name>,<alias>,<alias>...]", "", "Synonym: @detoad", "", "Turns the object into a player.  ", "If the name/alias... specification is given, the object is also renamed.", "In order for this to work, the object must be a nonplayer descendant of $player and the new object name (or the original name if none is given in the command line) must be available for use as a player name.  As with ordinary player @renaming, any aliases which are unavailable for use as player names are eliminated.", "", "If the object is a descendant of $guest, then it becomes a new guest character.", "Otherwise the object is chowned to itself.  In the latter case, it is advisable to check that the .password property has something nontrivial in it.", "", "If the object is a descendant of $prog, then its .programmer flag is set.", "Note that the .wizard flag is not set under any circumstances." ]
#23 Wizard Help.routine_tasks rc = MOOList [ "There are a number of routine daily or weekly tasks that can help keep your MOO clean or otherwise well-maintained.", "", "", "$byte_quota_utils:schedule_measurement_task", "        If you are using byte quota, this will schedule your quota measurement task.  Every night, every item on the moo which has not been measured in the last $byte_quota_utils.cycle_days will be measured.  A report will be mailed to $byte_quota_utils.report_recipients.  You may wish to edit this verb to change the time that it runs---it will run at midnight PST.", "", "$wiz_utils:expire_mail_weekly", "        If you wish to expire old mail from users and mailing lists, run this verb.  Once a week (scheduled from the first time you type ;$wiz_utils:expire_mail_weekly(), not at a particular hour) it will go through and expire mail based on players' @mail-options settings.", "", "$wiz_utils:flush_editors", "        Once a week this will remove all sessions which were begun more than 30 days ago in the note, verb, and mail editors.  Schedule is from when first typed.", "", "$paranoid_db:semiweeklyish", "        This will go through the @paranoid database and remove entries for players who have not connected within the past three days, and for those users who have turned off the @paranoid function.  Schedule is at 11pm PST.", "", "$login:sample_lag", "        This will provide an estimate of the CPU portion of what is normally called "lag"---that is, the delay between entering a command and having that command fulfilled.", "", "$housekeeper:continuous", "        If you wish to provide players with the ability to have individual items transported to a known starting location, use this verb.", "", "", "Additionally, there are tasks that you don't have to start manually, but which get started by various actions in the MOO.", "", "$network:add_queued_mail", "        This indicates that there was a temporary failure to deliver email.  If this task is constantly in the queue, it is worth checking $network.queued_mail, deleting those which will never be delivered.  Queued mail does not expire.", "", "$housekeeper:move_players_home", "        This task is used to consolidate the tasks spawned by disconnecting players---they get a 5 minute grace period to log back in before they are moved back home." ]
#23 Wizard Help.advertised rc = MOOList [ "Some wizards choose not to be among those listed when a player types '@wizards' (or similar).", "", "The property $wiz.advertised defaults to 1; set it to 0 to remove yourself from the list.", "", "To keep your non-wizard character off the list, set your wizard character's .public_identity character to 0.  To get it back on, set .public_identity to the object number of your non-wizard character.", "", "$wiz_utils:is_wizard returns true for the wizard and the corresponding .public_identity player.  Both will likewise appear in $wiz_utils:connected_wizards_unadvertised() and $wiz_utils:all_wizards_unadvertised().", "", ":is_wizard is for checking permissions on wizard feature-objects and the like, while :all/connected_wizards_unadvertised wouble be for things like wizard-shouts (e.g., the one issued by $player:recycle)." ]
#23 Wizard Help.@grepcore rc = MOOList [ "Syntax:  @grepcore <pattern>", "         @who-calls <verbname>", "", "@grepcore pattern is @grep pattern in {all core objects}.  Core objects are computed for you by #0:core_objects().", "", "@who-calls greps for the verbname + "(", hoping to catch it as a verb call.  Currently @who-calls does not allow you to restrict the search as @grep does.  (Volunteers?)" ]
#23 Wizard Help.@unnewt rc = MOOList [ "*forward*", "@denewt" ]
#23 Wizard Help.@graylist rc = MOOList [ "*forward*", "@blacklist" ]
#23 Wizard Help.mail-lists rc = MOOList [ "You probably want to subscribe to (or at least be familiar with) the following mailing lists:", "", "*Player-Creation-Log", "*New-Prog-Log", "*Quota-Log", "*News", "*Site-Locks", "*Password-Change-Log", "" ]
#23 Wizard Help.@denewt rc = MOOList [ "Syntax:    @denewt <player> [commentary]", "", "Synonyms:  @unnewt", "           @get-better", "", "@denewt reverses the effects of @newt, removing the player from $login.newted, and if appropriate, $login.temporary_newts.", "", "Mail is sent to $newt_log including any commentary you provide.  E.g.,", "", "  @denewt Twit  He promises not to do it again." ]
#23 Wizard Help.@temp-newt rc = MOOList [ "Information about $wiz:@temp-newt", "----", "@temp-newt victim [for duration] [reason]", "", "Temporarily newts victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. E will be automatically removed the first time e tries to connect after the duration expires.  You will be prompted for a reason for the newting, but as of this writing, specifying a reason from the command line isn't an option." ]
#23 Wizard Help.@detoad rc = MOOList [ "*forward*", "@untoad" ]
#23 Wizard Help.spooflist rc = MOOList [ "*forward*", "blacklist" ]
#23 Wizard Help.blacklist rc = MOOList [ "", "The Site Blacklist", "------------------", "$login maintains three lists of hosts/domains to support player registration schemes and blocking of connections from highly untrusted hosts:", "", "  .redlist   -- all connections from these sites are disabled ", "  .blacklist -- player creation and guest logins are disabled", "  .graylist  -- advisory list of potential trouble spots (putting a site on the", "                .graylist merely annotates it in @net-who listings).", "  .spooflist -- guests from these sites cannot use @request to request ", "                a character", "", "The lists are kept in a special format so it is highly recommended that you ", "either use $wiz:@*list/@un*list or the following verbs to query/update the ", "respective lists rather than bash them directly:", "", "  $login:*listed     (host)              is host is on .*list?", "  $login:*list_add   (domain or subnet)  add domain or subnet to .*list", "  $login:*list_remove(domain or subnet)  remove domain or subnet from .*list", "", "where `*' is one of `black', `red', `gray', or `spoof'.", "", "There are also temporary versions of the above four lists, stored in associated $login.temporary_*list in the same format, except two additional bits of data are stored.  The time the temporary *listing started, and the duration that it will last.  In addition there exists:", "", "  $login:*list_add_temp(domain or subnet, start time, duration)", "  $login:*list_remove_temp(domain or subnet)", "", "When the normal $login:*listed verb is called, both the regular *list and the temporary *list are checked.  If the host is on the temporary list, then the length of MOO up time since the start time is checked against the duration.  If expired, the host is removed from the temporary *list and a false value is returned (meaning that the host is not *listed).", "", "One may either specify a domain name (e.g., "baz.edu") or a numeric IP address (e.g., "36.0.23.17").  Domain names match all hosts underneath that domain, so, e.g., puting "baz.edu" on a list effectively adds "x.bax.edu" for all x as well.  ", "Likewise, an incomplete numeric address, e.g., "128.42" will match that entire subnet, in this case all hosts whose IP numbers have the form "128.42.m.n" for arbitrary integers m and n.", "", "One may also give a domain name containing a wildcard ("*"), e.g., "fritz*.baz.edu", in which case all hostnames matching in the sense of $string_utils:match_string() are considred to be on the list.  Wildcard matching should be avoided since it is more time-consuming.", "", "It should be noted that, since there is no direct access to the domain name service from within the MOO, it is possible for a host to be blacklisted or redlisted via its domain name, and yet have someone be able to connect from that host (and, in the case of a blacklisted host, create a character) --- this can happen if the name service is down and connection_name() on that player thus has given the numeric IP address rather than the domain name.  Similarly, if you list a host by IP number alone, it will still be possible to get in via the site's domain name.  Thus to be completely assured of shutting out a site, you need to list it both by domain name and IP number." ]
#23 Wizard Help.@new-password rc = MOOList [ "@new-password player is [password]", "Sets a player's password; omit password string to have one randomly generated.  Prints the encrypted old string when done for error recovery.  [No current software will allow you to give the encrypted string as input.]", "", "Offers to send mail to the user with the new password, if the user has a registered email address and the network is enabled." ]
#23 Wizard Help.@chown# rc = MOOList [ "*forward*", "@chown" ]
#23 Wizard Help.@grepall rc = MOOList [ "*forward*", "@grep" ]
#23 Wizard Help.@dump-database rc = MOOList [ "Syntax:  @dump-database", "", "Invokes the builtin dump_database(), which requests that the server checkpoint the database at its next opportunity.  It is not normally necessary to call this function; the server automatically checkpoints the database at regular intervals; see the chapter on server assumptions about the database for details." ]
#23 Wizard Help.recycling-players rc = MOOList [ "General procedure:", "", "  Make sure e doesn't own anything.", "  @toad em", "  @recycle em", "", "It makes a real mess if you don't clean up .owned_objects.  See $wiz_utils:initialize_owned, but note, running this verb takes maybe three hours (at last report) and adds to lag.  This is why we frown so severely on leaving blood on the carpet." ]
================================#24 Wizard Utilities===============================================
#24 Wizard Utilities.chparent_restricted  = MOOList [ ]
#24 Wizard Utilities.missed_help_counters r = MOOList [ ]
#24 Wizard Utilities.default_player_quota rc = MOONumber 7
#24 Wizard Utilities.programmer_restricted rc = MOOList [ ]
#24 Wizard Utilities.system_chars rc = MOOList [ #36, #38, #71 ]
#24 Wizard Utilities.suicide_string rc = MOOString "You don't *really* want to commit suicide, do you?"
#24 Wizard Utilities.expiration_progress rc = MOOObjRef #-1
#24 Wizard Utilities.rename_restricted  = MOOList [ ]
#24 Wizard Utilities.record_missed_help rc = MOONumber 0
#24 Wizard Utilities.next_perm_index rc = MOONumber 1
#24 Wizard Utilities.old_task_perms_user rc = MOOList [ #8060 ]
#24 Wizard Utilities.new_core_message r = MOOList [ "Getting Started with your LambdaCore MOO", "========================================", "", "Thank you for choosing LambdaCore!", "", "Initial Setup Notes", "-------------------", "", "The "welcome" screen, seen when a player connects.", "  -- this is stored in $login.welcome_message", "", "Do you want on-line character creation?", "  -- this is stored in $login.create_enabled", "     for more detailed information, edit $login:player_creation_enabled", "", "Do you want to limit the number of players on the MOO at once?", "  -- look at $login.max_connections", "     the `connection_limit' message on $login is the message printed", "     when this limit is reached.", "", "Do you want a different default player class?", "  -- set $player_class to a different value", "     *do not* change $player", "", "You should also set the following:", "  $network.postmaster", "    -- your email address, or the email address of the person who will ", "       handle your email", "  $network.site", "    -- the machine your MOO is running on (e.g. "lambda.moo.mud.org")", "  $network.port", "    -- the port your MOO is running on (e.g. 8888)", "  $network.MOO_Name", "    -- the name of your MOO (e.g. "LambdaMOO")", "  $site_db.domain", "  -- this is set to the `domain' of your address", "     (eg `foo.com' for `moo.foo.com')", "", "If you compiled the server with open_network_connection() enabled (allowing the MOO to open up connections with other computers on the network), then you should set", "  $network.active = 1", "     This will enable @newpassword, @registerme, @password, @mailme, @netforward, and others to send mail from the MOO.", "", "-------------------------------------------------------------------", "", "Setting Yourself Up", "-------------------", "", "Set a password for yourself.", "  -- @password <new-password>", "", "Set a description for yourself.", "  -- @describe me as <anything>", "", "Set a gender for yourself.", "  -- @gender <gender>", "", "There are, also, a large number of messages you can set on yourself.  Setting them will enhance the virtual reality.", "", "-------------------------------------------------------------------", "", "About Guests", "------------", "", "To make a new Guest character:", "  -- @make-guest <guestname>", "     will make a new guest with the name you specify with `_Guest' appended", "     and some other standard but useful aliases", "", "This is the easiest way to make Guest characters.  The most important things to remember about Guests, if you want to make them yourself, are:", "  -- make them owned by nonwizards, and not owned by themselves", "  -- make sure they've got .password == 0, and that .password is nonclear", "  -- at least one Guest must always be named `Guest'; this can be an alias", "", "To set the default description and gender for a guest:", "  -- set .default_description to the description the guest should start with", "  -- set .default_gender to the gender the guest should start with", "  -- remember to set .description and .gender too, for the guest's first use", "", "-------------------------------------------------------------------", "", "Adding to the Newspaper", "-----------------------", "", "The newspaper is a special mailing list.  To add a post to the newspaper, send mail to it (as *News or $news), and then note the number of your post (let's call it <x> and:", "  -- @addnews <x> to *News", "... in general, `@addnews $ to *News' will work as well.", "", "-------------------------------------------------------------------", "", "Quota", "-----", "", "By default, LambdaCore runs with byte-based quota, an in-DB quota system, limiting users by total database space as opposed to total objects.  You'll need to do two things:", "  -- decide on the default quota:", "     ;$byte_quota_utils.default_quota[1] = <a number of bytes>", "  -- start the measurement task; see `help routine_tasks' for more information (Note: this help topic contains information about more than just the quota task; it should be read regardless of how quota is set).", "", "If you prefer the quota system documented in the LambdaMOO Programmer's Manual, directly supported by the server, you can enable object-based quota:", "  -- set $quota_utils to $object_quota_utils", "", "It's best that you make this switch before users start, because converting existing users is an awkward (and inherently arbitrary and political) move.", "", "-------------------------------------------------------------------", "", "Making Programmers", "------------------", "", "The command to turn someone into a programmer is `@programmer'  Its syntax is `@programmer <user>'.  For example:", "  -- @programmer Haakon", "The `@programmer' verb will prompt you if the user isn't set up with a description and a gender.", "", "No code to automatically grant programmer bits is included with LambdaCore.", "", "Making Wizards", "--------------", "", "THINK CAREFULLY.", "", "Be very careful before giving someone a wizard bit.  That person can do gross damage to your database, and fixable but serious damage to the machine it runs on.  That person can quite possibly open outbound network connections from your machine, and thus commit acts for which your host system will be blamed.  That person can ruin your MOO's as-yet-untarnished reputation.", "", "Wizards have technical power, the ability to change anything within the database, to create anything within the database.  Be careful with the idea of a `Social Wizard' -- a nontechnical person holding a wizard bit is fairly likely to, at some point, accidentally do something destructive.  It's a good idea not to socialize as your wizard character, for the same reason, to make it less likely to be accidentally destructive.", "", "That said, in general you don't turn an existing character into a wizard, you make a -new- character to be the wizard.  This is because the existing character probably owns code and objects which could be destructive if suddenly made wizardly; it's a good security measure to make a fresh player.  So, to make a fresh player:", "  -- @make-player (see `help @make-player' for more information)", "     this will make you a new player. for this example, #123", "", "To make #123 a wizard:", "  -- @programmer #123", "     (a nonprogrammer wizard is a truly strange beast)", "  -- ;#123.wizard = 1;", "  -- @chparent #123 to $wiz", "  -- ;#123.public_identity = <the player's nonwizard character's object number>", "", "-------------------------------------------------------------------", "", "Good luck with your new LambdaCore database!", "", "Visit us at LambdaMOO: lambda.moo.mud.org 8888", "", "Join the international mailing list for MOO coders: send an email message to moo-cows-request@the-b.org with the word `subscribe' as the body of your message.", "", "Do good things.", "", "The LambdaMOO Wizards", "[authored February 15, 1999]" ]
#24 Wizard Utilities.missed_help_strings r = MOOList [ ]
#24 Wizard Utilities.default_programmer_quota rc = MOONumber 7
#24 Wizard Utilities.change_password_restricted  = MOOList [ ]
#24 Wizard Utilities.expiration_recipient rc = MOOList [ #2 ]
#24 Wizard Utilities.boot_exceptions rc = MOOList [ ]
#24 Wizard Utilities.boot_task rc = MOONumber 585440461
#24 Wizard Utilities.programmer_restricted_temp rc = MOOList [ ]
#24 Wizard Utilities.registration_domain_restricted rc = MOONumber 0
#24 Wizard Utilities.wizards rc = MOOList [ #2 ]
#24 Wizard Utilities:set_programmer this n/a this
":set_programmer(victim[,mail from])  => 1 or error.";
"Sets victim.programmer, chparents victim to $prog if necessary, and sends mail to $new_prog_log, mail is from optional second arg or caller_perms().";
whodunnit = caller_perms();
{victim, ?mailfrom = whodunnit} = args;
if (!whodunnit.wizard)
return E_PERM;
elseif (!(valid(victim) && (is_player(victim) && $object_utils:isa(victim, $player))))
return E_INVARG;
elseif (victim.programmer)
return E_NONE;
elseif (this:check_prog_restricted(victim))
return E_INVARG;
elseif (typeof(e = `victim.programmer = 1 ! ANY') == ERR)
return e;
else
$quota_utils:adjust_quota_for_programmer(victim);
if (!$object_utils:isa(victim, $prog))
if (typeof(e = `chparent(victim, $prog) ! ANY') == ERR)
"...this isn't really supposed to happen but it could...";
player:notify(tostr("chparent(", victim, ",", $prog, ") failed:  ", e));
player:notify("Check for common properties.");
endif
else
player:notify(tostr(victim.name, " was already a child of ", parent(victim).name, " (", parent(victim), ")"));
endif
if (!$mail_agent:send_message(mailfrom, {$new_prog_log, victim}, tostr("@programmer ", victim.name, " (", victim, ")"), tostr("I just gave ", victim.name, " a programmer bit."))[1])
$mail_agent:send_message(mailfrom, {$new_prog_log}, tostr("@programmer ", victim.name, " (", victim, ")"), tostr("I just gave ", victim.name, " a programmer bit."));
endif
return 1;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:set_player this n/a this
":set_player(victim[,nochown]) => 1 or error";
"Set victim's player flag, (maybe) chown to itself, add name and aliases to $player_db.";
" E_NONE == already a player,";
" E_NACC == player_db is frozen,";
" E_RECMOVE == name is unavailable";
{victim, ?nochown = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!(valid(victim) && $object_utils:isa(victim, $player)))
return E_INVARG;
elseif (is_player(victim))
return E_NONE;
elseif ($player_db.frozen)
return E_NACC;
elseif (!$player_db:available(name = victim.name))
return E_RECMOVE;
else
set_player_flag(victim, 1);
if (0 && $object_utils:isa(victim, $prog))
victim.programmer = 1;
else
victim.programmer = $player.programmer;
endif
if (!nochown)
$wiz_utils:set_owner(victim, victim);
endif
$player_db:insert(name, victim);
for a in (setremove(aliases = victim.aliases, name))
if (index(a, " "))
"..ignore ..";
elseif ($player_db:available(a) in {this, 1})
$player_db:insert(a, victim);
else
aliases = setremove(aliases, a);
endif
endfor
victim.aliases = setadd(aliases, name);
return 1;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:set_owner this n/a this
":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug).";
{object, newowner, ?suspendok = 0} = args;
if (!valid(object))
return E_INVIND;
elseif (!caller_perms().wizard)
return E_PERM;
elseif (!(valid(newowner) && is_player(newowner)))
return E_INVARG;
endif
oldowner = object.owner;
object.owner = newowner;
for pname in ($object_utils:all_properties(object))
if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))
suspend(0);
endif
perms = property_info(object, pname)[2];
if (index(perms, "c"))
set_property_info(object, pname, {newowner, perms});
endif
endfor
if ($object_utils:isa(oldowner, $player))
if (is_player(oldowner) && (object != oldowner))
$quota_utils:reimburse_quota(oldowner, object);
endif
if (typeof(oldowner.owned_objects) == LIST)
oldowner.owned_objects = setremove(oldowner.owned_objects, object);
endif
endif
if ($object_utils:isa(newowner, $player))
if (object != newowner)
$quota_utils:charge_quota(newowner, object);
endif
if (typeof(newowner.owned_objects) == LIST)
newowner.owned_objects = setadd(newowner.owned_objects, object);
endif
endif
return 1;
-------------------------------------------------------------------------------
#24 Wizard Utilities:set_property_owner this n/a this
":set_property_owner(object,prop,newowner[,suspendok])  changes the ownership of object.prop to newowner.  If the property is !c, changes the ownership on all of the descendents as well.  Otherwise, we just chown the property on the object itself and give a warning if newowner!=object.owner (--Rog thinks this is a server bug that one is able to do this at all...).";
{object, pname, newowner, ?suspendok = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!(info = `property_info(object, pname) ! ANY'))
"... handles E_PROPNF and invalid object errors...";
return info;
elseif (!is_player(newowner))
return E_INVARG;
elseif (index(info[2], "c"))
if (suspendok / 2)
"...(recursive call)...";
"...child property is +c while parent is -c??...RUN AWAY!!";
return E_NONE;
else
set_property_info(object, pname, listset(info, newowner, 1));
return (newowner == object.owner) || E_NONE;
endif
else
set_property_info(object, pname, listset(info, newowner, 1));
if ((suspendok % 2) && ((ticks_left() < 10000) || (seconds_left() < 2)))
suspend(0);
endif
suspendok = 2 + suspendok;
for c in (children(object))
this:set_property_owner(c, pname, newowner, suspendok);
endfor
return 1;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:unset_player this n/a this
":unset_player(victim[,newowner])  => 1 or error";
"Reset victim's player flag, chown victim to newowner (if given), remove all of victim's names and aliases from $player_db.";
{victim, ?newowner = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!valid(victim))
return E_INVARG;
elseif (!is_player(victim))
return E_NONE;
endif
if (typeof(newowner) == OBJ)
$wiz_utils:set_owner(victim, newowner);
endif
victim.programmer = 0;
victim.wizard = 0;
set_player_flag(victim, 0);
if ($object_utils:has_property($local, "second_char_registry"))
$local.second_char_registry:delete_player(victim);
`$local.second_char_registry:delete_shared(victim) ! ANY';
endif
if ($player_db.frozen)
player:tell("Warning:  player_db is in the middle of a :load().");
endif
$player_db:delete2(victim.name, victim);
for a in (victim.aliases)
$player_db:delete2(a, victim);
"I don't *think* this is bad---we've already toaded the guy.  And folks with lots of aliases screw us. --Nosredna";
$command_utils:suspend_if_needed(0);
endfor
return 1;
"Paragraph (#122534) - Sat Nov 5, 2005 - Remove any shared character registry listings for `victim'.";
-------------------------------------------------------------------------------
#24 Wizard Utilities:set_property_flags this n/a this
":set_property_flags(object,prop,flags[,suspendok])  changes the permissions on object.prop to flags.  Unlike a mere set_property_info, this changes the flags on all descendant objects as well.  We also change the ownership on the descendent properties where necessary.";
{object, pname, flags, ?suspendok = 0} = args;
perms = caller_perms();
if (!(info = `property_info(object, pname) ! ANY'))
"... handles E_PROPNF and invalid object errors...";
return info;
elseif ($set_utils:difference($string_utils:char_list(flags), {"r", "w", "c"}))
"...not r, w, or c?...";
return E_INVARG;
elseif ((pinfo = `property_info(parent(object), pname) ! ANY') && (flags != pinfo[2]))
"... property doesn't actually live here...";
"... only allowed to correct so that this property matches parent...";
return E_INVARG;
elseif (!(perms.wizard || (info[1] == perms)))
"... you have to own the property...";
return E_PERM;
elseif (!(((!(c = index(flags, "c"))) == (!index(info[2], "c"))) || $perm_utils:controls(perms, object)))
"... if you're changing the c flag, you have to own the object...";
return E_PERM;
else
if (c)
set_property_info(object, pname, {object.owner, kflags = flags});
else
set_property_info(object, pname, kflags = listset(info, flags, 2));
endif
for kid in (children(object))
this:_set_property_flags(kid, pname, kflags, suspendok);
endfor
return 1;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:_set_property_flags this n/a this
"_set_property_flags(object, pname, {owner, flags} or something+\"c\", suspendok)";
"auxiliary to :set_property_flags... don't call this directly.";
if (caller != this)
return E_PERM;
endif
if (args[4] && $command_utils:running_out_of_time(0))
suspend(0);
endif
object = args[1];
if (typeof(args[3]) != LIST)
set_property_info(object, args[2], {object.owner, args[3]});
else
set_property_info(@args[1..3]);
endif
for kid in (children(object))
this:_set_property_flags(@listset(args, kid, 1));
endfor
-------------------------------------------------------------------------------
#24 Wizard Utilities:random_password this n/a this
"Generate a random password of length args[1].  Alternates vowels and consonants, for maximum pronounceability.  Uses its own list of consonants which exclude F and C and K to prevent generating obscene sounding passwords.";
"Capital I and lowercase L are excluded on the basis of looking like each other.";
vowels = "aeiouyAEUY";
consonants = "bdghjmnpqrstvwxzBDGHJLMNPQRSTVWXZ";
len = toint(args[1]);
if (len)
alt = random(2) - 1;
s = "";
for i in [1..len]
newchar = alt ? vowels[random($)] | consonants[random($)];
s = s + newchar;
alt = !alt;
endfor
return s;
else
return E_INVARG;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:queued_tasks this n/a this
":queued_tasks(player) => list of queued tasks for that player.";
"shouldn't the server builtin should work this way?  oh well";
set_task_perms(caller_perms());
if (typeof(e = `set_task_perms(who = args[1]) ! ANY') == ERR)
return e;
elseif (who.wizard)
tasks = {};
for t in (queued_tasks())
if (t[5] == who)
tasks = {@tasks, t};
endif
endfor
return tasks;
else
return queued_tasks();
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:isnewt this n/a this
"Return 1 if args[1] is a newted player.";
if (!caller_perms().wizard)
return E_PERM;
else
return args[1] in $login.newted;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:initialize_owned this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
set_task_perms(caller_perms());
player:tell("Beginning initialize_owned:  ", ctime());
for o in [#0..max_object()]
if (valid(o))
if ($object_utils:isa(owner = o.owner, $player) && (typeof(owner.owned_objects) == LIST))
owner.owned_objects = setadd(owner.owned_objects, o);
endif
endif
$command_utils:suspend_if_needed(0);
endfor
player:tell("Done adding, beginning verification pass.");
this:verify_owned_objects();
player:tell("Finished:  ", ctime());
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:verify_owned_objects this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
for p in (players())
if (typeof(p.owned_objects) == LIST)
for o in (p.owned_objects)
if (((typeof(o) != OBJ) || (!valid(o))) || (o.owner != p))
p.owned_objects = setremove(p.owned_objects, o);
player:tell("Removed ", $string_utils:nn(o), " from ", $string_utils:nn(p), "'s .owned_objects list.");
if (((typeof(o) == OBJ) && valid(o)) && (typeof(o.owner.owned_objects) == LIST))
o.owner.owned_objects = setadd(o.owner.owned_objects, o);
endif
endif
$command_utils:suspend_if_needed(0, p);
endfor
endif
endfor
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:connected_wizards connected_wizards_unadvertised this n/a this
":connected_wizards() => list of currently connected wizards and players mentioned in .public_identity properties as being wizard counterparts.";
wizzes = $object_utils:leaves($wiz);
wlist = {};
everyone = verb == "connected_wizards_unadvertised";
for w in (wizzes)
if (w.wizard && (w.advertised || everyone))
if (`connected_seconds(w) ! ANY => 0')
wlist = setadd(wlist, w);
endif
if (`connected_seconds(w.public_identity) ! ANY => 0')
wlist = setadd(wlist, w.public_identity);
endif
endif
endfor
return wlist;
-------------------------------------------------------------------------------
#24 Wizard Utilities:all_wizards_advertised all_wizards all_wizards_unadvertised this n/a this
":all_wizards_advertised() => list of all wizards who have set .advertised true and players mentioned their .public_identity properties as being wizard counterparts";
wizzes = $object_utils:leaves($wiz);
wlist = {};
everyone = verb == "all_wizards_unadvertised";
for w in (wizzes)
if (w.wizard && (w.advertised || everyone))
if (is_player(w))
wlist = setadd(wlist, w);
endif
if (`is_player(w.public_identity) ! ANY')
wlist = setadd(wlist, w.public_identity);
endif
endif
endfor
return wlist;
-------------------------------------------------------------------------------
#24 Wizard Utilities:rename_all_instances this n/a this
":rename_all_instances(object,oldname,newname)";
"Used to rename all instances of an unwanted verb (like recycle or disfunc)";
"if said verb is actually defined on the object itself";
if (caller_perms().wizard)
found = 0;
{object, oldname, newname} = args;
while (info = `verb_info(object, oldname) ! ANY')
`set_verb_info(object, oldname, listset(info, newname, 3)) ! ANY';
found = 1;
endwhile
return found;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:missed_help this n/a this
if (this.record_missed_help && (callers()[1][4] == $player))
miss = args[1];
if (!(index = miss in this.missed_help_strings))
this.missed_help_strings = {miss, @this.missed_help_strings};
this.missed_help_counters = {{0, 0}, @this.missed_help_counters};
index = 1;
endif
which = args[2] ? 2 | 1;
this.missed_help_counters[index][which] = this.missed_help_counters[index][which] + 1;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:show_missing_help this n/a this
mhs = this.missed_help_strings;
cnt = this.missed_help_counters;
"save values first, so subsequent changes during suspends wont affect it";
thresh = args ? args[1] | 5;
strs = {};
for i in [1..length(mhs)]
$command_utils:suspend_if_needed(0);
if ((cnt[i][1] + cnt[i][2]) > thresh)
strs = {@strs, ((($string_utils:right(tostr(cnt[i][1]), 5) + " ") + $string_utils:right(tostr(cnt[i][2]), 5)) + " ") + mhs[i]};
endif
endfor
sorted = $list_utils:sort_suspended(0, strs);
len = length(sorted);
player:tell(" miss ambig word");
for x in [1..len]
$command_utils:suspend_if_needed(0);
player:tell(sorted[(len - x) + 1]);
endfor
player:tell(" - - - - - - - - -");
-------------------------------------------------------------------------------
#24 Wizard Utilities:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
`delete_property(this, "guest_feature_restricted") ! ANY';
this.boot_exceptions = {};
this.programmer_restricted = {};
this.programmer_restricted_temp = {};
this.chparent_restricted = {};
this.rename_restricted = {};
this.change_password_restricted = {};
this.record_missed_help = 0;
this.missed_help_counters = this.missed_help_strings = {};
this.suicide_string = "You don't *really* want to commit suicide, do you?";
this.wizards = {#2};
this.next_perm_index = 1;
this.system_chars = {$hacker, $no_one, $housekeeper};
this.expiration_progress = $nothing;
this.expiration_recipient = {#2};
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:show_netwho_listing this n/a this
":show_netwho_listing(tell,player_list)";
" prints a listing of the indicated players showing connect sites.";
{who, unsorted} = args;
if (!caller_perms().wizard)
return E_PERM;
endif
if (!unsorted)
return;
endif
su = $string_utils;
alist = {};
footnotes = {};
nwidth = length("Player name");
for u in (unsorted)
$command_utils:suspend_if_needed(0);
if (u.programmer)
pref = "% ";
footnotes = setadd(footnotes, "prog");
else
pref = "  ";
endif
if (u in connected_players())
lctime = ctime(time() - connected_seconds(u));
where = connection_name(u);
else
lctime = ctime(u.last_connect_time);
where = u.last_connect_place;
endif
name = u.name;
if (length(name) > 15)
name = name[1..13] + "..";
endif
u3 = {tostr(pref, u.name, " (", u, ")"), lctime[5..10] + lctime[20..24]};
nwidth = max(length(u3[1]), nwidth);
where = $string_utils:connection_hostname(where);
if ($login:blacklisted(where))
where = "(*) " + where;
footnotes = setadd(footnotes, "black");
elseif ($login:graylisted(where))
where = "(+) " + where;
footnotes = setadd(footnotes, "gray");
endif
alist = {@alist, {@u3, where}};
endfor
alist = $list_utils:sort_alist_suspended(0, alist, 3);
$command_utils:suspend_if_needed(0);
headers = {"Player name", "Last Login", "From Where"};
before = {0, nwidth + 3, (nwidth + length(ctime(0))) - 11};
tell1 = "  " + headers[1];
tell2 = "  " + su:space(headers[1], "-");
for j in [2..3]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
who:notify(tell1);
who:notify(tell2);
for a in (alist)
$command_utils:suspend_if_needed(0);
tell1 = a[1];
for j in [2..3]
tell1 = su:left(tell1, before[j]) + a[j];
endfor
who:notify(tell1[1..min($, 79)]);
endfor
if (footnotes)
who:notify("");
if ("prog" in footnotes)
who:notify(" %  == programmer.");
endif
if ("black" in footnotes)
who:notify("(*) == blacklisted site.");
endif
if ("gray" in footnotes)
who:notify("(+) == graylisted site.");
endif
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:show_netwho_from_listing this n/a this
":show_netwho_from_listing(tell,site)";
"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.";
if (!caller_perms().wizard)
return E_PERM;
endif
{tellwho, where} = args;
su = $string_utils;
if (!index(where, "*"))
"Oh good... search for users from a site... the fast way.  No wild cards.";
nl = 0;
bozos = {};
sites = $site_db:find_all_keys(where);
while (sites)
s = sites;
sites = {};
for domain in (s)
"Temporary kluge until $site_db is repaired. --Nosredna";
for b in ($site_db:find_exact(domain) || {})
$command_utils:suspend_if_needed(0, "..netwho..");
if (typeof(b) == STR)
sites = setadd(sites, (b + ".") + domain);
else
bozos = setadd(bozos, b);
nl = max(length(tostr(b, (valid(b) && is_player(b)) ? b.name | "*** recreated ***")), nl);
endif
endfor
endfor
endwhile
if (bozos)
tellwho:notify(tostr(su:left("  Player", nl + 7), "From"));
tellwho:notify(tostr(su:left("  ------", nl + 7), "----"));
for who in (bozos)
st = su:left(tostr((valid(who) && is_player(who)) ? (who.programmer ? "% " | "  ") + who.name | "", " (", who, ")"), nl + 7);
comma = 0;
if ($object_utils:isa(who, $player) && is_player(who))
for p in ({$wiz_utils:get_email_address(who) || "*Unregistered*", @who.all_connect_places})
if (comma && (length(p) >= (78 - length(st))))
tellwho:notify(tostr(st, ","));
st = su:space(nl + 7) + p;
else
st = tostr(st, comma ? ", " | "", p);
endif
comma = 1;
$command_utils:suspend_if_needed(0);
endfor
else
st = st + (valid(who) ? "*** recreated ***" | "*** recycled ***");
endif
tellwho:notify(st);
endfor
tellwho:notify("");
tellwho:notify(tostr(length(bozos), " player", (length(bozos) == 1) ? "" | "s", " found."));
else
tellwho:notify(tostr("No sites matching `", where, "'"));
endif
else
"User typed 'from'.  Go search for users from this site.  (SLOW!)";
howmany = 0;
for who in (players())
$command_utils:suspend_if_needed(0);
matches = {};
for name in (who.all_connect_places)
if ((index(where, "*") && su:match_string(name, where)) || ((!index(where, "*")) && index(name, where)))
matches = {@matches, name};
endif
endfor
if (matches)
howmany = howmany + 1;
tellwho:notify(tostr(who.name, " (", who, "): ", su:english_list(matches)));
endif
endfor
tellwho:notify(tostr(howmany || "No", " matches found."));
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:check_player_request check_reregistration this n/a this
":check_player_request(name [,email [,connection]])";
" check if the request for player and email address is valid;";
" return empty string if it valid, or else a string saying why not.";
" The result starts with - if this is a 'send email, don't try again' situation.";
":check_reregistration(who, email, connection)";
"  Since name is ignored, only check the 'email' parts and use the first arg";
"  for the re-registering player.";
if (!caller_perms().wizard)
return E_PERM;
"accesses registration information -- wiz only";
endif
name = args[1];
if (verb == "check_reregistration")
"don't check player name";
elseif (!name)
return "A blank name isn't allowed.";
elseif (name == "<>")
return "Names with angle brackets aren't allowed.";
elseif (index(name, " "))
return "Names with spaces are not allowed. Use dashes or underscores.";
elseif (match(name, "^<.*>$"))
return tostr("Try using ", name[2..$ - 1], " instead of ", name, ".");
elseif ($player_db.frozen)
return "New players cannot be created at the moment, try again later.";
elseif (!$player_db:available(name))
return ("The name '" + name) + "' is not available.";
elseif ($login:_match_player(name) != $failed_match)
return ("The name '" + name) + "' doesn't seem to be available.";
endif
if (length(args) == 1)
"no email address supplied.";
return "";
endif
address = args[2];
addrargs = (verb == "check_reregistration") ? {name} | {};
if ($registration_db:suspicious_address(address, @addrargs))
return "-There has already been a character with that or a similar email address.";
endif
if (reason = $network:invalid_email_address(address))
return reason + ".";
endif
parsed = $network:parse_address(address);
if ($registration_db:suspicious_userid(parsed[1]))
return tostr("-Automatic registration from an account named ", parsed[1], " is not allowed.");
endif
connection = (length(args) > 2) ? args[3] | parsed[2];
check_connection = $wiz_utils.registration_domain_restricted && (verb == "check_player_request");
if ((connection[max($ - 2, 1)..$] == ".uk") && (parsed[2][1..3] == "uk."))
return tostr("Addresses must be in internet form. Try ", parsed[1], "@", $string_utils:from_list($list_utils:reverse($string_utils:explode(parsed[2], ".")), "."), ".");
elseif (check_connection && match(connection, "^[0-9.]+$"))
"Allow reregistration from various things we wouldn't allow registration from.  Let them register to their yahoo acct...";
return "-The system cannot resolve the name of the system you're connected from.";
elseif (check_connection && ((a = $network:local_domain(connection)) != (b = $network:local_domain(parsed[2]))))
return tostr("-The connection is from '", a, "' but the mail address is '", b, "'; these don't seem to be the same place.");
elseif ((verb == "check_player_request") && $login:spooflisted(parsed[2]))
return tostr("-Automatic registration is not allowed from ", parsed[2], ".");
endif
return "";
-------------------------------------------------------------------------------
#24 Wizard Utilities:make_player this n/a this
"create a player named NAME with email address ADDRESS; return {object, password}.  Optional third arg is comment to be put in registration db.";
"assumes $wiz_utils:check_player_request() has been called and it passes.";
if (!caller_perms().wizard)
return E_PERM;
endif
{name, address, @rest} = args;
new = $quota_utils:bi_create($player_class, $nothing);
new.name = name;
new.aliases = {name};
new.password = crypt(password = $wiz_utils:random_password(5));
new.last_password_time = time();
new.last_connect_time = $maxint;
"Last disconnect time is creation time, until they login.";
new.last_disconnect_time = time();
$quota_utils:initialize_quota(new);
if (!(error = $wiz_utils:set_player(new)))
return player:tell("An error, ", error, " occurred while trying to make ", new, " a player. The database is probably inconsistent.");
endif
$wiz_utils:set_email_address(new, address);
$registration_db:add(new, address, @rest);
move(new, $player_start);
new.programmer = $player_class.programmer;
return {new, password};
-------------------------------------------------------------------------------
#24 Wizard Utilities:send_new_player_mail this n/a this
":send_new_player_mail(preface, name, address, character#, password)";
"  used by $wiz:@make-player and $guest:@request";
if (!caller_perms().wizard)
return E_PERM;
endif
{preface, name, address, new, password} = args;
msg = {preface};
msg = {@msg, tostr("A character has been created, with name \"", name, "\" and password \"", password, "\"."), "Passwords are case sensitive, which means you have to type it exactly as", "it appears here, including capital and lowercase letters.", "So, to log in, you would type:", tostr("  Connect ", name, " ", password)};
if ($object_utils:has_property($local, "new_player_message"))
msg = {@msg, @$local.new_player_message};
endif
return $network:sendmail(address, (("Your " + $network.moo_name) + " character, ") + name, "Reply-to: " + $login.registration_address, @msg);
-------------------------------------------------------------------------------
#24 Wizard Utilities:do_make_player any ?-2? any
"do_maker_player(name,email,[comment])";
"Common code for @make-player";
"If no password is given, generates a random password for the player.";
"Email-address is stored in $registration_db and on the player object.";
if (!caller_perms().wizard)
return E_PERM;
endif
{name, email, @comments} = args;
comments = $string_utils:from_list(comments, " ");
reason = $wiz_utils:check_player_request(name, email);
if (others = $registration_db:find_exact(email))
player:notify(email + " is the registered address of the following characters:");
for x in (others)
player:notify(tostr(valid(x[1]) ? x[1].name | "<recycled>", (valid(x[1]) && (!is_player(x[1]))) ? " {nonplayer}" | "", " (", x[1], ") ", (length(x) > 1) ? ("[" + tostr(@x[2..$])) + "]" | ""));
endfor
if (!reason)
reason = "Already registered.";
endif
endif
if (reason)
player:notify(reason);
if (!$command_utils:yes_or_no("Create character anyway? "))
player:notify("Character not created.");
return;
endif
endif
new = $wiz_utils:make_player(name, email, comments);
player:notify(tostr(name, " (", new[1], ") created with password `", new[2], "' for ", email, comments ? (" [" + comments) + "]" | ""));
$mail_agent:send_message(player, $new_player_log, tostr(name, " (", new[1], ")"), tostr(email, comments ? " " + comments | ""));
if ($network.active)
if ($command_utils:yes_or_no(("Send email to " + email) + " with password? "))
player:notify(tostr("Sending the password to ", email, "."));
if ((result = $wiz_utils:send_new_player_mail(tostr("From ", player.name, "@", $network.moo_name, ":"), name, email, new[1], new[2])) == 0)
player:notify(tostr("Mail sent successfully to ", email, "."));
else
player:tell("Cannot send mail: ", result);
endif
else
player:notify("No mail sent.");
endif
else
player:notify("Sorry, the network isn't active.");
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:do_register this n/a this
"do_register(name, email_address [,comments])";
"change player's email address.";
if (!caller_perms().wizard)
return E_PERM;
endif
{whostr, email, @comments} = args;
comments = $string_utils:from_list(comments);
who = $string_utils:match_player(whostr);
if ($command_utils:player_match_failed(who, whostr))
return;
endif
if (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))
player:notify(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
return;
endif
if (reason = $network:invalid_email_address(email))
player:notify(reason);
if (!$command_utils:yes_or_no("Register anyway?"))
return player:notify("re-registration aborted.");
endif
endif
if (comments)
$registration_db:add(who, email, comments);
else
$registration_db:add(who, email);
endif
old = $wiz_utils:get_email_address(who);
$wiz_utils:set_email_address(who, email);
player:notify(tostr(who.name, " (", who, ") formerly ", old ? old | "unregistered", ", registered at ", email, ".", comments ? (" [" + comments) + "]" | ""));
-------------------------------------------------------------------------------
#24 Wizard Utilities:do_new_password this n/a this
"do_new_password(who, [password])";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, ?password = $wiz_utils:random_password(6)} = args;
if (!password)
password = $wiz_utils:random_password(6);
endif
whostr = $string_utils:nn(who);
player:notify(tostr("About to change password for ", whostr, ". Old encrypted password is \"", who.password, "\""));
who.password = crypt(password);
who.last_password_time = time();
player:notify(tostr(whostr, " new password is `", password, "'."));
if (!$wiz_utils:get_email_address(who))
player:notify(tostr(whostr, " doesn't have a registered email_address, cannot mail password; tell them some some other way."));
elseif ((who.last_connect_time == $maxint) && $command_utils:yes_or_no(tostr(who.name, " has never logged in.  Send mail with the password as though this were a new player request?")))
if ((result = $wiz_utils:send_new_player_mail(tostr("From ", player.name, "@", $network.moo_name, ":"), who.name, $wiz_utils:get_email_address(who), who, password)) == 0)
player:tell("Mail sent.");
else
player:tell("Trouble sending mail: ", result);
endif
elseif ($command_utils:yes_or_no(tostr("Email new password to ", whostr, "?")))
player:notify("Sending the password via email.");
$network:adjust_postmaster_for_password("enter");
if ((result = $network:sendmail($wiz_utils:get_email_address(who), ("Your " + $network.moo_name) + " password", ("The password for your " + $network.moo_name) + " character:", " " + whostr, "has been changed. The new password is:", " " + password, "", "Please note that passwords are case sensitive.")) == 0)
player:tell("Mail sent.");
else
player:tell("Trouble sending mail: ", result);
endif
$network:adjust_postmaster_for_password("exit");
else
player:tell("No mail sent.");
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:set_owner_new this n/a this
":set_owner(object,newowner[,suspendok])  does object.owner=newowner, taking care of c properties as well.  This should be used anyplace one is contemplating doing object.owner=newowner, since the latter leaves ownership of c properties unchanged.  (--Rog thinks this is a server bug).";
{object, newowner, ?suspendok = 0} = args;
if (!valid(object))
return E_INVIND;
elseif (!caller_perms().wizard)
return E_PERM;
elseif (!(valid(newowner) && is_player(newowner)))
return E_INVARG;
endif
oldowner = object.owner;
object.owner = newowner;
for pname in ($object_utils:all_properties(object))
if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))
suspend(0);
endif
perms = property_info(object, pname)[2];
if (index(perms, "c"))
set_property_info(object, pname, {newowner, perms});
endif
endfor
if ($object_utils:isa(oldowner, $player))
if (is_player(oldowner) && (object != oldowner))
$quota_utils:reimburse_quota(oldowner, object);
endif
if (typeof(oldowner.owned_objects) == LIST)
oldowner.owned_objects = setremove(oldowner.owned_objects, object);
endif
endif
if ($object_utils:isa(newowner, $player))
if (object != newowner)
$quota_utils:charge_quota(newowner, object);
endif
if (typeof(newowner.owned_objects) == LIST)
newowner.owned_objects = setadd(newowner.owned_objects, object);
endif
endif
return 1;
-------------------------------------------------------------------------------
#24 Wizard Utilities:boot_idlers this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
"------- constants ---- ";
"20 minutes idle for regular players";
mintime = 60 * 20;
"10 minutes for guests";
minguest = 60 * 10;
"wait 3 minutes before actually booting";
bootdelay = 3;
"start booting when there are 20 less than max players";
threshold = 20;
" ----------------------";
if ($code_utils:task_valid(this.boot_task) && (task_id() != this.boot_task))
"starting a new one: kill the old one";
kill_task(this.boot_task);
this.boot_task = 0;
endif
fork taskn ((bootdelay * 60) * 3)
maxplayers = $login:max_connections() - threshold;
if (length(pl = connected_players()) > maxplayers)
pll = {};
plt = {};
for x in (pl)
suspend(0);
min = $object_utils:isa(x, $guest) ? minguest | mintime;
if ((((idle = `idle_seconds(x) ! ANY => 0') > min) && (!x.wizard)) && (!(x in this.boot_exceptions)))
pll = {x, @pll};
plt = {idle, @plt};
endif
endfor
if (pll)
"Sort by idle time, and choose person who has been idle longest.";
pll = $list_utils:sort(pll, plt);
booted = pll[$];
guest = $object_utils:isa(booted, $guest);
min = guest ? minguest | mintime;
if (`idle_seconds(booted) ! ANY => 0' > min)
notify(booted, tostr("*** You've been idle more than ", min / 60, " minutes, and there are more than ", maxplayers, " players connected. If you're still idle and LambdaMOO is still busy in ", bootdelay, " minute", (bootdelay == 1) ? "" | "s", ", you will be booted. ***"));
fork (60 * bootdelay)
idle = `idle_seconds(booted) ! ANY => 0';
if ((idle > min) && (length(connected_players()) > ($login:max_connections() - threshold)))
notify(booted, "*** You've been idle too long and LambdaMOO is still too busy ***");
server_log(tostr("IDLE: ", booted.name, " (", booted, ") idle ", idle / 60));
boot_player(booted);
endif
endfork
endif
endif
endif
this:(verb)(@args);
endfork
this.boot_task = taskn;
"This is set up so that it forks the task first, and this.boot_task is the task_id of whatever is running the idle booter";
-------------------------------------------------------------------------------
#24 Wizard Utilities:grant_object this n/a this
":grant_object(what, towhom);";
"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).";
if (!caller_perms().wizard)
return E_PERM;
endif
{object, newowner} = args;
if (!is_player(newowner))
return E_INVARG;
endif
same = object.owner == newowner;
for vnum in [1..length(verbs(object))]
info = verb_info(object, vnum);
if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))
same = same && (info[1] == newowner);
set_verb_info(object, vnum, listset(info, newowner, 1));
endif
endfor
for prop in (properties(object))
$command_utils:suspend_if_needed(0);
info = property_info(object, prop);
if (!(index(info[2], "c") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))
same = same && (info[1] == newowner);
$wiz_utils:set_property_owner(object, prop, newowner, 1);
endif
endfor
suspend(0);
$wiz_utils:set_owner(object, newowner, 1);
return same ? "nothing changed" | "grant changed";
-------------------------------------------------------------------------------
#24 Wizard Utilities:connection_hash this n/a this
"connection_hash(forwhom, host [,seed])";
"Compute an encrypted hash of the host for 'forwhom', using 'crypt'.";
{forwhom, host, @seed} = args;
hash = toint(forwhom);
for i in [1..length(host)]
hash = (hash * 14) + index($string_utils.ascii, host[i]);
endfor
return crypt(tostr(hash), @seed);
-------------------------------------------------------------------------------
#24 Wizard Utilities:newt_player this n/a this
":newt_player(who [ , commentary] [, temporary])";
{who, ?comment = "", ?temporary = 0} = args;
if (!caller_perms().wizard)
$error:raise(E_PERM);
elseif (length(args) < 1)
$error:raise(E_ARGS);
elseif ((typeof(who = args[1]) != OBJ) || (!is_player(who)))
$error:raise(E_INVARG);
else
if (!comment)
player:notify("So why has this player been newted?");
comment = $command_utils:read();
endif
if (temporary)
comment = temporary + comment;
endif
$login.newted = setadd($login.newted, who);
if (msg = player:newt_victim_msg())
notify(who, msg);
endif
notify(who, $login:newt_registration_string());
boot_player(who);
player:notify(tostr(who.name, " (", who, ") has been turned into a newt."));
$mail_agent:send_message(player, $newt_log, tostr("@newt ", who.name, " (", who, ")"), {$string_utils:from_list(who.all_connect_places, " "), @comment ? {comment} | {}});
if ($object_utils:isa(who.location, $room) && (msg = player:newt_msg()))
who.location:announce_all_but({who}, msg);
endif
player:notify(tostr("Mail sent to ", $mail_agent:name($newt_log), "."));
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:unset_programmer this n/a this
":unset_programmer(victim[,reason[,start time,duration]]) => 1 or error.";
"Resets victim.programmer, adds victim to .programmer_restricted.";
"Put into temporary list if 3rd and 4th arguments are given. Which restricts the victim for uptime duration since start time. Must give a reason, though it can be blank, in this case.";
{victim, ?reason = "", ?start = 0, ?duration = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (!valid(victim))
return E_INVARG;
elseif ((!victim.programmer) && this:check_prog_restricted(victim))
return E_NONE;
else
victim.programmer = 0;
if (is_player(victim) && $object_utils:isa(victim, $player))
this.programmer_restricted = setadd(this.programmer_restricted, victim);
if (start)
this.programmer_restricted_temp = setadd(this.programmer_restricted_temp, {victim, start, duration});
endif
endif
$mail_agent:send_message(caller_perms(), {$newt_log}, tostr("@deprogrammer ", victim.name, " (", victim, ")"), reason ? (typeof(reason) == STR) ? {reason} | reason | {});
return 1;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:is_wizard this n/a this
":is_wizard(who) => whether `who' is a wizard or is the .public_identity of some wizard.";
"This verb is used for permission checks on commands that should only be accessible to wizards or their ordinary-player counterparts.  It will return true for unadvertised wizards.";
who = args[1];
if (who.wizard)
return 1;
else
for w in ($object_utils:leaves($wiz))
if ((w.wizard && is_player(w)) && (who == `w.public_identity ! ANY'))
return 1;
endif
endfor
endif
return 0;
-------------------------------------------------------------------------------
#24 Wizard Utilities:expire_mail none n/a none
if (!caller_perms().wizard)
return E_PERM;
endif
this:expire_mail_lists();
this:expire_mail_players();
-------------------------------------------------------------------------------
#24 Wizard Utilities:expire_mail_weekly this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
fork (((7 * 24) * 60) * 60)
this:(verb)();
endfork
this:expire_mail();
-------------------------------------------------------------------------------
#24 Wizard Utilities:check_prog_restricted this n/a this
"Checks to see if args[1] is restricted from programmer either permanently or temporarily. Removes from temporary list if time is up";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
if ((who = args[1]) in this.programmer_restricted)
"okay, who is restricted. Now check to see if it is temporary";
if (entry = $list_utils:assoc(who, this.programmer_restricted_temp))
if ($login:uptime_since(entry[2]) > entry[3])
"It's temporary and the time is up, remove and return false";
this.programmer_restricted_temp = setremove(this.programmer_restricted_temp, entry);
this.programmer_restricted = setremove(this.programmer_restricted, who);
return 0;
else
"time is not up";
return 1;
endif
else
return 1;
endif
else
return 0;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:expire_mail_players this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
s = 0;
for p in (players())
this.expiration_progress = p;
if ((p.owner == p) && is_player(p))
s = s + (p:expire_old_messages() || 0);
endif
if (ticks_left() < 10000)
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endfor
$mail_agent:send_message(player, this.expiration_recipient, verb, tostr(s, " messages have been expired from players."));
return s;
-------------------------------------------------------------------------------
#24 Wizard Utilities:expire_mail_lists this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
sum = 0;
for x in ($object_utils:leaves_suspended($mail_recipient))
this.expiration_progress = x;
temp = x:expire_old_messages();
if (typeof(temp) == INT)
sum = sum + temp;
endif
"just suspend for every fucker, I'm tired of losing.";
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endfor
$mail_agent:send_message(player, this.expiration_recipient, verb, tostr(sum, " messages have been expired from mailing lists."));
return sum;
-------------------------------------------------------------------------------
#24 Wizard Utilities:flush_editors this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
fork (86400 * 7)
this:(verb)();
endfork
player:tell("Flushing ancient editor sessions.");
for x in ({$verb_editor, $note_editor, $mail_editor})
x:do_flush(time() - (30 * 86400), 0);
$command_utils:suspend_if_needed(0);
endfor
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:random_wizard this n/a this
"Put all your wizards in $wiz_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.";
w = this.wizards;
i = this.next_perm_index;
if (i >= length(w))
i = 1;
else
i = i + 1;
endif
this.next_perm_index = i;
return w[i];
-------------------------------------------------------------------------------
#24 Wizard Utilities:set_email_address this n/a this
set_task_perms(caller_perms());
{who, email} = args;
if (typeof(who.email_address) == LIST)
who.email_address[1] = email;
else
who.email_address = email;
endif
-------------------------------------------------------------------------------
#24 Wizard Utilities:get_email_address this n/a this
set_task_perms(caller_perms());
{who} = args;
if (typeof(who.email_address) == LIST)
return who.email_address[1];
else
return who.email_address;
endif
-------------------------------------------------------------------------------
================================#25 Site DB===============================================
#25 Site DB.total_pruned_people rc = MOONumber 0
#25 Site DB.prune_task rc = MOONumber 298000796
#25 Site DB.prune_progress c = MOOString "aaa"
#25 Site DB.prune_stop rc = MOOString "zzz"
#25 Site DB.alphabet rc = MOOString "abcdefghijklmnopqrstuvwxy0123456789_z"
#25 Site DB. l  = MOOList [ "ocal", "", [ "localdomain", "localhost.localdomain" ], [ [ "localhost" ], [ #2 ] ] ]
#25 Site DB.domain r = MOOString "localdomain"
#25 Site DB.total_pruned_sites rc = MOONumber 0
#25 Site DB:find* _only* _every* this n/a this
return ((caller == this) || caller_perms().wizard) ? pass(@args) | E_PERM;
-------------------------------------------------------------------------------
#25 Site DB:add this n/a this
":add(player,site)";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, domain} = args;
if (this:domain_literal(domain))
"... just enter it...";
l = this:find_exact(domain);
if (l == $failed_match)
this:insert(domain, {who});
elseif (!(who in l))
this:insert(domain, setadd(l, who));
endif
else
"...an actual domain name; add player to list for that domain...";
"...then add domain itself to list for the next larger domain; repeat...";
"...  Example:  domain == foo.bar.edu:  ";
"...            enter #who  on foo.bar.edu list";
"...            enter `foo' on bar.edu list";
"...            enter `bar' on edu list";
if (!(dot = index(domain, ".")))
dot = length(domain) + 1;
domain = tostr(domain, ".", this.domain);
endif
prev = who;
while ($failed_match == (l = this:find_exact(domain)))
this:insert(domain, {prev});
if (dot)
prev = domain[1..dot - 1];
domain = domain[dot + 1..$];
else
return;
endif
dot = index(domain, ".");
endwhile
if (!(prev in l))
this:insert(domain, {@l, prev});
endif
return;
endif
-------------------------------------------------------------------------------
#25 Site DB:load this n/a this
":load([start]) -- reloads site_db with the connection places of all players.";
"This routine calls suspend() if it runs out of time.";
"WIZARDLY";
"...needs to be able to read .all_connect_places";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
plist = players();
if (!args)
this:clearall();
elseif (i = args[1] in plist)
plist[1..i - 1] = {};
else
return E_INVARG;
endif
for p in (plist)
if (valid(p) && (is_player(p) && (!$object_utils:isa(p, $guest))))
"... player may be recycled or toaded during the suspend(),...";
"... guests login from everywhere...";
for c in (p.all_connect_places)
this:add(p, c);
if ($command_utils:running_out_of_time())
player:tell("...", p);
suspend(0);
endif
endfor
endif
endfor
-------------------------------------------------------------------------------
#25 Site DB:domain_literal this n/a this
":domain_literal(string)";
" => true iff string is a domain literal (i.e., numeric IP address).";
if (10 <= (len = length(hnum = strsub(args[1], ".", ""))))
return toint(hnum[1..9]) && toint(hnum[6..len]);
else
return toint(hnum);
endif
"SLEAZY CODE ALERT";
"... what I wanted to do was return toint(strsub(args[1],\".\",\"\"))";
"... but on a 32-bit machine, this has a 1 in 4294967296 chance of failing";
"... (e.g., on \"42.94.967.296\", though I'll grant this particular example";
"...  entails some very strange subnetting on net 42, to say the least).";
"... So we do something that is guaranteed to work so long as internet";
"... addresses stay under 32 bits --- a while yet...";
"";
"... As soon as we're sure match() is working, this will become a one-liner:";
return match(args[1], "[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+");
-------------------------------------------------------------------------------
#25 Site DB:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this:clearall();
this.domain = "localdomain";
this:prune_reset();
endif
-------------------------------------------------------------------------------
#25 Site DB:prune_alpha this n/a this
"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.";
"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.";
"Another thing it should do is be clever about string typed items.  (What did I mean by this?)";
"New feature: If the site name contains `dialup', then, if none of the users who have connected from there still have it in their .all_connect_places, then consider it trashable.  Maybe this will get some space savings.";
"To run: call $site_db:prune_reset() then $site_db:prune_alpha().";
"or $site_db:prune_alpha(1) for verbose output";
verbose = args && args[1];
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.prune_task = task_id();
probe = this.prune_progress;
while ((probe <= this.prune_stop) && (length(probe) == length(this.prune_stop)))
for sitename in (z = this:find_all_keys(probe))
items = this:find_exact(sitename);
orig = items;
dialup = index(sitename, "dialup");
"Don't keep around dialups.";
for y in (items)
if ((typeof(y) == OBJ) && (((!valid(y)) || (!is_player(y))) || (dialup && (!(sitename in y.all_connect_places)))))
verbose && player:tell("removing ", $string_utils:nn(y), " from ", sitename);
items = setremove(items, y);
endif
$command_utils:suspend_if_needed(0);
endfor
useless = 1;
"If no player has this site in eir .all_connect_places, nuke it anyway.";
for y in (items)
if ((typeof(y) != OBJ) || (sitename in y.all_connect_places))
useless = 0;
break;
"unfortunately this can get kinna O(n^2).";
endif
$command_utils:suspend_if_needed(0);
endfor
if (useless)
verbose && player:tell(sitename, " declared useless and nuked");
items = {};
endif
if (!items)
this:delete(sitename);
this.total_pruned_sites = this.total_pruned_sites + 1;
elseif (items == orig)
else
this:insert(sitename, items);
this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);
endif
$command_utils:suspend_if_needed(0);
if (probe >= this.prune_stop)
return player:tell("Prune stopped at ", toliteral(this.prune_progress));
endif
endfor
probe = $string_utils:incr_alpha(probe, this.alphabet);
this.prune_progress = probe;
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endwhile
player:tell("Prune stopped at ", toliteral(this.prune_progress));
-------------------------------------------------------------------------------
#25 Site DB:report_prune_progress this n/a this
player:tell("Prune is up to ", toliteral(this.prune_progress), ".");
mine = 0;
if (typeof(this.prune_progress) == STR)
alphalen = length(this.alphabet);
total = (alphalen * alphalen) * alphalen;
for x in [1..3]
mine = ((mine * alphalen) + index(this.alphabet, this.prune_progress[x])) - 1;
endfor
else
total = 256 * 256;
mine = (this.prune_progress[1] * 256) + this.prune_progress[2];
endif
percent = (100.0 * tofloat(mine)) / tofloat(total);
player:tell("We have processed ", mine, " entries out of ", total, ", or ", toint(percent), ".", toint(10.0 * percent) % 10, "%.");
player:tell("There were ", this.total_pruned_people, " individual list entries removed, and ", this.total_pruned_sites, " whole sites removed.");
if ($code_utils:task_valid(this.prune_task))
player:tell("Prune task is ", this.prune_task, ".  Stacktrace:");
for x in (task_stack(this.prune_task, 1))
if (valid(x[4]))
player:tell(x[4], ":", x[2], " [", x[1], "]  ", x[3].name, "  (", x[6], ")");
endif
endfor
else
player:tell("The recorded task_id is no longer valid.");
endif
-------------------------------------------------------------------------------
#25 Site DB:prune_fixup this n/a this
if (!caller_perms().wizard)
raise(E_PERM);
endif
if (!args)
for x in ({"com", "edu", "us", "au", "net", "za", "uk", "at", "ca", "org", "il", "mil", "no", "gov", "se", "fi", "it", "be", "jp", "de", "pt", "sg", "ie", "br", "nl", "gr", "ch", "pl", "nz", "<none>", "<bad>", "ee", "dk", "fr", "si", "cz", "th", "tw", "hk", "su", "es", "kr", "hr", "is", "mx", "my", "ro", "kw", "cl", "ph", "cr", "tr", "in", "eg", "ec", "lv", "ve", "sk", "ar", "co", "pe", "hu", "jm", "ni", "ru", "id", "bm", "mt", "cn", "bg", "pk", "uy", "yu", "ae", "zw", "gi", "sm", "nu"})
this:prune_fixup(x);
endfor
return;
endif
root = args[1];
items = this:find_exact(root);
orig = items;
if (items == #-3)
return 1;
endif
$site_db.prune_progress = root;
$site_db.prune_task = task_id();
for item in (items)
if (typeof(item) == STR)
if (this:prune_fixup((item + ".") + root))
items = setremove(items, item);
endif
endif
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endfor
if (!items)
this:delete(root);
this.total_pruned_sites = this.total_pruned_sites + 1;
return 1;
elseif (orig == items)
else
this:insert(root, items);
endif
-------------------------------------------------------------------------------
#25 Site DB:prune_numeric this n/a this
"Carefully loop through the db and delete items associated with !valid and !is_player objects.  If that results in no objects remaining for a site, delete that site.";
"Attempt to keep memory usage down by only asking for a small number of items at a time.  Should probably have some arguments to control this.";
"Another thing it should do is be clever about string typed items.";
"Rewriting this to do numerics now.";
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.prune_task = task_id();
probe = this.prune_progress;
while (probe[1] <= this.prune_stop)
probestring = tostr(probe[1], ".", probe[2], ".");
for sitename in (z = this:find_all_keys(probestring))
items = this:find_exact(sitename);
orig = items;
for y in (items)
if ((typeof(y) == OBJ) && ((!valid(y)) || (!is_player(y))))
items = setremove(items, y);
endif
$command_utils:suspend_if_needed(0);
endfor
if (!items)
this:delete(sitename);
this.total_pruned_sites = this.total_pruned_sites + 1;
elseif (items == orig)
else
this:insert(sitename, items);
this.total_pruned_people = (this.total_pruned_people + length(orig)) - length(items);
endif
$command_utils:suspend_if_needed(0);
endfor
if (probe[2] == 255)
probe[1] = probe[1] + 1;
probe[2] = 0;
else
probe[2] = probe[2] + 1;
endif
this.prune_progress = probe;
if ($command_utils:running_out_of_time())
set_task_perms($wiz_utils:random_wizard());
suspend(0);
endif
endwhile
player:tell("Prune stopped at ", toliteral(this.prune_progress));
-------------------------------------------------------------------------------
#25 Site DB:schedule_prune this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
day = 24 * 3600;
hour_of_day_GMT = 9;
target = (((hour_of_day_GMT * 60) * 60) + day) - (time() % day);
if (target > 86400)
target = target - 86400;
endif
fork (target)
"Stop at 2am before checkpoint.";
if ($code_utils:task_valid(this.prune_task))
$site_db.prune_stop = "aaa";
"Restart after 3am.  Er, 4am.";
suspend(7500);
this:schedule_prune();
$site_db.prune_stop = "zzz";
"Just in case it didn't actually stop...";
if (!$code_utils:task_valid(this.prune_task))
$site_db:prune_alpha();
endif
endif
endfork
-------------------------------------------------------------------------------
#25 Site DB:prune_reset this n/a this
if (!caller_perms().wizard)
raise(E_PERM);
endif
this:report_prune_progress();
player:tell("Resetting...");
this.total_pruned_sites = 0;
this.total_pruned_people = 0;
this.prune_progress = "aaa";
this.prune_stop = "zzz";
`kill_task(this.prune_task) ! ANY';
-------------------------------------------------------------------------------
================================#26 Math Utilities===============================================
#26 Math Utilities.sines rc = MOOList [ 175, 349, 523, 698, 872, 1045, 1219, 1392, 1564, 1736, 1908, 2079, 2250, 2419, 2588, 2756, 2924, 3090, 3256, 3420, 3584, 3746, 3907, 4067, 4226, 4384, 4540, 4695, 4848, 5000, 5150, 5299, 5446, 5592, 5736, 5878, 6018, 6157, 6293, 6428, 6561, 6691, 6820, 6947, 7071, 7193, 7314, 7431, 7547, 7660, 7771, 7880, 7986, 8090, 8192, 8290, 8387, 8480, 8572, 8660, 8746, 8829, 8910, 8988, 9063, 9135, 9205, 9272, 9336, 9397, 9455, 9511, 9563, 9613, 9659, 9703, 9744, 9781, 9816, 9848, 9877, 9903, 9925, 9945, 9962, 9976, 9986, 9994, 9998, 10000, 9998, 9994, 9986, 9976, 9962, 9945, 9925, 9903, 9877, 9848, 9816, 9781, 9744, 9703, 9659, 9613, 9563, 9511, 9455, 9397, 9336, 9272, 9205, 9135, 9063, 8988, 8910, 8829, 8746, 8660, 8572, 8480, 8387, 8290, 8192, 8090, 7986, 7880, 7771, 7660, 7547, 7431, 7314, 7193, 7071, 6947, 6820, 6691, 6561, 6428, 6293, 6157, 6018, 5878, 5736, 5592, 5446, 5299, 5150, 5000, 4848, 4695, 4540, 4384, 4226, 4067, 3907, 3746, 3584, 3420, 3256, 3090, 2924, 2756, 2588, 2419, 2250, 2079, 1908, 1736, 1564, 1392, 1219, 1045, 872, 698, 523, 349, 175, 0, -175, -349, -523, -698, -872, -1045, -1219, -1392, -1564, -1736, -1908, -2079, -2250, -2419, -2588, -2756, -2924, -3090, -3256, -3420, -3584, -3746, -3907, -4067, -4226, -4384, -4540, -4695, -4848, -5000, -5150, -5299, -5446, -5592, -5736, -5878, -6018, -6157, -6293, -6428, -6561, -6691, -6820, -6947, -7071, -7193, -7314, -7431, -7547, -7660, -7771, -7880, -7986, -8090, -8192, -8290, -8387, -8480, -8572, -8660, -8746, -8829, -8910, -8988, -9063, -9135, -9205, -9272, -9336, -9397, -9455, -9511, -9563, -9613, -9659, -9703, -9744, -9781, -9816, -9848, -9877, -9903, -9925, -9945, -9962, -9976, -9986, -9994, -9998, -10000, -9998, -9994, -9986, -9976, -9962, -9945, -9925, -9903, -9877, -9848, -9816, -9781, -9744, -9703, -9659, -9613, -9563, -9511, -9455, -9397, -9336, -9272, -9205, -9135, -9063, -8988, -8910, -8829, -8746, -8660, -8572, -8480, -8387, -8290, -8192, -8090, -7986, -7880, -7771, -7660, -7547, -7431, -7314, -7193, -7071, -6947, -6820, -6691, -6561, -6428, -6293, -6157, -6018, -5878, -5736, -5592, -5446, -5299, -5150, -5000, -4848, -4695, -4540, -4384, -4226, -4067, -3907, -3746, -3584, -3420, -3256, -3090, -2924, -2756, -2588, -2419, -2250, -2079, -1908, -1736, -1564, -1392, -1219, -1045, -872, -698, -523, -349, -175, 0, 175 ]
#26 Math Utilities.and rc = MOOList [ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], [ 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 ], [ 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2 ], [ 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3 ], [ 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4 ], [ 0, 1, 0, 1, 4, 5, 4, 5, 0, 1, 0, 1, 4, 5, 4, 5 ], [ 0, 0, 2, 2, 4, 4, 6, 6, 0, 0, 2, 2, 4, 4, 6, 6 ], [ 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7 ], [ 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8 ], [ 0, 1, 0, 1, 0, 1, 0, 1, 8, 9, 8, 9, 8, 9, 8, 9 ], [ 0, 0, 2, 2, 0, 0, 2, 2, 8, 8, 10, 10, 8, 8, 10, 10 ], [ 0, 1, 2, 3, 0, 1, 2, 3, 8, 9, 10, 11, 8, 9, 10, 11 ], [ 0, 0, 0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 12, 12 ], [ 0, 1, 0, 1, 4, 5, 4, 5, 8, 9, 8, 9, 12, 13, 12, 13 ], [ 0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 14, 14 ], [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ] ]
#26 Math Utilities.piscale rc = MOONumber 0.00872664625997164
#26 Math Utilities.tangents rc = MOOList [ 174, 349, 524, 699, 874, 1051, 1227, 1405, 1583, 1763, 1943, 2125, 2308, 2493, 2679, 2867, 3057, 3249, 3443, 3639, 3838, 4040, 4244, 4452, 4663, 4877, 5095, 5317, 5543, 5773, 6008, 6248, 6494, 6745, 7002, 7265, 7535, 7812, 8097, 8390, 8692, 9004, 9325, 9656, 10000 ]
#26 Math Utilities.xor rc = MOOList [ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ], [ 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14 ], [ 2, 3, 0, 1, 6, 7, 4, 5, 10, 11, 8, 9, 14, 15, 12, 13 ], [ 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12 ], [ 4, 5, 6, 7, 0, 1, 2, 3, 12, 13, 14, 15, 8, 9, 10, 11 ], [ 5, 4, 7, 6, 1, 0, 3, 2, 13, 12, 15, 14, 9, 8, 11, 10 ], [ 6, 7, 4, 5, 2, 3, 0, 1, 14, 15, 12, 13, 10, 11, 8, 9 ], [ 7, 6, 5, 4, 3, 2, 1, 0, 15, 14, 13, 12, 11, 10, 9, 8 ], [ 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7 ], [ 9, 8, 11, 10, 13, 12, 15, 14, 1, 0, 3, 2, 5, 4, 7, 6 ], [ 10, 11, 8, 9, 14, 15, 12, 13, 2, 3, 0, 1, 6, 7, 4, 5 ], [ 11, 10, 9, 8, 15, 14, 13, 12, 3, 2, 1, 0, 7, 6, 5, 4 ], [ 12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3 ], [ 13, 12, 15, 14, 9, 8, 11, 10, 5, 4, 7, 6, 1, 0, 3, 2 ], [ 14, 15, 12, 13, 10, 11, 8, 9, 6, 7, 4, 5, 2, 3, 0, 1 ], [ 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ] ]
#26 Math Utilities.factor rc = MOONumber 10000
#26 Math Utilities.taylor rc = MOONumber 100
#26 Math Utilities.e rc = MOONumber 2.71828182845905
#26 Math Utilities.base_alphabet rc = MOOString "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
#26 Math Utilities.phi rc = MOONumber 1.618033988749895
#26 Math Utilities.e_string rc = MOOString "2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003059921817413596629043572900334295260595630738132328627943490763233829880753195251019"
#26 Math Utilities.pi rc = MOONumber 3.141592653589793
#26 Math Utilities:xsin this n/a this
"xsin(INT x) -- calculates the taylor approximation for the sine function";
if (typeof(x = args[1]) != INT)
return E_TYPE;
endif
if ((x * x) > this.taylor)
return ((this:xsin(x / 2) * this:xcos((x + 1) / 2)) + (this:xsin((x + 1) / 2) * this:xcos(x / 2))) / 10000;
else
return (x * (17453000 - ((x * x) * 886))) / 100000;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:xcos this n/a this
"xcos(INT x) -- calculates the taylor approximation for the cosine function";
if (typeof(x = args[1]) != INT)
return E_TYPE;
endif
if ((x * x) > this.taylor)
return ((this:xcos(x / 2) * this:xcos((x + 1) / 2)) - (this:xsin(x / 2) * this:xsin((x + 1) / 2))) / 10000;
else
return (1000000000 - ((x * x) * (152309 + ((4 * x) * x)))) / 100000;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:factorial this n/a this
"factorial(INT n) -- returns n factorial for 0 <= n (<= 12).";
if ((number = args[1]) < 0)
return E_INVARG;
elseif (typeof(number) != INT)
return E_TYPE;
endif
fact = 1;
for i in [2..number]
fact = fact * i;
endfor
return fact;
-------------------------------------------------------------------------------
#26 Math Utilities:pow this n/a this
"pow(INT|FLOAT x,(INT)|(INT|FLOAT) n) -- returns x raised to the nth power. n must be >= 0. If x is an integer, n must be an integer. If x is a floating point number, n can be either.";
"This verb was revised on 2006-03-16 by Gary (#110811) to allow for floating input of the second argument.  The help documentation had said this was allowed but actually it caused a traceback.  How many people are actually using this, I wonder? ";
{x, n} = args;
"if (n < 0)";
if (((typeof(n) == INT) && (n < 0)) || ((typeof(n) == FLOAT) && (n < 0.0)))
return E_INVARG;
elseif ((typeof(x) == INT) && (typeof(n) == FLOAT))
return E_TYPE;
endif
return x ^ n;
"old code below";
n = args[1];
if (power % 2)
ret = n;
else
ret = 1;
endif
while (power = power / 2)
n = n * n;
if (power % 2)
ret = ret * n;
endif
endwhile
return ret;
-------------------------------------------------------------------------------
#26 Math Utilities:fibonacci this n/a this
"fibonacci(INT n) -- calculates the fibonacci numbers to the nth term";
"and returns them in a list. n must be >= 0.";
if (typeof(n = args[1]) != INT)
return E_TYPE;
elseif (n < 0)
return E_INVARG;
elseif (n == 0)
return {0};
else
x = {0, 1};
for i in [2..n]
x = {@x, x[$ - 1] + x[$]};
endfor
return x;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:geometric this n/a this
"geometric(INT|FLOAT x [,INT n]) -- calculates the value of the geometric series at x to the nth term. i.e., approximates 1/(1-x) when |x| < 1. This, of course, is impossible in MOO, but someone may find it useful in some way.";
"n defaults to 5. n must be >= 0.";
"This verb was revised on 2006-03-16 by Gary (#110811) to allow for floating point input of the first argument.  The help documentation had said this was allowed but actually it caused a traceback.  How many people are actually using this, I wonder? ";
{n, ?order = 5} = args;
if ((!(typeof(n) in {INT, FLOAT})) || (typeof(order) != INT))
return E_TYPE;
elseif (order <= 0)
return E_INVARG;
endif
x = (typeof(n) == FLOAT) ? 1.0 | 1;
for i in [1..order]
x = x + (n ^ i);
endfor
return x;
-------------------------------------------------------------------------------
#26 Math Utilities:divmod this n/a this
"divmod(INT n, INT d) => {q,r} such that n = dq + r";
"  handles negative numbers correctly   0<=r<d if d>0, -d<r<=0 if d<0.";
{n, d} = args;
if ((typeof(n) != INT) && (typeof(d) != INT))
return E_TYPE;
endif
r = ((n % d) + d) % d;
q = (n - r) / d;
return {q, r};
-------------------------------------------------------------------------------
#26 Math Utilities:combinations this n/a this
"combinations(INT n, INT r) -- returns the number of ways one can choose r";
"objects from n distinct choices.";
"C(n,r) = n!/[r!(n-r)!]";
"  overflow may occur if n>29...";
{n, r} = args;
if ((typeof(n) != INT) && (typeof(r) != INT))
return E_TYPE;
endif
if (0 > (r = min(r, n - r)))
return 0;
else
c = 1;
n = n + 1;
for i in [1..r]
c = (c * (n - i)) / i;
endfor
return c;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:permutations this n/a this
"permutations(INT n, INT r) -- returns the number of ways possible for one to";
"order r distinct objects given n locations.";
"P(n,r) = n!/(n-r)!";
{n, r} = args;
if ((typeof(n) != INT) && (typeof(r) != INT))
return E_TYPE;
endif
if ((r < 1) || ((diff = n - r) < 0))
return 0;
else
p = n;
for i in [diff + 1..n - 1]
p = p * i;
endfor
return p;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:simpson this n/a this
"simpson({a,b},{f(a),f((a+b)/2),f(b)} [,INT ret-float])";
" -- given two endpoints, a and b, and the functions value at a, (a+b)/2, and b, this will calculate a numerical approximation of the integral using simpson's rule.";
"Entries can either be all INT or all FLOAT. Don't mix!";
"If the optional 3rd argument is provided and true, the answer is returned as a floating point regardless of what the input was. Otherwise, if the input was all INT, the answer is returned as {integer,fraction}";
{point, fcn, ?retfloat = 0} = args;
if ((!retfloat) && (typeof(point[1]) == INT))
numer = (point[2] - point[1]) * ((fcn[1] + (4 * fcn[2])) + fcn[3]);
return this:parts(numer, 6);
else
numer = tofloat(point[2] - point[1]) * ((tofloat(fcn[1]) + (4.0 * tofloat(fcn[2]))) + tofloat(fcn[3]));
return numer / 6.0;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:parts this n/a this
"parts(INT n, INT q [,INT i]) -- returns a decomposition of n by q into integer and floating point parts with i = the number of digits after the decimal.";
"i defaults to 5.";
"warning: it is quite easy to hit maxint which results in unpredictable";
"         results";
{n, q, ?i = 5} = args;
if (((typeof(n) != INT) && (typeof(q) != INT)) && (typeof(i) != INT))
return E_TYPE;
endif
parts = {n / q, n % q};
return {parts[1], (parts[2] * (10 ^ i)) / q};
-------------------------------------------------------------------------------
#26 Math Utilities:sqrt this n/a this
"sqrt(INT|FLOAT n) => largest integer <= square root of n. Returns the same type as the input. (Backwards compatibility)";
n = args[1];
return (typeof(n) == INT) ? toint(sqrt(tofloat(n))) | sqrt(n);
"Old code. Newton's method";
if (n < 0)
return E_RANGE;
elseif (n)
x1 = n;
while (x1 > (x2 = (x1 + (n / x1)) / 2))
x1 = x2;
endwhile
return x1;
else
return 0;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:div this n/a this
"div(INT n, INT d) => q such that n = dq + r and  (0<=r<d if d>0, -d<r<=0 if d<0).";
return this:divmod(@args)[1];
-------------------------------------------------------------------------------
#26 Math Utilities:mod this n/a this
"A correct mod function.";
"mod(INT n, INT d) => r such that n = dq + r and (0<=r<d if d>0 or -d<r<=0 if d<0).";
{n, d} = args;
if ((typeof(n) != INT) && (typeof(d) != INT))
return E_TYPE;
endif
return ((n % d) + d) % d;
-------------------------------------------------------------------------------
#26 Math Utilities:exp this n/a this
"exp(INT|FLOAT x[,INT n]) -- calculates an nth order taylor approximation for e^x.";
"n defaults to 5. Any n given must be >= 0. you need to divide the result";
"the answer will be returned as {integer part,fractional part} if the input x was an integer. If it is floating point, so will the answer (and this uses the builtin function.)";
{x, ?n = 5} = args;
if (typeof(x) == FLOAT)
return exp(x);
elseif ((typeof(x) != INT) && (typeof(n) != INT))
return E_TYPE;
endif
ex = nfact = 1;
for i in [0..n - 1]
j = n - i;
ex = (ex * x) + (nfact = nfact * j);
endfor
return this:parts(ex, nfact);
-------------------------------------------------------------------------------
#26 Math Utilities:aexp this n/a this
"returns 10000 exp (x/10000)";
"The accuracy seems to be ~0.1% for 0<x<4";
x = args[1];
if (x < 0)
z = this:(verb)(-x);
return (100000000 + (z / 2)) / z;
elseif (x > 1000)
z = this:(verb)(x / 2);
if (z > 1073741823)
return $maxint;
"maxint for overflows";
elseif (z > 460000)
z = ((z + 5000) / 10000) * z;
elseif (z > 30000)
z = ((((z + 50) / 100) * z) + 50) / 100;
else
z = ((z * z) + 5000) / 10000;
endif
if (x % 2)
return z + ((z + 5000) / 10000);
else
return z;
endif
else
return ((10000 + x) + (((x * x) + 10000) / 20000)) + ((((x * x) * x) + 300000000) / 600000000);
endif
-------------------------------------------------------------------------------
#26 Math Utilities:random this n/a this
"random(INT n): returns a random integer in the following manner:";
"random(n > 0) will return a integer in the range 0 to n";
"random(n < 0) will return a integer in the range n to 0";
if (typeof(prob = args[1]) != INT)
return E_TYPE;
endif
mod = (prob < 0) ? -1 | 1;
return (mod * random(abs(prob + mod))) - mod;
-------------------------------------------------------------------------------
#26 Math Utilities:random_range this n/a this
"random_range(INT range [,INT mean]): returns a random integer within the given range from the mean. if the mean isn't given, it defaults to 0";
"e.g., random_range(10) => -10..10";
"      random_range(10,4) => -6..14";
{range, ?mean = 0} = args;
if ((typeof(range) != INT) && (typeof(mean) != INT))
return E_TYPE;
endif
return mean + (((random(2) == 1) ? -1 | 1) * this:random(range));
-------------------------------------------------------------------------------
#26 Math Utilities:is_prime this n/a this
"is_prime(INT number) returns 1 if the number is prime or 0 if it isn't.";
"of course, only positive numbers are candidates for primality.";
if (typeof(number = args[1]) != INT)
return E_TYPE;
endif
if (number == 2)
return 1;
elseif ((number < 2) || ((number % 2) == 0))
return 0;
else
max = toint(ceil(sqrt(tofloat(number))));
choice = 3;
while (choice <= max)
if ((seconds_left() < 2) || (ticks_left() < 25))
suspend(0);
endif
if ((number % choice) == 0)
return 0;
endif
choice = choice + 2;
endwhile
endif
return 1;
-------------------------------------------------------------------------------
#26 Math Utilities:AND XOR this n/a this
"Only useful for integer input.";
{x, y} = args;
if ((typeof(x) != INT) && (typeof(y) != INT))
return E_TYPE;
endif
table = this.(verb);
if (xsgn = x < 0)
x = x + $minint;
endif
if (ysgn = y < 0)
y = y + $minint;
endif
power = 1;
z = 0;
while (x || y)
z = z + (power * table[1 + (x % 16)][1 + (y % 16)]);
x = x / 16;
y = y / 16;
power = power * 16;
endwhile
if (table[1 + xsgn][1 + ysgn])
return z + $minint;
else
return z;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:OR this n/a this
return this:NOT(this:AND(this:NOT(args[1]), this:NOT(args[2])));
-------------------------------------------------------------------------------
#26 Math Utilities:NOT this n/a this
return -(1 + args[1]);
"";
"... here's what it used to be ...";
bl1 = this:BLFromInt(args[1]);
blOut = {};
for i in [1..32]
blOut = {@blOut, !bl1[i]};
endfor
return this:IntFromBL(blOut);
-------------------------------------------------------------------------------
#26 Math Utilities:BLFromInt this n/a this
"BlFromInt(INT x) => converts the number provided into a 32 bit binary number, which is returned via a 32 element LIST of 1's and 0's. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.";
if (typeof(x = args[1]) != INT)
return E_TYPE;
endif
l = {};
firstbit = x < 0;
if (firstbit)
x = x + $minint;
endif
for i in [1..31]
l = {x % 2, @l};
x = x / 2;
endfor
return {firstbit, @l};
-------------------------------------------------------------------------------
#26 Math Utilities:IntFromBL this n/a this
"IntFromBl(LIST of 1's and 0's) => converts the 32 bit binary representation given by the list of 1's and 0's and converts it to a normal decimal number. Note that this verb was originally written to be used with the $math_utils verbs: AND, NOT, OR, XOR, but has since been taken out of them.";
bl = args[1];
x = 0;
for l in (bl)
x = x * 2;
x = x + l;
endfor
return x;
-------------------------------------------------------------------------------
#26 Math Utilities:gcd greatest_common_divisor this n/a this
"gcd(INT num1,INT num2): find the greatest common divisor of the two numbers";
"using the division algorithm. the absolute values of num1 and num2 are";
"used without loss of generality.";
num1 = abs(args[1]);
num2 = abs(args[2]);
max = max(num1, num2);
min = min(num1, num2);
if (r1 = max % min)
while (r2 = min % r1)
min = r1;
r1 = r2;
endwhile
return r1;
else
return min;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:lcm least_common_multiple this n/a this
"lcm(INT num1,INT num2): find the least common multiple of the two numbers.";
"we shall use the positive lcm value without loss of generality.";
"since we have gcd already, we'll just use lcm*gcd = num1*num2";
num1 = abs(args[1]);
num2 = abs(args[2]);
return (num1 * num2) / this:gcd(num1, num2);
-------------------------------------------------------------------------------
#26 Math Utilities:are_rel_prime are_relatively_prime this n/a this
"are_rel_prime(INT num1,INT num2): returns 1 if num1 and num2 are relatively";
"prime.";
"since we have gcd, this is pretty easy.";
if (this:gcd(args[1], args[2]) == 1)
return 1;
else
return 0;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:base_conversion this n/a this
"Synopsis:    :base_conversion(number, current_base, desired_base)";
"---";
"Call with first arg either a number or a string, being the number";
"desired for conversion. capital letters denote values from 10-35;";
"lowercase letters from 36 to 61. Maximal base is 62.";
"You will be unable to use the extra 26 lowercases as separate unless";
"you pass a nonzero fourth argument. Passing zero or none uses the";
"default value, which is to have AAAA=aaaa.";
"The second and third arguments should be the base of the number and";
"the base you want it in, respectively.";
"Any of the arguments can be strings or nums, but high-base numbers";
"will need to be strings. This returns a string.";
"Any problems, talk to Ozymandias.";
sensitive = 0;
if (length(args) < 3)
return E_INVARG;
elseif (length(args) == 4)
sensitive = toint(args[4]);
endif
result = 0;
thenum = tostr(args[1]);
origbase = toint(args[2]);
newbase = toint(args[3]);
if ((((origbase < 2) || (newbase < 2)) || (origbase > 62)) || (newbase > 62))
return E_INVARG;
endif
for which in [1..length(thenum)]
value = index(this.base_alphabet, thenum[which], sensitive);
if ((!value) || (value > origbase))
return E_INVARG;
endif
result = ((result * origbase) + value) - 1;
endfor
thestring = "";
if (result < 0)
return E_INVARG;
endif
while (result)
if ((which = (result % newbase) + 1) <= length(this.base_alphabet))
thestring = this.base_alphabet[which] + thestring;
else
return E_INVARG;
endif
result = result / newbase;
endwhile
return thestring ? thestring | "0";
-------------------------------------------------------------------------------
#26 Math Utilities:norm this n/a this
":norm(a,b,c,d...) => sqrt(a^2+b^2+c^2+...)";
m = max(max(@args), -min(@args));
logm = length(tostr(m));
if (logm <= 4)
s = 0;
for a in (args)
s = s + (a * a);
endfor
return toint(sqrt(tofloat(s)));
else
factor = toint("1" + "0000000"[1..logm - 4]);
s = 0;
for a in (args)
a = a / factor;
s = s + (a * a);
endfor
return toint(sqrt(tofloat(s))) * factor;
endif
-------------------------------------------------------------------------------
#26 Math Utilities:sin this n/a this
"Copied from Trig_Utils (#25800):sin by Obvious (#54879) Fri Nov 17 06:07:39 1995 PST";
theta = args[1];
if (typeof(theta) == FLOAT)
return sin(theta);
elseif (typeof(theta) == INT)
degtheta = theta % 360;
mintheta = 0;
elseif (typeof(theta) == LIST)
degtheta = theta[1] % 360;
mintheta = theta[2] % 60;
else
return E_INVARG;
endif
if (mintheta < 0)
mintheta = mintheta + 60;
degtheta = degtheta - 1;
endif
while (degtheta < 1)
degtheta = degtheta + 360;
endwhile
if (mintheta == 0)
return this.sines[degtheta];
endif
lim1 = this.sines[degtheta];
lim2 = this.sines[degtheta + 1];
delta = lim2 - lim1;
result = (((delta * mintheta) + 30) / 60) + lim1;
return result;
-------------------------------------------------------------------------------
#26 Math Utilities:cos this n/a this
"Copied from Trig_Utils (#25800):cos by Obvious (#54879) Fri Nov 17 06:07:50 1995 PST";
theta = args[1];
if (typeof(theta) == FLOAT)
return cos(theta);
elseif (typeof(theta) == INT)
degtheta = 90 - theta;
mintheta = 0;
elseif (typeof(theta) == LIST)
degtheta = 89 - theta[1];
mintheta = 60 - theta[2];
else
return;
endif
return this:sin({degtheta, mintheta});
-------------------------------------------------------------------------------
#26 Math Utilities:tan this n/a this
"Copied from Trig_Utils (#25800):tan by Obvious (#54879) Fri Nov 17 06:07:53 1995 PST";
{theta} = args;
if (typeof(theta) == FLOAT)
return tan(theta);
endif
sine = this:sin(theta);
cosine = this:cos(theta);
return ((sine * 10000) + ((cosine + 1) / 2)) / cosine;
-------------------------------------------------------------------------------
#26 Math Utilities:arcsin asin this n/a this
"Copied from Trig_Utils (#25800):arcsin by Obvious (#54879) Fri Nov 17 06:08:01 1995 PST";
{given} = args;
if (typeof(given) == FLOAT)
return asin(given);
endif
given = abs(given);
if (given > 10000)
return E_RANGE;
endif
i = 1;
while (given > this.sines[i])
i = i + 1;
endwhile
if (given == this.sines[i])
if (args[1] < 0)
return {-i, 0};
else
return {i, 0};
endif
endif
degrees = i - 1;
if (i == 1)
lower = 0;
else
lower = this.sines[i - 1];
endif
upper = this.sines[i];
delta1 = given - lower;
delta2 = upper - lower;
minutes = ((delta1 * 60) + ((delta2 + 1) / 2)) / delta2;
if (args[1] < 0)
degrees = -degrees;
minutes = -minutes;
endif
return {degrees, minutes};
-------------------------------------------------------------------------------
#26 Math Utilities:arccos acos this n/a this
"Copied from Trig_Utils (#25800):arccos by Obvious (#54879) Fri Nov 17 06:08:08 1995 PST";
given = args[1];
if (typeof(given) == FLOAT)
return acos(given);
endif
arcsin = this:arcsin(given);
degrees = 89 - arcsin[1];
minutes = 60 - arcsin[2];
"//* Changed (minutes > 60) to (minutes >= 60) following bug report by Loufah (#116455).  2000-03-24 23:00 CST  Gary (#110811).";
if (minutes >= 60)
minutes = minutes - 60;
degrees = degrees + 1;
endif
return {degrees, minutes};
-------------------------------------------------------------------------------
#26 Math Utilities:arctan atan this n/a this
"Copied from Trig_Utils (#25800):arctan by Obvious (#54879) Fri Nov 17 06:08:18 1995 PST";
given = args[1];
if (typeof(given) == FLOAT)
return atan(given);
endif
reciprocal = ((given * given) / 10000) + 10000;
reciprocal = sqrt(reciprocal * 10000);
cosine = 100000000 / reciprocal;
return this:arccos(cosine);
-------------------------------------------------------------------------------
#26 Math Utilities:deg2rads deg2rad this n/a this
":deg2rad(FLOAT Degrees) => FLOAT Radians";
return tofloat(args[1]) * 0.0174532925199433;
-------------------------------------------------------------------------------
#26 Math Utilities:rads2deg rad2deg this n/a this
":rads2deg(FLOAT Radians) => FLOAT Degrees";
return tofloat(args[1]) * 57.2957795130824;
-------------------------------------------------------------------------------
#26 Math Utilities:precision this n/a this
":precision(FLOAT Number, INT Digits of Precision) => FLOAT Number";
"Cuts the given number to the given digits of precision.  Uses rounding.";
{digits, pre} = args;
mult = 10.0 ^ pre;
return this:rint(digits * mult) / mult;
-------------------------------------------------------------------------------
#26 Math Utilities:round this n/a this
"Usage: round(INT number, INT round)";
"Rounds 'number' off to the nearest multiple of 'round'.";
"Rounds UP numbers exactly half way in between two round possibilities.";
{what, round} = args;
low = (what / round) * round;
return (what < (low + (round / 2))) ? low | (low + round);
-------------------------------------------------------------------------------
#26 Math Utilities:mean average this n/a this
"Usage: mean(INT, INT, ... )";
"       mean({INT, INT, ...})";
"Returns the average of all integers provided.";
return this:sum(rlist = (typeof(args[1]) == LIST) ? args[1] | args) / length(rlist);
-------------------------------------------------------------------------------
#26 Math Utilities:sum_float this n/a this
":sum_float(FLOAT num, num, num ...) => Total of all arguments added together.";
":sum_float({num, num, num, ...}) will also work.";
{?total = 0.0, @rest} = args;
if (typeof(total) == LIST)
{?total = 0.0, @rest} = total;
endif
for number in (rest)
total = total + number;
endfor
return total;
-------------------------------------------------------------------------------
#26 Math Utilities:sum_int sum this n/a this
":sum_int(INT num, num, num ...) => Total of all arguments added together.";
":sum_int({num, num, num, ...}) will also work.";
"(...also named :sum for backward compatibility).";
"Use :sum_float to sum a list of floats.";
{?total = 0, @rest} = args;
if (typeof(total) == LIST)
{?total = 0, @rest} = total;
endif
for number in (rest)
total = total + number;
endfor
return total;
"... N.B.  For the sake of backward compatibility this routine will also return the float sum of a non-empty lists of floats, but using it this way should not be encouraged.";
-------------------------------------------------------------------------------
#26 Math Utilities:rint this n/a this
":rint(FLOAT Number) => FLOAT Number";
"Returns the given floating-point number rounded to the nearest integer, as a floating-point number.  In case of ties, rounds away from 0.";
{f} = args;
return trunc((f > 0.0) ? f + 0.5 | (f - 0.5));
-------------------------------------------------------------------------------
================================#27 Set Utilities===============================================
#27 Set Utilities:union this n/a this
"Returns the set union of all of the lists provided as arguments.";
if (!args)
return {};
endif
{set, @rest} = args;
for l in (rest)
for x in (l)
set = setadd(set, x);
endfor
endfor
return set;
-------------------------------------------------------------------------------
#27 Set Utilities:intersection this n/a this
"Returns the set intersection of all the lists provided as arguments.";
if (!args)
return {};
endif
max = 0;
{result, @rest} = args;
for set in (rest)
if (length(result) < length(set))
set1 = result;
set2 = set;
else
set1 = set;
set2 = result;
endif
for x in (set1)
if (!(x in set2))
set1 = setremove(set1, x);
endif
endfor
result = set1;
endfor
return result;
-------------------------------------------------------------------------------
#27 Set Utilities:diff*erence this n/a this
"Usage:  diff(set 1, set 2, ..., set n)";
"Returns all elements of set 1 that are not in sets 2..n";
{set, @rest} = args;
for l in (rest)
for x in (l)
set = setremove(set, x);
endfor
endfor
return set;
-------------------------------------------------------------------------------
#27 Set Utilities:contains this n/a this
"True if the first list given is a superset of all subsequent lists.";
"False otherwise.  {} is a superset of {} and nothing else; anything is";
"a superset of {}.  If only one list is given, return true.";
{?super = {}, @rest} = args;
for l in (rest)
for x in (l)
if (!(x in super))
return 0;
endif
endfor
endfor
return 1;
-------------------------------------------------------------------------------
#27 Set Utilities:exclusive_or xor this n/a this
"Usage:  exclusive_or(set, set, ...)";
"Return the set of all elements that are in exactly one of the input sets";
"For two sets, this is the equivalent of (A u B) - (A n B).";
if (!args)
return {};
endif
{set, @rest} = args;
so_far = set;
for l in (rest)
for x in (l)
if (x in so_far)
set = setremove(set, x);
else
set = setadd(set, x);
endif
endfor
so_far = {@so_far, @l};
endfor
return set;
-------------------------------------------------------------------------------
#27 Set Utilities:difference_suspended diff_suspended this n/a this
"Usage:  diff_suspended(set 1, set 2, ..., set n)";
"Returns all elements of set 1 that are not in sets 2..n";
"Suspends as needed if the lists are large.";
{set, @rest} = args;
for l in (rest)
for x in (l)
set = setremove(set, x);
$command_utils:suspend_if_needed(0);
endfor
endfor
return set;
-------------------------------------------------------------------------------
#27 Set Utilities:equal this n/a this
"True if the two lists given contain the same elements.";
"False otherwise.";
{set1, set2} = args;
while (set1)
{elt, @set1} = set1;
if (elt in set2)
set2 = setremove(set2, elt);
while (elt in set2)
set2 = setremove(set2, elt);
endwhile
while (elt in set1)
set1 = setremove(set1, elt);
endwhile
else
return 0;
endif
endwhile
if (set2)
return 0;
else
return 1;
endif
-------------------------------------------------------------------------------
#27 Set Utilities:intersection_preserve_case this n/a this
"Copied from Fox (#54902):intersection Mon Dec 27 17:02:57 1993 PST";
"a version of $set_utils:intersection that maintains the property that everything in the return value is in the first argument, even considering case";
if (!args)
return {};
endif
{result, @rest} = args;
for s in (rest)
for x in (result)
if (!(x in s))
result = setremove(result, x);
endif
endfor
endfor
return result;
-------------------------------------------------------------------------------
================================#28 Builtin Function Help===============================================
#28 Builtin Function Help.toliteral() rc = MOOList [ "Syntax:  toliteral (<value>)   => STR", "", "Returns a string containing a MOO literal expression that, when evaluated, would be equal to <value>. If no arguments or more than one argument is given, E_ARGS is raised.", "", "Examples:", "toliteral(43)                       =>  "43"", "toliteral(1.0/3.0)                  =>  "0.33333333333333"", "toliteral(#17)                      =>  "#17"", "toliteral(E_PERM)                   =>  "E_PERM"", "toliteral({"A", "B", {"C", 123}})   =>  "{\"A\", \"B\", {\"C\", 123}}"" ]
#28 Builtin Function Help.value_hash() rc = MOOList [ "Syntax:  value_hash (<value>)   => STR", "", "Returns the same string as `string_hash(toliteral(<value>))'; see the description of `string_hash()' for details." ]
#28 Builtin Function Help.length() rc = MOOList [ "Syntax:  length (<list or string>)   => int", "", "Returns the number of characters in <list or string>.  ", "", "    length("foo")       =>   3", "    length("")          =>   0", "    length({1, 2, 3})   =>   3", "    length({})          =>   0" ]
#28 Builtin Function Help.listdelete() rc = MOOList [ "Syntax:  listdelete (LIST <list>, INT <index>)   => LIST", "", "Returns a copy of <list> with the <index>th element removed.  If <index> is not in the range `[1..length(<list>)]', then E_RANGE is raised.", "", "    x = {"foo", "bar", "baz"};", "    listdelete(x, 2)   =>   {"foo", "baz"}" ]
#28 Builtin Function Help.tostr() rc = MOOList [ "Syntax:  tostr (<value>, ...)   => STR", "", "Converts all of the given MOO values into strings and returns the concatenation of the results.", "", "    tostr(17)                  =>   "17"", "    tostr(1.0/3.0)             =>   "0.333333333333333"", "    tostr(#17)                 =>   "#17"", "    tostr("foo")               =>   "foo"", "    tostr({1, 2})              =>   "{list}"", "    tostr(E_PERM)              =>   "Permission denied"", "    tostr("3 + 4 = ", 3 + 4)   =>   "3 + 4 = 7"", "", "Note that `tostr()' does not do a good job of converting lists into strings; all lists, including the empty list, are converted into the string `"{list}"'. The function `toliteral()' is better for this purpose." ]
#28 Builtin Function Help.listinsert() rc = MOOList [ "Syntax:  listinsert (LIST <list>, <value> [, INT <index>])   => list", "         listappend (LIST <list>, <value> [, INT <index>])   => list", "", "These functions return a copy of <list> with <value> added as a new element.  `listinsert()' and `listappend()' add <value> before and after (respectively) the existing element with the given <index>, if provided.", "", "The following three expressions always have the same value:", "", "    listinsert(<list>, <element>, <index>)", "    listappend(<list>, <element>, <index> - 1)", "    {@<list>[1..<index> - 1], <element>, @<list>[<index>..length(<list>)]}", "", "If <index> is not provided, then `listappend()' adds the <value> at the end of the list and `listinsert()' adds it at the beginning; this usage is discouraged, however, since the same intent can be more clearly expressed using the list-construction expression, as shown in the examples below.", "", "    x = {1, 2, 3};", "    listappend(x, 4, 2)   =>   {1, 2, 4, 3}", "    listinsert(x, 4, 2)   =>   {1, 4, 2, 3}", "    listappend(x, 4)      =>   {1, 2, 3, 4}", "    listinsert(x, 4)      =>   {4, 1, 2, 3}", "    {@x, 4}               =>   {1, 2, 3, 4}", "    {4, @x}               =>   {4, 1, 2, 3}" ]
#28 Builtin Function Help.resume() rc = MOOList [ "Syntax:  resume (INT task-id [, value])   => none", "", "Immediately ends the suspension of the suspended task with the given <task-id>; that task's call to `suspend()' will return <value>, which defaults to zero. `Resume()' raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task." ]
#28 Builtin Function Help.seconds_left() rc = MOOList [ "*forward*", "ticks_left()" ]
#28 Builtin Function Help.asin() rc = MOOList [ "Syntax:  asin (FLOAT <x>)   => FLOAT", "", "Returns the arc-sine (inverse sine) of x, in the range [-pi/2..pi/2]. Raises E_INVARG if x is outside the range [-1.0..1.0]." ]
#28 Builtin Function Help.task_id() rc = MOOList [ "Syntax:  task_id ()   => INT", "", "Returns the numeric identifier for the currently-executing task.  Such numbers are randomly selected for each task and can therefore safely be used in circumstances where unpredictability is required." ]
#28 Builtin Function Help.listset() rc = MOOList [ "Syntax:  listset (LIST <list>, <value>, INT <index>)   => LIST", "", "Returns a copy of <list> with the <index>th element replaced by <value>.  If <index> is not in the range `[1..length(<list>)]', then E_RANGE is raised.", "", "    x = {"foo", "bar", "baz"};", "    listset(x, "mumble", 2)   =>   {"foo", "mumble", "baz"}", "", "This function exists primarly for historical reasons; it was used heavily before the server supported indexed assignments like x[i] = v. New code should always use indexed assignment instead of `listset()' wherever possible." ]
#28 Builtin Function Help.exp() rc = MOOList [ "Syntax:  exp (FLOAT x)   => FLOAT", "", "Returns `e' raised to the power of <x>." ]
#28 Builtin Function Help.parent() rc = MOOList [ "Syntax:  parent (OBJ <object>)   => OBJ", "       children (OBJ <object>)   => LIST", "", "These functions return the parent and a list of the children of <object>, respectively.  If <object> is not valid, then E_INVARG is raised." ]
#28 Builtin Function Help.is_player() rc = MOOList [ "Syntax:  is_player (OBJ <object>)   => INT", "", "Returns a true value if the given <object> is a player object and a false value otherwise.  If <object> is not valid, E_INVARG is raised." ]
#28 Builtin Function Help.substitute() rc = MOOList [ "Syntax:  substitute (STR <template>, LIST <subs>)  => STR", "", "Performs a standard set of substitutions on the string <template>, using the information contained in <subs>, returning the resulting, transformed <template>.  <Subs> should be a list like those returned by `match()' or `rmatch()' when the match succeeds.", "", "In <template>, the strings `%1' through `%9' will be replaced by the text matched by the first through ninth parenthesized sub-patterns when `match()' or `rmatch()' was called.  The string `%0' in <template> will be replaced by the text matched by the pattern as a whole when `match()' or `rmatch()' was called. The string '%%' will be replaced by a single '%' sign. If '%' appears in <template> followed by any other character, E_INVARG will be raised.", "", "     subs = match("*** Welcome to LambdaMOO!!!", "%(%w*%) to %(%w*%)");", "     substitute("I thank you for your %1 here in %2.", subs)", "             =>   "I thank you for your Welcome here in LambdaMOO."" ]
#28 Builtin Function Help.shutdown() rc = MOOList [ "Syntax:  shutdown ([STR <message>])   => none", "", "Requests that the server shut itself down at its next opportunity.  Before doing so, the given <message> is printed to all connected players.  If the programmer is not a wizard, then E_PERM is raised." ]
#28 Builtin Function Help.acos() rc = MOOList [ "Syntax:  acos (FLOAT <x>)   => FLOAT", "", "Returns the arc-cosine (inverse cosine) of x, in the range [0..pi]. Raises E_INVARG if x is outside the range [-1.0..1.0]." ]
#28 Builtin Function Help.set_connection_option() rc = MOOList [ "Syntax:  set_connection_option (OBJ conn, STR option, value)   => none", "", "Controls a number of optional behaviors associated the connection <conn>. Raises `E_INVARG' if <conn> does not specify a current connection and `E_PERM' if the programmer is neither <conn> nor a wizard. Unless otherwise specified below, options can only be set (<value> is true) or unset (otherwise). The following values for <option> are currently supported:  ", "", ""binary"", "   When set, the connection is in `binary mode', in which case both input from and output to <conn> can contain arbitrary bytes. Input from a connection in binary mode is not broken into lines at all; it is delivered to either the read() function or normal command parsing as `binary strings', in whatever size chunks come back from the operating system. (See the early section in the LambdaMOO Programmers Manual on MOO value types for a description of the binary string representation.) For output to a connection in binary mode, the second argument to `notify()' must be a binary string; if it is malformed, `E_INVARG' is raised.", "", "   Fine point: If the connection mode is changed at any time when there is pending input on the connection, said input will be delivered as per the previous mode (i.e., when switching out of binary mode, there may be pending ``lines'' containing tilde-escapes for embedded linebreaks, tabs, tildes and other characters; when switching into binary mode, there may be pending lines containing raw tabs and from which nonprintable characters have been silently dropped as per normal mode. Only during the initial invocation of `$do_login_command()' on an incoming connection or immediately after the call to `open_network_connection()' that creates an outgoing connection is there guaranteed not to be pending input. At other times you will probably want to flush any pending input immediately after changing the connection mode.", "", ""hold-input"", "   When set, no input received on <conn> will be treated as a command; instead, all input remains in the queue until retrieved by calls to `read()' or until this connection option is unset, at which point command processing resumes. Processing of out-of-band input lines is unaffected by this option.", "", ""disable-oob"", "   When set, disables all out of band processing. All subsequent input lines until the next command that unsets this option will be made available for reading tasks or normal command parsing exactly as if the out-of-band prefix and the out-of-band quoting prefix had not been defined for this server.", "", ""client-echo"", "   The setting of this option is of no significance to the server. However calling `set_connection_option()' for this option sends the Telnet Protocol `WONT ECHO' or `WILL ECHO' command, depending on whether <value> is true or false, respectively. For clients that support the Telnet Protocol, this should toggle whether or not the client echoes locally the characters typed by the user. Note that the server itself never echoes input characters under any circumstances. (This option is only available under the TCP/IP networking configurations.)", "", ""flush-command"", "   This option is string-valued. If <value> is a non-empty string, then it becomes the new `flush' command for this connection, by which the player can flush all queued input that has not yet been processed by the server. If the string is empty, then <conn> is set to have no flush command at all. `set_connection_option' also allows specifying a non-string <value> which is equivalent to specifying the empty string. The default value of this option can be set via the property `$server_options.default_flush_command'; see the chapter in the LambdaMOO Programmers Manual on server assumptions about the database for details.", "", ""intrinsic-commands"", "   This option value is a list of strings, each being the name of one of the available server intrinsic commands (see the section in the LambdaMOO Programmers Manual on Command Lines That Receive Special Treatment). Commands not on the list are disabled, i.e., treated as normal MOO commands to be handled by `$do_command' and/or the built-in command parser. `set_connection_option' also allows specifying an integer <value> which, if zero, is equivalent to specifying the empty list, and otherwise is taken to be the list of all available intrinsic commands (the default setting).  ", "", "   Thus, one way to make the verbname `PREFIX' available as an ordinary command is as follows:", "", "    set_connection_option(player, "intrinsic-commands",", "      setremove(connection_option(player, "intrinsic-commands"), "PREFIX"));", "", "   Note that `connection_option()' always returns the list, even if `set_connection_option' was previously called with a numeric value.  Thus,", "", "    save = connection_option(player,"intrinsic-commands");", "    set_connection_option(player, "intrinsic-commands, 1);", "    full_list = connection_option(player,"intrinsic-commands");", "    set_connection_option(player,"intrinsic-commands", save);", "    return full_list;", "", "   is a way of getting the full list of intrinsic commands available in the server while leaving the current connection unaffected." ]
#28 Builtin Function Help.toint() rc = MOOList [ "*forward*", "tonum()" ]
#28 Builtin Function Help.clear_property() rc = MOOList [ "Syntax:  clear_property (OBJ <object>, STR <prop-name>)  => none", "      is_clear_property (OBJ <object>, STR <prop-name>)  => INT", "", "These two functions test for clear and set to clear, respectively, the property named <prop-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> has no non-built-in property named <prop-name>, then E_PROPNF is raised.  If the programmer does not have read (write) permission on the property in question, then `is_clear_property()' (`clear_property()') raises E_PERM. If a property is clear, then when the value of that property is queried the value of the parent's property of the same name is returned.  If the parent's property is clear, then the parent's parent's value is examined, and so on. If <object> is the definer of the property <prop-name>, as opposed to an inheritor of the property, then `clear_property()' raises E_INVARG." ]
#28 Builtin Function Help.listeners() rc = MOOList [ "Syntax:  listeners ()  => LIST", "", "Returns a list describing all existing listening points, including the default one set up automatically by the server when it was started (unless that one has since been destroyed by a call to `unlisten()'). Each element of the list has the following form:", "", "  {<object>, <canon>, <print-messages>}", "", "where <object> is the first argument given in the call to `listen()' to create this listening point, <print-messages> is true if the third argument in that call was provided and true, and <canon> was the value returned by that call. (For the initial listening point, <object> is #0, <canon> is determined by the command-line arguments or a network-configuration-specific default, and <print-messages> is true.)" ]
#28 Builtin Function Help.setadd() rc = MOOList [ "Syntax:  setadd (LIST <list>, <value>)   => LIST", "      setremove (LIST <list>, <value>)   => LIST", "", "Returns a copy of <list> with the given <value> added or removed, as appropriate.  `Setadd()' only adds <value> if it is not already an element of <list>; <list> is thus treated as a mathematical set. <value> is added at the end of the resulting list, if at all.  Similarly, `setremove()' returns a list identical to <list> if <value> is not an element.  If <value> appears more than once in <list>, only the first occurrence is removed in the returned copy.", "", "    setadd({1, 2, 3}, 3)         =>   {1, 2, 3}", "    setadd({1, 2, 3}, 4)         =>   {1, 2, 3, 4}", "    setremove({1, 2, 3}, 3)      =>   {1, 2}", "    setremove({1, 2, 3}, 4)      =>   {1, 2, 3}", "    setremove({1, 2, 3, 2}, 2)   =>   {1, 3, 2}" ]
#28 Builtin Function Help.listen() rc = MOOList [ "Syntax:  listen (OBJ object, point [, print-messages])   => value", "", "Create a new point at which the server will listen for network connections, just as it does normally. <Object> is the object whose verbs `do_login_command', `do_command', `do_out_of_band_command', `user_connected', `user_created', `user_reconnected', `user_disconnected', and `user_client_disconnected' will be called at appropriate points asthese verbs are called on #0 for normal connections. (See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for the complete story on when these functions are called.) <Point> is a network-configuration-specific parameter describing the listening point. If <print-messages> is provided and true, then the various database-configurable messages (also detailed in the chapter on server assumptions) will be printed on connections received at the new listening point. `Listen()' returns <canon>, a `canonicalized' version of <point>, with any configuration-specific defaulting or aliasing accounted for.", "", "This raises E_PERM if the programmer is not a wizard, E_INVARG if <object> is invalid or there is already a listening point described by <point>, and E_QUOTA if some network-configuration-specific error occurred.", "", "For the TCP/IP configurations, <point> is a TCP port number on which to listen and <canon> is equal to <point> unless <point> is zero, in which case <canaon> is a port number assigned by the operating system.", "", "For the local multi-user configurations, <point> is the UNIX file name to be used as the connection point and <canon> is always equal to <point>.", "", "In the single-user configuration, there can be only one listening point at a time; <point> can be any value at all and <canon> is always zero." ]
#28 Builtin Function Help.valid() rc = MOOList [ "Syntax:  valid (OBJ <object>)   => INT", "", "Returns a non-zero integer (i.e., a true value) if <object> is a valid object (one that has been created and not yet recycled) and zero (i.e., a false value) otherwise.", "", "    valid(#0)    =>   1", "    valid(#-1)   =>   0" ]
#28 Builtin Function Help.strsub() rc = MOOList [ "Syntax:  strsub (STR <subject>, STR <what>, STR <with> [, <case-matters>])   => STR", "", "Replaces all occurrences in <subject> of <what> with <with>, performing string substitution.  The occurrences are found from left to right and all substitutions happen simultaneously.  By default, occurrences of <what> are searched for while ignoring the upper/lower case distinction. If <case-matters> is provided and true, then case is treated as significant in all comparisons.", "", "    strsub("%n is a fink.", "%n", "Fred")   =>   "Fred is a fink."", "    strsub("foobar", "OB", "b")             =>   "fobar"", "    strsub("foobar", "OB", "b", 1)          =>   "foobar"" ]
#28 Builtin Function Help.verb_cache_stats() rc = MOOList [ "Syntax:  verb_cache_stats ()   => LIST", "         log_cache_stats ()    => none", "", "As of version 1.8.1, the server caches verbname-to-program lookups to improve performance.  These functions respectively return or write to the server log file the current cache statistics.  For `verb_cache_stats' the return value will be a list of the form", "", "    {<hits>, <negative_hits>, <misses>, <table_clears>, <histogram>}", "", "though this may change in future server releases.  The cache is invalidated by any builtin function call that may have an effect on verb lookups (e.g., `delete_verb()')." ]
#28 Builtin Function Help.ctime() rc = MOOList [ "Syntax:  ctime ([INT <time>])   => str", "", "Interprets <time> as a time, using the same representation as given in the description of `time()', and converts it into a 28-character, human-readable string in the following format:", "", "    Mon Aug 13 19:13:20 1990 PDT", "", "If the current day of the month is less than 10, then an extra blank appears between the month and the day:", "", "    Mon Apr  1 14:10:43 1991 PST", "", "If <time> is not provided, then the current time is used.", "", "Note that `ctime()' interprets <time> for the local time zone of the computer on which the MOO server is running." ]
#28 Builtin Function Help.boot_player() rc = MOOList [ "Syntax:  boot_player (obj <player>)   => none", "", "Immediately terminates any currently-active connection to the given <player>.  The connection will not actually be closed until the currently-running task returns or suspends, but all MOO functions (such as notify(), connected_players(), and the like) immediately behave as if the connection no longer exists. If the programmer is not either a wizard or the same as <player>, then `E_PERM' is returned.  If there is no currently-active connection to <player>, then this function does nothing.", "", "If there was a currently-active connection, then the following verb call is made when the connection is actually closed:", "", "$user_disconnected(player)", "", "It is not an error if this verb does not exist; the corresponding call is simply skipped." ]
#28 Builtin Function Help.max() rc = MOOList [ "*forward*", "min()" ]
#28 Builtin Function Help.set_property_info() rc = MOOList [ "*forward*", "property_info()" ]
#28 Builtin Function Help.queued_tasks() rc = MOOList [ "Syntax:  queued_tasks ()   => LIST", "", "Returns information on each of the background tasks (i.e., forked, suspended, or reading)  owned by the programmer (or, if the programmer is a wizard, all queued tasks). The returned value is a list of lists, each of which encodes certain information about a particular queued task in the following format:", "", "    {<task-id>, <start-time>, <ticks>, <clock-id>,", "     <programmer>, <verb-loc>, <verb-name>, <line>, <this>, <task-size>}", "", "where <task-id> is a numeric identifier for this queued task, <start-time> is the time after which this task will begin execution (in `time()' format), <ticks> is the number of ticks this task will have when it starts (always 20,000 now, though this is changeable. This makes this value obsolete and no longer interesting), <clock-id> is a number whose value is no longer interesting, <programmer> is the permissions with which this task will begin execution (and also the player who "owns" this task), <verb-loc> is the object on which the verb that forked this task was defined at the time, <verb-name> is that name of that verb, <line> is the number of the first line of the code in that verb that this task will execute, and <this> is the value of the variable `this' in that verb. For reading tasks, <start-time> is `-1'.  <task-size> is in bytes, and is the size of memory in use by the task for local variables, stack frames, etc.", "", "The <ticks> and <clock-id> fields are now obsolete and are retained only for backward-compatibility reasons.  They may disappear in a future version of the server." ]
#28 Builtin Function Help.server_version() rc = MOOList [ "Syntax:  server_version ()   => str", "", "Returns a string giving the version number of the MOO server in the following", "format:", "", "    "<major>.<minor>.<release>"", "", "where <major>, <minor>, and <release> are all decimal numbers.", "", "The major version number changes very slowly, only when existing MOO code might", "stop working, due to an incompatible change in the syntax or semantics of the", "programming language, or when an incompatible change is made to the database", "format.", "", "The minor version number changes more quickly, whenever an upward-compatible", "change is made in the programming language syntax or semantics.  The most", "common cause of this is the addition of a new kind of expression, statement, or", "built-in function.", "", "The release version number changes as frequently as bugs are fixed in the", "server code.  Changes in the release number indicate changes that should only", "be visible to users as bug fixes, if at all." ]
#28 Builtin Function Help.read() rc = MOOList [ "Syntax:  read ([OBJ <conn> [, non-blocking]])   => STR", "", "Reads and returns a line of input from the connection <conn> (or, if not provided, from the player that typed the command that initiated the current task). If <non-blocking> is false or not provided, this function suspends the current task, resuming it when there is input available to be read. If <non-blocking> is provided and true, this function never suspends the calling task; if there is no input currently available for input, `read()' simply returns 0 immediately.", "", "If <conn> is provided, then the programmer must either be a wizard or the owner of <conn>, if <conn> is not provided, then `read()' may only be called by a wizard and only in the task that was last spawned by a command from the connection in question. Otherwise, E_PERM is raised. If the given <conn> is not currently connected and has no pending lines of input, or if the connection is closed while a task is waiting for input but before any lines of input are received, then `read()' raises E_INVARG.", "", "The restriction on the use of `read()' without any arguments preserves the following simple invariant: if input is being read from a player, it is for the task started by the last command that the player typed. This invariant adds responsibility to the programmer, however. If your program calls another verb before doing a `read()', then either that verb must not suspend, or else you must arrange that no commands will be read from the connection in the meantime. The most straightforward way to do this is to call", "", "  set_connection_option(<conn>, "hold-input", 1)", "", "before any task suspension could happen, then make all of your calls to `read()' and other code that might suspend, and finally call", "", "  set_connection_option(<conn>, "hold-input", 0)", "", "to allow commands once again to be read and interpreted normally." ]
#28 Builtin Function Help.tanh() rc = MOOList [ "*forward*", "sinh()" ]
#28 Builtin Function Help.log_cache_stats() rc = MOOList [ "*forward*", "verb_cache_stats()" ]
#28 Builtin Function Help.delete_verb() rc = MOOList [ "Syntax:  delete_verb (obj <object>, str <verb-name>)   => none", "", "Removes the verb named <verb-name> from the given <object>.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised. If <object> does not define a verb named <verb-name>, then E_VERBNF is raised." ]
#28 Builtin Function Help.reset_max_object() rc = MOOList [ "Syntax:  reset_max_object ()   => none", "", "The server's idea of the highest object number ever used is changed to be the highest object number of a currently-existing object, thus allowing reuse of any higher numbers that refer to now-recycled objects.  If the programmer is not a wizard, then E_PERM is raised.", "", "This operation is intended for use in making new versions of the LambdaCore database from the then-current LambdaMOO database, and other similar situations.  Its use requires great care." ]
#28 Builtin Function Help.players() rc = MOOList [ "Syntax:  players ()   => list", "", "Returns a list of the object numbers of all player objects in the database." ]
#28 Builtin Function Help.floor() rc = MOOList [ "Syntax:  floor (FLOAT x)   => FLOAT", "", "Returns the largest integer not greater than x, as a floating-point number." ]
#28 Builtin Function Help.sin() rc = MOOList [ "Syntax:  cos (FLOAT x)   => FLOAT", "         sin (FLOAT x)   => FLOAT", "         tan (FLOAT x)   => FLOAT", "", "Returns the cosine, sine, or tangent of <x>, respectively." ]
#28 Builtin Function Help.property_info() rc = MOOList [ "Syntax:  property_info (OBJ <object>, STR <prop-name>)   => LIST", "     set_property_info (OBJ <object>, STR <prop-name>, LIST <info>)   => none", "", "These two functions get and set (respectively) the owner and permission bits for the property named <prop-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> has no non-built-in property named <prop-name>, then E_PROPNF is raised.  If the programmer does not have read (write) permission on the property in question, then `property_info()' (`set_property_info()') raises E_PERM.  Property info has the following form:", "", "    {<owner>, <perms> [, new-name]}", "", "where <owner> is an object and <perms> is a string containing only characters from the set `r', `w', and `c', and <new-name> is a string; <new-name> is never part of the value returned by `property_info()', but it may optionally be given as part of the value provided to `set_property_info()'.  This list is the kind of value returned by `property_info()' and expected as the third argument to `set_property_info()'; the latter function raises E_INVARG if <owner> is not valid or <perms> contains any illegal characters, or, when <new-name> is given, if <prop-name> is not defined directly on <object> or <new-name> names an existing property defined on <object> or any of its ancestors or descendants." ]
#28 Builtin Function Help.log() rc = MOOList [ "Syntax:  log (FLOAT x)     => FLOAT", "         log10 (FLOAT x)   => FLOAT", "", "Returns the natural or base 10 logarithm of <x>. Raises E_INVARG if <x> is not positive." ]
#28 Builtin Function Help.time() rc = MOOList [ "Syntax:  time ()   => INT", "", "Returns the current time, represented as the number of seconds that have elapsed since midnight on 1 January 1970, Greenwich Mean Time." ]
#28 Builtin Function Help.is_clear_property() rc = MOOList [ "*forward*", "clear_property()" ]
#28 Builtin Function Help.call_function() rc = MOOList [ "Syntax:  call_function (STR func-name, arg, ...)   => value", "", "Calls the built-in function named `func-name', passing the given arguments, and returns whatever that function returns. Raises E_INVARG if func-name is not recognized as the name of a known built-in function. This allows you to compute the name of the function to call and, in particular, allows you to write a call to a built-in function that may or may not exist in the particular version of the server you're using." ]
#28 Builtin Function Help.set_verb_code() rc = MOOList [ "*forward*", "verb_code()" ]
#28 Builtin Function Help.floatstr() rc = MOOList [ "Syntax:  floatstr (FLOAT x, INT precision [, scientific])   => STR", "", "Converts <x> into a string with more control than provided by either `tostr()' or `toliteral()'. <Precision> is the number of digits to appear to the right of the decimal point, capped at 4 more than the maximum available precision, a total of 19 on most machines; this makes it possible to avoid rounding errors if the resulting string is subsequently read back as a floating-point value. If <scientific> is false or not provided, the result is a string in the form "MMMMMMM.DDDDDD", preceded by a minus sign if and only if <x> is negative. If <scientific> is provided and true, the result is a string in the form "M.DDDDDDe+EEE", again preceded by a minus sign if and only if <x> is negative." ]
#28 Builtin Function Help.tonum() rc = MOOList [ "Syntax:  toint (<value>)   => INT", "         tonum (<value>)   => INT", "", "Converts the given MOO value into an integer and returns that integer. Floating-point numbers are rounded toward zero, truncating their fractional parts. Object numbers are converted into the equivalent integers, strings are parsed as the decimal encoding of a real number which is then converted to an integer. Errors are converted into integers obeying the same ordering (with respect to `<=' as the errors themselves.) `Toint()' raises E_TYPE if <value> is a LIST.  If <value> is a string but the string does not contain a syntactically-correct number, then `toint()' returns 0.", "", "    toint(34.7)        =>   34", "    toint(-34.7)       =>   34", "    toint(#34)         =>   34", "    toint("34")        =>   34", "    toint("34.7")      =>   34", "    toint(" - 34  ")   =>  -34", "    toint(E_TYPE)      =>    1" ]
#28 Builtin Function Help.cos() rc = MOOList [ "*forward*", "sin()" ]
#28 Builtin Function Help.equal() rc = MOOList [ "Syntax:  equal(value1, value2)   => INT", "", "Returns true if <value1> is completely indistinguishable from <value2>. This is much the same operation as "<value1> == <value2>" except that, unlike ==, the `equal()' function does not treat upper- and lower-case characters in strings as equal.", "", "Raises E_ARGS if none, one, or more than two arguments are given.", "", "equal(1, 2)                   => 0", "equal("ChIcKeN", "chicken")   => 0", "equal("ABC123", "ABC123")     => 1" ]
#28 Builtin Function Help.notify() rc = MOOList [ "Syntax:  notify (OBJ conn, STR string [, no-flush]) => 0 or 1", "", "Enqueues <string> for output (on a line by itself) on the connection <conn>. If the programmer is not <conn> or a wizard, then E_PERM is raised. If <conn> is not a currently-active connection, then this function does nothing. Output is normally written to connections only between tasks, not during execution.", "", "The server will not queue an arbitrary amount of output for a connection; the `MAX_QUEUED_OUTPUT' compilation option (in `options.h') controls the limit. When an attempt is made to enqueue output that would take the server over its limit, it first tries to write as much output as possible to the connection without having to wait for the other end. If that doesn't result in the new output being able to fit in the queue, the server starts throwing away the oldest lines in the queue until the new output will fit. The server remembers how many lines of output it has `flushed' in this way and, when next it can succeed in writing anything to the connection, it first writes a line like `>> Network buffer overflow; X lines of output to you have been lost <<' where <X> is the number of of flushed lines.", "", "If <no-flush> is provided and true, then `notify()' never flushes any output from the queue; instead it immediately returns false. `Notify()' otherwise always returns true." ]
#28 Builtin Function Help.set_player_flag() rc = MOOList [ "Syntax:  set_player_flag (OBJ <object>, <value>)   => none", "", "Confers or removes the ``player object'' status of the given <object>, depending upon the truth value of <value>.  If <object> is not valid, E_INVARG is raised.  If the programmer is not a wizard, then E_PERM is raised.", "", "If <value> is true, then <object> gains (or keeps) "player object" status: it will be an element of the list returned by `players()', the expression `is_player(<object>)' will return true, and users can connect to <object> by name when they log into the server.", "", "If <value> is false, the <object> loses (or continues to lack) "player object" status: it will not be an element of the list returned by `players()', the expression `is_player(<object>)' will return false, and users cannot connect to <object> by name when they log into the server.  In addition, if a user is connected to <object> at the time that it loses ``player object'' status, then that connection is immediately broken, just as if `boot_player(<object>)' had been called (see the description of `boot_player()' below)." ]
#28 Builtin Function Help.verb_code() rc = MOOList [ "Syntax:  verb_code (OBJ <object>, STR <verb-name> [, <fully-paren> [, <indent>]])   => LIST", "     set_verb_code (OBJ <object>, STR <verb-name>, LIST <code>)   => LIST", "", "These functions get and set (respectively) the MOO-code program associated with the verb named <verb-name> on <object>.  The program is represented as a list of strings, one for each line of the program; this is the kind of value returned by `verb_code()' and expected as the third argument to `set_verb_code()'.  For `verb_code()', the expressions in the returned code are usually written with the minimum-necessary parenthesization; if <fully-paren> is true, then all expressions are fully parenthesized. Also for `verb_code()', the lines in the returned code are usually not indented at all; if <indent> is true, each line is indented to better show the nesting of statements.", "", "If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_code()' (`set_verb_code()') raises E_PERM.  If the programmer is not, in fact, a programmer, then E_PERM is raised.", "", "For `set_verb_code()', the result is a list of strings, the error messages generated by the MOO-code compiler during processing of <code>.  If the list is non-empty, then `set_verb_code()' did not install <code>; the program associated with the verb in question is unchanged." ]
#28 Builtin Function Help.abs() rc = MOOList [ "Syntax:  abs (num <x>)   => num", "", "Returns the absolute value of <x>.  If <x> is negative, then the result is `-<x>'; otherwise, the result is <x>. The number x can be either integer or floating-point; the result is of the same kind." ]
#28 Builtin Function Help.ceil() rc = MOOList [ "Syntax:  ceil (FLOAT <x>)   => FLOAT", "", "Returns the smallest integer not less than x, as a floating-point number." ]
#28 Builtin Function Help.caller_perms() rc = MOOList [ "Syntax:  caller_perms ()   => obj", "", "Returns the permissions in use by the verb that called the currently-executing", "verb.  If the currently-executing verb was not called by another verb (i.e., it", "is the first verb called in a command or server task), then", "`caller_perms()' returns `#-1'." ]
#28 Builtin Function Help.tofloat() rc = MOOList [ "Syntax:  tofloat (value)   => FLOAT", "", "Converts the given MOO value into a floating-point number and returns that number. Integers and objects numbers are converted into the corresponding integral floating-point numbers. Strings are parsed as the decimal encoding of a real number which is then represented as closely as possible as a floating-point number. Errors are first converted to integers as in `toint()' and then converted as integers are. `Tofloat()' raises E_TYPE if <value> is a LIST. If <value> is a string but the string does not contain a syntactically-correct number, then `tofloat()' raises E_INVARG.", "", "  tofloat(34)       =>  34.0", "  tofloat(#34)      =>  34.0", "  tofloat("34")     =>  34.0", "  tofloat("34.7")   =>  34.7", "  tofloat(E_TYPE)   =>  1.0" ]
#28 Builtin Function Help.pass() rc = MOOList [ "Syntax:  pass (<arg>, ...)   => value", "", "Often, it is useful for a child object to define a verb that *augments* the behavior of a verb on its parent object. For example, the root object (an ancestor of every other object) defines a :description() verb that simply returns the value of `this.description'; this verb is used by the implementation of the `look' command. In many cases, a programmer would like the description of some object to include some non-constant part; for example, a sentence about whether or not the object was `awake' or `sleeping'.  This sentence should be added onto the end of the normal description.  The programmer would like to have a means of calling the normal `description' verb and then appending the sentence onto the end of that description.  The function `pass()' is for exactly such situations.", "", "`Pass()' calls the verb with the same name as the current verb but as defined on the parent of the object that defines the current verb.  The arguments given to the called verb are the ones given to pass() and the returned value of the called verb is returned from the call to pass(). The initial value of `this' in the called verb is the same as in the calling verb.", "", "Thus, in the example above, the child-object's :description() verb might have the following implementation:", "", "    return pass(@args) + "  It is " + (this.awake ? "awake." | "sleeping.");", "", "That is, it calls its parent's :description() verb and then appends to the result a sentence whose content is computed based on the value of a property on the object.", "", "In the above example, `pass()' would have worked just as well, since :description() is not normally given any arguements.  However, it is a good idea to get into the habit of using `pass(@args)' rather than `pass(args[1])' or `pass()' even if the verb being pass()ed to is already known to take a set number of arguments or none at all.  For one thing, though the args may be irrelevant to the code that you've written, it may be that the corresponding verb on the parent has been rewritten to take additional arguments, in which case you will want your verb to continue to work..." ]
#28 Builtin Function Help.max_object() rc = MOOList [ "Syntax:  max_object ()   => obj", "", "Returns the largest object number yet assigned to a created object.  Note that", "the object with this number may no longer exist; it may have been recycled.", "The next object created will be assigned the object number one larger than the", "value of `max_object()'." ]
#28 Builtin Function Help.force_input() rc = MOOList [ "Syntax:  force_input (OBJ conn, STR line [, at-front])   => none", "", "Inserts the string <line> as an input task in the queue for the connection <conn>, just as if it had arrived as input over the network. If <at-front> is provided and true, then the new line of input is put at the front of <conn>'s queue, so that it will be the very next line of input processed even if there is already some other input in that queue. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard." ]
#28 Builtin Function Help.connected_seconds() rc = MOOList [ "Syntax:  connected_seconds (obj <player>)   => int", "              idle_seconds (obj <player>)   => int", "", "These functions return the number of seconds that the currently-active connection to <player> has existed and been idle, respectively.  If <player> is not the object number of a player object with a currently-active connection, then E_INVARG is raised." ]
#28 Builtin Function Help.create() rc = MOOList [ "Syntax:  create (obj <parent> [, obj <owner>])   => obj", "", "Creates and returns a new object whose parent is <parent> and whose owner is as described below.  Either the given <parent> object must be fertile (i.e., its `f' bit must be set) or else the programmer must own <parent> or be a wizard; otherwise `E_PERM' is raised. `E_PERM' is also raised if <owner> is provided and not the same as the programmer, unless the programmer is a wizard.  After the new object is created, its `initialize' verb, if any, is called with no arguments.", "", "The new object is assigned the least non-negative object number that has not yet been used for a created object.  Note that no object number is ever reused, even if the object with that number is recycled.", "", "The owner of the new object is either the programmer (if <owner> is not provided), the new object itself (if <owner> was given as `#-1'), or <owner> (otherwise).", "", "The other built-in properties of the new object are initialized as follows:", "    name         """, "    location     #-1", "    contents     {}", "    programmer   0", "    wizard       0", "    r            0", "    w            0", "    f            0", "", "In addition, the new object inherits all of the other properties on <parent>.  These properties have the same permission bits as on <parent>.  If the `c' permissions bit is set, then the owner of the property on the new object is the same as the owner of the new object itself; otherwise, the owner of the property on the new object is the same as that on <parent>.  The initial value of every inherited property is "clear"; see the description of the built-in function `clear_property()' for details.", "", "", "If the intended owner of the new object has a property named `ownership_quota' and the value of that property is a number, then `create()' treats that value as a "quota".  If the quota is less than or equal to zero, then the quota is considered to be exhausted and `create()' raises `E_QUOTA' instead of creating an object. Otherwise, the quota is decremented and stored back into the `ownership_quota' property as a part of the creation of the new object." ]
#28 Builtin Function Help.renumber() rc = MOOList [ "Syntax:  renumber (OBJ <object>)   => OBJ", "", "The object number of the object currently numbered <object> is changed to be the least nonnegative object number not currently in use and the new object number is returned.  If <object> is not valid, then E_INVARG is raised.  If the programmer is not a wizard, then E_PERM is raised. If there are no unused nonnegative object numbers less than <object>, then <object> is returned and no changes take place.", "", "The references to <object> in the parent/children and location/contents hierarchies are updated to use the new object number, and any verbs, properties and/or objects owned by <object> are also changed to be owned by the new object number.  The latter operation can be quite time consuming if the database is large.  No other changes to the database are performed; in particular, no object references in property values or verb code are updated.", "", "This operation is intended for use in making new versions of the LambdaCore database from the then-current LambdaMOO database, and other similar situations.  Its use requires great care." ]
#28 Builtin Function Help.open_network_connection() rc = MOOList [ "Syntax:  open_network_connection (<value>, ... [, <listener>])   => obj", "", "Establishes a network connection to the place specified by the arguments and more-or-less pretends that a new, normal player connection has been established from there.  The new connection, as usual, will not be logged in initially and will have a negative object number associated with it for use with `read()', `notify()', and `boot_player()'.  This object number is the value returned by this function.", "", "If the programmer is not a wizard or if the `OUTBOUND_NETWORK' compilation option was not used in building the server, then `E_PERM' is raised.  If the network connection cannot be made for some reason, then other errors will be returned, depending upon the particular network implementation in use.", "", "For the TCP/IP network implementations (the only ones as of this writing that support outbound connections), there must be at least two arguments, a string naming a host (possibly using the numeric Internet syntax) and an integer specifying a TCP port.  If a connection cannot be made because the host does not exist, the port does not exist, the host is not reachable or refused the connection, `E_INVARG' is raised.  If the connection cannot be made for other reasons, including resource limitations, then `E_QUOTA' is raised.", "", "Beginning with version 1.8.3, an optional third argument may be supplied, `listener' must be an object, whose listening verbs will be called at appropriate points.  See the description in `listen()' for more details.", "", "The outbound connection process involves certain steps that can take quite a long time, during which the server is not doing anything else, including responding to user commands and executing MOO tasks.  See the chapter on server assumptions about the database for details about how the server limits the amount of time it will wait for these steps to successfully complete.", "", "It is worth mentioning one tricky point concerning the use of this function.  Since the server treats the new connection pretty much like any normal player connection, it will naturally try to parse any input from that connection as commands in the usual way.  To prevent this treatment, you should use `set_connection_option()' to set the `hold-input' option true on the connection." ]
#28 Builtin Function Help.crypt() rc = MOOList [ "Syntax:  crypt (str <text> [, str <salt>])   => str", "", "Encrypts the given <text> using the standard UNIX encryption method.  If provided, <salt> should be a two-character string for use as the extra encryption ``salt'' in the algorithm.  If <salt> is not provided, a random pair of characters is used.  In any case, the salt used is also returned as the first two characters of the resulting encrypted string.  ", "", "Aside from the possibly-random selection of the salt, the encryption algorithm is entirely deterministic.  In particular, you can test whether or not a given string is the same as the one used to produced a given piece of encrypted text; simply extract the first two characters of the encrypted text and pass the candidate string and those two characters to `crypt()'.  If the result is identical to the given encrypted text, then you've got a match.  ", "", "    crypt("foobar")         =>   "J3fSFQfgkp26w"", "    crypt("foobar", "J3")   =>   "J3fSFQfgkp26w"", "    crypt("mumble", "J3")   =>   "J3D0.dh.jjmWQ"", "    crypt("foobar", "J4")   =>   "J4AcPxOJ4ncq2"", "", "Note: As of version 1.8.3, the entire salt (of any length) is passed to the operating system's low-level crypt function.  It is unlikely, however, that all operating systems will return the same string when presented with a longer salt.  Therefore, identical calls to `crypt()' may generate different results on different platforms, and your password verification systems will fail.  Use a salt longer than two characters at your own risk." ]
#28 Builtin Function Help.index() rc = MOOList [ "Syntax:  index (STR <str1>, STR <str2> [, <case-matters>])   => INT", "        rindex (STR <str1>, STR <str2> [, <case-matters>])   => INT", "", "The function `index()' (`rindex()') returns the index of the first character of the first (last) occurrence of <str2> in <str1>, or zero if <str2> does not occur in <str1> at all.  By default the search for an occurrence of <str2> is done while ignoring the upper/lower case distinction.  If <case-matters> is provided and true, then case is treated as significant in all comparisons.", "", "    index("foobar", "o")        =>   2", "    rindex("foobar", "o")       =>   3", "    index("foobar", "x")        =>   0", "    index("foobar", "oba")      =>   3", "    index("Foobar", "foo", 1)   =>   0" ]
#28 Builtin Function Help.connection_name() rc = MOOList [ "Syntax:  connection_name (obj <player>)   => str", "", "Returns a network-specific string identifying the connection being used by the given player.  If the programmer is not a wizard and not <player>, then E_PERM is raised.  If <player> is not currently connected, then E_INVARG is raised.", "", "For the TCP/IP networking configurations, for in-bound connections, the string has the form", "", "  "port <lport> from <host>, port <port>"", "", "where <lport> is the listening port on which the connection arrived, <host> is either the name or decimal TCP address of the host to which the connection was opened, and <port> is the decimal TCP port of the connection on that host.", "", "For the System V 'local' networking configuration, the string is the UNIX login name of the connecting user or, if no such name can be found, something of the form", "", "  "User <#number>"", "", "where <#number> is a UNIX numeric user ID.", "", "For the other networking configurations, the string is the same for all connections and, thus, useless." ]
#28 Builtin Function Help.sqrt() rc = MOOList [ "Syntax:  sqrt (FLOAT <x>)  => FLOAT", "", "Returns the square root of <x>.  If <x> is negative, then E_INVARG is raised." ]
#28 Builtin Function Help.children() rc = MOOList [ "*forward*", "parent()" ]
#28 Builtin Function Help.decode_binary() rc = MOOList [ "Syntax:  decode_binary (STR bin-string [, fully])   => LIST", "", "Returns a list of strings and/or integers representing the bytes in the binary string <bin-string> in order. If <fully> is false or omitted, the list contains an integer only for each non-printing, non-space byte; all other characters are grouped into the longest possible contiguous substrings. If <fully> is proved and true, the list contains only integers, one for each byte represented in <bin-string>. Raises E_INVARG if <bin-string> is not a properly-formed binary string. (See the LambdaMOO programmer's manual on MOO value types for a full description of binary strings.)", "", "decode_binary("foo")               =>  {"foo"}", "decode_binary("~~foo")             =>  {"~foo"}", "decode_binary("foo~0D~0A")         =>  {"foo", 13, 10}", "decode_binary("foo~0Abar~0Abaz")   =>  {"foo", 10, "bar", 10, "baz"}", "decode_binary("foo~0D~0A", 1)      =>  {102, 111, 111, 13, 10}" ]
#28 Builtin Function Help.disassemble() rc = MOOList [ "Syntax:  disassemble (OBJ object, STR verb-desc)   => LIST", "", "Returns a (longish) list of strings giving a listing of the server's internal "compiled" form of the verb as specified by <verb-desc> on <object>. This format is not documented and may indeed change from release to release, but some programmers may nonetheless find the output of `disassemble()' interesting to peruse as a way to gain a deeper appreciation of how the server works.", "", "If <object> is not valid, then E_INVARG is raised. If <object> does not define a verb as specified by <verb-desc>, then E_VERBNF is raised. If the programmer does not have read permission on the verb in question, then disassemble() raises E_PERM." ]
#28 Builtin Function Help.unlisten() rc = MOOList [ "Syntax:  unlisten (<canon>)   => none", "", "Stop listening for connections on the point described by <canon>, which should be the second element of some element of the list returned by `listeners()'. Raises E_PERM if the programmer is not a wizard and E_INVARG if there does not exist a listener with that description." ]
#28 Builtin Function Help.listappend() rc = MOOList [ "*forward*", "listinsert()" ]
#28 Builtin Function Help.match() rc = MOOList [ "Syntax:  match (STR <subject>, STR <pattern> [, <case-matters>])  => LIST", "         rmatch (STR <subject>, STR <pattern> [, <case-matters>])  => LIST", "", "The function `match()' (`rmatch()') searches for the first (last) occurrence of the regular expression <pattern> in the string <subject>.  If <pattern> is syntactically malformed, then E_INVARG is raised. The process of matching can in some cases consume a great deal of memory in the server; should this memory consumption become excessive, then the matching process is aborted and E_QUOTA is raised.", "", "If no match is found, the empty list is returned; otherwise, these functions return a list containing information about the match (see below).  By default, the search ignores upper/lower case distinctions.  If <case-matters> is provided and true, then case is treated as significant in all comparisons.", "", "The list that `match()' (`rmatch()') returns contains the details about the match made.  The list is in the form:", "", "     {<start>, <end>, <replacements>, <subject>}", "", "where <start> is the index in STRING of the beginning of the match, <end> is the index of the end of the match, <replacements> is a list described below, and <subject> is the same string that was given as the first argument to the `match()' or `rmatch()'.", "", "The <replacements> list is always nine items long, each item itself being a list of two numbers, the start and end indices in <subject> matched by some parenthesized sub-pattern of <pattern>.  The first item in <replacements> carries the indices for the first parenthesized sub-pattern, the second item carries those for the second sub-pattern, and so on.  If there are fewer than nine parenthesized sub-patterns in <pattern>, or if some sub-pattern was not used in the match, then the corresponding item in <replacements> is the list {0, -1}.  See the discussion of `%)' in `help regular-expressions', for more information on parenthesized sub-patterns.", "", "   match("foo", "f*o")          =>  {1, 2, {{0, -1}, ...}, "foo"}", "   match("foo", "fo*")          =>  {1, 3, {{0, -1}, ...}, "foo"}", "   match("foobar", "o*b")       =>  {2, 4, {{0, -1}, ...}, "foobar"}", "   rmatch("foobar", "o*b")      =>  {4, 4, {{0, -1}, ...}, "foobar"}", "   match("foobar", "f%(o*%)b")  =>  {1, 4, {{2, 3}, {0, -1}, ...}, "foobar"}", "", "See `help regular-expressions' for information on the syntax and semantics of patterns." ]
#28 Builtin Function Help.eval() rc = MOOList [ "Syntax:  eval (str <string>)   => list", "", "The MOO-code compiler processes <string> as if it were to be the program associated with some verb and, if no errors are found, that fictional verb is invoked.  If the programmer is not, in fact, a programmer, then E_PERM is raised.  The normal result of calling `eval()' is a two element list. The first element is true if there were no compilation errors and false otherwise.  The second element is either the result returned from the fictional verb (if there were no compilation errors) or a list of the compiler's error messages (otherwise).", "", "When the fictional verb is invoked, the various built-in variables have values as shown below:", "", "    player    the same as in the calling verb", "    this      #-1", "    caller    the same as the initial value of `this' in the calling verb", "", "    args      {}", "    argstr    """, "", "    verb      """, "    dobjstr   """, "    dobj      #-1", "    prepstr   """, "    iobjstr   """, "    iobj      #-1", "", "The fictional verb runs with the permissions of the programmer and as if its `d' permissions bit were on.", "", "    eval("return 3 + 4;")   =>   {1, 7}" ]
#28 Builtin Function Help.builtin-index rc = MOOList [ "*index*", "Server Built-in Functions" ]
#28 Builtin Function Help.toobj() rc = MOOList [ "Syntax:  toobj (<value>)   => OBJ", "", "Converts the given MOO value into an object number and returns that object number.  The conversions are very similar to those for `toint()' except that for strings, the number *may* be preceded by `#'.", "", "    toobj("34")       =>   #34", "    toobj("#34")      =>   #34", "    toobj("foo")      =>   #0", "    toobj({1, 2})     -error->   E_TYPE" ]
#28 Builtin Function Help.flush_input() rc = MOOList [ "Syntax:  flush_input (OBJ conn [, show-messages])   => none", "", "Performs the same actions as if the connection <conn>'s definied flush command had been received on that connection, i.e., removes all pending lines of input from <conn>'s queue and, if <show-messages> is provided and true, prints a messages to <conn> listing the flushed lines, if any.  See the chapter in the LambdaMOO Programmer's Manual on server assumptions about the database for more information about a connection's defined flush command." ]
#28 Builtin Function Help.strcmp() rc = MOOList [ "Syntax:  strcmp (STR <str1>, STR <str2>)   => INT", "", "Performs a case-sensitive comparison of the two argument strings.  If <str1> is lexicographically less than <str2>, the `strcmp()' returns a negative number.  If the two strings are identical, `strcmp()' returns zero.  Otherwise, `strcmp()' returns a positive number.  The ASCII character ordering is used for the comparison." ]
#28 Builtin Function Help.value_bytes() rc = MOOList [ "Syntax:  value_bytes(<value>)   => INT", "", "Returns the number of bytes of the server's memory required to store the given <value>." ]
#28 Builtin Function Help.memory_usage() rc = MOOList [ "Syntax:  memory_usage ()   => list", "", "On some versions of the server, this returns statistics concerning the server", "consumption of system memory.  The result is a list of lists, each in the", "following format:", "", "    {<block-size>, <nused>, <nfree>}", "", "where <block-size> is the size in bytes of a particular class of memory", "fragments, <nused> is the number of such fragments currently in use in the", "server, and <nfree> is the number of such fragments that have been reserved", "for use but are currently free.", "", "On servers for which such statistics are not available, `memory_usage()'", "returns `{}'.  The compilation option `USE_SYSTEM_MALLOC' controls", "whether or not statistics are available; if the option is provided, statistics", "are not available." ]
#28 Builtin Function Help.verb_info() rc = MOOList [ "Syntax:  verb_info (OBJ <object>, STR <verb-name>)   => LIST", "     set_verb_info (OBJ <object>, STR <verb-name>, LIST <info>)   => none", "", "These two functions get and set (respectively) the owner, permission bits, and name(s) for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised. If the programmer does not have read (write) permission on the verb in question, then `verb_info()' (`set_verb_info()') raises E_PERM.  Verb info has the following form:", "", "    {<owner>, <perms>, <names>}", "", "where <owner> is an object, <perms> is a string containing only characters from the set `r', `w', `x', and `d', and <names> is a string.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'. The latter function raises E_INVARG if <owner> is not valid, if <perms> contains any illegal characters, or if <names> is the empty string or consists entirely of spaces; it raises E_PERM if <owner> is not the programmer and the programmer is not a wizard." ]
#28 Builtin Function Help.output_delimiters() rc = MOOList [ "Syntax:  output_delimiters (OBJ <player>)   => LIST", "", "Returns a list of two strings, the current "output prefix" and "output suffix" for <player>.  If <player> does not have an active network connection, then E_INVARG is raised.  If either string is currently undefined, the value `""' is used instead.  See the discussion of the `PREFIX' and `SUFFIX' commands in the LambdaMOO Programmers Manual for more information about the output prefix and suffix." ]
#28 Builtin Function Help.function_info() rc = MOOList [ "Syntax:  function_info ([STR name])   => LIST", "", "Returns descriptions of the various built-in functions available on the server. If <name> is provided, only the description of the function with that name is returned. If <name> is omitted, a list of descriptions is returned, one for each function available on the server. E_INVARG is raised if <name> is provided but no function with that name is available on the server.", "", "Each function description is a list of the following form:", "", "  {<name>, <min-args>, <max-args>, <types>}", "", "where <name> is the name of the built-in function, <min-args> is the minimum number of arguments that must be to the function, <max-args> is the maximum number of arguments that can be provided to the function or -1 if there is no maximum, and <types> is a list of <max-args> integers (or <min-args> if <max-args> is -1), each of which represents the type of argument required in the corresponding position. Each type number is as would be returned from the `typeof()' built-in function except that -1 indicates that any type of value is acceptable and -2 indicates that either integers or floating-point numbers may be given. For example, here are several entries from the list:", "", "  {"listdelete", 2, 2, {4, 0}}", "  {"suspend", 0, 1, {0}}", "  {"server_log", 1, 2, {2, -1}}", "  {"max", 1, -1, {-2}}", "  {"tostr", 0, -1, {}}", "", "`Listdelete()' takes exactly 2 arguments, of which the first must be a list (LIST == 4) and the second must be an integer (INT == 0). `Suspend()' has one optional argument that, if provided, must be an integer. `Server_log()' has one required argument that must be a string (STR == 2) and one optional argument that, if provided, may be of any type. `Max()' requires at least one argument but can take any number above that, and the first argument must be either an integer or a floating-point number; the type(s) required for any other arguments can't be determined from this description. Finally, `tostr()' takes any number of arguments at all, but it can't be determined from this description which argument types would be acceptable in which positions." ]
#28 Builtin Function Help.sinh() rc = MOOList [ "Syntax:  cosh (FLOAT x)   => FLOAT", "         sinh (FLOAT x)   => FLOAT", "         tanh (FLOAT x)   => FLOAT", "", "Returns the hyperbolic cosine, sine, or tangent of <x>, respectively." ]
#28 Builtin Function Help.add_verb() rc = MOOList [ "Syntax:  add_verb (obj <object>, list <info>, list <args>)   => int", "", "Defines a new verb on the given <object>.  The new verb's owner, permission bits and name(s) are given by <info> in the same format as is returned by `verb_info()'.  The new verb's direct-object, preposition, and indirect-object specifications are given by <args> in the same format as is returned by `verb_args()'.  The new verb initially has the empty program associated with  it; this program does nothing but return an unspecified value.  ", "", "If <object> is not valid, or <info> does not specify a valid owner and well-formed permission bits and verb names, or <args> is not a legitimate syntax specification, then `E_INVARG' is raised.  If the programmer does not have write permission on <object> or if the owner specified by <info> is not the programmer and the programmer is not a wizard, then `E_PERM' is raised.  Otherwise, this function returns a positive integer representing the new verb's index in this object's `verbs()' list.  " ]
#28 Builtin Function Help.connection_options() rc = MOOList [ "Syntax:  connection_options (OBJ conn)   => LIST", "", "Return a list of (<name>, <value>) pairs describing the current settings of all of the allowed options for the connection <conn>. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard." ]
#28 Builtin Function Help.recycle() rc = MOOList [ "Syntax:  recycle (OBJ <object>)   => none", "", "The given <object> is destroyed, irrevocably.  The programmer must either own <object> or be a wizard; otherwise, E_PERM is raised.  If <object> is not valid, then E_INVARG is raised.  The children of <object> are reparented to the parent of <object>.  Before <object> is recycled, each object in its contents is moved to `#-1' (implying a call to <object>'s `exitfunc' verb, if any) and then <object>'s `recycle' verb, if any, is called with no arguments.", "", "After <object> is recycled, if the owner of the former object has a property named `ownership_quota' and the value of that property is a number, then `recycle()' treats that value as a "quota" and increments it by one, storing the result back into the `ownership_quota' property." ]
#28 Builtin Function Help.server_log() rc = MOOList [ "Syntax:  server_log (STR <message> [, <is-error>])  => none", "", "The text in <message> is sent to the server log.  If the programmer is not a wizard, then E_PERM is raised.  If <is-error> is provided and true, then <message> is marked in the server log as an error." ]
#28 Builtin Function Help.chparent() rc = MOOList [ "Syntax:  chparent (obj <object>, obj <new-parent>)   => none", "", "Changes the parent of <object> to be <new-parent>. If <object> is not valid, or if <new-parent> is neither valid nor equal to #-1, then E_INVARG is raised. If the programmer is neither a wizard or the owner of <object>, or if <new-parent> is not fertile (i.e., its `f' bit is not set) and the programmer is neither the owner of <new-parent> nor a wizard, then `E_PERM' is raised.  If <new-parent> is equal to <object> or one of its current ancestors, E_RECMOVE is raised. If <object> or one of its descendants defines a property with the same name as one defined either on <new-parent> or on one of its ancestors, then `E_INVARG' is returned.", "", "Changing an object's parent can have the effect of removing some properties from and adding some other properties to that object and all of its descendants (i.e., its children and its children's children, etc.).  Let <common> be the nearest ancestor that <object> and <new-parent> have in common before the parent of <object> is changed.  Then all properties defined by ancestors of <object> under <common> (that is, those ancestors of <object> that are in turn descendants of <common>) are removed from <object> and all of its descendants.  All properties defined by <new-parent> or its ancestors under <common> are added to <object> and all of its descendants.  As with `create()', the newly-added properties are given the same permission bits as they have on <new-parent>, the owner of each added property is either the owner of the object it's added to (if the `c' permissions bit is set) or the owner of that property on <new-parent>, and the value of each added property is "clear"; see the description of the built-in function `clear_property()' for details.  All properties that are not removed or added in the reparenting process are completely unchanged.", "", "If <new-parent> is equal to #-1, then <object> is given no parent at all; it becomes a new root of the parent/child hierarchy. In this case, all formerly inherited properties on <object> are simply removed." ]
#28 Builtin Function Help.rmatch() rc = MOOList [ "*forward*", "match()" ]
#28 Builtin Function Help.callers() rc = MOOList [ "Syntax:  callers ([include-line-numbers])   => list", "", "Returns information on each of the verbs and built-in functions currently waiting to resume execution in the current task.  When one verb or function calls another verb or function, execution of the caller is temporarily suspended, pending the called verb or function returning a value.  At any given time, there could be several such pending verbs and functions: the one that called the currently executing verb, the verb or function that called that one, and so on.  The result of `callers()' is a list, each element of which gives information about one pending verb or function in the following format:", "", "  {<this>, <verb-name>, <programmer>, <verb-loc>, <player>, <line-number>}", "", "For verbs, <this> is the initial value of the variable `this' in that verb, <verb-name> is the name used to invoke that verb, <programmer> is the player with whose permissions that verb is running, <verb-loc> is the object on which that verb is defined, and <player> is the initial value of the variable `player' in that verb, and <line-number> indicates which line of the verb's code is executing. The <line-number> element is included only if the `include-line-numbers' argument was provided and is true.", "", "For functions, <this>, <programmer>, and <verb-loc> are all #-1, <verb-name> is the name of the function, and <line-number> is an index used internally to determine the current state of the built-in function. The simplest correct test for a built-in function entry is", "", "(VERB-LOC == #-1 && PROGRAMMER == #-1 && VERB-NAME != "")", "", "", "The first element of the list returned by `callers()' gives information on the verb that called the currently-executing verb, the second element describes the verb that called that one, and so on.  The last element of the list describes the first verb called in this task." ]
#28 Builtin Function Help.delete_property() rc = MOOList [ "Syntax:  delete_property (obj <object>, str <prop-name>)   => none", "", "Removes the property named <prop-name> from the given <object> and all of its descendants.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have write permission on <object>, then E_PERM is raised.  If <object> does not directly define a property named <prop-name> (as opposed to inheriting one from its parent), then `E_PROPNF' is raised." ]
#28 Builtin Function Help.atan() rc = MOOList [ "Syntax:  atan (FLOAT <y> [, FLOAT <x>])   => FLOAT", "", "Returns the arc-tangent (inverse tangent) of y in the range [-pi/2..pi/2] if x is not provided, or of y/x in the range [-pi..pi] if x is provided." ]
#28 Builtin Function Help.set_verb_info() rc = MOOList [ "*forward*", "verb_info()" ]
#28 Builtin Function Help.string_hash() rc = MOOList [ "*forward*", "binary_hash()" ]
#28 Builtin Function Help.set_verb_args() rc = MOOList [ "*forward*", "verb_args()" ]
#28 Builtin Function Help.rindex() rc = MOOList [ "*forward*", "index()" ]
#28 Builtin Function Help.add_property() rc = MOOList [ "Syntax:  add_property (obj <object>, str <prop-name>, <value>, list <info>)   => none", "", "Defines a new property on the given <object>, inherited by all of its descendants; the property is named <prop-name>, its initial value is <value>, and its owner and initial permission bits are given by <info> in the same format as is returned by `property_info()'. If <object> is not valid or <object> already has a property named <prop-name> or <info> does not specify a legitimate owner and permission bits, then E_INVARG is raised.  If the programmer does not have write permission on <object> or if the owner specified by <info> is not the programmer and the programmer is not a wizard, then E_PERM is raised." ]
#28 Builtin Function Help.connection_option() rc = MOOList [ "Syntax:  connection_option (OBJ conn, STR name)   => value", "", "Returns the current setting of the option <name> for the connection <conn>. Raises E_INVARG if <conn> does not specify a current connection and E_PERM if the programmer is neither <conn> nor a wizard." ]
#28 Builtin Function Help.setremove() rc = MOOList [ "*forward*", "setadd()" ]
#28 Builtin Function Help.move() rc = MOOList [ "Syntax:  move (OBJ <what>, OBJ <where>)   => none", "", "Changes <what>'s location to be <where>.  This is a complex process because a number of permissions checks and notifications must be performed. The actual movement takes place as described in the following paragraphs.", "", "<what> should be a valid object and <where> should be either a valid object or `#-1' (denoting a location of 'nowhere'); otherwise E_INVARG is raised.  The programmer must be either the owner of <what> or a wizard; otherwise, E_PERM is raised.", "", "If <where> is a valid object, then the verb-call", "", "    <where>:accept(<what>)", "", "is performed before any movement takes place.  If the verb returns a false value and the programmer is not a wizard, then <where> is considered to have refused entrance to <what>; `move()' raises E_NACC.  If <where> does not define an `accept' verb, then it is treated as if it defined one that always returned false.", "", "If moving <what> into <where> would create a loop in the containment hierarchy (i.e., <what> would contain itself, even indirectly), then E_RECMOVE is raised instead.", "", "The `location' property of <what> is changed to be <where>, and the `contents' properties of the old and new locations are modified appropriately.  Let <old-where> be the location of <what> before it was moved.  If <old-where> is a valid object, then the verb-call", "", "    <old-where>:exitfunc(<what>)", "", "is performed and its result is ignored; it is not an error if <old-where> does not define a verb named `exitfunc'.  Finally, if <where> and <what> are still valid objects, and <where> is still the location of <what>, then the verb-call", "", "    <where>:enterfunc(<what>)", "", "is performed and its result is ignored; again, it is not an error if <where> does not define a verb named `enterfunc'." ]
#28 Builtin Function Help.verb_args() rc = MOOList [ "Syntax:  verb_args (OBJ <object>, STR <verb-name>)   => LIST", "     set_verb_args (OBJ <object>, STR <verb-name>, LIST <args>)   => none", "", "These two functions get and set (respectively) the direct-object, preposition, and indirect-object specifications for the verb named <verb-name> on the given <object>.  If <object> is not valid, then E_INVARG is raised.  If <object> does not define a verb named <verb-name>, then E_VERBNF is raised.  If the programmer does not have read (write) permission on the verb in question, then `verb_args()' (`set_verb_args()') raises E_PERM.  Verb args specifications have the following form:", "", "    {<dobj>, <prep>, <iobj>}", "", "where <dobj> and <iobj> are strings drawn from the set `"this"', `"none"', and `"any"', and <prep> is a string that is either `"none"', `"any"', or one of the prepositional phrases listed much earlier in the description of verbs in the first chapter.  This is the kind of value returned by `verb_info()' and expected as the third argument to `set_verb_info()'.  Note that for `set_verb_args()', <prep> must be only one of the prepositional phrases, not (as is shown in that table) a set of such phrases separated by `/' characters.  `Set_verb_args()' raises E_INVARG if any of the <dobj>, <prep>, or <iobj> strings is illegal.", "", "    verb_args($container, "take")", "                        =>   {"any", "out of/from inside/from", "this"}", "    set_verb_args($container, "take", {"any", "from", "this"})" ]
#28 Builtin Function Help.cosh() rc = MOOList [ "*forward*", "sinh()" ]
#28 Builtin Function Help.kill_task() rc = MOOList [ "Syntax:  kill_task (INT <task-id>)   => none", "", "Removes the task with the given <task-id> from the queue of waiting tasks. If the programmer is not the owner of that task and not a wizard, then E_PERM is raised.  If there is no task on the queue with the given <task-id>, then E_INVARG is raised." ]
#28 Builtin Function Help.suspend() rc = MOOList [ "Syntax:  suspend ([INT <seconds>])   => value", "", "Suspends the current task, and resumes it after at least <seconds> seconds. (If <seconds> is not provided, the task is suspended indefinitely; such a task can only be resumed by use of the `resume()' function.) When the task is resumed, it will have a full quota of ticks and seconds.  This function is useful for programs that run for a long time or require a lot of ticks.  If <seconds> is negative, then E_INVARG is raised. `Suspend()' returns zero unless it was resumed via `resume()' in which case it returns the second argument given to that function.", "", "In some sense, this function forks the `rest' of the executing task.  However, there is a major difference between the use of `suspend(<seconds>)' and the use of the `fork (<seconds>)'.  The `fork' statement creates a new task (a "forked task") while the currently-running task still goes on to completion, but a `suspend()' suspends the currently-running task (thus making it into a "suspended task").  This difference may be best explained by the following examples, in which one verb calls another:", "", "    .program   #0:caller_A", "    #0.prop = 1;", "    #0:callee_A();", "    #0.prop = 2;", "    .", "", "    .program   #0:callee_A", "    fork(5)", "      #0.prop = 3;", "    endfork", "    .", "", "    .program   #0:caller_B", "    #0.prop = 1;", "    #0:callee_B();", "    #0.prop = 2;", "    .", "", "    .program   #0:callee_B", "    suspend(5);", "    #0.prop = 3;", "    .", "", "Consider `#0:caller_A', which calls `#0:callee_A'.  Such a task would assign 1 to `#0.prop', call `#0:callee_A', fork a new task, return to `#0:caller_A', and assign 2 to `#0.prop', ending this task.  Five seconds later, if the forked task had not been killed, then it would begin to run; it would assign 3 to `#0.prop' and then stop.  So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 3.", "", "Now consider `#0:caller_B', which calls `#0:callee_B' instead of `#0:callee_A'.  This task would assign 1 to `#0.prop', call `#0:callee_B', and suspend.  Five seconds later, if the suspended task had not been killed, then it would resume; it would assign 3 to `#0.prop', return to `#0:caller', and assign 2 to `#0.prop', ending the task. So, the final value of `#0.prop' (i.e., the value after more than 5 seconds) would be 2.", "", "A suspended task, like a forked task, can be described by the `queued_tasks()' function and killed by the `kill_task()' function. Suspending a task does not change its task id.  A task can be suspended again and again by successive calls to `suspend()'.", "", "Once `suspend()' has been used in a particular task, then the `read()' function will always raise E_PERM in that task.  For more details, see the description of `read()'.", "", "By default, there is no limit to the number of tasks any player may suspend, but such a limit can be imposed from within the database. See the chapter in the LambdaMOO Programmers Manual on server assumptions about the database for details." ]
#28 Builtin Function Help.idle_seconds() rc = MOOList [ "*forward*", "connected_seconds()" ]
#28 Builtin Function Help.trunc() rc = MOOList [ "Syntax:  trunc (FLOAT <x>)   => FLOAT", "", "Returns the integer obtained by truncating <x> at the decimal point, as a floating-point number. For negative <x>, this is equivalent to `ceil()'; otherwise, it is equivalent to `floor()'." ]
#28 Builtin Function Help.db_disk_size() rc = MOOList [ "Syntax:  db_disk_size()   => INT", "", "Returns the total size, in bytes, of the most recent full representation of the database as one or more disk files. Raises E_QUOTA if, for some reason, no such on-disk representation is currently available." ]
#28 Builtin Function Help.set_task_perms() rc = MOOList [ "Syntax:  set_task_perms (OBJ <player>)   => none", "", "Changes the permissions with which the currently-executing verb is running to be those of <player>.  If <player> is not of type OBJ, then E_INVARG is raised.  If the programmer is neither <player> nor a wizard, then E_PERM is raised.", "", "Note: This does not change the owner of the currently-running verb, only the permissions of this particular invocation.  It is used in verbs owned by wizards to make themselves run with lesser (usually non-wizard) permissions." ]
#28 Builtin Function Help.verbs() rc = MOOList [ "Syntax:  verbs (OBJ <object>)   => LIST", "", "Returns a list of the names of the verbs defined directly on the given <object>, not inherited from its parent.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have read permission on <object>, then E_PERM is raised." ]
#28 Builtin Function Help.ticks_left() rc = MOOList [ "Syntax:  ticks_left ()   => INT", "       seconds_left ()   => INT", "", "These two functions return the number of ticks or seconds (respectively) left to the current task before it will be forcibly terminated.  These are useful, for example, in deciding when to fork another task to continue a long-lived computation." ]
#28 Builtin Function Help.connected_players() rc = MOOList [ "Syntax:  connected_players ([include-all])   => LIST", "", "Returns a list of the object numbers of those player objects with currently-active connections. If <include-all> is provided and true, includes the object numbers associated with all current connections, including those that are outbound and/or not yet logged-in." ]
#28 Builtin Function Help.min() rc = MOOList [ "Syntax:  min (num <x>, ...)   => num", "         max (num <x>, ...)   => num", "", "These two functions return the smallest or largest of their arguments, respectively.  All of the arguments must be numbers of the same kind (i.e., either integer or floating-point); otherwise E_TYPE is raised." ]
#28 Builtin Function Help.raise() rc = MOOList [ "Syntax:  raise (code [, STR message [, value]])   => none", "", "Raises <code> as an error in the same way as other MOO expressions, statements, and functions do. <Message>, which defaults to the value `tostr(<code>)', and <value>, which defaults to zero, are made available to any `try-except' statements to catch the error. If the error is not caught, then <message> will appear on the first line of the traceback printed to the user." ]
#28 Builtin Function Help.random() rc = MOOList [ "Syntax:  random ([INT <mod>])   => INT", "", "<Mod> must be a positive integer; otherwise, E_INVARG is raised.  An integer is chosen randomly from the range `[1..<mod>]' and returned. If <mod> is not provided, it defaults to the largest MOO integer, 2147483647." ]
#28 Builtin Function Help.log10() rc = MOOList [ "*forward*", "log()" ]
#28 Builtin Function Help.is_member() rc = MOOList [ "Syntax:  is_member (ANY value, LIST list)   => INT", "", "Returns true if there is an element of <list> that is completely indistinguishable from <value>. This is much the same operation as "<value> in <list>" except that, unlike `in', the `is_member()' function does not treat upper- and lower-case characters in strings as equal.", "", "Raises E_ARGS if two values are given or if more than two values are given. Raises E_TYPE if the second argument is not a list. Otherwise returns the index of <value> in <list>, or 0 if it's not in there.", "", "  is_member(3, {3, 10, 11})                 => 1", "  is_member("a", {"A", "B", "C"})           => 0", "  is_member("XyZ", {"XYZ", "xyz", "XyZ"})   => 3" ]
#28 Builtin Function Help.load_server_options() rc = MOOList [ "Syntax:  load_server_options ()   => none", "", "After modifying properties on $server_options, wizards must call `load_server_options()'.  Changes made may not take effect until this function is called.  This allows the server to cache option values internally; this significantly speeds up built-in function invocation.  If the programmer is not a wizard, then E_PERM is raised." ]
#28 Builtin Function Help.properties() rc = MOOList [ "Syntax:  properties (OBJ <object>)   => LIST", "", "Returns a list of the names of the properties defined directly on the given <object>, not inherited from its parent.  If <object> is not valid, then E_INVARG is raised.  If the programmer does not have read permission on <object>, then E_PERM is raised." ]
#28 Builtin Function Help.encode_binary() rc = MOOList [ "Syntax:  encode_binary(arg, ...)   => STR", "", "Each argument must be an integer between 0 and 255, a string, or a list containing only legal arguments for this function. This function translates each integer and string in turn into its binary string equivalent, returning the concatenation of all these substrings into a single binary string. (See the early sections in the LambdaMOO Programmer's Manual on MOO value types for a full description of binary strings.)", "", "encode_binary("~foo")                     =>  "~7Efoo"", "encode_binary({"foo", 10}, {"bar", 13})   =>  "foo~0Abar~0D"", "encode_binary("foo", 10, "bar", 13)       =>  "foo~0Abar~0D"" ]
#28 Builtin Function Help.typeof() rc = MOOList [ "Syntax:  typeof (<value>)   => INT", "", "Takes any MOO value and returns a number representing the type of <value>. The result is the same as the initial value of one of these built-in variables: `INT', `FLOAT', `STR', `LIST', `OBJ', or `ERR'.  Thus, one usually writes code like this:", "", "    if (typeof(x) == LIST) ...", "", "and not like this:", "", "    if (typeof(x) == 4) ...", "", "because the former is much more readable than the latter." ]
#28 Builtin Function Help.object_bytes() rc = MOOList [ "Syntax:  object_bytes (OBJ object)   => INT", "", "Returns the number of bytes of the server's memory required to store the given <object>, including the space used by the values of all its non-clear properties and by the verbs and properties defined directly on the object. Raises E_INVARG if <object> is not a valid object and E_PERM if the programmer is not a wizard." ]
#28 Builtin Function Help.tan() rc = MOOList [ "*forward*", "sin()" ]
#28 Builtin Function Help.buffered_output_length() rc = MOOList [ "Syntax:  buffered_output_length ([OBJ conn])   => INT", "", "Returns the number of bytes currently buffered for output to the connection `conn'.  If conn is not provided, returns the maximum number of bytes that will be buffered up for output on any connection." ]
#28 Builtin Function Help.binary_hash() rc = MOOList [ "Syntax:  binary_hash (STR bin-string)   => STR", "         string_hash (STR text)         => STR", "", "Returns a 32-character hexadecimal string encoding the result of applying the MD5 cryptographically secure hash function to the contents of the string `text' or the binary string `bin-string'. MD5, like other such functions, has the property that, if", "", "string_hash(x) == string_hash(y)", "", "then, almost certainly", "", "equal(x, y)", "", "This can be useful, for example, in certain networking applications:  after sending a large piece of text across a connection, also send across the result of applying string_hash() to the text; if the destination site also applies string_hash() to the text and gets the same result, you can be quite confident that the large text has arrived unchanged." ]
#28 Builtin Function Help.dump_database() rc = MOOList [ "Syntax:  dump_database ()   => none", "", "Requests that the server checkpoint the database at its next opportunity.  It is not normally necessary to call this function; the server automatically checkpoints the database at regular intervals; see the chapter on server assumptions about the database for details.  If the programmer is not a wizard, then E_PERM is raised." ]
#28 Builtin Function Help.queue_info() rc = MOOList [ "queue_info([obj user])", "", "Returns the number of forked tasks that <user> has at the moment.  Since it doesn't say which tasks, security is not a significant issue.  If no argument is given, then gives a list of all users with task queues in the server.  (Essentially all connected players + all open connections + all users with tasks running in the background.)" ]
#28 Builtin Function Help.task_stack() rc = MOOList [ "Syntax:  task_stack (INT task-id [, include-line-numbers])  => LIST", "", "Returns information like that returned by the `callers()' function, but for the suspended task with the given <task-id>; the <include-line-numbers> argument has the same meaning as in `callers()'. Raises E_INVARG if <task-id> does not specify an existing suspended task and E_PERM if the programmer is neither a wizard nor the owner of the specified task." ]
================================#29 New-Prog-Log===============================================
#29 New-Prog-Log.keyword rc = MOOString "PROGRAMMER"
#29 New-Prog-Log:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#29 New-Prog-Log:receive_message this n/a this
if (!this:is_writable_by(caller_perms()))
return E_PERM;
else
if (msgs = this.messages)
new = msgs[$][1] + 1;
else
new = 1;
endif
if (rmsgs = this.messages_going)
lbrm = rmsgs[$][2];
new = max(new, lbrm[$][1] + 1);
endif
m = args[1];
if (index(m[4], "@programmer ") == 1)
m = {m[1], toobj(args[2]), o = $mail_agent:parse_address_field(m[4])[1], o.name};
endif
this.messages = {@msgs, {new, m}};
this.last_msg_date = m[1];
this.last_used_time = time();
return new;
endif
-------------------------------------------------------------------------------
#29 New-Prog-Log:display_seq_headers display_seq_full this n/a this
":display_seq_headers(msg_seq[,cur])";
":display_seq_full(msg_seq[,cur]) => {cur}";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{msg_seq, ?cur = 0, ?read_date = $maxint} = args;
last = ldate = 0;
player:tell("       WHEN           ", $string_utils:left(this.keyword, -30), "BY");
for x in (msgs = this:messages_in_seq(args[1]))
msgnum = $string_utils:right(last = x[1], 4, (cur == x[1]) ? ">" | " ");
ldate = x[2][1];
if (typeof(x[2][2]) != OBJ)
hdr = this:msg_summary_line(@x[2]);
else
if (ldate < (time() - 31536000))
c = player:ctime(ldate);
date = c[5..11] + c[21..25];
else
date = player:ctime(ldate)[5..16];
endif
hdr = tostr(ctime(ldate)[5..16], "   ", $string_utils:left(tostr(x[2][4], " (", x[2][3], ")"), 30), valid(w = x[2][2]) ? w.name | "??", " (", x[2][2], ")");
endif
player:tell(msgnum, (ldate > read_date) ? ":+ " | ":  ", hdr);
$command_utils:suspend_if_needed(0);
endfor
if (verb == "display_seq_full")
return {last, ldate};
else
player:tell("----+");
endif
-------------------------------------------------------------------------------
#29 New-Prog-Log:from_msg_seq this n/a this
":from_msg_seq(object or list[,mask])";
" => msg_seq of messages from any of these senders";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
fseq = {};
for msg in (this.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
if (msg[2][2] in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
-------------------------------------------------------------------------------
#29 New-Prog-Log:to_msg_seq this n/a this
":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
fseq = {};
for msg in (this.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
if (msg[2][3] in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages about @programmer'ing " + $string_utils:english_list(plist, "no one", " or "));
-------------------------------------------------------------------------------
#29 New-Prog-Log:%to_msg_seq subject_msg_seq this n/a this
":%to_msg_seq/subject_msg_seq(string or list of strings[,mask])";
" => msg_seq of messages containing one of strings in the to line";
if (!this:ok(caller, caller_perms()))
return E_PERM;
endif
{nlist, ?mask = {1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
i = 1;
fseq = {};
for msg in (this.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
if (msg[2][4] in nlist)
fseq = $seq_utils:add(fseq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages about @programmer'ing " + $string_utils:english_list(nlist, "no one", " or "));
-------------------------------------------------------------------------------
#29 New-Prog-Log:%from_msg_seq this n/a this
return this.name + " doesn't understand %%from:";
-------------------------------------------------------------------------------
================================#30 Generic Help Database===============================================
#30 Generic Help Database.index_cache r = MOOList [ ]
#30 Generic Help Database.index rc = MOOList [ ]
#30 Generic Help Database:find_topics this n/a this
"WIZARDLY";
if (args)
"...check for an exact match first...";
search = args[1];
if (`$object_utils:has_property(parent(this), search) ! ANY')
if ($object_utils:has_property(this, " " + search))
return {search};
endif
elseif ($object_utils:has_property(this, search))
return {search};
endif
"...search for partial matches, allowing for";
"...confusion between topics that do and don't start with @, and";
".. confusion between - and _ characters.";
props = properties(this);
topics = {};
if (search[1] == "@")
search = search[2..$];
endif
search = strsub(search, "-", "_");
if (!search)
"...don't try searching for partial matches if the string is empty or @";
"...we'd get *everything*...";
return {};
endif
for prop in (props)
if (((i = index(strsub(prop, "-", "_"), search)) == 1) || ((i == 2) && index(" @", prop[1])))
topics = {@topics, (prop[1] == " ") ? prop[2..$] | prop};
endif
endfor
return topics;
else
"...return list of all topics...";
props = setremove(properties(this), "");
for p in (`$object_utils:all_properties(parent(this)) ! ANY => {}')
if (i = (" " + p) in props)
props = {p, @listdelete(props, i)};
endif
endfor
return props;
endif
-------------------------------------------------------------------------------
#30 Generic Help Database:get_topic this n/a this
"WIZARDLY";
{topic, ?dblist = {}} = args;
if (`$object_utils:has_property(parent(this), topic) ! ANY')
text = `this.(" " + topic) ! ANY';
else
text = `this.(topic) || this.(" " + topic) ! ANY';
endif
if (typeof(text) == LIST)
if (text && (text[1] == (("*" + (vb = strsub(text[1], "*", ""))) + "*")))
text = `this:(vb)(listdelete(text, 1), dblist) ! ANY';
endif
endif
return text;
-------------------------------------------------------------------------------
#30 Generic Help Database:sort_topics this n/a this
":sort_topics(list_of_topics) -- sorts the given list of strings, assuming that they're help-system topic names";
buckets = "abcdefghijklmnopqrstuvwxyz";
keys = names = $list_utils:make(length(buckets) + 1, {});
for name in (setremove(args[1], ""))
key = index(".@", name[1]) ? name[2..$] + " " | name;
k = index(buckets, key[1]) + 1;
bucket = keys[k];
i = $list_utils:find_insert(bucket, key);
keys[k] = listinsert(bucket, key, i);
names[k] = listinsert(names[k], name, i);
$command_utils:suspend_if_needed(0);
endfor
return $list_utils:append(@names);
-------------------------------------------------------------------------------
#30 Generic Help Database:columnize this n/a this
":columnize(@list_of_strings) -- prints the given list in a number of columns wide enough to accomodate longest entry. But no more than 4 columns.";
longest = $list_utils:longest(args);
for d in ({4, 3, 2, 1})
if ((79 / d) >= length(longest))
return $string_utils:columnize_suspended(0, args, d);
endif
endfor
-------------------------------------------------------------------------------
#30 Generic Help Database:forward pass this n/a this
"{\"*forward*\", topic, @rest}  => text for topic from this help db.";
"{\"*pass*\",    topic, @rest}  => text for topic from next help db.";
"In both cases the text of @rest is appended.  ";
"@rest may in turn begin with a *<verb>*";
{text, ?dblist = {}} = args;
if (verb == "forward")
first = this:get_topic(text[1], dblist);
elseif ((result = $code_utils:help_db_search(text[1], dblist)) && ((db = result[1]) != $ambiguous_match))
first = db:get_topic(result[2], dblist[(db in dblist) + 1..$]);
else
first = {};
endif
if (2 <= length(text))
if (text[2] == (("*" + (vb = strsub(text[2], "*", ""))) + "*"))
return {@first, @`this:(vb)(text[3..$], dblist) ! ANY => {}'};
else
return {@first, @text[2..$]};
endif
else
return first;
endif
-------------------------------------------------------------------------------
#30 Generic Help Database:subst this n/a this
"{\"*subst*\", @text} => text with the following substitutions:";
"  \"...%[expr]....\" => \"...\"+value of expr (assumed to be a string)+\"....\"";
"  \"%;expr\"         => @(value of expr (assumed to be a list of strings))";
newlines = {};
for old in (args[1])
new = "";
bomb = 0;
while ((prcnt = index(old, "%")) && (prcnt < length(old)))
new = new + old[1..prcnt - 1];
code = old[prcnt + 1];
old = old[prcnt + 2..$];
if (code == "[")
prog = "";
while ((b = index(old + "]", "]")) > (p = index(old + "%", "%")))
prog = (prog + old[1..p - 1]) + old[p + 1];
old = old[p + 2..$];
endwhile
prog = prog + old[1..b - 1];
old = old[b + 1..$];
value = $no_one:eval_d(prog);
if (value[1])
new = tostr(new, value[2]);
else
new = tostr(new, toliteral(value[2]));
bomb = 1;
endif
elseif ((code != ";") || new)
new = (new + "%") + code;
else
value = $no_one:eval_d(old);
if (value[1] && (typeof(r = value[2]) == LIST))
newlines = {@newlines, @r[1..$ - 1]};
new = tostr(r[$]);
else
new = tostr(new, toliteral(value[2]));
bomb = 1;
endif
old = "";
endif
endwhile
if (bomb)
newlines = {@newlines, new + old, tostr("@@@ Helpfile alert:  Previous line is messed up; notify ", this.owner.wizard ? "" | tostr(this.owner.name, " (", this.owner, ") or "), "a wizard. @@@")};
else
newlines = {@newlines, new + old};
endif
endfor
return newlines;
-------------------------------------------------------------------------------
#30 Generic Help Database:index this n/a this
"{\"*index*\" [, title]}";
"This produces a columnated list of topics in this help db, headed by title.";
$command_utils:suspend_if_needed(0);
title = args[1] ? args[1][1] | tostr(this.name, " (", this, ")");
su = $string_utils;
return {"", title, su:from_list($list_utils:map_arg(su, "space", su:explode(title), "-"), " "), @this:columnize(@this:sort_topics(this:find_topics()))};
-------------------------------------------------------------------------------
#30 Generic Help Database:initialize this n/a this
pass(@args);
if ($perm_utils:controls(caller_perms(), this))
this.r = 1;
this.f = 0;
endif
-------------------------------------------------------------------------------
#30 Generic Help Database:verbdoc this n/a this
"{\"*verbdoc*\", \"object\", \"verbname\"}  use documentation for this verb";
set_task_perms(this.owner);
if (!valid(object = $string_utils:match_object(args[1][1], player.location)))
return E_INVARG;
elseif (!(hv = $object_utils:has_verb(object, vname = args[1][2])))
return E_VERBNF;
else
return $code_utils:verb_documentation(hv[1], vname);
endif
-------------------------------------------------------------------------------
#30 Generic Help Database:dump_topic this n/a this
try
text = this.(fulltopic = args[1]);
return {tostr(";;", $code_utils:corify_object(this), ".(", toliteral(fulltopic), ") = $command_utils:read_lines()"), @$command_utils:dump_lines(text)};
except error (ANY)
return error[1];
endtry
-------------------------------------------------------------------------------
#30 Generic Help Database:objectdoc this n/a this
"{\"*objectdoc*\", \"object\"} => text for topic from object:help_msg";
if (!valid(object = $string_utils:literal_object(args[1][1])))
return E_INVARG;
elseif (!($object_utils:has_verb(object, "help_msg") || $object_utils:has_property(object, "help_msg")))
return E_VERBNF;
else
return $code_utils:verb_or_property(object, "help_msg");
endif
-------------------------------------------------------------------------------
#30 Generic Help Database:find_index_topics this n/a this
":find_index_topic([search])";
"Return the list of index topics of this help DB";
"(i.e., those which contain an index (list of topics)";
"this DB, return it, otherwise return false.";
"If search argument is given and true,";
"we first remove any cached information concerning index topics.";
{?search = 0} = args;
if (this.index_cache && (!search))
"...make sure every topic listed in .index_cache really is an index topic";
for p in (this.index_cache)
if (!("*index*" in `this.(p) ! ANY => {}'))
search = 1;
endif
endfor
if (!search)
return this.index_cache;
endif
elseif ($generic_help == this)
return {};
endif
itopics = {};
for p in (properties(this))
if ((h = `this.(p) ! ANY') && ("*index*" in h))
itopics = {@itopics, p};
endif
endfor
this.index_cache = itopics;
return itopics;
-------------------------------------------------------------------------------
================================#31 Generic Guest===============================================
#31 Generic Guest.extra_confunc_msg rc = MOOString ""
#31 Generic Guest.default_gender r = MOOString "neuter"
#31 Generic Guest.default_description r = MOOList [ "By definition, guests appear nondescript." ]
#31 Generic Guest.free_to_use r = MOONumber 1
#31 Generic Guest.request  = MOONumber 0
#31 Generic Guest:boot this n/a this
if (!caller_perms().wizard)
return;
endif
player = this;
this:notify(tostr("Sorry, but you've been here for ", $string_utils:from_seconds(connected_seconds(this)), " and someone else wants to be a guest now.  Feel free to come back", @$login:player_creation_enabled(player) ? {" or even create your own character if you want..."} | {" or type `create' to learn more about how to get a character of your own."}));
"boot_player(this)";
return;
"See #0:user_reconnected.";
-------------------------------------------------------------------------------
#31 Generic Guest:disfunc this n/a this
if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))
return E_PERM;
endif
"Don't let another guest use this one until all this is done. See :defer, Ho_Yan 1/19/94";
this.free_to_use = 0;
this:log_disconnect();
this:erase_paranoid_data();
try
if (this.location != this.home)
this:room_announce(player.name, " has disconnected.");
this:room_announce($string_utils:pronoun_sub($housekeeper.take_away_msg, this, $housekeeper));
move(this, this.home);
this:room_announce($string_utils:pronoun_sub($housekeeper.drop_off_msg, this, $housekeeper));
endif
finally
this:do_reset();
this.free_to_use = 1;
endtry
-------------------------------------------------------------------------------
#31 Generic Guest:defer this n/a this
"Called by #0:connect_player when this object is about to be used as the next guest character.  Usually returns `this', but if for some reason some other guest character should be used, that player object is returned instead";
if (!caller_perms().wizard)
"...caller is not :do_login_command; doesn't matter what we return...";
return this;
elseif ($login:blacklisted($string_utils:connection_hostname(connection_name(player))))
return #-2;
elseif (!(this in connected_players()))
"...not logged in, no problemo...";
return this;
endif
longest = 900;
"...guests get 15 minutes before they can be dislodged...";
candidate = #-1;
free = {};
for g in ($object_utils:leaves($guest))
if (!is_player(g))
"...a toaded guest?...";
elseif ((!(con = g in connected_players())) && g.free_to_use)
"...yay; found an unused guest...and their last :disfunc is complete";
free = {@free, g};
elseif (con && ((t = connected_seconds(g)) > longest))
longest = t;
candidate = g;
endif
endfor
if (free)
candidate = free[random($)];
elseif (valid(candidate))
"...someone's getting bumped...";
candidate:boot();
endif
return candidate;
-------------------------------------------------------------------------------
#31 Generic Guest:mail_catch_up this n/a this
return;
-------------------------------------------------------------------------------
#31 Generic Guest:create any ?-2? any
if ($login:player_creation_enabled(player))
player:tell("First @quit, then connect to the MOO again and, rather than doing `connect guest' do `create <name> <password>'");
else
player:tell($login:registration_string());
endif
-------------------------------------------------------------------------------
#31 Generic Guest:eject this n/a this
return pass(@args);
-------------------------------------------------------------------------------
#31 Generic Guest:log this n/a this
":log(islogin,time,where) adds an entry to the connection log for this guest.";
if (caller != this)
return E_PERM;
elseif (length(this.connect_log) < this.max_connect_log)
this.connect_log = {args, @this.connect_log};
else
this.connect_log = {args, @this.connect_log[1..this.max_connect_log - 1]};
endif
-------------------------------------------------------------------------------
#31 Generic Guest:confunc this n/a this
if ((((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (cp != this)) && (caller != #0))
return E_PERM;
else
$guest_log:enter(1, time(), $string_utils:connection_hostname(connection_name(this)));
ret = pass(@args);
this:tell_lines(this:extra_confunc_msg());
return ret;
endif
-------------------------------------------------------------------------------
#31 Generic Guest:log_disconnect this n/a this
if (caller != this)
return E_PERM;
else
cname = `connection_name(this) ! ANY' || this.last_connect_place;
$guest_log:enter(0, time(), $string_utils:connection_hostname(cname));
endif
-------------------------------------------------------------------------------
#31 Generic Guest:@last-c*onnection any n/a none
if (!valid(caller_perms()))
player:tell("Sorry, that information is not available.");
endif
-------------------------------------------------------------------------------
#31 Generic Guest:my_huh this n/a this
if (caller_perms() != this)
return E_PERM;
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#31 Generic Guest:@read @peek any ?-2? any
return pass(@args);
-------------------------------------------------------------------------------
#31 Generic Guest:set_current_folder this n/a this
return pass(@args);
"only for setting permission";
-------------------------------------------------------------------------------
#31 Generic Guest:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.extra_confunc_msg = "";
endif
-------------------------------------------------------------------------------
#31 Generic Guest:set_name set_aliases this n/a this
"disallow guests from setting aliases on themselves";
if ($perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#31 Generic Guest:extra_confunc_msg this n/a this
return $string_utils:pronoun_sub(this.(verb));
-------------------------------------------------------------------------------
#31 Generic Guest:do_reset this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
flush_input(this, 0);
for x in ({"paranoid", "lines", "responsible", "linelen", "linebuffer", "brief", "gaglist", "rooms", "pagelen", "current_message", "current_folder", "messages", "messages_going", "request", "mail_options", "edit_options", "home", "spurned_objects", "web_info"})
if ($object_utils:has_property(parent(this), x))
clear_property(this, x);
endif
endfor
this:set_description(this.default_description);
this:set_gender(this.default_gender);
for x in (this.contents)
this:eject(x);
endfor
for x in (this.features)
if (!(x in $guest.features))
this:remove_feature(x);
endif
endfor
for x in ($guest.features)
if (!(x in this.features))
this:add_feature(x);
endif
endfor
for x in ($object_utils:descendants($generic_editor))
if (loc = this in x.active)
x:kill_session(loc);
endif
endfor
endif
-------------------------------------------------------------------------------
#31 Generic Guest:@request any ?-2? any
"Usage:  @request <player-name> for <email-address>";
if (player != this)
return player:tell(E_PERM);
endif
if (this.request)
return player:tell("Sorry, you appear to have already requested a character.");
endif
name = dobjstr;
if ((prepstr != "for") || ((!dobjstr) || index(address = iobjstr, " ")))
return player:notify_lines($code_utils:verb_usage());
endif
if ($login:request_character(player, name, address))
this.request = 1;
endif
"Copied from Generic Guest (#5678):@request by Froxx (#49853) Mon Apr  4 10:49:26 1994 PDT";
-------------------------------------------------------------------------------
#31 Generic Guest:connection_name_hash this n/a this
"Compute an encrypted hash of the guest's (last) connection, using 'crypt'. Basically, you can't tell where the guest came from, but it is unlikely that two guests will have the same hash";
"You can use guest:connection_name_hash(seed) as a string to identify whether two guests are from the same place.";
hash = toint(caller_perms());
host = $string_utils:connection_hostname(this.last_connect_place);
for i in [1..length(host)]
hash = (hash * 14) + index($string_utils.ascii, host[i]);
endfor
return crypt(tostr(hash), @args);
-------------------------------------------------------------------------------
#31 Generic Guest:@subscribe*-quick @unsubscribed*-quick any ?-2? any
if ((caller_perms() != $nothing) && (caller_perms() != player))
return E_PERM;
endif
if (!args)
all_mlists = {@$mail_agent.contents, @this.mail_lists};
if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr("There are ", length(all_mlists), " mailing lists.  Are you sure you want the whole list?"))))
return player:tell("OK, aborting.");
endif
for c in (all_mlists)
$command_utils:suspend_if_needed(0);
if ((c:is_usable_by(this) || c:is_readable_by(this)) && (verb != "@unsubscribed"))
`c:look_self(1) ! ANY';
endif
endfor
player:tell("--End of List--");
else
player:tell("Sorry, Guests don't have full mailing privileges.  You may use @read and @peek for mailing lists.  Or try @request to get yourself a character.");
endif
"Paragraph (#122534) - Tue Nov 8, 2005 - Added to prevent a silly traceback from occuring, since Guests can't read their own .current_message.";
-------------------------------------------------------------------------------
#31 Generic Guest:current_folder this n/a this
if (caller_perms() in {this, this.owner})
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#31 Generic Guest:notify this n/a this
if ((caller_perms().wizard || (caller_perms() in {this, this.owner})) || (caller == this))
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
================================#32 Mr. Spell===============================================
#32 Mr. Spell. Engli r = MOOList [ "sh", "m", [ "English" ] ]
#32 Mr. Spell. burr r = MOOList [ "", "o", [ "Burr" ] ]
#32 Mr. Spell. provid r = MOOList [ "", "e", [ "providing" ] ]
#32 Mr. Spell. lami r = MOOList [ "na", "", [ "laminate", "laminar" ] ]
#32 Mr. Spell. burs r = MOOList [ "", "t", [ "bursitis" ] ]
#32 Mr. Spell. arou r = MOOList [ "", "s", [ "around" ] ]
#32 Mr. Spell. antag r = MOOList [ "onis", "", [ "antagonist", "antagonism" ] ]
#32 Mr. Spell. Engla r = MOOList [ "nd", "", [ "Englander", "England" ] ]
#32 Mr. Spell. bridg r = MOOList [ "e", "tw", [ "Bridgeport", "bridgehead", "bridgeable", "bridge" ] ]
#32 Mr. Spell. Vand r = MOOList [ "", "e", [ "vandal" ] ]
#32 Mr. Spell. Vanc r = MOOList [ "", "", [ "Vancouver", "Vance" ] ]
#32 Mr. Spell. indec r = MOOList [ "", "i", [ "indecomposable", "indecent" ] ]
#32 Mr. Spell. homol r = MOOList [ "og", "", [ "homology", "homologue", "homologous" ] ]
#32 Mr. Spell. murd r = MOOList [ "er", "", [ "murderous", "murder" ] ]
#32 Mr. Spell. homom r = MOOList [ "orphi", "", [ "homomorphism", "homomorphic" ] ]
#32 Mr. Spell. controll r = MOOList [ "", "e", [ "controlling", "controllable" ] ]
#32 Mr. Spell. carlo r = MOOList [ "", "", [ "carload", "Carlo" ] ]
#32 Mr. Spell. lamp r = MOOList [ "", "", [ "lamprey", "lampoon", "lamplight", "lampblack", "lamp" ] ]
#32 Mr. Spell. Engle r = MOOList [ "", "", [ "Englewood", "Engle" ] ]
#32 Mr. Spell. provin r = MOOList [ "c", "", [ "provincial", "province" ] ]
#32 Mr. Spell. bride r = MOOList [ "", "", [ "bridesmaid", "bridegroom", "bride" ] ]
#32 Mr. Spell. wall r = MOOList [ "", "aeo", [ "wally", "Walls", "wallpaper", "Wallis", "wallboard", "wall" ] ]
#32 Mr. Spell. walk r = MOOList [ "", "o", [ "walkway", "walkie", "walk" ] ]
#32 Mr. Spell. provis r = MOOList [ "", "", [ "proviso", "provision" ] ]
#32 Mr. Spell. resisti r = MOOList [ "", "", [ "resistive", "resistible" ] ]
#32 Mr. Spell. burd r = MOOList [ "", "e", [ "burdock" ] ]
#32 Mr. Spell. brick r = MOOList [ "", "l", [ "brickbat", "brick" ] ]
#32 Mr. Spell. believ r = MOOList [ "e", "", [ "believes", "believe" ] ]
#32 Mr. Spell. Sigm r = MOOList [ "", "", [ "Sigmund", "sigma" ] ]
#32 Mr. Spell. bure r = MOOList [ "", "at", [ ] ]
#32 Mr. Spell. lame r = MOOList [ "", "n", [ "lamellar", "lame" ] ]
#32 Mr. Spell. burg r = MOOList [ "", "elu", [ "burgher", "burg" ] ]
#32 Mr. Spell. Luth r = MOOList [ "er", "", [ "Lutheran", "Luther" ] ]
#32 Mr. Spell. burl r = MOOList [ "", "e", [ "burly", "Burlington", "burlap", "burl" ] ]
#32 Mr. Spell. ponti r = MOOList [ "", "f", [ "Pontiac" ] ]
#32 Mr. Spell. differe r = MOOList [ "nt", "i", [ "differently", "different" ] ]
#32 Mr. Spell. Jona r = MOOList [ "", "", [ "Jonathan", "Jonas" ] ]
#32 Mr. Spell. lamb r = MOOList [ "", "d", [ "lambert", "lamb" ] ]
#32 Mr. Spell. arom r = MOOList [ "a", "", [ "aromatic", "aroma" ] ]
#32 Mr. Spell. issue r = MOOList [ "", "", [ "issues", "issue" ] ]
#32 Mr. Spell. responsi r = MOOList [ "", "", [ "responsive", "responsible" ] ]
#32 Mr. Spell. A& r = MOOList [ "", "", [ "A&P", "A&M" ] ]
#32 Mr. Spell. burle r = MOOList [ "", "", [ "burley", "burlesque" ] ]
#32 Mr. Spell. tide r = MOOList [ "", "", [ "tidewater", "tideland", "tide" ] ]
#32 Mr. Spell. indel r = MOOList [ "i", "", [ "indelicate", "indelible" ] ]
#32 Mr. Spell. Adre r = MOOList [ "nal", "", [ "adrenaline", "adrenal" ] ]
#32 Mr. Spell. indef r = MOOList [ "", "i", [ "indefensible", "indefatigable" ] ]
#32 Mr. Spell. malada r = MOOList [ "pt", "", [ "maladaptive", "maladapt" ] ]
#32 Mr. Spell. indet r = MOOList [ "ermina", "", [ "indeterminate", "indeterminacy", "indeterminable" ] ]
#32 Mr. Spell. Adri r = MOOList [ "", "a", [ "adrift", "Adrienne" ] ]
#32 Mr. Spell. Mason r = MOOList [ "", "i", [ "masonry", "mason" ] ]
#32 Mr. Spell. indes r = MOOList [ "", "", [ "indestructible", "indescribable" ] ]
#32 Mr. Spell. inden r = MOOList [ "t", "", [ "indenture", "indentation", "indent" ] ]
#32 Mr. Spell. AA r = MOOList [ "", "Ar", [ ] ]
#32 Mr. Spell. Aura r = MOOList [ "", "", [ "aural", "aura" ] ]
#32 Mr. Spell. tick r = MOOList [ "", "l", [ "ticket", "tick" ] ]
#32 Mr. Spell. arms r = MOOList [ "", "", [ "arms", "Armstrong" ] ]
#32 Mr. Spell. swan r = MOOList [ "", "k", [ "Swanson", "swanlike", "swan" ] ]
#32 Mr. Spell. voic r = MOOList [ "e", "", [ "voiceband", "voices", "voice" ] ]
#32 Mr. Spell. swam r = MOOList [ "", "p", [ "swami", "swam" ] ]
#32 Mr. Spell. equiv r = MOOList [ "", "", [ "equivocal", "equivalent" ] ]
#32 Mr. Spell. Auri r = MOOList [ "", "", [ "Auriga", "auric" ] ]
#32 Mr. Spell. titani r = MOOList [ "", "", [ "titanium", "titanic" ] ]
#32 Mr. Spell. equit r = MOOList [ "", "a", [ "equity" ] ]
#32 Mr. Spell. swar r = MOOList [ "", "t", [ "swarm" ] ]
#32 Mr. Spell. AM r = MOOList [ "", "abeimopuy", [ "Amtrak", "Amsterdam", "amra", "Amherst", "am" ] ]
#32 Mr. Spell. swat r = MOOList [ "", "h", [ "swatch", "swat" ] ]
#32 Mr. Spell. equip r = MOOList [ "", "op", [ "equipment", "equip" ] ]
#32 Mr. Spell. pharmaco r = MOOList [ "", "", [ "pharmacopoeia", "pharmacology" ] ]
#32 Mr. Spell. equin r = MOOList [ "", "o", [ "equine" ] ]
#32 Mr. Spell. Sieg r = MOOList [ "", "e", [ "Siegmund", "Sieglinda", "Siegfried" ] ]
#32 Mr. Spell. swag r = MOOList [ "", "", [ "swage", "swag" ] ]
#32 Mr. Spell. equil r = MOOList [ "", "i", [ "equilateral" ] ]
#32 Mr. Spell. arma r = MOOList [ "", "dt", [ "armament", "Armageddon" ] ]
#32 Mr. Spell. swal r = MOOList [ "low", "", [ "swallowtail", "swallow" ] ]
#32 Mr. Spell. millenn r = MOOList [ "i", "", [ "millennium", "millennia" ] ]
#32 Mr. Spell. swab r = MOOList [ "", "", [ "swabby", "swab" ] ]
#32 Mr. Spell. carna r = MOOList [ "", "", [ "carnation", "carnal", "carnage" ] ]
#32 Mr. Spell. armi r = MOOList [ "", "", [ "armistice", "armillaria" ] ]
#32 Mr. Spell. tibe r = MOOList [ "", "t", [ "Tiber" ] ]
#32 Mr. Spell. clair r = MOOList [ "", "", [ "clairvoyant", "Claire" ] ]
#32 Mr. Spell. Ab r = MOOList [ "", "Abdehilnorsuy", [ "abject", "abc" ] ]
#32 Mr. Spell. Adol r = MOOList [ "", "p", [ "adolescent" ] ]
#32 Mr. Spell. Ad r = MOOList [ "", "adehijmorsuv", [ "adposition", "Adler", "Adkins", "ad" ] ]
#32 Mr. Spell. intelli r = MOOList [ "g", "e", [ "intelligible" ] ]
#32 Mr. Spell. Ai r = MOOList [ "", "dlnr", [ "Aitken", "aisle", "aim", "Aiken" ] ]
#32 Mr. Spell. Aj r = MOOList [ "a", "", [ "Ajax", "ajar" ] ]
#32 Mr. Spell. Ak r = MOOList [ "", "", [ "Akron", "akin", "Akers", "AK" ] ]
#32 Mr. Spell. carmi r = MOOList [ "", "", [ "carmine", "Carmichael" ] ]
#32 Mr. Spell. imprope r = MOOList [ "r", "", [ "improperly", "improper" ] ]
#32 Mr. Spell. wais r = MOOList [ "t", "", [ "waistline", "waistcoat", "waist" ] ]
#32 Mr. Spell. Kalm r = MOOList [ "", "", [ "Kalmuk", "kalmia" ] ]
#32 Mr. Spell. Ar r = MOOList [ "", "abcdegiklmoprstu", [ "aryl", "Arnold", "arhat", "AR" ] ]
#32 Mr. Spell. advant r = MOOList [ "age", "", [ "advantageous", "advantage" ] ]
#32 Mr. Spell. At r = MOOList [ "", "ahklmortw", [ "atypic", "AT&T", "ate", "Atchison", "at" ] ]
#32 Mr. Spell. intelle r = MOOList [ "ct", "", [ "intellectual", "intellect" ] ]
#32 Mr. Spell. Au r = MOOList [ "", "bcdgnrst", [ "auxiliary", "auk", "Auerbach" ] ]
#32 Mr. Spell. muni r = MOOList [ "", "c", [ "munition", "munificent" ] ]
#32 Mr. Spell. Ay r = MOOList [ "", "e", [ "Aylesbury" ] ]
#32 Mr. Spell. Az r = MOOList [ "", "it", [ "azure", "Azerbaijan", "azalea", "AZ" ] ]
#32 Mr. Spell. justi r = MOOList [ "", "cn", [ "justify" ] ]
#32 Mr. Spell. Edwardi r = MOOList [ "", "", [ "Edwardine", "Edwardian" ] ]
#32 Mr. Spell. bunk r = MOOList [ "", "", [ "bunkmate", "bunk" ] ]
#32 Mr. Spell. tanta r = MOOList [ "", "l", [ "tantamount" ] ]
#32 Mr. Spell. laid r = MOOList [ "", "", [ "Laidlaw", "laid" ] ]
#32 Mr. Spell. Bh r = MOOList [ "", "", [ "Bhutan", "bhoy" ] ]
#32 Mr. Spell. paraph r = MOOList [ "", "", [ "paraphrase", "paraphernalia" ] ]
#32 Mr. Spell. chromati r = MOOList [ "", "", [ "chromatin", "chromatic" ] ]
#32 Mr. Spell. munc r = MOOList [ "", "", [ "Muncie", "munch" ] ]
#32 Mr. Spell. CO r = MOOList [ "", "abcdefghilmnopqrstuvwxyz", [ "coke", "CO" ] ]
#32 Mr. Spell. minue r = MOOList [ "", "", [ "minuet", "minuend" ] ]
#32 Mr. Spell. chromato r = MOOList [ "gra", "p", [ "chromatogram" ] ]
#32 Mr. Spell. carpe r = MOOList [ "", "n", [ "carpet" ] ]
#32 Mr. Spell. anten r = MOOList [ "na", "", [ "antennae", "antenna" ] ]
#32 Mr. Spell. Sici r = MOOList [ "l", "", [ "Sicily", "Sicilian" ] ]
#32 Mr. Spell. histor r = MOOList [ "", "i", [ "history" ] ]
#32 Mr. Spell. bund r = MOOList [ "", "", [ "bundy", "Bundoora", "bundle", "Bundestag" ] ]
#32 Mr. Spell. wrin r = MOOList [ "", "", [ "wrinkle", "wring" ] ]
#32 Mr. Spell. lamen r = MOOList [ "t", "", [ "lamentation", "lament" ] ]
#32 Mr. Spell. cattlem r = MOOList [ "", "", [ "cattlemen", "cattleman" ] ]
#32 Mr. Spell. writ r = MOOList [ "", "e", [ "writhe", "writ", "written" ] ]
#32 Mr. Spell. minus r = MOOList [ "", "", [ "minuscule", "minus" ] ]
#32 Mr. Spell. minut r = MOOList [ "", "e", [ "minutiae" ] ]
#32 Mr. Spell. bung r = MOOList [ "", "", [ "bungle", "bungalow" ] ]
#32 Mr. Spell. wris r = MOOList [ "t", "", [ "wristwatch", "wristband", "wrist" ] ]
#32 Mr. Spell. Hibe r = MOOList [ "rn", "", [ "Hibernia", "hibernate" ] ]
#32 Mr. Spell. Ce r = MOOList [ "", "cdlmnrst", [ "Cezanne", "Ceylon", "Cepheus", "ceil", "cease" ] ]
#32 Mr. Spell. wrig r = MOOList [ "", "", [ "Wrigley", "wright", "wriggle" ] ]
#32 Mr. Spell. Ch r = MOOList [ "", "aeiloru", [ ] ]
#32 Mr. Spell. mult r = MOOList [ "i", "pt", [ "multi-purpose", "multinomial", "multifarious", "multi" ] ]
#32 Mr. Spell. luxuri r = MOOList [ "", "a", [ "luxurious" ] ]
#32 Mr. Spell. briga r = MOOList [ "", "d", [ "brigantine" ] ]
#32 Mr. Spell. sunsh r = MOOList [ "", "i", [ "sunshade" ] ]
#32 Mr. Spell. practic r = MOOList [ "", "a", [ "practice" ] ]
#32 Mr. Spell. bump r = MOOList [ "", "", [ "bumptious", "bump" ] ]
#32 Mr. Spell. Siam r = MOOList [ "", "", [ "Siamese", "SIAM" ] ]
#32 Mr. Spell. histoc r = MOOList [ "hemi", "", [ "histochemistry", "histochemic" ] ]
#32 Mr. Spell. John r = MOOList [ "", "s", [ "Johnny", "John" ] ]
#32 Mr. Spell. brigh r = MOOList [ "", "t", [ "Brigham" ] ]
#32 Mr. Spell. wagg r = MOOList [ "", "", [ "waggle", "wagging" ] ]
#32 Mr. Spell. revol r = MOOList [ "", "u", [ "revolve", "revolt" ] ]
#32 Mr. Spell. Cu r = MOOList [ "", "bcdflmnprst", [ "cuisine", "cue" ] ]
#32 Mr. Spell. Masse r = MOOList [ "", "", [ "Massey", "masseur" ] ]
#32 Mr. Spell. bumb r = MOOList [ "le", "", [ "bumblebee", "bumble" ] ]
#32 Mr. Spell. individ r = MOOList [ "ua", "l", [ "individuate" ] ]
#32 Mr. Spell. mull r = MOOList [ "", "ei", [ "mullah", "mull" ] ]
#32 Mr. Spell. charis r = MOOList [ "ma", "", [ "charismatic", "charisma" ] ]
#32 Mr. Spell. charit r = MOOList [ "", "", [ "charity", "charitable" ] ]
#32 Mr. Spell. somew r = MOOList [ "h", "", [ "somewhere", "somewhat" ] ]
#32 Mr. Spell. carry r = MOOList [ "", "", [ "carryover", "carry" ] ]
#32 Mr. Spell. bull r = MOOList [ "", "defhy", [ "bullwhack", "bullseye", "bullock", "bullish", "bull" ] ]
#32 Mr. Spell. somet r = MOOList [ "", "i", [ "something" ] ]
#32 Mr. Spell. bulk r = MOOList [ "", "", [ "bulky", "bulkhead", "bulk" ] ]
#32 Mr. Spell. minsk r = MOOList [ "", "", [ "Minsky", "Minsk" ] ]
#32 Mr. Spell. mulc r = MOOList [ "", "", [ "mulct", "mulch" ] ]
#32 Mr. Spell. Dn r = MOOList [ "", "", [ "Dnieper", "DNA" ] ]
#32 Mr. Spell. carro r = MOOList [ "", "", [ "carrot", "Carroll" ] ]
#32 Mr. Spell. parabolo r = MOOList [ "id", "", [ "paraboloidal", "paraboloid" ] ]
#32 Mr. Spell. Do r = MOOList [ "", "bcdeglmnoprstuvwz", [ "doing", "Doyle", "Doherty", "doff", "do" ] ]
#32 Mr. Spell. aris r = MOOList [ "", "et", [ ] ]
#32 Mr. Spell. Hiat r = MOOList [ "", "", [ "hiatus", "Hiatt" ] ]
#32 Mr. Spell. degre r = MOOList [ "", "", [ "degree", "degrease" ] ]
#32 Mr. Spell. venom r = MOOList [ "", "", [ "venomous", "venom" ] ]
#32 Mr. Spell. Lund r = MOOList [ "", "", [ "Lundquist", "Lundberg", "Lund" ] ]
#32 Mr. Spell. Joha r = MOOList [ "n", "ns", [ ] ]
#32 Mr. Spell. aria r = MOOList [ "", "", [ "Arianism", "Ariadne" ] ]
#32 Mr. Spell. Ea r = MOOList [ "", "grstv", [ "each" ] ]
#32 Mr. Spell. Eb r = MOOList [ "", "", [ "ebullient", "ebony", "Eben", "ebb" ] ]
#32 Mr. Spell. Oce r = MOOList [ "", "a", [ "ocelot" ] ]
#32 Mr. Spell. Ec r = MOOList [ "", "chlostu", [ ] ]
#32 Mr. Spell. degra r = MOOList [ "d", "", [ "degrade", "degradation" ] ]
#32 Mr. Spell. minst r = MOOList [ "rel", "", [ "minstrelsy", "minstrel" ] ]
#32 Mr. Spell. Ed r = MOOList [ "", "degimuw", [ "EDT", "Edna", "Ed" ] ]
#32 Mr. Spell. bulg r = MOOList [ "", "", [ "bulge", "Bulgaria" ] ]
#32 Mr. Spell. archiv r = MOOList [ "", "", [ "archive", "archival" ] ]
#32 Mr. Spell. Eg r = MOOList [ "", "agory", [ ] ]
#32 Mr. Spell. Eh r = MOOList [ "", "", [ "Ehrlich", "eh" ] ]
#32 Mr. Spell. dexte r = MOOList [ "r", "", [ "dexterity", "dexter" ] ]
#32 Mr. Spell. archit r = MOOList [ "ect", "u", [ "architectonic", "architect" ] ]
#32 Mr. Spell. parama r = MOOList [ "gnet", "", [ "paramagnetic", "paramagnet" ] ]
#32 Mr. Spell. Ek r = MOOList [ "", "", [ "Ektachrome", "Ekstrom", "eke" ] ]
#32 Mr. Spell. FM r = MOOList [ "", "", [ "FMC", "FM" ] ]
#32 Mr. Spell. accel r = MOOList [ "er", "", [ "accelerometer", "accelerate" ] ]
#32 Mr. Spell. accen r = MOOList [ "t", "u", [ "accent" ] ]
#32 Mr. Spell. accep r = MOOList [ "t", "", [ "accepted", "acceptor", "acceptant", "accept" ] ]
#32 Mr. Spell. someb r = MOOList [ "ody", "", [ "somebody'll", "somebody" ] ]
#32 Mr. Spell. FT r = MOOList [ "", "", [ "FTC", "Ft" ] ]
#32 Mr. Spell. acces r = MOOList [ "s", "i", [ "accessory", "access" ] ]
#32 Mr. Spell. Eu r = MOOList [ "", "cglprt", [ "Eunice", "Eumenides", "eukaryote" ] ]
#32 Mr. Spell. parall r = MOOList [ "", "e", [ "parallax" ] ]
#32 Mr. Spell. Ez r = MOOList [ "", "", [ "Ezra", "Ezekiel" ] ]
#32 Mr. Spell. homog r = MOOList [ "en", "e", [ "homogenate" ] ]
#32 Mr. Spell. fragm r = MOOList [ "ent", "a", [ "fragment" ] ]
#32 Mr. Spell. Kris r = MOOList [ "", "", [ "Kristin", "Krishna" ] ]
#32 Mr. Spell. someo r = MOOList [ "ne", "", [ "someone'll", "someone" ] ]
#32 Mr. Spell. audito r = MOOList [ "r", "", [ "auditory", "auditorium", "auditor" ] ]
#32 Mr. Spell. summar r = MOOList [ "", "", [ "summary", "summarily" ] ]
#32 Mr. Spell. Fa r = MOOList [ "", "bcdhilmnrstuyk", [ "faze", "fawn", "fag", "Fafnir", "faery", "FAA" ] ]
#32 Mr. Spell. transver r = MOOList [ "s", "", [ "transverse", "transversal" ] ]
#32 Mr. Spell. summat r = MOOList [ "", "", [ "summation", "summate" ] ]
#32 Mr. Spell. somer r = MOOList [ "", "s", [ "Somerville" ] ]
#32 Mr. Spell. dextr r = MOOList [ "o", "", [ "dextrous", "dextrose" ] ]
#32 Mr. Spell. Ode r = MOOList [ "", "", [ "Odessa", "ode" ] ]
#32 Mr. Spell. multiplex r = MOOList [ "", "", [ "multiplexor", "multiplex" ] ]
#32 Mr. Spell. argi r = MOOList [ "", "", [ "Argive", "arginine", "argillaceous" ] ]
#32 Mr. Spell. antic r = MOOList [ "", "i", [ "antic" ] ]
#32 Mr. Spell. Loren r = MOOList [ "", "", [ "Lorenz", "Loren" ] ]
#32 Mr. Spell. GM r = MOOList [ "", "", [ "GMT", "GM" ] ]
#32 Mr. Spell. sophom r = MOOList [ "or", "", [ "sophomoric", "sophomore" ] ]
#32 Mr. Spell. hypothe r = MOOList [ "", "s", [ "hypothetic" ] ]
#32 Mr. Spell. franc r = MOOList [ "", "eio", [ "franchise", "franca", "franc" ] ]
#32 Mr. Spell. argo r = MOOList [ "", "n", [ "argot", "argo" ] ]
#32 Mr. Spell. antiq r = MOOList [ "u", "a", [ "antiquity", "antique" ] ]
#32 Mr. Spell. Ody r = MOOList [ "sse", "", [ "Odyssey", "Odysseus" ] ]
#32 Mr. Spell. antip r = MOOList [ "", "a", [ "antipode", "antiphonal", "antiperspirant" ] ]
#32 Mr. Spell. voca r = MOOList [ "", "bl", [ "vocate" ] ]
#32 Mr. Spell. mullig r = MOOList [ "a", "", [ "mulligatawny", "mulligan" ] ]
#32 Mr. Spell. Fu r = MOOList [ "", "cgjlmnrstz", [ "fuel", "fudge" ] ]
#32 Mr. Spell. argu r = MOOList [ "", "m", [ "Argus", "argue" ] ]
#32 Mr. Spell. invite r = MOOList [ "", "", [ "invitee", "invite" ] ]
#32 Mr. Spell. carti r = MOOList [ "lag", "", [ "cartilaginous", "cartilage" ] ]
#32 Mr. Spell. wres r = MOOList [ "t", "", [ "wrestle", "wrest" ] ]
#32 Mr. Spell. withs r = MOOList [ "t", "", [ "withstood", "withstand" ] ]
#32 Mr. Spell. carto r = MOOList [ "", "g", [ "cartoon", "carton" ] ]
#32 Mr. Spell. antis r = MOOList [ "emit", "", [ "antisemitic", "antisemite" ] ]
#32 Mr. Spell. sext r = MOOList [ "", "u", [ "sexton", "sextillion", "sextet", "Sextans" ] ]
#32 Mr. Spell. class r = MOOList [ "", "i", [ "classy", "classroom", "classmate", "class" ] ]
#32 Mr. Spell. withh r = MOOList [ "", "", [ "withhold", "withheld" ] ]
#32 Mr. Spell. accid r = MOOList [ "ent", "", [ "accidental", "accident" ] ]
#32 Mr. Spell. sophoc r = MOOList [ "le", "", [ "Sophocles", "Sophoclean" ] ]
#32 Mr. Spell. I' r = MOOList [ "", "", [ "I've", "i's", "I'm", "I'll", "I'd" ] ]
#32 Mr. Spell. carte r = MOOList [ "", "", [ "Cartesian", "cartel", "carte" ] ]
#32 Mr. Spell. lady r = MOOList [ "", "", [ "ladyfern", "lady" ] ]
#32 Mr. Spell. Vande r = MOOList [ "", "r", [ "Vandenberg" ] ]
#32 Mr. Spell. frame r = MOOList [ "", "", [ "framework", "frame" ] ]
#32 Mr. Spell. felic r = MOOList [ "", "i", [ "Felice" ] ]
#32 Mr. Spell. schoolb r = MOOList [ "o", "", [ "schoolboy", "schoolbook" ] ]
#32 Mr. Spell. anthe r = MOOList [ "", "", [ "anther", "anthem" ] ]
#32 Mr. Spell. wrec r = MOOList [ "k", "", [ "wreckage", "wreck" ] ]
#32 Mr. Spell. Chapl r = MOOList [ "", "", [ "Chaplin", "chaplain" ] ]
#32 Mr. Spell. vener r = MOOList [ "", "a", [ "venereal" ] ]
#32 Mr. Spell. buil r = MOOList [ "", "dt", [ ] ]
#32 Mr. Spell. wack r = MOOList [ "", "", [ "wacky", "wacke", "wack" ] ]
#32 Mr. Spell. Go r = MOOList [ "", "abdeglnoprstuv", [ "going", "gown", "Goff", "go" ] ]
#32 Mr. Spell. solut r = MOOList [ "", "", [ "solution", "solute" ] ]
#32 Mr. Spell. wrea r = MOOList [ "", "t", [ "wreak" ] ]
#32 Mr. Spell. Gu r = MOOList [ "", "aeilmnrsty", [ "guzzle", "Guggenheim", "guffaw", "gubernatorial", "GU" ] ]
#32 Mr. Spell. Englishm r = MOOList [ "", "", [ "Englishmen", "Englishman" ] ]
#32 Mr. Spell. yello r = MOOList [ "w", "", [ "Yellowstone", "Yellowknife", "yellowish", "yellow" ] ]
#32 Mr. Spell. towns r = MOOList [ "", "m", [ "Townsend" ] ]
#32 Mr. Spell. Gw r = MOOList [ "", "", [ "Gwyn", "Gwen" ] ]
#32 Mr. Spell. lacu r = MOOList [ "", "n", [ "lacustrine" ] ]
#32 Mr. Spell. emph r = MOOList [ "", "ay", [ ] ]
#32 Mr. Spell. lact r = MOOList [ "", "", [ "lactose", "lactate" ] ]
#32 Mr. Spell. incredu r = MOOList [ "l", "", [ "incredulous", "incredulity" ] ]
#32 Mr. Spell. empi r = MOOList [ "r", "", [ "empiric", "empire" ] ]
#32 Mr. Spell. tange r = MOOList [ "", "n", [ "tangerine" ] ]
#32 Mr. Spell. anthr r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. hexa r = MOOList [ "", "g", [ "hexane", "hexameter", "hexafluoride", "hexadecimal", "hexachloride" ] ]
#32 Mr. Spell. empo r = MOOList [ "", "", [ "empower", "emporium" ] ]
#32 Mr. Spell. schoolm r = MOOList [ "a", "", [ "schoolmate", "schoolmaster", "schoolmarm" ] ]
#32 Mr. Spell. empl r = MOOList [ "", "o", [ "emplace" ] ]
#32 Mr. Spell. burst r = MOOList [ "", "", [ "bursty", "burst" ] ]
#32 Mr. Spell. NIMb r = MOOList [ "", "", [ "nimbus", "nimble" ] ]
#32 Mr. Spell. actin r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. actio r = MOOList [ "n", "", [ "actions", "action" ] ]
#32 Mr. Spell. Ha r = MOOList [ "", "abcdgilmnprstuvwyz", [ "Hahn", "hafnium", "ha" ] ]
#32 Mr. Spell. IC r = MOOList [ "", "eo", [ "icy", "icky", "icicle", "ichneumon", "ICC", "Icarus" ] ]
#32 Mr. Spell. solve r = MOOList [ "", "", [ "solvent", "solve" ] ]
#32 Mr. Spell. schoolg r = MOOList [ "irl", "", [ "schoolgirlish", "schoolgirl" ] ]
#32 Mr. Spell. activ r = MOOList [ "", "a", [ "activities" ] ]
#32 Mr. Spell. Hi r = MOOList [ "", "abcdeglmnprst", [ "hive", "hike", "hijack", "hifalutin", "hi" ] ]
#32 Mr. Spell. lace r = MOOList [ "", "r", [ "lacewing", "lace" ] ]
#32 Mr. Spell. brink r = MOOList [ "", "", [ "brinkmanship", "brink" ] ]
#32 Mr. Spell. synchron r = MOOList [ "", "", [ "synchrony", "synchronous", "synchronism" ] ]
#32 Mr. Spell. magic r = MOOList [ "", "", [ "magician", "magic" ] ]
#32 Mr. Spell. bring r = MOOList [ "", "", [ "brings", "bring" ] ]
#32 Mr. Spell. lack r = MOOList [ "", "", [ "lackey", "lackadaisic", "lack" ] ]
#32 Mr. Spell. Bacca r = MOOList [ "", "", [ "baccarat", "baccalaureate" ] ]
#32 Mr. Spell. aren r = MOOList [ "", "a", [ "aren't" ] ]
#32 Mr. Spell. Hu r = MOOList [ "", "bcdfglmnrstx", [ "huzzah", "huh", "hue" ] ]
#32 Mr. Spell. labr r = MOOList [ "ador", "", [ "labradorite", "Labrador" ] ]
#32 Mr. Spell. thym r = MOOList [ "", "", [ "thymus", "thymine", "thyme" ] ]
#32 Mr. Spell. Hy r = MOOList [ "", "adgmps", [ "hying", "hyena", "hybrid" ] ]
#32 Mr. Spell. thyr r = MOOList [ "", "o", [ "thyratron" ] ]
#32 Mr. Spell. magis r = MOOList [ "t", "", [ "magistrate", "magisterial" ] ]
#32 Mr. Spell. labo r = MOOList [ "", "r", [ "labour" ] ]
#32 Mr. Spell. girli r = MOOList [ "", "", [ "girlish", "girlie" ] ]
#32 Mr. Spell. brind r = MOOList [ "", "", [ "brindle", "Brindisi" ] ]
#32 Mr. Spell. Id r = MOOList [ "", "aeioy", [ "idle", "ID" ] ]
#32 Mr. Spell. indeci r = MOOList [ "", "s", [ "indecipherable" ] ]
#32 Mr. Spell. area r = MOOList [ "", "w", [ "area" ] ]
#32 Mr. Spell. mugg r = MOOList [ "", "", [ "muggy", "mugging" ] ]
#32 Mr. Spell. rever r = MOOList [ "", "es", [ "revery", "revert", "reverie", "reverberate", "rever" ] ]
#32 Mr. Spell. bugg r = MOOList [ "", "", [ "buggy", "bugging" ] ]
#32 Mr. Spell. arde r = MOOList [ "n", "", [ "ardent", "Arden" ] ]
#32 Mr. Spell. withe r = MOOList [ "", "", [ "wither", "withe" ] ]
#32 Mr. Spell. withd r = MOOList [ "r", "a", [ "withdrew" ] ]
#32 Mr. Spell. labi r = MOOList [ "", "al", [ ] ]
#32 Mr. Spell. Ir r = MOOList [ "", "aeikorv", [ "Irwin", "IRS", "Irma", "IR" ] ]
#32 Mr. Spell. Is r = MOOList [ "", "ailorst", [ "isn't", "Isfahan", "isentropic", "is" ] ]
#32 Mr. Spell. It r = MOOList [ "", "aei's", [ "ITT", "IT&T", "Ito", "Ithaca", "itch", "it" ] ]
#32 Mr. Spell. bioti r = MOOList [ "", "", [ "biotite", "biotic" ] ]
#32 Mr. Spell. Iv r = MOOList [ "", "a", [ "ivy", "ivory", "Iverson", "iv" ] ]
#32 Mr. Spell. clari r = MOOList [ "", "", [ "clarity", "clarinet", "clarify" ] ]
#32 Mr. Spell. arcs r = MOOList [ "in", "", [ "arcsine", "arcsin" ] ]
#32 Mr. Spell. arct r = MOOList [ "", "a", [ "Arcturus", "arctic" ] ]
#32 Mr. Spell. produce r = MOOList [ "", "", [ "produces", "produced", "produce" ] ]
#32 Mr. Spell. narci r = MOOList [ "ss", "", [ "narcissus", "narcissist" ] ]
#32 Mr. Spell. produci r = MOOList [ "", "", [ "producing", "producible" ] ]
#32 Mr. Spell. Ja r = MOOList [ "", "bcgikmnprsuvwz", [ "jay", "jalopy", "Jaeger", "jade" ] ]
#32 Mr. Spell. Slove r = MOOList [ "n", "", [ "Slovenia", "sloven" ] ]
#32 Mr. Spell. revel r = MOOList [ "", "a", [ "revelry", "revel" ] ]
#32 Mr. Spell. arous r = MOOList [ "", "", [ "arouse", "arousal" ] ]
#32 Mr. Spell. product r = MOOList [ "", "i", [ "products", "product" ] ]
#32 Mr. Spell. cataly r = MOOList [ "", "s", [ "catalytic" ] ]
#32 Mr. Spell. reven r = MOOList [ "", "", [ "revenue", "revenge" ] ]
#32 Mr. Spell. provoc r = MOOList [ "at", "i", [ "provocateur" ] ]
#32 Mr. Spell. narco r = MOOList [ "", "", [ "narcotic", "narcosis" ] ]
#32 Mr. Spell. india r = MOOList [ "", "n", [ "India" ] ]
#32 Mr. Spell. arcc r = MOOList [ "os", "", [ "arccosine", "arccos" ] ]
#32 Mr. Spell. messa r = MOOList [ "ge", "", [ "messages", "message" ] ]
#32 Mr. Spell. Jo r = MOOList [ "", "abceghilnrsuvwy", [ "jot", "joke", "Jo" ] ]
#32 Mr. Spell. arch r = MOOList [ "", "aei", [ "archfool", "archdiocese", "archbishop", "arch" ] ]
#32 Mr. Spell. sett r = MOOList [ "", "i", [ "settle" ] ]
#32 Mr. Spell. Ju r = MOOList [ "", "abdgijklmnrstx", [ "juvenile", "Jupiter" ] ]
#32 Mr. Spell. indig r = MOOList [ "", "en", [ "indigo" ] ]
#32 Mr. Spell. indic r = MOOList [ "", "a", [ "indict", "indices" ] ]
#32 Mr. Spell. wrap r = MOOList [ "", "", [ "wrapup", "wrap" ] ]
#32 Mr. Spell. maggo r = MOOList [ "t", "", [ "maggoty", "maggot" ] ]
#32 Mr. Spell. wrat r = MOOList [ "h", "", [ "wrathful", "wrath" ] ]
#32 Mr. Spell. custome r = MOOList [ "r", "", [ "customers", "customer" ] ]
#32 Mr. Spell. Joan r = MOOList [ "", "n", [ "Joan" ] ]
#32 Mr. Spell. glacia r = MOOList [ "", "", [ "glaciate", "glacial" ] ]
#32 Mr. Spell. Ka r = MOOList [ "", "bflmnoprtuy", [ "kazoo", "kava", "Kaskaskia", "Kajar", "kaiser", "Kahn", "Kaddish" ] ]
#32 Mr. Spell. parago r = MOOList [ "n", "", [ "paragonite", "paragon" ] ]
#32 Mr. Spell. Ke r = MOOList [ "", "aelnprsty", [ "Kevin", "Kemp", "Keith", "keg", "keddah" ] ]
#32 Mr. Spell. colloquia r = MOOList [ "", "", [ "colloquial", "colloquia" ] ]
#32 Mr. Spell. messi r = MOOList [ "", "", [ "messieurs", "Messiah" ] ]
#32 Mr. Spell. waltz r = MOOList [ "", "", [ "waltzing", "waltz" ] ]
#32 Mr. Spell. Kl r = MOOList [ "", "ae", [ "klystron", "Klux", "Kline" ] ]
#32 Mr. Spell. Kn r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. Ko r = MOOList [ "", "cdelnrw", [ "Kovacs", "kosher", "Koppers", "kombu", "koinonia", "kohlrabi", "Kobayashi", "koala" ] ]
#32 Mr. Spell. Kr r = MOOList [ "", "aeiu", [ "krypton", "Kronecker" ] ]
#32 Mr. Spell. dicho r = MOOList [ "", "", [ "dichotomy", "dichondra" ] ]
#32 Mr. Spell. arbi r = MOOList [ "t", "r", [ "arbiter" ] ]
#32 Mr. Spell. Adel r = MOOList [ "", "", [ "Adelia", "Adele", "Adelaide" ] ]
#32 Mr. Spell. viscou r = MOOList [ "", "", [ "viscous", "viscount" ] ]
#32 Mr. Spell. Reub r = MOOList [ "", "", [ "Reuben", "Reub" ] ]
#32 Mr. Spell. imagi r = MOOList [ "n", "a", [ "imagine" ] ]
#32 Mr. Spell. Goody r = MOOList [ "", "", [ "Goodyear", "goody" ] ]
#32 Mr. Spell. sportsm r = MOOList [ "", "", [ "sportsmen", "sportsman" ] ]
#32 Mr. Spell. Goodw r = MOOList [ "i", "", [ "Goodwin", "goodwill" ] ]
#32 Mr. Spell. Ky r = MOOList [ "", "", [ "Kyoto", "Kyle", "KY" ] ]
#32 Mr. Spell. image r = MOOList [ "", "", [ "imagery", "imagen", "image" ] ]
#32 Mr. Spell. arbo r = MOOList [ "re", "", [ "arboretum", "arboreal" ] ]
#32 Mr. Spell. quizz r = MOOList [ "", "", [ "quizzical", "quizzes" ] ]
#32 Mr. Spell. improvi r = MOOList [ "", "s", [ "improvident" ] ]
#32 Mr. Spell. sacri r = MOOList [ "", "fl", [ ] ]
#32 Mr. Spell. pleni r = MOOList [ "", "", [ "plenitude", "plenipotentiary" ] ]
#32 Mr. Spell. spectac r = MOOList [ "", "", [ "spectacular", "spectacle" ] ]
#32 Mr. Spell. accla r = MOOList [ "", "", [ "acclamation", "acclaim" ] ]
#32 Mr. Spell. reflec r = MOOList [ "t", "", [ "reflector", "reflectance", "reflect" ] ]
#32 Mr. Spell. plent r = MOOList [ "", "", [ "plenty", "plentiful" ] ]
#32 Mr. Spell. sacra r = MOOList [ "", "m", [ "sacral" ] ]
#32 Mr. Spell. sportsw r = MOOList [ "", "r", [ "sportswear" ] ]
#32 Mr. Spell. indiv r = MOOList [ "i", "d", [ "indivisible" ] ]
#32 Mr. Spell. mudd r = MOOList [ "", "l", [ "muddy", "Mudd" ] ]
#32 Mr. Spell. indir r = MOOList [ "", "", [ "indirect", "Indira" ] ]
#32 Mr. Spell. indis r = MOOList [ "", "cpt", [ "indissoluble" ] ]
#32 Mr. Spell. arac r = MOOList [ "hn", "", [ "arachnid", "Arachne" ] ]
#32 Mr. Spell. roseb r = MOOList [ "u", "", [ "rosebush", "rosebud" ] ]
#32 Mr. Spell. budg r = MOOList [ "e", "t", [ "budge" ] ]
#32 Mr. Spell. serp r = MOOList [ "en", "t", [ "Serpens" ] ]
#32 Mr. Spell. prepara r = MOOList [ "t", "i", [ "preparatory" ] ]
#32 Mr. Spell. Lu r = MOOList [ "", "bcdfgklmnrstx", [ "Luzon", "lupine", "Luis" ] ]
#32 Mr. Spell. Addi r = MOOList [ "", "st", [ "adding", "addict" ] ]
#32 Mr. Spell. Canad r = MOOList [ "", "", [ "Canadian", "Canada" ] ]
#32 Mr. Spell. Ly r = MOOList [ "", "mnrs", [ "Lyon", "Lyle", "Lykes", "lying", "lye", "Lydia", "lycopodium" ] ]
#32 Mr. Spell. revie r = MOOList [ "w", "", [ "reviews", "review" ] ]
#32 Mr. Spell. serv r = MOOList [ "", "ioe", [ "servant" ] ]
#32 Mr. Spell. culpa r = MOOList [ "", "", [ "culpable", "culpa" ] ]
#32 Mr. Spell. seri r = MOOList [ "", "a", [ "serious", "serine", "serif", "series" ] ]
#32 Mr. Spell. thul r = MOOList [ "", "", [ "thulium", "Thule" ] ]
#32 Mr. Spell. thun r = MOOList [ "der", "bs", [ "thunderous", "thunderflower", "thunderclap", "thunder" ] ]
#32 Mr. Spell. NB r = MOOList [ "", "", [ "NBS", "NBC" ] ]
#32 Mr. Spell. Ma r = MOOList [ "", "cdeghijklmnoprstuvwxyz", [ "Mabel", "ma" ] ]
#32 Mr. Spell. thum r = MOOList [ "", "b", [ "thump" ] ]
#32 Mr. Spell. NC r = MOOList [ "", "", [ "NCR", "NCO", "NCAA", "NC" ] ]
#32 Mr. Spell. Mb r = MOOList [ "A", "", [ "Mbabane", "MBA" ] ]
#32 Mr. Spell. Mc r = MOOList [ "", "ACDFGIKLMN", [ "McPherson", "McHugh", "McElroy", "McBride" ] ]
#32 Mr. Spell. claus r = MOOList [ "", "et", [ "Clausius", "Claus" ] ]
#32 Mr. Spell. Mi r = MOOList [ "", "acdglmnrstx", [ "Mizar", "Miocene", "mike", "miff", "mien", "mi" ] ]
#32 Mr. Spell. sere r = MOOList [ "n", "d", [ "serene", "serenade" ] ]
#32 Mr. Spell. thug r = MOOList [ "", "", [ "thuggee", "thug" ] ]
#32 Mr. Spell. serg r = MOOList [ "e", "", [ "Sergei", "sergeant", "serge" ] ]
#32 Mr. Spell. accom r = MOOList [ "", "p", [ "accommodate" ] ]
#32 Mr. Spell. NN r = MOOList [ "", "", [ "NNW", "NNE" ] ]
#32 Mr. Spell. reviv r = MOOList [ "", "", [ "revive", "revival" ] ]
#32 Mr. Spell. NO r = MOOList [ "", "abcdeilmnorstuvw", [ "nozzle", "noxious", "no" ] ]
#32 Mr. Spell. here r = MOOList [ "", "aditu", [ "herewith", "heresy", "hereof", "Hereford", "hereby", "here" ] ]
#32 Mr. Spell. Mr r = MOOList [ "", "s", [ "mr.", "Mr" ] ]
#32 Mr. Spell. Chart r = MOOList [ "", "r", [ "Charta", "chart" ] ]
#32 Mr. Spell. heri r = MOOList [ "ta", "", [ "heritage", "heritable" ] ]
#32 Mr. Spell. herp r = MOOList [ "e", "", [ "herpetology", "herpes" ] ]
#32 Mr. Spell. buch r = MOOList [ "", "a", [ "Buchwald", "Buchenwald" ] ]
#32 Mr. Spell. buck r = MOOList [ "", "els", [ "buckwheat", "buckthorn", "Bucknell", "buckhorn", "buckboard", "buckaroo", "buck" ] ]
#32 Mr. Spell. NY r = MOOList [ "", "m", [ "NYU", "Nyquist", "nylon", "NYC", "NY" ] ]
#32 Mr. Spell. My r = MOOList [ "", "cenorst", [ "mylar", "my" ] ]
#32 Mr. Spell. hers r = MOOList [ "", "h", [ "herself", "Herschel", "hers" ] ]
#32 Mr. Spell. Charl r = MOOList [ "", "eo", [ "Charlie" ] ]
#32 Mr. Spell. sequ r = MOOList [ "", "ei", [ "Sequoia" ] ]
#32 Mr. Spell. herr r = MOOList [ "", "", [ "herringbone", "Herr" ] ]
#32 Mr. Spell. separ r = MOOList [ "a", "", [ "separate", "separable" ] ]
#32 Mr. Spell. roset r = MOOList [ "t", "", [ "rosette", "Rosetta" ] ]
#32 Mr. Spell. Oly r = MOOList [ "mpi", "", [ "Olympic", "Olympia" ] ]
#32 Mr. Spell. Nd r = MOOList [ "", "", [ "Ndjamena", "ND" ] ]
#32 Mr. Spell. paradi r = MOOList [ "", "g", [ "paradise" ] ]
#32 Mr. Spell. Ne r = MOOList [ "", "abcegiloprstuvw", [ "next", "nemesis", "Nehru", "Neff", "Ned", "ne" ] ]
#32 Mr. Spell. Krak r = MOOList [ "", "", [ "Krakow", "Krakatoa" ] ]
#32 Mr. Spell. indefi r = MOOList [ "n", "", [ "indefinite", "indefinable" ] ]
#32 Mr. Spell. Claren r = MOOList [ "", "", [ "Clarendon", "Clarence" ] ]
#32 Mr. Spell. parado r = MOOList [ "x", "", [ "paradoxic", "paradox" ] ]
#32 Mr. Spell. Ols r = MOOList [ "", "", [ "Olson", "Olsen" ] ]
#32 Mr. Spell. Gett r = MOOList [ "", "y", [ "getting" ] ]
#32 Mr. Spell. Ni r = MOOList [ "", "abceghklmnopt", [ "Nixon", "nirvana" ] ]
#32 Mr. Spell. hypotha r = MOOList [ "lam", "", [ "hypothalamus", "hypothalamic" ] ]
#32 Mr. Spell. revis r = MOOList [ "", "ai", [ "revise" ] ]
#32 Mr. Spell. herd r = MOOList [ "", "", [ "herdsman", "herd" ] ]
#32 Mr. Spell. Decat r = MOOList [ "", "", [ "Decatur", "decathlon" ] ]
#32 Mr. Spell. indul r = MOOList [ "ge", "", [ "indulgent", "indulge" ] ]
#32 Mr. Spell. graphi r = MOOList [ "", "", [ "graphite", "graphic" ] ]
#32 Mr. Spell. indus r = MOOList [ "tr", "i", [ "industry" ] ]
#32 Mr. Spell. theoret r = MOOList [ "ic", "", [ "theoretician", "theoretic" ] ]
#32 Mr. Spell. perip r = MOOList [ "", "h", [ "peripatetic" ] ]
#32 Mr. Spell. chea r = MOOList [ "", "t", [ "cheap" ] ]
#32 Mr. Spell. brickl r = MOOList [ "ay", "", [ "bricklaying", "bricklayer" ] ]
#32 Mr. Spell. chec r = MOOList [ "k", "es", [ "checkup", "checkpoint", "checkout", "checklist", "checkbook", "check" ] ]
#32 Mr. Spell. peris r = MOOList [ "", "", [ "perish", "periscope" ] ]
#32 Mr. Spell. mean r = MOOList [ "", "t", [ "means", "meanwhile", "meaningful", "meander", "mean" ] ]
#32 Mr. Spell. brita r = MOOList [ "", "n", [ "Britain" ] ]
#32 Mr. Spell. chee r = MOOList [ "", "krs", [ "cheetah" ] ]
#32 Mr. Spell. meal r = MOOList [ "", "", [ "mealy", "mealtime", "meal" ] ]
#32 Mr. Spell. Oe r = MOOList [ "", "d", [ "oersted" ] ]
#32 Mr. Spell. perio r = MOOList [ "d", "", [ "periodic", "period" ] ]
#32 Mr. Spell. metab r = MOOList [ "ol", "i", [ "metabole" ] ]
#32 Mr. Spell. Oh r = MOOList [ "", "m", [ "Ohio", "oh" ] ]
#32 Mr. Spell. hesitat r = MOOList [ "e", "", [ "hesitater", "hesitate" ] ]
#32 Mr. Spell. metrop r = MOOList [ "oli", "", [ "metropolitan", "metropolis" ] ]
#32 Mr. Spell. Stevens r = MOOList [ "", "", [ "Stevenson", "Stevens" ] ]
#32 Mr. Spell. induc r = MOOList [ "", "t", [ "inducible", "induce" ] ]
#32 Mr. Spell. meas r = MOOList [ "", "", [ "measure", "measle" ] ]
#32 Mr. Spell. chem r = MOOList [ "", "i", [ "chemotherapy" ] ]
#32 Mr. Spell. Ol r = MOOList [ "", "adeisy", [ "Olga", "olfactory" ] ]
#32 Mr. Spell. meat r = MOOList [ "", "", [ "meaty", "meat" ] ]
#32 Mr. Spell. spectrograp r = MOOList [ "h", "", [ "spectrography", "spectrograph" ] ]
#32 Mr. Spell. Om r = MOOList [ "", "abein", [ ] ]
#32 Mr. Spell. Camelo r = MOOList [ "", "", [ "Camelot", "camelopard" ] ]
#32 Mr. Spell. septu r = MOOList [ "", "", [ "septum", "septuagenarian" ] ]
#32 Mr. Spell. nucleo r = MOOList [ "", "l", [ "nucleotide" ] ]
#32 Mr. Spell. metap r = MOOList [ "hor", "", [ "metaphoric", "metaphor" ] ]
#32 Mr. Spell. increa r = MOOList [ "s", "e", [ "increasing", "increasable" ] ]
#32 Mr. Spell. metam r = MOOList [ "orph", "io", [ ] ]
#32 Mr. Spell. incred r = MOOList [ "", "u", [ "incredible" ] ]
#32 Mr. Spell. peric r = MOOList [ "le", "", [ "Pericles", "Periclean" ] ]
#32 Mr. Spell. Os r = MOOList [ "", "bcimst", [ "Oswald", "osprey", "Oslo", "Oshkosh", "Osgood", "Osaka" ] ]
#32 Mr. Spell. beas r = MOOList [ "t", "", [ "beastie", "beast" ] ]
#32 Mr. Spell. accor r = MOOList [ "d", "i", [ "accordant", "accord" ] ]
#32 Mr. Spell. heterog r = MOOList [ "", "e", [ "heterogamous" ] ]
#32 Mr. Spell. bear r = MOOList [ "", "d", [ "bearish", "bearberry", "bear" ] ]
#32 Mr. Spell. toxic r = MOOList [ "", "", [ "toxicology", "toxic" ] ]
#32 Mr. Spell. beat r = MOOList [ "", "ei", [ "Beatrice", "beatnik", "beat" ] ]
#32 Mr. Spell. accou r = MOOList [ "", "n", [ "accouter" ] ]
#32 Mr. Spell. One r = MOOList [ "", "", [ "oneupmanship", "onetime", "oneself", "onerous", "Oneida", "one" ] ]
#32 Mr. Spell. fraud r = MOOList [ "", "", [ "fraudulent", "fraud" ] ]
#32 Mr. Spell. septi r = MOOList [ "", "", [ "septillion", "septic" ] ]
#32 Mr. Spell. metal r = MOOList [ "", "l", [ "metalwork", "metal" ] ]
#32 Mr. Spell. mead r = MOOList [ "", "o", [ "mead" ] ]
#32 Mr. Spell. nuclei r = MOOList [ "", "", [ "nucleic", "nuclei" ] ]
#32 Mr. Spell. septe r = MOOList [ "", "", [ "septennial", "September" ] ]
#32 Mr. Spell. Pa r = MOOList [ "", "bcdgiklmnprstuvwy", [ "Paz", "pax", "Paoli", "paean", "pa" ] ]
#32 Mr. Spell. glassw r = MOOList [ "", "", [ "glasswort", "glassware" ] ]
#32 Mr. Spell. barber r = MOOList [ "", "", [ "barberry", "barber" ] ]
#32 Mr. Spell. titi r = MOOList [ "", "", [ "titillate", "titian" ] ]
#32 Mr. Spell. septa r = MOOList [ "", "", [ "septate", "septa" ] ]
#32 Mr. Spell. regiment r = MOOList [ "", "", [ "regimentation", "regiment" ] ]
#32 Mr. Spell. pontif r = MOOList [ "", "i", [ "pontiff" ] ]
#32 Mr. Spell. beac r = MOOList [ "", "h", [ "beacon" ] ]
#32 Mr. Spell. Pe r = MOOList [ "", "acdeglmnoprstw", [ "Peugeot", "Peking", "pejorative", "pebble" ] ]
#32 Mr. Spell. rhodo r = MOOList [ "", "", [ "rhodonite", "rhodolite", "rhododendron" ] ]
#32 Mr. Spell. Pf r = MOOList [ "", "", [ "Pfizer", "pfennig" ] ]
#32 Mr. Spell. nuclea r = MOOList [ "", "", [ "nucleate", "nuclear", "nucleant" ] ]
#32 Mr. Spell. bead r = MOOList [ "", "", [ "beady", "beadle", "bead" ] ]
#32 Mr. Spell. Marshal r = MOOList [ "", "", [ "Marshall", "marshal" ] ]
#32 Mr. Spell. tita r = MOOList [ "n", "i", [ "titanate", "Titan" ] ]
#32 Mr. Spell. paralle r = MOOList [ "l", "", [ "parallelepiped", "parallel" ] ]
#32 Mr. Spell. Aven r = MOOList [ "", "", [ "avenue", "Aventine", "avenge" ] ]
#32 Mr. Spell. Lean r = MOOList [ "", "", [ "Leander", "lean" ] ]
#32 Mr. Spell. betro r = MOOList [ "th", "", [ "betrothal", "betroth" ] ]
#32 Mr. Spell. accru r = MOOList [ "", "", [ "accrue", "accrual" ] ]
#32 Mr. Spell. distrib r = MOOList [ "ut", "i", [ "distributor" ] ]
#32 Mr. Spell. culti r = MOOList [ "va", "", [ "cultivate", "cultivable" ] ]
#32 Mr. Spell. irrepr r = MOOList [ "", "o", [ "irrepressible" ] ]
#32 Mr. Spell. betra r = MOOList [ "y", "", [ "betrayal", "betray" ] ]
#32 Mr. Spell. temperat r = MOOList [ "", "", [ "temperature", "temperate" ] ]
#32 Mr. Spell. heteros r = MOOList [ "", "", [ "heterostructure", "heterosexual" ] ]
#32 Mr. Spell. enig r = MOOList [ "ma", "", [ "enigmatic", "enigma" ] ]
#32 Mr. Spell. Lebe r = MOOList [ "", "", [ "Lebesgue", "lebensraum" ] ]
#32 Mr. Spell. Toroi r = MOOList [ "d", "", [ "toroidal", "toroid" ] ]
#32 Mr. Spell. cultu r = MOOList [ "r", "", [ "culture", "cultural" ] ]
#32 Mr. Spell. lazy r = MOOList [ "", "", [ "lazybones", "lazy" ] ]
#32 Mr. Spell. Ope r = MOOList [ "", "rn", [ "Opel", "OPEC" ] ]
#32 Mr. Spell. tire r = MOOList [ "", "", [ "tiresome", "tire" ] ]
#32 Mr. Spell. perfo r = MOOList [ "r", "m", [ "perforce", "perforate" ] ]
#32 Mr. Spell. perfi r = MOOList [ "d", "", [ "perfidy", "perfidious" ] ]
#32 Mr. Spell. Myel r = MOOList [ "", "", [ "myeloid", "myeline", "myel" ] ]
#32 Mr. Spell. assas r = MOOList [ "sin", "", [ "assassinate", "assassin" ] ]
#32 Mr. Spell. accre r = MOOList [ "", "d", [ "accretion" ] ]
#32 Mr. Spell. SI r = MOOList [ "", "abcdeglmnrstxz", [ "siva", "sip", "Sioux", "Sikorsky", "sift" ] ]
#32 Mr. Spell. chemis r = MOOList [ "", "ot", [ "chemise" ] ]
#32 Mr. Spell. perfu r = MOOList [ "", "m", [ "perfusion", "perfunctory" ] ]
#32 Mr. Spell. tira r = MOOList [ "", "", [ "Tirana", "tirade" ] ]
#32 Mr. Spell. sadis r = MOOList [ "", "", [ "sadist", "sadism" ] ]
#32 Mr. Spell. ways r = MOOList [ "", "", [ "wayside", "ways" ] ]
#32 Mr. Spell. techno r = MOOList [ "", "c", [ "technology" ] ]
#32 Mr. Spell. SS r = MOOList [ "", "", [ "SSW", "SST", "SSE" ] ]
#32 Mr. Spell. cham r = MOOList [ "", "bop", [ "chamfer", "chameleon" ] ]
#32 Mr. Spell. custodi r = MOOList [ "a", "", [ "custodian", "custodial" ] ]
#32 Mr. Spell. chal r = MOOList [ "", "ck", [ "Chalmers", "challenge", "chalice" ] ]
#32 Mr. Spell. chao r = MOOList [ "", "", [ "chaotic", "chaos", "Chao" ] ]
#32 Mr. Spell. chan r = MOOList [ "", "cdgt", [ "chanson", "channel" ] ]
#32 Mr. Spell. depreci r = MOOList [ "a", "", [ "depreciate", "depreciable" ] ]
#32 Mr. Spell. chap r = MOOList [ "", "el", [ "chapter", "Chapman", "chaparral", "chap" ] ]
#32 Mr. Spell. techni r = MOOList [ "", "c", [ "technique", "Technion" ] ]
#32 Mr. Spell. inexpl r = MOOList [ "", "i", [ "inexplainable" ] ]
#32 Mr. Spell. chas r = MOOList [ "", "t", [ "chassis", "chasm", "chase" ] ]
#32 Mr. Spell. wayl r = MOOList [ "a", "", [ "waylay", "waylaid" ] ]
#32 Mr. Spell. Ry r = MOOList [ "", "d", [ "rye", "Ryan" ] ]
#32 Mr. Spell. char r = MOOList [ "", "agilt", [ "Charybdis", "Charon", "charm", "chard", "charcoal", "char" ] ]
#32 Mr. Spell. perfe r = MOOList [ "ct", "", [ "perfectible", "perfect" ] ]
#32 Mr. Spell. chau r = MOOList [ "", "", [ "Chautauqua", "Chauncey", "chauffeur", "Chaucer" ] ]
#32 Mr. Spell. chat r = MOOList [ "", "et", [ "Chatham", "chat" ] ]
#32 Mr. Spell. Camil r = MOOList [ "l", "", [ "Camille", "camilla" ] ]
#32 Mr. Spell. bette r = MOOList [ "", "", [ "better", "Bette" ] ]
#32 Mr. Spell. qua r = MOOList [ "", "cdiklnrst", [ "quay", "quaver", "quahog", "quagmire", "quaff", "qua" ] ]
#32 Mr. Spell. depreca r = MOOList [ "t", "", [ "deprecatory", "deprecate" ] ]
#32 Mr. Spell. cycl r = MOOList [ "", "io", [ "cycle", "Cyclades" ] ]
#32 Mr. Spell. Fisch r = MOOList [ "", "", [ "Fischer", "Fischbein" ] ]
#32 Mr. Spell. ulti r = MOOList [ "mat", "", [ "ultimatum", "ultimate" ] ]
#32 Mr. Spell. Hitc r = MOOList [ "h", "", [ "Hitchcock", "hitch" ] ]
#32 Mr. Spell. Sisy r = MOOList [ "ph", "", [ "Sisyphus", "Sisyphean" ] ]
#32 Mr. Spell. U. r = MOOList [ "S", "", [ "U.S.A", "U.S" ] ]
#32 Mr. Spell. engi r = MOOList [ "ne", "", [ "engineer", "engine" ] ]
#32 Mr. Spell. TN r = MOOList [ "", "", [ "TNT", "TN" ] ]
#32 Mr. Spell. irreve r = MOOList [ "r", "", [ "irreversible", "irreverent" ] ]
#32 Mr. Spell. chaf r = MOOList [ "", "", [ "chaff", "chafe" ] ]
#32 Mr. Spell. laym r = MOOList [ "", "", [ "laymen", "layman" ] ]
#32 Mr. Spell. chai r = MOOList [ "", "r", [ "chaise", "chain" ] ]
#32 Mr. Spell. Sist r = MOOList [ "", "", [ "Sistine", "sister" ] ]
#32 Mr. Spell. swor r = MOOList [ "", "d", [ "sworn", "swore" ] ]
#32 Mr. Spell. layo r = MOOList [ "", "", [ "layout", "layoff" ] ]
#32 Mr. Spell. accur r = MOOList [ "a", "", [ "accurate", "accuracy" ] ]
#32 Mr. Spell. inexpe r = MOOList [ "", "r", [ "inexpensive", "inexpedient" ] ]
#32 Mr. Spell. accus r = MOOList [ "", "a", [ "accustom", "accuse" ] ]
#32 Mr. Spell. TT r = MOOList [ "", "", [ "TTY", "TTL" ] ]
#32 Mr. Spell. consumer r = MOOList [ "", "", [ "consumers", "consumer" ] ]
#32 Mr. Spell. enfo r = MOOList [ "rc", "", [ "enforcible", "enforceable" ] ]
#32 Mr. Spell. TV r = MOOList [ "", "", [ "TVA", "TV" ] ]
#32 Mr. Spell. TW r = MOOList [ "", "aeio", [ "TWX" ] ]
#32 Mr. Spell. Oro r = MOOList [ "", "", [ "Orono", "orography" ] ]
#32 Mr. Spell. committa r = MOOList [ "", "", [ "committal", "committable" ] ]
#32 Mr. Spell. Sy r = MOOList [ "", "bclmnrs", [ "syzygy", "Sykes", "syenite", "Sydney" ] ]
#32 Mr. Spell. Orl r = MOOList [ "", "", [ "Orleans", "Orlando" ] ]
#32 Mr. Spell. hillm r = MOOList [ "", "", [ "hillmen", "hillman" ] ]
#32 Mr. Spell. tipp r = MOOList [ "", "", [ "tippy", "tipple", "Tipperary" ] ]
#32 Mr. Spell. committe r = MOOList [ "", "e", [ "committed" ] ]
#32 Mr. Spell. Osb r = MOOList [ "orn", "", [ "Osborne", "Osborn" ] ]
#32 Mr. Spell. treasu r = MOOList [ "r", "", [ "treasury", "treasure" ] ]
#32 Mr. Spell. Th r = MOOList [ "", "aeioruwy", [ ] ]
#32 Mr. Spell. Ti r = MOOList [ "", "bcdefglmnprt", [ "tissue", "Tioga", "ti" ] ]
#32 Mr. Spell. qui r = MOOList [ "", "celnprtxz", [ "quiver", "quid", "quibble" ] ]
#32 Mr. Spell. treaso r = MOOList [ "n", "", [ "treasonous", "treason" ] ]
#32 Mr. Spell. peace r = MOOList [ "", "", [ "peacetime", "peacemake", "peaceful", "peaceable", "peace" ] ]
#32 Mr. Spell. quo r = MOOList [ "", "t", [ "quorum", "quonset", "quod", "quo" ] ]
#32 Mr. Spell. Orw r = MOOList [ "ell", "", [ "Orwellian", "Orwell" ] ]
#32 Mr. Spell. emitt r = MOOList [ "", "e", [ "emitting", "emittance" ] ]
#32 Mr. Spell. laws r = MOOList [ "", "", [ "lawsuit", "Lawson" ] ]
#32 Mr. Spell. ener r = MOOList [ "", "g", [ "enervate" ] ]
#32 Mr. Spell. lawr r = MOOList [ "enc", "", [ "lawrencium", "Lawrence" ] ]
#32 Mr. Spell. puppy r = MOOList [ "", "", [ "puppyish", "puppy" ] ]
#32 Mr. Spell. Osi r = MOOList [ "", "", [ "Osiris", "osier" ] ]
#32 Mr. Spell. sophis r = MOOList [ "", "t", [ "sophism" ] ]
#32 Mr. Spell. barbar r = MOOList [ "", "i", [ "barbarous", "Barbara" ] ]
#32 Mr. Spell. lawg r = MOOList [ "iv", "", [ "lawgiving", "lawgiver" ] ]
#32 Mr. Spell. lawb r = MOOList [ "reak", "", [ "lawbreaking", "lawbreaker" ] ]
#32 Mr. Spell. Uk r = MOOList [ "", "r", [ "UK" ] ]
#32 Mr. Spell. perch r = MOOList [ "", "", [ "perchlorate", "perchance", "perch" ] ]
#32 Mr. Spell. refracto r = MOOList [ "", "", [ "refractory", "refractometer" ] ]
#32 Mr. Spell. controlle r = MOOList [ "", "", [ "controller", "controlled" ] ]
#32 Mr. Spell. handicr r = MOOList [ "aft", "s", [ "handicraft" ] ]
#32 Mr. Spell. martia r = MOOList [ "", "", [ "Martian", "martial" ] ]
#32 Mr. Spell. percu r = MOOList [ "ssi", "", [ "percussive", "percussion" ] ]
#32 Mr. Spell. Hiro r = MOOList [ "shi", "", [ "Hiroshima", "Hiroshi" ] ]
#32 Mr. Spell. Technic r = MOOList [ "", "", [ "technician", "technic" ] ]
#32 Mr. Spell. puppe r = MOOList [ "t", "", [ "puppeteer", "puppet" ] ]
#32 Mr. Spell. lawm r = MOOList [ "", "a", [ "lawmen" ] ]
#32 Mr. Spell. Ut r = MOOList [ "", "eiot", [ "Utrecht", "utmost", "Utah", "UT" ] ]
#32 Mr. Spell. Ott r = MOOList [ "", "o", [ "otter", "Ottawa", "Ott" ] ]
#32 Mr. Spell. tint r = MOOList [ "", "", [ "tintype", "tint" ] ]
#32 Mr. Spell. magne r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. wave r = MOOList [ "", "fl", [ "wavenumber", "waveguide", "wave" ] ]
#32 Mr. Spell. Hipp r = MOOList [ "", "o", [ "hippy" ] ]
#32 Mr. Spell. Novel r = MOOList [ "", "", [ "novelty", "novel" ] ]
#32 Mr. Spell. magni r = MOOList [ "", "f", [ "magnitude" ] ]
#32 Mr. Spell. endo r = MOOList [ "", "gt", [ "endow", "endosperm", "endorse", "endomorphism", "endoderm" ] ]
#32 Mr. Spell. metall r = MOOList [ "", "iou", [ ] ]
#32 Mr. Spell. irreso r = MOOList [ "l", "u", [ "irresolvable" ] ]
#32 Mr. Spell. handica r = MOOList [ "p", "p", [ "handicap" ] ]
#32 Mr. Spell. asses r = MOOList [ "s", "", [ "assessor", "assess" ] ]
#32 Mr. Spell. irresp r = MOOList [ "", "", [ "irresponsible", "irrespective" ] ]
#32 Mr. Spell. tink r = MOOList [ "", "", [ "tinkle", "tinker" ] ]
#32 Mr. Spell. perce r = MOOList [ "", "np", [ "perceive" ] ]
#32 Mr. Spell. Oti r = MOOList [ "", "", [ "Otis", "otiose" ] ]
#32 Mr. Spell. Letha r = MOOList [ "", "", [ "lethargy", "lethal" ] ]
#32 Mr. Spell. magna r = MOOList [ "", "n", [ "magnate", "magna" ] ]
#32 Mr. Spell. assem r = MOOList [ "bl", "", [ "assemble", "assemblage" ] ]
#32 Mr. Spell. Jacks r = MOOList [ "on", "", [ "Jacksonville", "Jackson" ] ]
#32 Mr. Spell. lava r = MOOList [ "", "", [ "lavatory", "lavabo", "lava" ] ]
#32 Mr. Spell. Vl r = MOOList [ "adi", "", [ "Vladivostok", "Vladimir" ] ]
#32 Mr. Spell. ting r = MOOList [ "", "", [ "tingle", "tinge" ] ]
#32 Mr. Spell. dicta r = MOOList [ "", "t", [ "dicta" ] ]
#32 Mr. Spell. methy r = MOOList [ "l", "", [ "methylene", "methyl" ] ]
#32 Mr. Spell. laur r = MOOList [ "", "e", [ "Laurie", "laura" ] ]
#32 Mr. Spell. enco r = MOOList [ "", "m", [ "encore" ] ]
#32 Mr. Spell. ventu r = MOOList [ "r", "e", [ "venturi" ] ]
#32 Mr. Spell. metho r = MOOList [ "d", "", [ "methods", "methodology", "methodic", "method" ] ]
#32 Mr. Spell. encu r = MOOList [ "mb", "", [ "encumbrance", "encumber" ] ]
#32 Mr. Spell. encr r = MOOList [ "", "", [ "encryption", "encroach" ] ]
#32 Mr. Spell. timo r = MOOList [ "", "", [ "timothy", "Timon" ] ]
#32 Mr. Spell. watt r = MOOList [ "", "", [ "Watts", "wattle", "wattage", "watt" ] ]
#32 Mr. Spell. Platonis r = MOOList [ "", "", [ "Platonist", "Platonism" ] ]
#32 Mr. Spell. sandpi r = MOOList [ "", "", [ "sandpiper", "sandpile" ] ]
#32 Mr. Spell. laug r = MOOList [ "h", "", [ "laughter", "Laughlin", "laughingstock", "laugh" ] ]
#32 Mr. Spell. timb r = MOOList [ "", "e", [ "timbre" ] ]
#32 Mr. Spell. time r = MOOList [ "", "s", [ "timeless", "Timex", "timeworn", "timetable", "timepiece", "timeout", "time" ] ]
#32 Mr. Spell. Marti r = MOOList [ "", "an", [ ] ]
#32 Mr. Spell. assig r = MOOList [ "n", "", [ "assigning", "assignee", "assignation", "assign" ] ]
#32 Mr. Spell. laun r = MOOList [ "", "d", [ "launch" ] ]
#32 Mr. Spell. assid r = MOOList [ "u", "", [ "assiduous", "assiduity" ] ]
#32 Mr. Spell. planeta r = MOOList [ "r", "i", [ "planetary" ] ]
#32 Mr. Spell. Wu r = MOOList [ "", "", [ "Wuhan", "Wu" ] ]
#32 Mr. Spell. Jovi r = MOOList [ "a", "", [ "Jovian", "jovial" ] ]
#32 Mr. Spell. dicti r = MOOList [ "on", "", [ "dictionary", "diction" ] ]
#32 Mr. Spell. fourte r = MOOList [ "en", "", [ "fourteenth", "fourteen" ] ]
#32 Mr. Spell. latt r = MOOList [ "", "", [ "lattice", "latter" ] ]
#32 Mr. Spell. Glend r = MOOList [ "a", "", [ "Glendale", "Glenda" ] ]
#32 Mr. Spell. vort r = MOOList [ "", "i", [ "vortex" ] ]
#32 Mr. Spell. Wy r = MOOList [ "", "an", [ "Wyoming", "Wyman", "Wylie", "Wyeth", "WY" ] ]
#32 Mr. Spell. watc r = MOOList [ "h", "m", [ "watchword", "watchful", "watchdog", "watchband", "watch" ] ]
#32 Mr. Spell. tilt r = MOOList [ "", "", [ "tilth", "tilt" ] ]
#32 Mr. Spell. parasi r = MOOList [ "t", "", [ "parasitic", "parasite" ] ]
#32 Mr. Spell. minutem r = MOOList [ "", "", [ "minutemen", "minuteman" ] ]
#32 Mr. Spell. inval r = MOOList [ "", "i", [ "invaluable" ] ]
#32 Mr. Spell. rectif r = MOOList [ "", "", [ "rectify", "rectifier" ] ]
#32 Mr. Spell. electroni r = MOOList [ "c", "", [ "electronics", "electronic" ] ]
#32 Mr. Spell. lanca r = MOOList [ "s", "", [ "Lancaster", "Lancashire" ] ]
#32 Mr. Spell. wast r = MOOList [ "", "e", [ "wastrel", "wastage", "wast" ] ]
#32 Mr. Spell. vora r = MOOList [ "ci", "", [ "voracity", "voracious" ] ]
#32 Mr. Spell. Owe r = MOOList [ "", "", [ "Owens", "owe" ] ]
#32 Mr. Spell. late r = MOOList [ "", "r", [ "latest", "latex", "latent", "late" ] ]
#32 Mr. Spell. provide r = MOOList [ "", "n", [ "provides", "provided", "provide" ] ]
#32 Mr. Spell. lath r = MOOList [ "", "", [ "Lathrop", "lathe", "lath" ] ]
#32 Mr. Spell. wasp r = MOOList [ "", "", [ "waspish", "wasp" ] ]
#32 Mr. Spell. Duran r = MOOList [ "", "", [ "Durango", "durance" ] ]
#32 Mr. Spell. lass r = MOOList [ "", "", [ "lasso", "lass" ] ]
#32 Mr. Spell. wash r = MOOList [ "", "b", [ "washy", "washout", "wash", "washington" ] ]
#32 Mr. Spell. Christo r = MOOList [ "", "p", [ "Christoffel" ] ]
#32 Mr. Spell. perpe r = MOOList [ "", "t", [ "perpendicular" ] ]
#32 Mr. Spell. Marve r = MOOList [ "l", "", [ "marvelous", "marvel" ] ]
#32 Mr. Spell. Irishm r = MOOList [ "", "", [ "Irishmen", "Irishman" ] ]
#32 Mr. Spell. Silv r = MOOList [ "er", "", [ "silvery", "silverware", "silversmith", "Silverman", "silver" ] ]
#32 Mr. Spell. warr r = MOOList [ "", "a", [ "warrior", "warren" ] ]
#32 Mr. Spell. swin r = MOOList [ "", "g", [ "swine", "swindle" ] ]
#32 Mr. Spell. lasc r = MOOList [ "", "", [ "lascivious", "lascar" ] ]
#32 Mr. Spell. Vaud r = MOOList [ "", "", [ "Vaudois", "vaudeville" ] ]
#32 Mr. Spell. swim r = MOOList [ "", "", [ "swimsuit", "swim" ] ]
#32 Mr. Spell. warp r = MOOList [ "", "", [ "warplane", "warp" ] ]
#32 Mr. Spell. Simo r = MOOList [ "n", "", [ "Simonson", "Simon" ] ]
#32 Mr. Spell. Hind r = MOOList [ "", "", [ "hinder", "Hindu", "hindsight", "hindrance", "hindmost", "hind" ] ]
#32 Mr. Spell. medicin r = MOOList [ "", "", [ "medicine", "medicinal" ] ]
#32 Mr. Spell. swir r = MOOList [ "l", "", [ "swirly", "swirl" ] ]
#32 Mr. Spell. invar r = MOOList [ "ia", "", [ "invariant", "invariable" ] ]
#32 Mr. Spell. scrupu r = MOOList [ "lo", "", [ "scrupulous", "scrupulosity" ] ]
#32 Mr. Spell. invas r = MOOList [ "i", "", [ "invasive", "invasion" ] ]
#32 Mr. Spell. Auste r = MOOList [ "", "", [ "austere", "austenite" ] ]
#32 Mr. Spell. wart r = MOOList [ "", "", [ "warty", "wartime", "wart" ] ]
#32 Mr. Spell. Vaug r = MOOList [ "h", "", [ "Vaughn", "Vaughan" ] ]
#32 Mr. Spell. swit r = MOOList [ "", "cz", [ ] ]
#32 Mr. Spell. swis r = MOOList [ "", "h", [ "swiss" ] ]
#32 Mr. Spell. Austr r = MOOList [ "", "a", [ "Austria" ] ]
#32 Mr. Spell. incant r = MOOList [ "", "", [ "incantation", "incant" ] ]
#32 Mr. Spell. swig r = MOOList [ "", "", [ "swigging", "swig" ] ]
#32 Mr. Spell. Christi r = MOOList [ "", "an", [ "Christie" ] ]
#32 Mr. Spell. Simm r = MOOList [ "", "", [ "Simmons", "simmer" ] ]
#32 Mr. Spell. Yv r = MOOList [ "e", "", [ "Yvette", "Yves" ] ]
#32 Mr. Spell. processi r = MOOList [ "", "", [ "processing", "procession" ] ]
#32 Mr. Spell. warm r = MOOList [ "", "", [ "warmup", "warmth", "warmonger", "warmish", "warmhearted", "warm" ] ]
#32 Mr. Spell. Christe r = MOOList [ "n", "s", [ "Christendom", "christen" ] ]
#32 Mr. Spell. Vass r = MOOList [ "a", "", [ "Vassar", "vassal" ] ]
#32 Mr. Spell. initial r = MOOList [ "", "", [ "initialize", "initial" ] ]
#32 Mr. Spell. haven r = MOOList [ "", "", [ "haven't", "haven" ] ]
#32 Mr. Spell. ward r = MOOList [ "", "r", [ "warden", "ward" ] ]
#32 Mr. Spell. ware r = MOOList [ "", "h", [ "ware" ] ]
#32 Mr. Spell. lary r = MOOList [ "n", "g", [ "larynx" ] ]
#32 Mr. Spell. Ze r = MOOList [ "", "anrs", [ "Zeus", "zeta", "Zellerbach", "Zeiss", "zebra" ] ]
#32 Mr. Spell. larv r = MOOList [ "a", "", [ "larval", "larvae", "larva" ] ]
#32 Mr. Spell. Kath r = MOOList [ "", "", [ "Kathy", "Kathleen", "Katherine", "Katharine" ] ]
#32 Mr. Spell. Hilt r = MOOList [ "", "", [ "Hilton", "hilt" ] ]
#32 Mr. Spell. assis r = MOOList [ "t", "", [ "assistant", "assist" ] ]
#32 Mr. Spell. Jose r = MOOList [ "", "p", [ "Josef", "Jose" ] ]
#32 Mr. Spell. lands r = MOOList [ "", "", [ "landslide", "landscape" ] ]
#32 Mr. Spell. arte r = MOOList [ "", "mr", [ ] ]
#32 Mr. Spell. larc r = MOOList [ "", "", [ "larch", "larceny" ] ]
#32 Mr. Spell. sauce r = MOOList [ "", "", [ "saucepan", "sauce" ] ]
#32 Mr. Spell. bayon r = MOOList [ "", "", [ "Bayonne", "bayonet" ] ]
#32 Mr. Spell. Bruce r = MOOList [ "", "", [ "brucellosis", "Bruce" ] ]
#32 Mr. Spell. arti r = MOOList [ "", "cfs", [ "artillery", "Artie" ] ]
#32 Mr. Spell. Zu r = MOOList [ "", "", [ "Zurich", "zucchini" ] ]
#32 Mr. Spell. extoll r = MOOList [ "", "e", [ "extolling" ] ]
#32 Mr. Spell. metha r = MOOList [ "", "n", [ "methacrylate" ] ]
#32 Mr. Spell. larg r = MOOList [ "e", "s", [ "larger", "largemouth", "large" ] ]
#32 Mr. Spell. baseba r = MOOList [ "", "", [ "baseband", "baseball" ] ]
#32 Mr. Spell. spectra r = MOOList [ "", "", [ "spectral", "spectra" ] ]
#32 Mr. Spell. Frederick r = MOOList [ "", "", [ "Fredericksburg", "Frederick" ] ]
#32 Mr. Spell. centu r = MOOList [ "", "", [ "century", "centum" ] ]
#32 Mr. Spell. permu r = MOOList [ "t", "", [ "permute", "permutation" ] ]
#32 Mr. Spell. Luxe r = MOOList [ "", "", [ "Luxembourg", "luxe" ] ]
#32 Mr. Spell. proven r = MOOList [ "", "", [ "provenance", "proven" ] ]
#32 Mr. Spell. honey r = MOOList [ "", "", [ "Honeywell", "honeysuckle", "honeymoon", "honeydew", "honeycomb", "honeybee", "honey" ] ]
#32 Mr. Spell. Hila r = MOOList [ "ri", "", [ "hilarity", "hilarious" ] ]
#32 Mr. Spell. arse r = MOOList [ "n", "ai", [ ] ]
#32 Mr. Spell. gibbe r = MOOList [ "", "", [ "gibbet", "gibberish" ] ]
#32 Mr. Spell. assail r = MOOList [ "", "", [ "assailant", "assail" ] ]
#32 Mr. Spell. posses r = MOOList [ "s", "i", [ "possessor", "possess" ] ]
#32 Mr. Spell. prover r = MOOList [ "b", "", [ "proverbial", "proverb" ] ]
#32 Mr. Spell. centr r = MOOList [ "", "ie", [ "centroid", "central" ] ]
#32 Mr. Spell. spectro r = MOOList [ "", "gs", [ "spectrophotometer", "spectrometer" ] ]
#32 Mr. Spell. Adria r = MOOList [ "", "", [ "Adriatic", "Adrian" ] ]
#32 Mr. Spell. gibbo r = MOOList [ "", "", [ "gibbous", "gibbon" ] ]
#32 Mr. Spell. Jorg r = MOOList [ "e", "n", [ "Jorge" ] ]
#32 Mr. Spell. centi r = MOOList [ "", "", [ "centipede", "centigrade" ] ]
#32 Mr. Spell. hones r = MOOList [ "t", "", [ "honesty", "honest" ] ]
#32 Mr. Spell. possem r = MOOList [ "", "", [ "possemen", "posseman" ] ]
#32 Mr. Spell. cente r = MOOList [ "", "nr", [ ] ]
#32 Mr. Spell. perme r = MOOList [ "a", "", [ "permeate", "permeable" ] ]
#32 Mr. Spell. saddl r = MOOList [ "e", "", [ "saddlebag", "saddle" ] ]
#32 Mr. Spell. Kara r = MOOList [ "", "", [ "karate", "Karamazov", "Karachi" ] ]
#32 Mr. Spell. perma r = MOOList [ "", "", [ "permanent", "permalloy" ] ]
#32 Mr. Spell. meteo r = MOOList [ "r", "i", [ "meteorology", "meteor" ] ]
#32 Mr. Spell. permi r = MOOList [ "", "st", [ "Permian" ] ]
#32 Mr. Spell. arra r = MOOList [ "", "n", [ "array", "arraign", "Arragon", "arrack" ] ]
#32 Mr. Spell. machin r = MOOList [ "", "e", [ "machination" ] ]
#32 Mr. Spell. censu r = MOOList [ "", "", [ "census", "censure" ] ]
#32 Mr. Spell. arre r = MOOList [ "", "", [ "arrest", "arrear" ] ]
#32 Mr. Spell. censo r = MOOList [ "r", "", [ "censorial", "censor" ] ]
#32 Mr. Spell. narra r = MOOList [ "", "", [ "narrate", "Narragansett" ] ]
#32 Mr. Spell. arri r = MOOList [ "v", "", [ "arrive", "arrival" ] ]
#32 Mr. Spell. mutt r = MOOList [ "", "", [ "mutton", "mutter", "mutt" ] ]
#32 Mr. Spell. arro r = MOOList [ "", "gw", [ "arroyo" ] ]
#32 Mr. Spell. mutu r = MOOList [ "", "", [ "mutuel", "mutual" ] ]
#32 Mr. Spell. lape r = MOOList [ "l", "", [ "lapelled", "lapel" ] ]
#32 Mr. Spell. butt r = MOOList [ "", "eor", [ "butt" ] ]
#32 Mr. Spell. muta r = MOOList [ "", "nt", [ "mutagen" ] ]
#32 Mr. Spell. Camera r = MOOList [ "", "m", [ "camera" ] ]
#32 Mr. Spell. buty r = MOOList [ "", "r", [ "butyl" ] ]
#32 Mr. Spell. want r = MOOList [ "", "", [ "wanton", "wants", "wanting", "wanted", "want" ] ]
#32 Mr. Spell. laryng r = MOOList [ "e", "", [ "larynges", "laryngeal" ] ]
#32 Mr. Spell. muti r = MOOList [ "", "n", [ "mutilate" ] ]
#32 Mr. Spell. tigh r = MOOList [ "t", "", [ "tighten", "tight" ] ]
#32 Mr. Spell. buta r = MOOList [ "", "", [ "butane", "butadiene" ] ]
#32 Mr. Spell. swel r = MOOList [ "", "t", [ "swell" ] ]
#32 Mr. Spell. assoc r = MOOList [ "ia", "t", [ "associable" ] ]
#32 Mr. Spell. butc r = MOOList [ "h", "", [ "butchery", "butch" ] ]
#32 Mr. Spell. Camero r = MOOList [ "", "", [ "Cameroun", "Cameron" ] ]
#32 Mr. Spell. bute r = MOOList [ "", "", [ "buteo", "butene" ] ]
#32 Mr. Spell. musl r = MOOList [ "i", "", [ "muslin", "muslim" ] ]
#32 Mr. Spell. volu r = MOOList [ "", "mn", [ "voluptuous", "voluble" ] ]
#32 Mr. Spell. Nicho r = MOOList [ "l", "s", [ "Nicholls", "Nicholas" ] ]
#32 Mr. Spell. wang r = MOOList [ "", "", [ "wangle", "Wang" ] ]
#32 Mr. Spell. wand r = MOOList [ "", "", [ "wander", "wand" ] ]
#32 Mr. Spell. swee r = MOOList [ "", "pt", [ "Sweeney" ] ]
#32 Mr. Spell. circumsc r = MOOList [ "ri", "", [ "circumscription", "circumscribe" ] ]
#32 Mr. Spell. slugg r = MOOList [ "i", "", [ "sluggish", "slugging" ] ]
#32 Mr. Spell. must r = MOOList [ "", "a", [ "musty", "mustn't", "must" ] ]
#32 Mr. Spell. wron r = MOOList [ "", "g", [ "Wronskian" ] ]
#32 Mr. Spell. voll r = MOOList [ "ey", "", [ "volleyball", "volley" ] ]
#32 Mr. Spell. rab r = MOOList [ "", "bi", [ "rabat" ] ]
#32 Mr. Spell. rac r = MOOList [ "", "ehk", [ "racy", "racial", "raccoon" ] ]
#32 Mr. Spell. bust r = MOOList [ "", "", [ "bustle", "bustard", "bust" ] ]
#32 Mr. Spell. lank r = MOOList [ "", "", [ "lanky", "Lanka" ] ]
#32 Mr. Spell. rag r = MOOList [ "", "", [ "ragweed", "ragout", "ragging", "rage", "rag" ] ]
#32 Mr. Spell. musi r = MOOList [ "c", "", [ "musicology", "musician", "musicale", "music" ] ]
#32 Mr. Spell. volc r = MOOList [ "an", "i", [ "volcano" ] ]
#32 Mr. Spell. rai r = MOOList [ "", "lns", [ "raid" ] ]
#32 Mr. Spell. raj r = MOOList [ "", "", [ "rajah", "raj" ] ]
#32 Mr. Spell. mush r = MOOList [ "", "", [ "mushy", "mushroom", "mush" ] ]
#32 Mr. Spell. damas r = MOOList [ "", "", [ "damask", "Damascus" ] ]
#32 Mr. Spell. rak r = MOOList [ "", "", [ "rakish", "rake" ] ]
#32 Mr. Spell. muse r = MOOList [ "", "", [ "museum", "muse" ] ]
#32 Mr. Spell. ral r = MOOList [ "", "", [ "Ralston", "Ralph", "rally", "Raleigh" ] ]
#32 Mr. Spell. musc r = MOOList [ "", "ou", [ "muscle", "Muscat" ] ]
#32 Mr. Spell. lant r = MOOList [ "", "h", [ "lantern" ] ]
#32 Mr. Spell. diminu r = MOOList [ "ti", "", [ "diminutive", "diminution" ] ]
#32 Mr. Spell. circumsp r = MOOList [ "", "", [ "circumsphere", "circumspect" ] ]
#32 Mr. Spell. ran r = MOOList [ "", "cdgks", [ "rant", "Ranier", "ran" ] ]
#32 Mr. Spell. circumst r = MOOList [ "an", "c", [ "circumstantial" ] ]
#32 Mr. Spell. backwar r = MOOList [ "d", "", [ "backwards", "backward" ] ]
#32 Mr. Spell. murk r = MOOList [ "", "", [ "murky", "murk" ] ]
#32 Mr. Spell. busi r = MOOList [ "ness", "m", [ "businesses", "business" ] ]
#32 Mr. Spell. bush r = MOOList [ "", "", [ "bushy", "bushwhack", "Bushnell", "bushmaster", "bushel", "bush" ] ]
#32 Mr. Spell. abstra r = MOOList [ "ct", "", [ "abstractor", "abstract" ] ]
#32 Mr. Spell. Voltai r = MOOList [ "", "", [ "Voltaire", "voltaic" ] ]
#32 Mr. Spell. murr r = MOOList [ "", "", [ "murre", "Murray" ] ]
#32 Mr. Spell. land r = MOOList [ "", "s", [ "landowner", "landmark", "landlord", "Landis", "landhold", "landfill", "landau", "land" ] ]
#32 Mr. Spell. revisa r = MOOList [ "", "", [ "revisal", "revisable" ] ]
#32 Mr. Spell. West r = MOOList [ "", "e", [ "westward", "Weston", "Westminster", "Westinghouse", "Westfield", "Westchester", "westbound", "west" ] ]
#32 Mr. Spell. profit r = MOOList [ "", "", [ "profits", "profit" ] ]
#32 Mr. Spell. merl r = MOOList [ "", "", [ "merlin", "Merle" ] ]
#32 Mr. Spell. Erat r = MOOList [ "o", "", [ "Eratosthenes", "Erato" ] ]
#32 Mr. Spell. bese r = MOOList [ "", "t", [ "beseech" ] ]
#32 Mr. Spell. besi r = MOOList [ "", "", [ "besiege", "beside" ] ]
#32 Mr. Spell. revisi r = MOOList [ "on", "", [ "revisionary", "revision" ] ]
#32 Mr. Spell. Wesl r = MOOList [ "ey", "", [ "Wesleyan", "Wesley" ] ]
#32 Mr. Spell. Prac r = MOOList [ "ti", "c", [ "practitioner", "practise" ] ]
#32 Mr. Spell. - r = MOOList [ "", "", [ "--", "-" ] ]
#32 Mr. Spell. rap r = MOOList [ "", "ipt", [ "Raphael", "rape", "rapacious", "rap" ] ]
#32 Mr. Spell. rubi r = MOOList [ "", "", [ "Rubin", "rubidium", "rubicund" ] ]
#32 Mr. Spell. berr r = MOOList [ "", "", [ "berry", "Berra" ] ]
#32 Mr. Spell. rar r = MOOList [ "", "e", [ "Raritan" ] ]
#32 Mr. Spell. irons r = MOOList [ "", "", [ "ironstone", "ironside" ] ]
#32 Mr. Spell. chur r = MOOList [ "", "c", [ "churn" ] ]
#32 Mr. Spell. ras r = MOOList [ "", "pt", [ "Rasmussen", "rash", "rascal", "rasa" ] ]
#32 Mr. Spell. bert r = MOOList [ "", "hr", [ "Bertie", "Bert" ] ]
#32 Mr. Spell. abor r = MOOList [ "", "i", [ "abort", "aborning" ] ]
#32 Mr. Spell. rat r = MOOList [ "", "eit", [ "rather", "rata", "rat" ] ]
#32 Mr. Spell. chut r = MOOList [ "", "", [ "chutney", "chute" ] ]
#32 Mr. Spell. rav r = MOOList [ "", "ei", [ "ravage" ] ]
#32 Mr. Spell. abou r = MOOList [ "", "", [ "about", "abound" ] ]
#32 Mr. Spell. raw r = MOOList [ "", "", [ "Rawlinson", "rawhide", "rawboned", "raw" ] ]
#32 Mr. Spell. abov r = MOOList [ "e", "", [ "abovementioned", "aboveground", "aboveboard", "above" ] ]
#32 Mr. Spell. meri r = MOOList [ "", "dt", [ "meringue" ] ]
#32 Mr. Spell. rubb r = MOOList [ "", "", [ "rubble", "rubbish", "rubbery" ] ]
#32 Mr. Spell. raz r = MOOList [ "", "o", [ "raze" ] ]
#32 Mr. Spell. merg r = MOOList [ "", "", [ "merge", "merganser" ] ]
#32 Mr. Spell. bery r = MOOList [ "l", "", [ "beryllium", "beryl" ] ]
#32 Mr. Spell. merc r = MOOList [ "", "aehu", [ "mercy", "Merck", "merciful" ] ]
#32 Mr. Spell. intel r = MOOList [ "l", "ei", [ ] ]
#32 Mr. Spell. summi r = MOOList [ "t", "", [ "summitry", "summit" ] ]
#32 Mr. Spell. intem r = MOOList [ "pera", "", [ "intemperate", "intemperance" ] ]
#32 Mr. Spell. A r = MOOList [ "", "AbcdefghijklMn&pqrstuvwxyz", [ "a's", "aorta", "a" ] ]
#32 Mr. Spell. chuc r = MOOList [ "k", "", [ "chuckwalla", "chuckle", "chuck" ] ]
#32 Mr. Spell. chub r = MOOList [ "", "", [ "chubby", "chub" ] ]
#32 Mr. Spell. summe r = MOOList [ "r", "", [ "summertime", "Summers", "summer" ] ]
#32 Mr. Spell. bombas r = MOOList [ "t", "", [ "bombastic", "bombast" ] ]
#32 Mr. Spell. roads r = MOOList [ "", "", [ "roadster", "roadside" ] ]
#32 Mr. Spell. McGra r = MOOList [ "", "", [ "McGraw", "McGrath" ] ]
#32 Mr. Spell. F r = MOOList [ "", "aeilMorTu", [ "fjord", "f's", "FPC", "FDA", "FCC", "FBI", "f" ] ]
#32 Mr. Spell. chug r = MOOList [ "", "", [ "chugging", "chug" ] ]
#32 Mr. Spell. integ r = MOOList [ "", "r", [ "integument", "integer" ] ]
#32 Mr. Spell. G r = MOOList [ "", "aehilMnoruwy", [ "GSA", "g's", "GPO", "g" ] ]
#32 Mr. Spell. Brenn r = MOOList [ "", "", [ "Brenner", "Brennan" ] ]
#32 Mr. Spell. I r = MOOList [ "", "abCdfgil'mnoprstv", [ "Izvestia", "ix", "IQ", "Ike", "IEEE", "i" ] ]
#32 Mr. Spell. berg r = MOOList [ "", "ls", [ "Bergman", "Bergen", "bergamot", "berg" ] ]
#32 Mr. Spell. pontifi r = MOOList [ "c", "", [ "pontificate", "pontific" ] ]
#32 Mr. Spell. inter r = MOOList [ "", "cfimnprsve", [ "interlude", "interject", "interdict", "inter" ] ]
#32 Mr. Spell. handym r = MOOList [ "", "", [ "handymen", "handyman" ] ]
#32 Mr. Spell. K r = MOOList [ "", "aehilnoruy", [ "kwashiorkor", "KS", "k's", "k" ] ]
#32 Mr. Spell. intes r = MOOList [ "t", "", [ "intestine", "intestate" ] ]
#32 Mr. Spell. flori r = MOOList [ "", "d", [ "florist", "florin", "florican" ] ]
#32 Mr. Spell. beri r = MOOList [ "b", "", [ "beriberi", "beribbon" ] ]
#32 Mr. Spell. chum r = MOOList [ "", "", [ "chump", "chummy", "chum" ] ]
#32 Mr. Spell. Were r = MOOList [ "", "", [ "weren't", "were" ] ]
#32 Mr. Spell. berk r = MOOList [ "", "e", [ "Berkshire", "Berkowitz" ] ]
#32 Mr. Spell. N r = MOOList [ "", "aBCdeiNOuY", [ "NW", "NV", "NTIS", "NSF", "n's", "NRC", "NM", "NJ", "NH", "Nguyen", "n" ] ]
#32 Mr. Spell. inten r = MOOList [ "", "dst", [ ] ]
#32 Mr. Spell. abol r = MOOList [ "i", "", [ "abolition", "abolish" ] ]
#32 Mr. Spell. chun r = MOOList [ "", "k", [ "Chungking" ] ]
#32 Mr. Spell. abom r = MOOList [ "ina", "", [ "abominate", "abominable" ] ]
#32 Mr. Spell. abA r = MOOList [ "", "cs", [ "abate", "abandon", "abalone", "Ababa", "ABA" ] ]
#32 Mr. Spell. Q r = MOOList [ "", "u", [ "q's", "QED", "Qatar", "q" ] ]
#32 Mr. Spell. holoc r = MOOList [ "", "", [ "Holocene", "holocaust" ] ]
#32 Mr. Spell. aspa r = MOOList [ "r", "a", [ "aspartic" ] ]
#32 Mr. Spell. T r = MOOList [ "", "aehiNoruysTVW", [ "TX", "t's", "t" ] ]
#32 Mr. Spell. holog r = MOOList [ "ra", "", [ "holography", "hologram" ] ]
#32 Mr. Spell. roadb r = MOOList [ "", "", [ "roadblock", "roadbed" ] ]
#32 Mr. Spell. aspe r = MOOList [ "", "r", [ "aspen", "aspect" ] ]
#32 Mr. Spell. X r = MOOList [ "", "ey", [ "x's", "xi", "Xavier", "x" ] ]
#32 Mr. Spell. Brend r = MOOList [ "a", "", [ "Brendan", "Brenda" ] ]
#32 Mr. Spell. asph r = MOOList [ "", "", [ "asphyxiate", "aspheric", "asphalt" ] ]
#32 Mr. Spell. aspi r = MOOList [ "", "r", [ "aspidistra" ] ]
#32 Mr. Spell. Wert r = MOOList [ "", "", [ "Werther", "wert" ] ]
#32 Mr. Spell. Lest r = MOOList [ "", "", [ "Lester", "lest" ] ]
#32 Mr. Spell. b r = MOOList [ "", "aehiloruy", [ "BTL", "BSTJ", "b's", "BP", "BMW", "b" ] ]
#32 Mr. Spell. ac r = MOOList [ "", "acehikmoqrtu", [ "acyclic", "AC" ] ]
#32 Mr. Spell. abs r = MOOList [ "", "ceot", [ "absurd", "absinthe" ] ]
#32 Mr. Spell. c r = MOOList [ "", "aehilOpruyz", [ "CT", "csnet", "c's", "cf", "CDC", "CBS", "c" ] ]
#32 Mr. Spell. d r = MOOList [ "", "ae'hinoruwy", [ "Djakarta", "DC", "d" ] ]
#32 Mr. Spell. crawl r = MOOList [ "", "", [ "crawlspace", "crawl" ] ]
#32 Mr. Spell. ae r = MOOList [ "", "gnors", [ ] ]
#32 Mr. Spell. abu r = MOOList [ "", "st", [ "abundant", "abuilding" ] ]
#32 Mr. Spell. e r = MOOList [ "", "abcdefghijklmnopqr'stuvxyz", [ "ewe", "e" ] ]
#32 Mr. Spell. af r = MOOList [ "", "fgilort", [ "afar" ] ]
#32 Mr. Spell. ag r = MOOList [ "", "aeginor", [ "Agway", "ague", "agleam", "aghast" ] ]
#32 Mr. Spell. ah r = MOOList [ "", "e", [ "ahoy", "Ahmedabad", "ah" ] ]
#32 Mr. Spell. h r = MOOList [ "", "aeiouy", [ "h's", "Hrothgar", "h" ] ]
#32 Mr. Spell. guan r = MOOList [ "", "i", [ "guano" ] ]
#32 Mr. Spell. aby r = MOOList [ "s", "s", [ "abysmal" ] ]
#32 Mr. Spell. diffusi r = MOOList [ "", "", [ "diffusive", "diffusion", "diffusible" ] ]
#32 Mr. Spell. j r = MOOList [ "", "aeiou", [ "j's", "Jr", "j" ] ]
#32 Mr. Spell. al r = MOOList [ "", "abcdefgiklmopstuvw", [ "alyssum", "already", "Alhambra", "AL" ] ]
#32 Mr. Spell. l r = MOOList [ "", "aeio'uy", [ "LCD", "LTV", "LSI", "Lloyd", "l" ] ]
#32 Mr. Spell. guar r = MOOList [ "", "ad", [ ] ]
#32 Mr. Spell. circumfe r = MOOList [ "ren", "", [ "circumferential", "circumference" ] ]
#32 Mr. Spell. m r = MOOList [ "", "abceinoruys", [ "Mt", "m's", "MPH", "MD", "m" ] ]
#32 Mr. Spell. an r = MOOList [ "", "acdeghiknostxy", [ "anvil", "anus", "an" ] ]
#32 Mr. Spell. o r = MOOList [ "", "abc'defghiklmnoprstuvwxz", [ "oyster", "o" ] ]
#32 Mr. Spell. ap r = MOOList [ "", "aehioprt", [ "apse", "aplomb" ] ]
#32 Mr. Spell. aca r = MOOList [ "", "d", [ "Acapulco", "acanthus" ] ]
#32 Mr. Spell. three r = MOOList [ "", "", [ "threesome", "threefold", "three" ] ]
#32 Mr. Spell. p r = MOOList [ "", "aefhilnorstuy", [ "pc", "PVC", "p's", "ppm", "PM", "PDP", "PBS", "p" ] ]
#32 Mr. Spell. Dayto r = MOOList [ "n", "", [ "Daytona", "Dayton" ] ]
#32 Mr. Spell. courte r = MOOList [ "", "s", [ "courteous" ] ]
#32 Mr. Spell. attri r = MOOList [ "", "b", [ "attrition" ] ]
#32 Mr. Spell. aq r = MOOList [ "u", "aei", [ ] ]
#32 Mr. Spell. Libret r = MOOList [ "t", "", [ "libretto", "librettist" ] ]
#32 Mr. Spell. defla r = MOOList [ "te", "", [ "deflater", "deflate" ] ]
#32 Mr. Spell. abb r = MOOList [ "", "eor", [ "abbas" ] ]
#32 Mr. Spell. r r = MOOList [ "", "aehiouy", [ "Rwanda", "RSVP", "r's", "RPM", "RNA", "R&D", "Rd", "RCA", "r" ] ]
#32 Mr. Spell. as r = MOOList [ "", "chikpstuy", [ "asocial", "asleep", "aseptic", "asbestos", "as" ] ]
#32 Mr. Spell. s r = MOOList [ "", "acehIklmnopqStuwy", [ "Szilard", "svelte", "s's", "Sri", "sforzando", "SD", "s" ] ]
#32 Mr. Spell. Pam r = MOOList [ "", "p", [ "Pamela", "Pam" ] ]
#32 Mr. Spell. abd r = MOOList [ "", "o", [ "abduct", "abdicate" ] ]
#32 Mr. Spell. threa r = MOOList [ "", "dt", [ ] ]
#32 Mr. Spell. pompo r = MOOList [ "", "", [ "pompous", "pomposity", "pompon" ] ]
#32 Mr. Spell. freshm r = MOOList [ "", "", [ "freshmen", "freshman" ] ]
#32 Mr. Spell. abe r = MOOList [ "", "lrty", [ "abed", "Abe" ] ]
#32 Mr. Spell. u r = MOOList [ "", "npsbgklmr.t", [ "u's", "UHF", "UCLA", "u" ] ]
#32 Mr. Spell. Pak r = MOOList [ "istan", "", [ "Pakistani", "Pakistan" ] ]
#32 Mr. Spell. defle r = MOOList [ "ct", "", [ "deflector", "deflect" ] ]
#32 Mr. Spell. av r = MOOList [ "", "aeio", [ ] ]
#32 Mr. Spell. v r = MOOList [ "", "aioelu", [ "vying", "VT", "v's", "Vreeland", "VHF", "v" ] ]
#32 Mr. Spell. aw r = MOOList [ "", "ae", [ "awry", "awoke", "awn", "awl", "awkward", "awhile", "awful" ] ]
#32 Mr. Spell. w r = MOOList [ "", "aehioruy", [ "WV", "w's", "w" ] ]
#32 Mr. Spell. ax r = MOOList [ "", "io", [ "axle", "axe", "ax" ] ]
#32 Mr. Spell. abh r = MOOList [ "orre", "", [ "abhorrent", "abhorred" ] ]
#32 Mr. Spell. y r = MOOList [ "", "eoaituv", [ "YWCA", "y's", "Ypsilanti", "YMCA", "y" ] ]
#32 Mr. Spell. z r = MOOList [ "", "iouae", [ "zygote", "z's", "zloty", "z" ] ]
#32 Mr. Spell. pompe r = MOOList [ "", "", [ "pompey", "Pompeii" ] ]
#32 Mr. Spell. abl r = MOOList [ "", "a", [ "ablution", "able" ] ]
#32 Mr. Spell. adven r = MOOList [ "t", "u", [ "adventitious", "advent" ] ]
#32 Mr. Spell. abn r = MOOList [ "", "", [ "abnormal", "Abner" ] ]
#32 Mr. Spell. Pab r = MOOList [ "", "", [ "Pabst", "Pablo" ] ]
#32 Mr. Spell. abo r = MOOList [ "", "lmruv", [ "abode", "aboard", "Abo" ] ]
#32 Mr. Spell. ba r = MOOList [ "", "bcdfghiklmnprstuwy", [ "bazaar", "Baxter", "Bavaria" ] ]
#32 Mr. Spell. rec r = MOOList [ "", "eiklortu", [ "recycle", "recherche", "recalcitrant" ] ]
#32 Mr. Spell. acr r = MOOList [ "", "eoy", [ "acrid" ] ]
#32 Mr. Spell. red r = MOOList [ "", "abdesur", [ "redwood", "redtop", "redpoll", "redound", "redneck", "Redmond", "redhead", "redcoat", "red" ] ]
#32 Mr. Spell. ree r = MOOList [ "", "dv", [ "Reese", "reel", "reek", "reef" ] ]
#32 Mr. Spell. ref r = MOOList [ "", "elru", [ "reformatory" ] ]
#32 Mr. Spell. irrepro r = MOOList [ "", "", [ "irreproducible", "irreproachable" ] ]
#32 Mr. Spell. handwr r = MOOList [ "it", "", [ "handwritten", "handwrite" ] ]
#32 Mr. Spell. d' r = MOOList [ "", "", [ "d's", "d'oeuvre", "d'etat", "d'art" ] ]
#32 Mr. Spell. be r = MOOList [ "", "acdefghilmnoqrstvwy", [ "bezel", "beplaster", "bebop", "be" ] ]
#32 Mr. Spell. acu r = MOOList [ "", "", [ "acute", "acumen", "acuity" ] ]
#32 Mr. Spell. suntann r = MOOList [ "", "", [ "suntanning", "suntanned" ] ]
#32 Mr. Spell. reg r = MOOList [ "", "airu", [ "regent" ] ]
#32 Mr. Spell. reh r = MOOList [ "", "e", [ "rehabilitate" ] ]
#32 Mr. Spell. pompa r = MOOList [ "", "", [ "pompano", "pompadour" ] ]
#32 Mr. Spell. rej r = MOOList [ "", "o", [ "reject" ] ]
#32 Mr. Spell. Quak r = MOOList [ "e", "", [ "Quakeress", "quake" ] ]
#32 Mr. Spell. bi r = MOOList [ "", "abcdefgjlmnoprstvz", [ "bikini", "biharmonic" ] ]
#32 Mr. Spell. rel r = MOOList [ "", "aei", [ "reluctant" ] ]
#32 Mr. Spell. dispell r = MOOList [ "", "", [ "dispelling", "dispelled" ] ]
#32 Mr. Spell. rem r = MOOList [ "", "aeiou", [ "remnant", "Rembrandt" ] ]
#32 Mr. Spell. bl r = MOOList [ "", "aeiou", [ "Blythe", "Blvd" ] ]
#32 Mr. Spell. ren r = MOOList [ "", "adeot", [ "renunciate", "Rensselaer" ] ]
#32 Mr. Spell. Pau r = MOOList [ "", "ln", [ "pause", "pauper", "paucity" ] ]
#32 Mr. Spell. postma r = MOOList [ "", "", [ "postmaster", "postmark", "postman" ] ]
#32 Mr. Spell. Pat r = MOOList [ "", "cehirt", [ "Patsy", "Patagonia", "pat" ] ]
#32 Mr. Spell. rep r = MOOList [ "", "aelortu", [ "rep" ] ]
#32 Mr. Spell. Pas r = MOOList [ "", "cst", [ "Paso", "pasha", "Pasadena" ] ]
#32 Mr. Spell. Lucre r = MOOList [ "", "t", [ "lucre" ] ]
#32 Mr. Spell. bo r = MOOList [ "", "abcdeghilmnorstuwxy", [ "bovine", "bop" ] ]
#32 Mr. Spell. req r = MOOList [ "u", "i", [ "request" ] ]
#32 Mr. Spell. browni r = MOOList [ "", "", [ "brownish", "brownie", "Brownian" ] ]
#32 Mr. Spell. ada r = MOOList [ "", "gmp", [ "Adair", "Ada" ] ]
#32 Mr. Spell. br r = MOOList [ "", "aeiouy", [ ] ]
#32 Mr. Spell. incen r = MOOList [ "", "", [ "incentive", "incense", "incendiary" ] ]
#32 Mr. Spell. acc r = MOOList [ "", "eiloru", [ ] ]
#32 Mr. Spell. chro r = MOOList [ "", "mn", [ ] ]
#32 Mr. Spell. bu r = MOOList [ "", "bcdefgilmnorstxzy", [ "Bujumbura" ] ]
#32 Mr. Spell. ace r = MOOList [ "", "rt", [ "ace" ] ]
#32 Mr. Spell. ach r = MOOList [ "", "i", [ "achromatic", "ache" ] ]
#32 Mr. Spell. by r = MOOList [ "", "lprwz", [ "byte", "bystander", "bygone", "bye", "by" ] ]
#32 Mr. Spell. aci r = MOOList [ "d", "", [ "acidulous", "acidic", "acid" ] ]
#32 Mr. Spell. Cante r = MOOList [ "", "r", [ "canteen" ] ]
#32 Mr. Spell. inces r = MOOList [ "", "t", [ "incessant" ] ]
#32 Mr. Spell. acm r = MOOList [ "", "", [ "acme", "ACM" ] ]
#32 Mr. Spell. aco r = MOOList [ "", "", [ "acoustic", "acorn", "acolyte" ] ]
#32 Mr. Spell. rea r = MOOList [ "", "cdls", [ "reave", "rear", "reap", "ream", "Reagan" ] ]
#32 Mr. Spell. Northr r = MOOList [ "", "", [ "Northrup", "Northrop" ] ]
#32 Mr. Spell. ca r = MOOList [ "", "bcdfghilmnprstuvy", [ "caw", "cake", "cajole", "Caesar", "CA" ] ]
#32 Mr. Spell. incep r = MOOList [ "t", "", [ "inceptor", "inception" ] ]
#32 Mr. Spell. acq r = MOOList [ "u", "ai", [ ] ]
#32 Mr. Spell. ads r = MOOList [ "or", "bp", [ ] ]
#32 Mr. Spell. plugg r = MOOList [ "", "", [ "plugging", "pluggable" ] ]
#32 Mr. Spell. e' r = MOOList [ "", "", [ "e's", "e'er" ] ]
#32 Mr. Spell. adu r = MOOList [ "l", "t", [ "adulate" ] ]
#32 Mr. Spell. adv r = MOOList [ "", "aeio", [ ] ]
#32 Mr. Spell. meni r = MOOList [ "", "", [ "meniscus", "meningitis", "menial" ] ]
#32 Mr. Spell. ci r = MOOList [ "", "cglnrtv", [ "cistern", "cipher", "cider", "CIA" ] ]
#32 Mr. Spell. abla r = MOOList [ "", "", [ "ablaze", "ablate" ] ]
#32 Mr. Spell. postpo r = MOOList [ "", "", [ "postposition", "postpone" ] ]
#32 Mr. Spell. preve r = MOOList [ "nti", "", [ "preventive", "prevention" ] ]
#32 Mr. Spell. ment r = MOOList [ "", "i", [ "mentor", "mental" ] ]
#32 Mr. Spell. cl r = MOOList [ "", "aeiouy", [ ] ]
#32 Mr. Spell. butter r = MOOList [ "", "f", [ "buttery", "butternut", "buttermilk", "buttercup", "butterball" ] ]
#32 Mr. Spell. mens r = MOOList [ "", "u", [ "menstruate" ] ]
#32 Mr. Spell. exhau r = MOOList [ "st", "i", [ "exhaust" ] ]
#32 Mr. Spell. cp r = MOOList [ "", "", [ "cpu", "CPA" ] ]
#32 Mr. Spell. chri r = MOOList [ "s", "t", [ "Chris" ] ]
#32 Mr. Spell. cheat r = MOOList [ "", "", [ "cheater", "cheat" ] ]
#32 Mr. Spell. cr r = MOOList [ "", "aeiouy", [ "CRT" ] ]
#32 Mr. Spell. res r = MOOList [ "", "ceioptu", [ ] ]
#32 Mr. Spell. ret r = MOOList [ "", "aeiru", [ "retort", "retch", "ret" ] ]
#32 Mr. Spell. add r = MOOList [ "", "eir", [ "adduce", "addle", "add" ] ]
#32 Mr. Spell. rev r = MOOList [ "", "eiov", [ "revulsion", "rev" ] ]
#32 Mr. Spell. preva r = MOOList [ "", "", [ "prevalent", "prevail" ] ]
#32 Mr. Spell. adh r = MOOList [ "e", "rs", [ ] ]
#32 Mr. Spell. cy r = MOOList [ "", "aclnprst", [ "Cygnus", "cybernetic" ] ]
#32 Mr. Spell. adi r = MOOList [ "", "", [ "Adirondack", "adipic", "adieu", "adiabatic" ] ]
#32 Mr. Spell. cz r = MOOList [ "", "ae", [ "CZ" ] ]
#32 Mr. Spell. adj r = MOOList [ "", "eou", [ "adjacent" ] ]
#32 Mr. Spell. mend r = MOOList [ "", "ae", [ "mend" ] ]
#32 Mr. Spell. adm r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. ado r = MOOList [ "", "lpr", [ "Adonis", "adobe", "ado" ] ]
#32 Mr. Spell. mena r = MOOList [ "", "", [ "menarche", "menagerie", "menace" ] ]
#32 Mr. Spell. da r = MOOList [ "", "bcdfhiklmnprstuvwyz", [ "dagger", "Daedalus" ] ]
#32 Mr. Spell. merid r = MOOList [ "i", "", [ "meridional", "meridian" ] ]
#32 Mr. Spell. defra r = MOOList [ "", "", [ "defray", "defraud" ] ]
#32 Mr. Spell. adr r = MOOList [ "", "ei", [ "adroit" ] ]
#32 Mr. Spell. de r = MOOList [ "", "abcdefghijlmnoprstuvwx", [ "dey", "De" ] ]
#32 Mr. Spell. adver r = MOOList [ "", "bst", [ ] ]
#32 Mr. Spell. thres r = MOOList [ "h", "", [ "threshold", "thresh" ] ]
#32 Mr. Spell. consulta r = MOOList [ "", "t", [ "consultant" ] ]
#32 Mr. Spell. dh r = MOOList [ "a", "", [ "dharma", "Dhabi" ] ]
#32 Mr. Spell. di r = MOOList [ "", "acdefglmnoprstvx", [ "dizzy", "diurnal", "dihedral", "dibble" ] ]
#32 Mr. Spell. Wend r = MOOList [ "", "", [ "Wendy", "Wendell" ] ]
#32 Mr. Spell. accoun r = MOOList [ "t", "", [ "accounts", "accountant", "account" ] ]
#32 Mr. Spell. benc r = MOOList [ "h", "", [ "benchmark", "bench" ] ]
#32 Mr. Spell. memo r = MOOList [ "", "r", [ "memoir", "memo" ] ]
#32 Mr. Spell. contributo r = MOOList [ "r", "", [ "contributory", "contributor" ] ]
#32 Mr. Spell. dr r = MOOList [ "", "aeiouy", [ "Dr" ] ]
#32 Mr. Spell. merit r = MOOList [ "", "", [ "meritorious", "merit" ] ]
#32 Mr. Spell. beni r = MOOList [ "g", "", [ "benign", "benight" ] ]
#32 Mr. Spell. du r = MOOList [ "", "abcdefglmnoprst", [ "Duquesne", "duke", "du" ] ]
#32 Mr. Spell. vacuol r = MOOList [ "", "", [ "vacuole", "vacuolate" ] ]
#32 Mr. Spell. dw r = MOOList [ "", "aei", [ "Dwyer" ] ]
#32 Mr. Spell. dy r = MOOList [ "", "aens", [ "Dylan", "Dyke", "dying" ] ]
#32 Mr. Spell. memb r = MOOList [ "", "e", [ "membrane" ] ]
#32 Mr. Spell. flowe r = MOOList [ "r", "", [ "flowery", "flowerpot" ] ]
#32 Mr. Spell. Leop r = MOOList [ "", "", [ "Leopold", "leopard" ] ]
#32 Mr. Spell. aer r = MOOList [ "", "o", [ "aerial", "aerate" ] ]
#32 Mr. Spell. Waterl r = MOOList [ "", "", [ "Waterloo", "waterline" ] ]
#32 Mr. Spell. Leon r = MOOList [ "", "ai", [ "Leone", "Leon" ] ]
#32 Mr. Spell. aes r = MOOList [ "", "t", [ "Aeschylus" ] ]
#32 Mr. Spell. ee r = MOOList [ "", "lr", [ "EEOC" ] ]
#32 Mr. Spell. ef r = MOOList [ "", "f", [ "eft" ] ]
#32 Mr. Spell. rhi r = MOOList [ "n", "eo", [ ] ]
#32 Mr. Spell. meli r = MOOList [ "", "", [ "Melissa", "meliorate", "Melinda" ] ]
#32 Mr. Spell. defor r = MOOList [ "", "em", [ ] ]
#32 Mr. Spell. peppe r = MOOList [ "r", "", [ "peppery", "pepperoni", "peppermint", "peppergrass" ] ]
#32 Mr. Spell. ei r = MOOList [ "", "dgns", [ "either", "Eire", "Eileen" ] ]
#32 Mr. Spell. upsta r = MOOList [ "", "t", [ "upstart", "upstand", "upstair" ] ]
#32 Mr. Spell. ej r = MOOList [ "", "e", [ "ejaculate" ] ]
#32 Mr. Spell. el r = MOOList [ "", "abdeiklmosuy", [ "elves", "Elton", "Elgin", "elfin", "el" ] ]
#32 Mr. Spell. em r = MOOList [ "", "abeimopu", [ "emcee", "em" ] ]
#32 Mr. Spell. floun r = MOOList [ "", "", [ "flounder", "flounce" ] ]
#32 Mr. Spell. en r = MOOList [ "", "cdefgioqrstuvz", [ "enmity", "enlargeable", "enjoinder", "enhance", "enamel", "en" ] ]
#32 Mr. Spell. eo r = MOOList [ "", "", [ "eosine", "eohippus", "Eocene" ] ]
#32 Mr. Spell. enve r = MOOList [ "lop", "", [ "envelope", "envelop" ] ]
#32 Mr. Spell. ep r = MOOList [ "", "Ahios", [ ] ]
#32 Mr. Spell. aga r = MOOList [ "", "it", [ "agave", "Agamemnon" ] ]
#32 Mr. Spell. eq r = MOOList [ "u", "ai", [ "equestrian" ] ]
#32 Mr. Spell. melo r = MOOList [ "", "d", [ "melon" ] ]
#32 Mr. Spell. irrede r = MOOList [ "", "n", [ "irredeemable" ] ]
#32 Mr. Spell. flour r = MOOList [ "", "", [ "floury", "flourish", "flour" ] ]
#32 Mr. Spell. er r = MOOList [ "", "aeginorsu", [ "Erwin", "Ervin", "Erlenmeyer", "ERDA", "erbium" ] ]
#32 Mr. Spell. mell r = MOOList [ "o", "", [ "mellow", "Mellon" ] ]
#32 Mr. Spell. es r = MOOList [ "", "copst", [ "esquire", "Esmark", "Eskimo" ] ]
#32 Mr. Spell. envi r = MOOList [ "", "", [ "environ", "envious", "enviable" ] ]
#32 Mr. Spell. et r = MOOList [ "", "cehi", [ "etymology", "etude", "Etruscan", "eta", "et" ] ]
#32 Mr. Spell. enun r = MOOList [ "cia", "", [ "enunciate", "enunciable" ] ]
#32 Mr. Spell. chok r = MOOList [ "e", "", [ "chokeberry", "choke" ] ]
#32 Mr. Spell. ev r = MOOList [ "", "aeio", [ "evzone" ] ]
#32 Mr. Spell. beli r = MOOList [ "", "e", [ "belittle" ] ]
#32 Mr. Spell. aff r = MOOList [ "", "aeilor", [ ] ]
#32 Mr. Spell. holla r = MOOList [ "nd", "", [ "Hollandaise", "Holland" ] ]
#32 Mr. Spell. Leni r = MOOList [ "", "n", [ "lenient" ] ]
#32 Mr. Spell. ex r = MOOList [ "", "acehioptu", [ "Exxon", "exquisite" ] ]
#32 Mr. Spell. enum r = MOOList [ "era", "", [ "enumerate", "enumerable" ] ]
#32 Mr. Spell. chol r = MOOList [ "", "e", [ "cholinesterase" ] ]
#32 Mr. Spell. ey r = MOOList [ "e", "bls", [ "eyewitness", "eyepiece", "eyeglass", "eyeful", "eye" ] ]
#32 Mr. Spell. choo r = MOOList [ "s", "", [ "choosy", "choose" ] ]
#32 Mr. Spell. afi r = MOOList [ "", "", [ "afire", "afield", "aficionado" ] ]
#32 Mr. Spell. thrif r = MOOList [ "t", "", [ "thrifty", "thrift" ] ]
#32 Mr. Spell. soldi r = MOOList [ "er", "", [ "soldiery", "soldier" ] ]
#32 Mr. Spell. sancti r = MOOList [ "", "", [ "sanctity", "sanction", "sanctimonious", "sanctify" ] ]
#32 Mr. Spell. belo r = MOOList [ "", "n", [ "below", "belove", "Beloit" ] ]
#32 Mr. Spell. afl r = MOOList [ "", "", [ "afloat", "aflame" ] ]
#32 Mr. Spell. Lent r = MOOList [ "", "i", [ "Lenten", "lent" ] ]
#32 Mr. Spell. irreco r = MOOList [ "", "", [ "irrecoverable", "irreconcilable" ] ]
#32 Mr. Spell. chos r = MOOList [ "e", "", [ "chosen", "chose" ] ]
#32 Mr. Spell. press r = MOOList [ "", "", [ "pressure", "press" ] ]
#32 Mr. Spell. chor r = MOOList [ "", "ade", [ "chorus", "chortle", "chorine" ] ]
#32 Mr. Spell. afo r = MOOList [ "", "r", [ "afoot" ] ]
#32 Mr. Spell. mela r = MOOList [ "", "n", [ "melamine" ] ]
#32 Mr. Spell. Thorn r = MOOList [ "", "", [ "thorny", "Thornton", "thorn" ] ]
#32 Mr. Spell. aske r = MOOList [ "", "", [ "asked", "askew" ] ]
#32 Mr. Spell. chow r = MOOList [ "", "", [ "chowder", "chow" ] ]
#32 Mr. Spell. belv r = MOOList [ "", "", [ "belvidere", "belvedere" ] ]
#32 Mr. Spell. advis r = MOOList [ "", "eo", [ "advisable" ] ]
#32 Mr. Spell. Peg r = MOOList [ "", "g", [ "pegboard", "Pegasus", "peg" ] ]
#32 Mr. Spell. afr r = MOOList [ "", "", [ "afro", "Africa", "afresh", "afraid" ] ]
#32 Mr. Spell. prest r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. Lenn r = MOOList [ "", "", [ "Lenny", "Lennox" ] ]
#32 Mr. Spell. presu r = MOOList [ "m", "p", [ "presuming", "presume" ] ]
#32 Mr. Spell. fe r = MOOList [ "", "abdeilmnrstuv", [ "few", "fecund", "Fe" ] ]
#32 Mr. Spell. aft r = MOOList [ "", "e", [ "aft" ] ]
#32 Mr. Spell. counter r = MOOList [ "", "afmps", [ "countervail", "counterintuitive", "counterexample", "counterclockwise", "counterbalance" ] ]
#32 Mr. Spell. presi r = MOOList [ "de", "n", [ "preside" ] ]
#32 Mr. Spell. fi r = MOOList [ "", "abcdeFglnrstvxz", [ ] ]
#32 Mr. Spell. ril r = MOOList [ "", "l", [ "Riley" ] ]
#32 Mr. Spell. rim r = MOOList [ "", "", [ "rimy", "rime", "rim" ] ]
#32 Mr. Spell. fl r = MOOList [ "", "aeiouy", [ "FL" ] ]
#32 Mr. Spell. bemA r = MOOList [ "", "", [ "beman", "bemadden", "BEMA" ] ]
#32 Mr. Spell. rin r = MOOList [ "", "g", [ "rinse", "rink", "Rinehart" ] ]
#32 Mr. Spell. choc r = MOOList [ "", "", [ "Choctaw", "chocolate", "chock" ] ]
#32 Mr. Spell. rip r = MOOList [ "", "e", [ "ripple", "ripoff", "Ripley", "riparian", "rip" ] ]
#32 Mr. Spell. presc r = MOOList [ "", "r", [ "Prescott" ] ]
#32 Mr. Spell. fo r = MOOList [ "", "acgilnoprsux", [ "foyer", "fowl", "fovea", "Fomalhaut", "foe", "fodder", "fob" ] ]
#32 Mr. Spell. bela r = MOOList [ "", "", [ "belate", "Bela" ] ]
#32 Mr. Spell. Weld r = MOOList [ "", "", [ "Weldon", "weld" ] ]
#32 Mr. Spell. Avoc r = MOOList [ "", "a", [ "avocet" ] ]
#32 Mr. Spell. ris r = MOOList [ "", "ek", [ "risible" ] ]
#32 Mr. Spell. fr r = MOOList [ "", "aeiouy", [ ] ]
#32 Mr. Spell. belf r = MOOList [ "", "", [ "belfry", "Belfast" ] ]
#32 Mr. Spell. rit r = MOOList [ "", "", [ "Ritz", "ritual", "Ritter", "rite", "Ritchie" ] ]
#32 Mr. Spell. choi r = MOOList [ "", "r", [ "choice" ] ]
#32 Mr. Spell. ahe r = MOOList [ "", "", [ "ahem", "ahead" ] ]
#32 Mr. Spell. riv r = MOOList [ "", "ae", [ "rivulet", "Riviera" ] ]
#32 Mr. Spell. prese r = MOOList [ "", "n", [ "preservation" ] ]
#32 Mr. Spell. umbr r = MOOList [ "", "a", [ "umbrella" ] ]
#32 Mr. Spell. agg r = MOOList [ "", "lr", [ ] ]
#32 Mr. Spell. rhy r = MOOList [ "", "t", [ "rhyme" ] ]
#32 Mr. Spell. agi r = MOOList [ "", "", [ "agitate", "aging", "agile" ] ]
#32 Mr. Spell. entr r = MOOList [ "", "ae", [ "entry", "entropy" ] ]
#32 Mr. Spell. ento r = MOOList [ "", "", [ "entourage", "entomology" ] ]
#32 Mr. Spell. Byro r = MOOList [ "", "n", [ "byroad" ] ]
#32 Mr. Spell. incar r = MOOList [ "", "", [ "incarnate", "incarcerate" ] ]
#32 Mr. Spell. ago r = MOOList [ "", "n", [ "agouti", "ago" ] ]
#32 Mr. Spell. postpr r = MOOList [ "ocess", "", [ "postprocessor", "postprocess" ] ]
#32 Mr. Spell. holly r = MOOList [ "", "", [ "Hollywood", "hollyhock", "holly" ] ]
#32 Mr. Spell. ga r = MOOList [ "", "bdfgilmnprstuvwyz", [ "GAO", "Gaelic", "GA" ] ]
#32 Mr. Spell. rib r = MOOList [ "", "o", [ "ribbon", "ribald", "rib" ] ]
#32 Mr. Spell. incap r = MOOList [ "a", "c", [ "incapable" ] ]
#32 Mr. Spell. ric r = MOOList [ "", "hko", [ "rice", "Rica" ] ]
#32 Mr. Spell. agr r = MOOList [ "", "ei", [ "agrarian" ] ]
#32 Mr. Spell. rid r = MOOList [ "", "dgi", [ "ride", "rid" ] ]
#32 Mr. Spell. incan r = MOOList [ "", "t", [ "incandescent" ] ]
#32 Mr. Spell. ge r = MOOList [ "", "eilmnorst", [ "geyser", "Gegenschein", "gecko", "gear", "GE" ] ]
#32 Mr. Spell. rif r = MOOList [ "", "l", [ "rift", "riffle" ] ]
#32 Mr. Spell. litho r = MOOList [ "", "gs", [ "lithology" ] ]
#32 Mr. Spell. gh r = MOOList [ "", "aeo", [ ] ]
#32 Mr. Spell. gi r = MOOList [ "", "abdfglmnruv", [ "gist", "Giovanni" ] ]
#32 Mr. Spell. gl r = MOOList [ "", "aeiouy", [ ] ]
#32 Mr. Spell. umbi r = MOOList [ "lic", "", [ "umbilicus", "umbilici", "umbilical" ] ]
#32 Mr. Spell. lithi r = MOOList [ "", "", [ "lithium", "lithic" ] ]
#32 Mr. Spell. gn r = MOOList [ "", "ao", [ "gnu", "GNP", "gneiss" ] ]
#32 Mr. Spell. ente r = MOOList [ "", "r", [ "entendre" ] ]
#32 Mr. Spell. gr r = MOOList [ "", "aeiou", [ "gryphon" ] ]
#32 Mr. Spell. prophet r = MOOList [ "", "", [ "prophetic", "prophet" ] ]
#32 Mr. Spell. enti r = MOOList [ "", "r", [ "entity", "entice" ] ]
#32 Mr. Spell. creati r = MOOList [ "", "", [ "creation", "creating" ] ]
#32 Mr. Spell. enth r = MOOList [ "", "u", [ "enthalpy" ] ]
#32 Mr. Spell. discr r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. chees r = MOOList [ "", "e", [ "cheesy" ] ]
#32 Mr. Spell. prefere r = MOOList [ "n", "", [ "preferential", "preference" ] ]
#32 Mr. Spell. gy r = MOOList [ "", "mpr", [ ] ]
#32 Mr. Spell. cheer r = MOOList [ "", "", [ "cheery", "cheerleader", "cheerful", "cheer" ] ]
#32 Mr. Spell. noblem r = MOOList [ "", "", [ "noblemen", "nobleman" ] ]
#32 Mr. Spell. plush r = MOOList [ "", "", [ "plushy", "plush" ] ]
#32 Mr. Spell. disco r = MOOList [ "", "", [ "discovery", "discordant", "discomfit", "discoid" ] ]
#32 Mr. Spell. cheek r = MOOList [ "", "", [ "cheeky", "cheekbone", "cheek" ] ]
#32 Mr. Spell. disci r = MOOList [ "pl", "i", [ "disciple" ] ]
#32 Mr. Spell. asia r = MOOList [ "", "", [ "Asiatic", "Asia" ] ]
#32 Mr. Spell. he r = MOOList [ "", "abcdefgil'mnprstuwxy", [ "he" ] ]
#32 Mr. Spell. disce r = MOOList [ "rn", "", [ "discernible", "discern" ] ]
#32 Mr. Spell. cyni r = MOOList [ "c", "", [ "cynical", "cynic" ] ]
#32 Mr. Spell. Phe r = MOOList [ "", "n", [ "Phelps", "pheasant" ] ]
#32 Mr. Spell. Mathi r = MOOList [ "", "", [ "Mathieu", "Mathias" ] ]
#32 Mr. Spell. Pha r = MOOList [ "", "glnr", [ "phase" ] ]
#32 Mr. Spell. ho r = MOOList [ "", "abcdfglmnoprstuvwy", [ "Hokan", "hoi", "hoe", "ho" ] ]
#32 Mr. Spell. ashm r = MOOList [ "", "", [ "Ashmolean", "ashmen", "ashman" ] ]
#32 Mr. Spell. gentil r = MOOList [ "", "", [ "gentility", "gentile" ] ]
#32 Mr. Spell. incli r = MOOList [ "n", "", [ "incline", "inclination" ] ]
#32 Mr. Spell. discu r = MOOList [ "s", "s", [ "discus" ] ]
#32 Mr. Spell. eaves r = MOOList [ "drop", "", [ "eavesdropping", "eavesdrop" ] ]
#32 Mr. Spell. beset r = MOOList [ "", "", [ "besetting", "beset" ] ]
#32 Mr. Spell. create r = MOOList [ "", "", [ "created", "create" ] ]
#32 Mr. Spell. licen r = MOOList [ "", "s", [ "licentious" ] ]
#32 Mr. Spell. Levit r = MOOList [ "", "", [ "levity", "Levitt", "Leviticus", "levitate" ] ]
#32 Mr. Spell. ail r = MOOList [ "", "e", [ "ailanthus", "ail" ] ]
#32 Mr. Spell. Salvat r = MOOList [ "", "", [ "Salvatore", "salvation" ] ]
#32 Mr. Spell. ia r = MOOList [ "", "", [ "Ian", "iambic", "IA" ] ]
#32 Mr. Spell. ib r = MOOList [ "", "ei", [ "Ibn", "IBM" ] ]
#32 Mr. Spell. air r = MOOList [ "", "eflmps", [ "airy", "airway", "airtight", "airdrop", "aircraft", "airborne", "air" ] ]
#32 Mr. Spell. Levin r = MOOList [ "", "", [ "Levine", "Levin" ] ]
#32 Mr. Spell. if r = MOOList [ "", "", [ "Ifni", "iffy", "if" ] ]
#32 Mr. Spell. Phi r = MOOList [ "", "l", [ "Phipps", "phi" ] ]
#32 Mr. Spell. ig r = MOOList [ "", "n", [ "Igor", "igloo" ] ]
#32 Mr. Spell. ii r = MOOList [ "", "", [ "iii", "ii" ] ]
#32 Mr. Spell. abet r = MOOList [ "", "t", [ "abet" ] ]
#32 Mr. Spell. il r = MOOList [ "", "il", [ "Ilyushin", "Ilona", "ileum", "IL" ] ]
#32 Mr. Spell. im r = MOOList [ "", "abimp", [ ] ]
#32 Mr. Spell. Pic r = MOOList [ "", "acknot", [ ] ]
#32 Mr. Spell. in r = MOOList [ "", "abcdefghijklmnopqstuv", [ "inward", "inroad", "in" ] ]
#32 Mr. Spell. abey r = MOOList [ "an", "", [ "abeyant", "abeyance" ] ]
#32 Mr. Spell. io r = MOOList [ "", "dn", [ "Iowa", "iota", "Io" ] ]
#32 Mr. Spell. ip r = MOOList [ "", "s", [ "ipecac" ] ]
#32 Mr. Spell. merry r = MOOList [ "", "", [ "merrymake", "merry" ] ]
#32 Mr. Spell. Signo r = MOOList [ "r", "", [ "Signora", "Signor" ] ]
#32 Mr. Spell. Eastw r = MOOList [ "", "", [ "Eastwood", "eastward" ] ]
#32 Mr. Spell. inclu r = MOOList [ "", "sd", [ ] ]
#32 Mr. Spell. behe r = MOOList [ "", "", [ "beheld", "behead" ] ]
#32 Mr. Spell. Pis r = MOOList [ "", "ct", [ "piss" ] ]
#32 Mr. Spell. Pir r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. Persec r = MOOList [ "ut", "", [ "persecutory", "persecution", "persecute" ] ]
#32 Mr. Spell. l' r = MOOList [ "", "", [ "L'vov", "l's", "l'oeil" ] ]
#32 Mr. Spell. je r = MOOList [ "", "afjlnorstw", [ "Jehovah", "jeep", "Jed" ] ]
#32 Mr. Spell. Virgini r = MOOList [ "a", "", [ "Virginian", "Virginia" ] ]
#32 Mr. Spell. Wein r = MOOList [ "", "", [ "Weinstein", "Weinberg" ] ]
#32 Mr. Spell. ji r = MOOList [ "", "glmnt", [ "jive", "jiffy", "jibe" ] ]
#32 Mr. Spell. begu r = MOOList [ "", "", [ "begun", "beguile" ] ]
#32 Mr. Spell. specifica r = MOOList [ "", "", [ "specification", "specifically" ] ]
#32 Mr. Spell. Selec r = MOOList [ "t", "m", [ "Selectric", "selector", "select" ] ]
#32 Mr. Spell. morphe r = MOOList [ "m", "", [ "morphemic", "morpheme" ] ]
#32 Mr. Spell. mega r = MOOList [ "", "blw", [ "megavolt", "megaton", "megahertz" ] ]
#32 Mr. Spell. preferr r = MOOList [ "", "", [ "preferring", "preferred" ] ]
#32 Mr. Spell. alb r = MOOList [ "", "aeru", [ "alb" ] ]
#32 Mr. Spell. alc r = MOOList [ "", "o", [ "Alcmena", "alchemy", "Alcestis" ] ]
#32 Mr. Spell. ald r = MOOList [ "", "er", [ ] ]
#32 Mr. Spell. alf r = MOOList [ "", "r", [ "alfonso", "alfalfa" ] ]
#32 Mr. Spell. alg r = MOOList [ "", "aeio", [ ] ]
#32 Mr. Spell. beha r = MOOList [ "", "v", [ "behalf" ] ]
#32 Mr. Spell. intox r = MOOList [ "ica", "", [ "intoxicate", "intoxicant" ] ]
#32 Mr. Spell. ali r = MOOList [ "", "acegs", [ "alizarin", "alive", "aliquot", "aliphatic", "alimony", "alike", "alibi", "Ali" ] ]
#32 Mr. Spell. Leig r = MOOList [ "h", "", [ "Leighton", "Leigh" ] ]
#32 Mr. Spell. bege r = MOOList [ "t", "", [ "begetting", "beget" ] ]
#32 Mr. Spell. begg r = MOOList [ "", "a", [ "begging" ] ]
#32 Mr. Spell. begi r = MOOList [ "n", "n", [ "begin" ] ]
#32 Mr. Spell. inton r = MOOList [ "", "", [ "intone", "intonate" ] ]
#32 Mr. Spell. intol r = MOOList [ "era", "", [ "intolerant", "intolerable" ] ]
#32 Mr. Spell. bego r = MOOList [ "", "", [ "begotten", "begonia" ] ]
#32 Mr. Spell. abdo r = MOOList [ "m", "", [ "abdominal", "abdomen" ] ]
#32 Mr. Spell. kh r = MOOList [ "", "a", [ "Khrushchev", "Khmer" ] ]
#32 Mr. Spell. ki r = MOOList [ "", "bcdelmnortvw", [ "kiss", "Kipling", "Kikuyu", "Kigali" ] ]
#32 Mr. Spell. hospit r = MOOList [ "a", "", [ "hospital", "hospitable" ] ]
#32 Mr. Spell. conniv r = MOOList [ "", "", [ "connive", "connivance" ] ]
#32 Mr. Spell. amphi r = MOOList [ "", "b", [ "amphioxis" ] ]
#32 Mr. Spell. handle r = MOOList [ "", "", [ "handlebar", "handleable", "handle" ] ]
#32 Mr. Spell. chit r = MOOList [ "", "", [ "chiton", "chit" ] ]
#32 Mr. Spell. chiv r = MOOList [ "", "a", [ "chive" ] ]
#32 Mr. Spell. amb r = MOOList [ "", "ilru", [ "amber", "ambassador" ] ]
#32 Mr. Spell. ame r = MOOList [ "", "lnrt", [ "Ames" ] ]
#32 Mr. Spell. ku r = MOOList [ "", "dr", [ "Kuwait", "kumquat", "kulak", "Kuhn", "Ku" ] ]
#32 Mr. Spell. ami r = MOOList [ "", "dn", [ "amity", "amiss", "amigo", "amicable", "ami" ] ]
#32 Mr. Spell. chie r = MOOList [ "f", "", [ "chieftain", "chiefdom", "chief" ] ]
#32 Mr. Spell. alk r = MOOList [ "al", "i", [ "alkaloid" ] ]
#32 Mr. Spell. fiddle r = MOOList [ "", "", [ "fiddlestick", "fiddle" ] ]
#32 Mr. Spell. meet r = MOOList [ "", "i", [ "meets", "meet" ] ]
#32 Mr. Spell. chig r = MOOList [ "", "", [ "chignon", "chigger" ] ]
#32 Mr. Spell. clockw r = MOOList [ "", "", [ "clockwork", "clockwise", "clockwatcher" ] ]
#32 Mr. Spell. alo r = MOOList [ "", "n", [ "aloud", "aloof", "aloha", "aloft", "aloe" ] ]
#32 Mr. Spell. la r = MOOList [ "", "bcdgikmnoprstuvwxyz", [ "Lahore", "Lafayette", "la" ] ]
#32 Mr. Spell. alp r = MOOList [ "", "eh", [ "alpine", "alp" ] ]
#32 Mr. Spell. befi r = MOOList [ "t", "", [ "befitting", "befit" ] ]
#32 Mr. Spell. morphi r = MOOList [ "", "", [ "morphism", "morphine" ] ]
#32 Mr. Spell. chim r = MOOList [ "", "e", [ "chimpanzee", "chimney", "Chimique" ] ]
#32 Mr. Spell. als r = MOOList [ "", "o", [ "Alsatian" ] ]
#32 Mr. Spell. le r = MOOList [ "", "abcdefghimnopstuvwx", [ "Leyden", "Leroy", "Leland" ] ]
#32 Mr. Spell. chil r = MOOList [ "", "dl", [ "chili", "Chile", "chilblain" ] ]
#32 Mr. Spell. alt r = MOOList [ "", "aehior", [ ] ]
#32 Mr. Spell. statesm r = MOOList [ "", "a", [ "statesmen" ] ]
#32 Mr. Spell. alu r = MOOList [ "", "m", [ "alundum" ] ]
#32 Mr. Spell. chin r = MOOList [ "", "ace", [ "chinquapin", "Chinook", "chink", "chin" ] ]
#32 Mr. Spell. alw r = MOOList [ "ay", "", [ "always", "alway" ] ]
#32 Mr. Spell. li r = MOOList [ "", "abcefgklmnopqstvz", [ "lid" ] ]
#32 Mr. Spell. chip r = MOOList [ "", "", [ "Chippendale", "chipmunk", "chipboard", "chip" ] ]
#32 Mr. Spell. befo r = MOOList [ "", "gr", [ "befoul" ] ]
#32 Mr. Spell. morpho r = MOOList [ "", "", [ "morphophonemic", "morphology" ] ]
#32 Mr. Spell. enor r = MOOList [ "m", "", [ "enormous", "enormity" ] ]
#32 Mr. Spell. trinit r = MOOList [ "", "", [ "trinity", "trinitarian" ] ]
#32 Mr. Spell. chir r = MOOList [ "", "p", [ "chiropractor" ] ]
#32 Mr. Spell. bryop r = MOOList [ "hyt", "", [ "bryophyte", "bryophyta" ] ]
#32 Mr. Spell. rom r = MOOList [ "", "ae", [ "Romulus", "romp" ] ]
#32 Mr. Spell. abbr r = MOOList [ "eviat", "", [ "abbreviation", "abbreviate" ] ]
#32 Mr. Spell. roo r = MOOList [ "", "fkms", [ "root", "rood" ] ]
#32 Mr. Spell. lo r = MOOList [ "", "abcdefgilmnopqrstuvwy", [ "lozenge", "Loki", "lo" ] ]
#32 Mr. Spell. moonl r = MOOList [ "i", "", [ "moonlit", "moonlight" ] ]
#32 Mr. Spell. anc r = MOOList [ "", "ehi", [ ] ]
#32 Mr. Spell. rou r = MOOList [ "", "gnst", [ "roulette" ] ]
#32 Mr. Spell. Macki r = MOOList [ "n", "a", [ "mackintosh" ] ]
#32 Mr. Spell. ane r = MOOList [ "", "c", [ "anew", "anent", "anemone" ] ]
#32 Mr. Spell. delicat r = MOOList [ "e", "", [ "delicatessen", "delicate" ] ]
#32 Mr. Spell. row r = MOOList [ "", "el", [ "rowdy", "rowboat", "row" ] ]
#32 Mr. Spell. roy r = MOOList [ "", "a", [ "Royce", "Roy" ] ]
#32 Mr. Spell. exhib r = MOOList [ "it", "", [ "exhibitor", "exhibition", "exhibit" ] ]
#32 Mr. Spell. chia r = MOOList [ "n", "", [ "chianti", "Chiang" ] ]
#32 Mr. Spell. ani r = MOOList [ "", "mos", [ "Anita", "aniline", "ani" ] ]
#32 Mr. Spell. pathog r = MOOList [ "en", "", [ "pathogenic", "pathogenesis", "pathogen" ] ]
#32 Mr. Spell. ank r = MOOList [ "", "", [ "ankle", "Ankara" ] ]
#32 Mr. Spell. befa r = MOOList [ "ll", "", [ "befallen", "befall" ] ]
#32 Mr. Spell. dishw r = MOOList [ "a", "", [ "dishwater", "dishwasher" ] ]
#32 Mr. Spell. beeb r = MOOList [ "", "", [ "beebread", "Beebe" ] ]
#32 Mr. Spell. ascr r = MOOList [ "i", "", [ "ascription", "ascribe" ] ]
#32 Mr. Spell. Ply r = MOOList [ "", "", [ "plywood", "plyscore", "Plymouth", "ply" ] ]
#32 Mr. Spell. amo r = MOOList [ "", "enru", [ "Amos", "amok", "Amoco" ] ]
#32 Mr. Spell. roa r = MOOList [ "", "d", [ "roast", "roar", "roam", "roach" ] ]
#32 Mr. Spell. amp r = MOOList [ "", "ehl", [ "amputate", "amp" ] ]
#32 Mr. Spell. abbe r = MOOList [ "", "", [ "abbey", "abbe" ] ]
#32 Mr. Spell. rob r = MOOList [ "", "beio", [ "robust", "rob" ] ]
#32 Mr. Spell. beef r = MOOList [ "", "", [ "beefy", "beefsteak", "beef" ] ]
#32 Mr. Spell. roc r = MOOList [ "", "k", [ "rococo", "Rochester" ] ]
#32 Mr. Spell. medl r = MOOList [ "", "", [ "medley", "medlar" ] ]
#32 Mr. Spell. induct r = MOOList [ "", "", [ "inductor", "inductee", "inductance", "induct" ] ]
#32 Mr. Spell. remove r = MOOList [ "", "", [ "removes", "remove" ] ]
#32 Mr. Spell. relatio r = MOOList [ "n", "", [ "relations", "relation" ] ]
#32 Mr. Spell. rod r = MOOList [ "", "e", [ "Rodriguez", "Rodney", "Rodgers", "rod" ] ]
#32 Mr. Spell. profus r = MOOList [ "", "", [ "profusion", "profuse" ] ]
#32 Mr. Spell. roe r = MOOList [ "", "", [ "Roentgen", "roebuck", "roe" ] ]
#32 Mr. Spell. o' r = MOOList [ "", "CDS", [ "O'Neill", "O'Leary", "O'Hare", "o'er", "O'Brien" ] ]
#32 Mr. Spell. me r = MOOList [ "", "acdegilmnrstx", [ "mezzo", "Meyer", "mew", "Mephistopheles", "Mekong", "me" ] ]
#32 Mr. Spell. amu r = MOOList [ "", "", [ "amuse", "amulet" ] ]
#32 Mr. Spell. rog r = MOOList [ "", "", [ "rogue", "Roger" ] ]
#32 Mr. Spell. merri r = MOOList [ "", "m", [ "Merritt", "Merrill", "Merriam" ] ]
#32 Mr. Spell. roi r = MOOList [ "", "", [ "roister", "roil" ] ]
#32 Mr. Spell. amy r = MOOList [ "", "", [ "amygdaloid", "amy" ] ]
#32 Mr. Spell. accomp r = MOOList [ "", "al", [ ] ]
#32 Mr. Spell. rol r = MOOList [ "", "l", [ "role", "Roland" ] ]
#32 Mr. Spell. bedr r = MOOList [ "", "o", [ "bedridden", "bedraggle" ] ]
#32 Mr. Spell. neglige r = MOOList [ "", "", [ "negligent", "negligee" ] ]
#32 Mr. Spell. mn r = MOOList [ "", "", [ "mnemonic", "MN" ] ]
#32 Mr. Spell. redef r = MOOList [ "in", "", [ "redefining", "redefine" ] ]
#32 Mr. Spell. mo r = MOOList [ "", "abcdehilmnorstuv", [ "Mozart", "Moyer", "mow", "mop", "Mogadiscio", "MO" ] ]
#32 Mr. Spell. meda r = MOOList [ "l", "", [ "medallion", "medal" ] ]
#32 Mr. Spell. docto r = MOOList [ "r", "a", [ "doctor" ] ]
#32 Mr. Spell. beds r = MOOList [ "", "p", [ "bedstraw", "bedside" ] ]
#32 Mr. Spell. abas r = MOOList [ "", "", [ "abash", "abase" ] ]
#32 Mr. Spell. parsim r = MOOList [ "on", "", [ "parsimony", "parsimonious" ] ]
#32 Mr. Spell. asce r = MOOList [ "", "n", [ "ascetic", "ascertain" ] ]
#32 Mr. Spell. louse r = MOOList [ "", "", [ "lousewort", "louse" ] ]
#32 Mr. Spell. ms r = MOOList [ "", "", [ "ms.", "Ms" ] ]
#32 Mr. Spell. doctr r = MOOList [ "in", "a", [ "doctrine" ] ]
#32 Mr. Spell. mu r = MOOList [ "", "cdefglmnorstz", [ "Mukden", "Muir", "mu" ] ]
#32 Mr. Spell. redem r = MOOList [ "pti", "", [ "redemptive", "redemption" ] ]
#32 Mr. Spell. medi r = MOOList [ "", "acot", [ "medium" ] ]
#32 Mr. Spell. vibrat r = MOOList [ "", "", [ "vibrato", "vibrate" ] ]
#32 Mr. Spell. incid r = MOOList [ "ent", "a", [ "incident" ] ]
#32 Mr. Spell. ano r = MOOList [ "", "dmnr", [ "another" ] ]
#32 Mr. Spell. quadru r = MOOList [ "p", "", [ "quadrupole", "quadruple" ] ]
#32 Mr. Spell. na r = MOOList [ "", "bdgikmnprstuvz", [ "nay", "Naomi", "NAACP" ] ]
#32 Mr. Spell. abac r = MOOList [ "", "", [ "abacus", "aback" ] ]
#32 Mr. Spell. Onom r = MOOList [ "atopoei", "", [ "onomatopoeic", "onomatopoeia" ] ]
#32 Mr. Spell. plumb r = MOOList [ "", "a", [ "plumb" ] ]
#32 Mr. Spell. ant r = MOOList [ "", "aehio", [ "Antwerp", "antler", "ant" ] ]
#32 Mr. Spell. bedi r = MOOList [ "m", "m", [ "bedim" ] ]
#32 Mr. Spell. russe r = MOOList [ "", "", [ "russet", "Russell" ] ]
#32 Mr. Spell. followe r = MOOList [ "", "", [ "followed", "followeth" ] ]
#32 Mr. Spell. anx r = MOOList [ "i", "", [ "anxious", "anxiety" ] ]
#32 Mr. Spell. any r = MOOList [ "", "bw", [ "anything", "anyplace", "anyone", "anyhow", "any" ] ]
#32 Mr. Spell. apa r = MOOList [ "", "rt", [ "apache" ] ]
#32 Mr. Spell. adeno r = MOOList [ "", "", [ "adenosine", "adenoma" ] ]
#32 Mr. Spell. meant r = MOOList [ "", "", [ "meantime", "meant" ] ]
#32 Mr. Spell. Maurit r = MOOList [ "", "", [ "Mauritius", "Mauritania" ] ]
#32 Mr. Spell. ape r = MOOList [ "", "r", [ "apex", "ape" ] ]
#32 Mr. Spell. quadri r = MOOList [ "", "cl", [ "quadrivium", "quadripartite" ] ]
#32 Mr. Spell. nu r = MOOList [ "", "bcdglmrt", [ "nuzzle", "nuptial", "nun", "nuisance", "nuance", "nu" ] ]
#32 Mr. Spell. aph r = MOOList [ "", "a", [ "Aphrodite", "aphorism", "aphid", "aphelion" ] ]
#32 Mr. Spell. api r = MOOList [ "", "", [ "apiece", "apices" ] ]
#32 Mr. Spell. mech r = MOOList [ "ani", "s", [ "mechanic" ] ]
#32 Mr. Spell. aspira r = MOOList [ "", "", [ "aspirate", "aspirant" ] ]
#32 Mr. Spell. quadra r = MOOList [ "", "nt", [ ] ]
#32 Mr. Spell. Words r = MOOList [ "", "", [ "Wordsworth", "words" ] ]
#32 Mr. Spell. Mauric r = MOOList [ "", "", [ "Mauricio", "Maurice" ] ]
#32 Mr. Spell. oa r = MOOList [ "", "kst", [ "oar", "oaf" ] ]
#32 Mr. Spell. ob r = MOOList [ "", "defjlostv", [ "obnoxious", "obituary" ] ]
#32 Mr. Spell. oc r = MOOList [ "", "cet", [ "ocular", "ocarina" ] ]
#32 Mr. Spell. od r = MOOList [ "", "eioy", [ "odd" ] ]
#32 Mr. Spell. of r = MOOList [ "", "ft", [ "of" ] ]
#32 Mr. Spell. og r = MOOList [ "", "r", [ "ogle", "Ogden" ] ]
#32 Mr. Spell. oi r = MOOList [ "", "l", [ "oint" ] ]
#32 Mr. Spell. beck r = MOOList [ "", "", [ "Becky", "beckon", "Beckman", "becket", "beck" ] ]
#32 Mr. Spell. button r = MOOList [ "", "", [ "buttonweed", "buttonhole", "button" ] ]
#32 Mr. Spell. ok r = MOOList [ "", "", [ "Oklahoma", "Okinawa", "okay", "OK" ] ]
#32 Mr. Spell. conclus r = MOOList [ "i", "", [ "conclusive", "conclusion" ] ]
#32 Mr. Spell. fifte r = MOOList [ "en", "", [ "fifteenth", "fifteen" ] ]
#32 Mr. Spell. incis r = MOOList [ "", "", [ "incisive", "incise" ] ]
#32 Mr. Spell. on r = MOOList [ "", "celorst", [ "onboard", "onyx", "onward", "onus", "onion", "ongoing", "on" ] ]
#32 Mr. Spell. Pon r = MOOList [ "", "cdt", [ "pony", "pong" ] ]
#32 Mr. Spell. oo r = MOOList [ "", "", [ "ooze", "oodles", "oocyte" ] ]
#32 Mr. Spell. op r = MOOList [ "", "aeiptu", [ "opossum", "Ophiucus" ] ]
#32 Mr. Spell. Pol r = MOOList [ "", "aeikloy", [ "pol" ] ]
#32 Mr. Spell. or r = MOOList [ "", "abcdegilnoptw", [ "Orville", "Orr", "Orkney", "or" ] ]
#32 Mr. Spell. ampli r = MOOList [ "", "", [ "amplitude", "amplify" ] ]
#32 Mr. Spell. ot r = MOOList [ "", "hit", [ ] ]
#32 Mr. Spell. ou r = MOOList [ "", "grtz", [ "ouvre", "oust", "ounce", "ouch", "Ouagadougou" ] ]
#32 Mr. Spell. ov r = MOOList [ "", "aei", [ ] ]
#32 Mr. Spell. equilibri r = MOOList [ "", "", [ "equilibrium", "equilibria" ] ]
#32 Mr. Spell. ow r = MOOList [ "", "eln", [ "ow" ] ]
#32 Mr. Spell. accusati r = MOOList [ "", "", [ "accusative", "accusation" ] ]
#32 Mr. Spell. ponde r = MOOList [ "r", "", [ "ponderous", "ponder" ] ]
#32 Mr. Spell. ox r = MOOList [ "", "aeiy", [ "Oxnard", "Oxonian", "Oxford", "oxcart", "ox" ] ]
#32 Mr. Spell. nigh r = MOOList [ "", "t", [ "nigh" ] ]
#32 Mr. Spell. oz r = MOOList [ "", "", [ "ozone", "Ozark" ] ]
#32 Mr. Spell. Dool r = MOOList [ "", "", [ "Doolittle", "Dooley" ] ]
#32 Mr. Spell. nigg r = MOOList [ "", "", [ "niggle", "nigger", "niggardly" ] ]
#32 Mr. Spell. loquac r = MOOList [ "i", "", [ "loquacity", "loquacious" ] ]
#32 Mr. Spell. nige r = MOOList [ "r", "", [ "Nigeria", "Niger" ] ]
#32 Mr. Spell. minis r = MOOList [ "t", "", [ "ministry", "ministerial" ] ]
#32 Mr. Spell. apo r = MOOList [ "", "clst", [ "apogee" ] ]
#32 Mr. Spell. app r = MOOList [ "", "aelor", [ "Appian" ] ]
#32 Mr. Spell. fant r = MOOList [ "", "a", [ "fantod" ] ]
#32 Mr. Spell. polo r = MOOList [ "", "n", [ "polopony", "polo" ] ]
#32 Mr. Spell. apt r = MOOList [ "", "", [ "aptitude", "apt" ] ]
#32 Mr. Spell. acad r = MOOList [ "", "e", [ "Acadia" ] ]
#32 Mr. Spell. tropos r = MOOList [ "pher", "", [ "tropospheric", "troposphere" ] ]
#32 Mr. Spell. ph r = MOOList [ "", "aeilory", [ "phthalate", "PhD" ] ]
#32 Mr. Spell. Pou r = MOOList [ "", "ln", [ "pout", "pour", "Poughkeepsie", "pouch" ] ]
#32 Mr. Spell. pi r = MOOList [ "", "acdeglmnopqrstvxz", [ "Pius", "pike", "pi" ] ]
#32 Mr. Spell. minim r = MOOList [ "", "a", [ "minimum", "minim" ] ]
#32 Mr. Spell. poly r = MOOList [ "", "ghmpt", [ "polysaccharide", "polynomial" ] ]
#32 Mr. Spell. thunderb r = MOOList [ "", "", [ "thunderbolt", "thunderbird" ] ]
#32 Mr. Spell. pl r = MOOList [ "", "aeiouy", [ "Pl" ] ]
#32 Mr. Spell. pn r = MOOList [ "eum", "o", [ "pneumatic" ] ]
#32 Mr. Spell. po r = MOOList [ "", "cdegiklmnoprstuw", [ "Poynting", "poverty", "POBox", "poach", "Po" ] ]
#32 Mr. Spell. handic r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. ara r = MOOList [ "", "bc", [ ] ]
#32 Mr. Spell. quint r = MOOList [ "", "i", [ "quintus", "quintet", "quint" ] ]
#32 Mr. Spell. fanf r = MOOList [ "", "", [ "fanfold", "fanfare" ] ]
#32 Mr. Spell. Done r = MOOList [ "", "", [ "Doneck", "done" ] ]
#32 Mr. Spell. arb r = MOOList [ "", "io", [ "arbutus" ] ]
#32 Mr. Spell. pr r = MOOList [ "", "aeiou", [ "pry", "PR" ] ]
#32 Mr. Spell. frot r = MOOList [ "h", "", [ "frothy", "froth" ] ]
#32 Mr. Spell. fanc r = MOOList [ "", "", [ "fancy", "fanciful" ] ]
#32 Mr. Spell. chemi r = MOOList [ "", "s", [ "chemic" ] ]
#32 Mr. Spell. arc r = MOOList [ "", "achst", [ "arclength", "arcing", "arc" ] ]
#32 Mr. Spell. ps r = MOOList [ "", "ay", [ "psi", "pseudo" ] ]
#32 Mr. Spell. pola r = MOOList [ "", "r", [ "Poland" ] ]
#32 Mr. Spell. fros r = MOOList [ "t", "b", [ "frosty", "frost" ] ]
#32 Mr. Spell. ard r = MOOList [ "", "e", [ "arduous" ] ]
#32 Mr. Spell. pt r = MOOList [ "", "Ao", [ "pterodactyl" ] ]
#32 Mr. Spell. froz r = MOOList [ "e", "", [ "frozen", "froze" ] ]
#32 Mr. Spell. are r = MOOList [ "", "an", [ "Ares", "Arequipa", "are" ] ]
#32 Mr. Spell. pu r = MOOList [ "", "bcdefglmnprst", [ "puzzle", "puke", "puissant" ] ]
#32 Mr. Spell. fang r = MOOList [ "", "", [ "fangled", "fang" ] ]
#32 Mr. Spell. arg r = MOOList [ "", "iou", [ "Argentina" ] ]
#32 Mr. Spell. noise r = MOOList [ "", "", [ "noisemake", "noise" ] ]
#32 Mr. Spell. frow r = MOOList [ "", "", [ "frowzy", "frown" ] ]
#32 Mr. Spell. Donn r = MOOList [ "", "e", [ "donnybrook", "Donna" ] ]
#32 Mr. Spell. py r = MOOList [ "", "grt", [ "Pyongyang", "Pyle", "pyknotic" ] ]
#32 Mr. Spell. polk r = MOOList [ "", "a", [ "Polk" ] ]
#32 Mr. Spell. doctora r = MOOList [ "", "", [ "doctorate", "doctoral" ] ]
#32 Mr. Spell. poli r = MOOList [ "", "cost", [ ] ]
#32 Mr. Spell. arm r = MOOList [ "", "acios", [ "army", "armpit", "armload", "armhole", "armful", "Armenia", "arm" ] ]
#32 Mr. Spell. thunders r = MOOList [ "", "", [ "thunderstorm", "thundershower" ] ]
#32 Mr. Spell. ponch r = MOOList [ "", "", [ "poncho", "Ponchartrain" ] ]
#32 Mr. Spell. aro r = MOOList [ "", "mu", [ "arose" ] ]
#32 Mr. Spell. pole r = MOOList [ "", "", [ "polemic", "polecat", "pole" ] ]
#32 Mr. Spell. Dono r = MOOList [ "", "", [ "Donovan", "donor" ] ]
#32 Mr. Spell. arp r = MOOList [ "", "", [ "arpeggio", "ARPA" ] ]
#32 Mr. Spell. connot r = MOOList [ "", "a", [ "connote" ] ]
#32 Mr. Spell. fron r = MOOList [ "t", "ai", [ "front" ] ]
#32 Mr. Spell. atav r = MOOList [ "is", "", [ "atavistic", "atavism" ] ]
#32 Mr. Spell. cerebr r = MOOList [ "a", "", [ "cerebrate", "cerebral" ] ]
#32 Mr. Spell. Dome r = MOOList [ "", "s", [ "Domenico", "dome" ] ]
#32 Mr. Spell. Prou r = MOOList [ "", "", [ "Proust", "proud" ] ]
#32 Mr. Spell. asc r = MOOList [ "", "er", [ "ASCII", "ascomycetes" ] ]
#32 Mr. Spell. satia r = MOOList [ "", "", [ "satiate", "satiable" ] ]
#32 Mr. Spell. incul r = MOOList [ "", "", [ "inculpable", "inculcate" ] ]
#32 Mr. Spell. Vietn r = MOOList [ "am", "", [ "Vietnamese", "Vietnam" ] ]
#32 Mr. Spell. qu r = MOOList [ "", "aeio", [ ] ]
#32 Mr. Spell. fami r = MOOList [ "", "l", [ "famish", "famine" ] ]
#32 Mr. Spell. contradic r = MOOList [ "t", "", [ "contradictory", "contradict" ] ]
#32 Mr. Spell. ash r = MOOList [ "", "elm", [ "ashy", "ashtray", "ashore", "ashame", "ash" ] ]
#32 Mr. Spell. Helle r = MOOList [ "", "", [ "Hellenic", "hellebore" ] ]
#32 Mr. Spell. ask r = MOOList [ "", "e", [ "asking", "askance", "ask" ] ]
#32 Mr. Spell. country r = MOOList [ "", "m", [ "countrywide", "countryside", "country" ] ]
#32 Mr. Spell. bespe r = MOOList [ "", "", [ "bespectacled", "bespeak" ] ]
#32 Mr. Spell. incur r = MOOList [ "", "r", [ "incursion", "incur" ] ]
#32 Mr. Spell. Panc r = MOOList [ "", "r", [ "Pancho", "pancake" ] ]
#32 Mr. Spell. asp r = MOOList [ "", "aehi", [ "asplenium" ] ]
#32 Mr. Spell. rub r = MOOList [ "", "bei", [ "ruby", "rubric", "rubdown", "rub" ] ]
#32 Mr. Spell. ra r = MOOList [ "", "bcdfgijklmnprstuvwyz", [ "Raoul", "Rae" ] ]
#32 Mr. Spell. Pand r = MOOList [ "", "ae", [ "Pandora" ] ]
#32 Mr. Spell. fals r = MOOList [ "", "", [ "Falstaff", "falsify", "false" ] ]
#32 Mr. Spell. thrus r = MOOList [ "", "", [ "thrust", "thrush" ] ]
#32 Mr. Spell. ars r = MOOList [ "", "e", [ "arson", "arsine" ] ]
#32 Mr. Spell. re r = MOOList [ "", "abcdefghijlmnpqstuvy", [ "Rex", "reward", "reredos", "re" ] ]
#32 Mr. Spell. aru r = MOOList [ "", "", [ "arum", "Aruba" ] ]
#32 Mr. Spell. rh r = MOOList [ "", "aeioy", [ "rhubarb" ] ]
#32 Mr. Spell. ri r = MOOList [ "", "bcdefglmnopstv", [ "Riyadh", "RI" ] ]
#32 Mr. Spell. crafts r = MOOList [ "", "mp", [ ] ]
#32 Mr. Spell. sunbu r = MOOList [ "rn", "", [ "sunburnt", "sunburn" ] ]
#32 Mr. Spell. intrus r = MOOList [ "i", "", [ "intrusive", "intrusion" ] ]
#32 Mr. Spell. countri r = MOOList [ "", "", [ "countries", "countrify" ] ]
#32 Mr. Spell. inflammat r = MOOList [ "", "", [ "inflammatory", "inflammation" ] ]
#32 Mr. Spell. ro r = MOOList [ "", "abcdegilmnostuwy", [ "Roxbury", "rove", "rope" ] ]
#32 Mr. Spell. incub r = MOOList [ "", "", [ "incubus", "incubi", "incubate" ] ]
#32 Mr. Spell. Dona r = MOOList [ "", "l", [ "donate", "Donahue" ] ]
#32 Mr. Spell. rus r = MOOList [ "", "hst", [ "rusk", "ruse" ] ]
#32 Mr. Spell. falc r = MOOList [ "on", "", [ "falconry", "falcon" ] ]
#32 Mr. Spell. rut r = MOOList [ "", "hl", [ "rutty", "rutile", "Rutgers", "rutabaga", "rut" ] ]
#32 Mr. Spell. philo r = MOOList [ "", "s", [ "philology", "philodendron" ] ]
#32 Mr. Spell. tropo r = MOOList [ "", "s", [ "tropopause" ] ]
#32 Mr. Spell. manager r = MOOList [ "", "", [ "managers", "manager", "managerial" ] ]
#32 Mr. Spell. ru r = MOOList [ "", "bdefimnpstl", [ "rural", "rug", "ruckus", "Ruanda" ] ]
#32 Mr. Spell. ath r = MOOList [ "", "el", [ "athwart", "Athabascan" ] ]
#32 Mr. Spell. Erod r = MOOList [ "", "", [ "erodible", "erode" ] ]
#32 Mr. Spell. fall r = MOOList [ "", "ao", [ "fallible", "fallen", "fall" ] ]
#32 Mr. Spell. atl r = MOOList [ "a", "n", [ "atlas" ] ]
#32 Mr. Spell. atm r = MOOList [ "ospher", "", [ "atmospheric", "atmosphere" ] ]
#32 Mr. Spell. ato r = MOOList [ "", "mn", [ "atop" ] ]
#32 Mr. Spell. satis r = MOOList [ "f", "ay", [ "satisfied" ] ]
#32 Mr. Spell. that' r = MOOList [ "", "", [ "that'll", "that'd" ] ]
#32 Mr. Spell. sa r = MOOList [ "", "bcdfgilmnprstuvwxy", [ "Sao", "sake", "Sahara", "sa" ] ]
#32 Mr. Spell. atr r = MOOList [ "", "o", [ "Atreus" ] ]
#32 Mr. Spell. sport r = MOOList [ "", "s", [ "sporty", "sport" ] ]
#32 Mr. Spell. sc r = MOOList [ "", "aehiloruy", [ "SCM", "SC" ] ]
#32 Mr. Spell. phila r = MOOList [ "", "n", [ "Philadelphia" ] ]
#32 Mr. Spell. rud r = MOOList [ "", "dioy", [ "rude" ] ]
#32 Mr. Spell. ass r = MOOList [ "", "aeiouy", [ "ass" ] ]
#32 Mr. Spell. se r = MOOList [ "", "acdegilmnpqrstvwx", [ "Seymour", "Seoul", "Sebastian", "SE" ] ]
#32 Mr. Spell. satir r = MOOList [ "", "", [ "satiric", "satire" ] ]
#32 Mr. Spell. rue r = MOOList [ "", "", [ "rueful", "rue" ] ]
#32 Mr. Spell. ast r = MOOList [ "", "aeior", [ "astute", "ASTM", "asthma" ] ]
#32 Mr. Spell. ruf r = MOOList [ "", "f", [ "Rufus", "rufous" ] ]
#32 Mr. Spell. poin r = MOOList [ "", "t", [ "poinsettia", "Poincare" ] ]
#32 Mr. Spell. asu r = MOOList [ "n", "", [ "asunder", "Asuncion" ] ]
#32 Mr. Spell. sh r = MOOList [ "", "aeioruy", [ "Shmuel" ] ]
#32 Mr. Spell. nick r = MOOList [ "", "", [ "nickname", "nickel", "nick" ] ]
#32 Mr. Spell. rui r = MOOList [ "n", "", [ "ruinous", "ruination", "ruin" ] ]
#32 Mr. Spell. contradis r = MOOList [ "tin", "", [ "contradistinguish", "contradistinct" ] ]
#32 Mr. Spell. clothe r = MOOList [ "", "s", [ "clothe" ] ]
#32 Mr. Spell. Prok r = MOOList [ "", "", [ "Prokofieff", "prokaryote" ] ]
#32 Mr. Spell. asy r = MOOList [ "", "mn", [ "asylum" ] ]
#32 Mr. Spell. sk r = MOOList [ "", "aeiuy", [ "Skopje" ] ]
#32 Mr. Spell. rul r = MOOList [ "e", "", [ "rules", "rule" ] ]
#32 Mr. Spell. sl r = MOOList [ "", "aeiou", [ "sly" ] ]
#32 Mr. Spell. troph r = MOOList [ "", "", [ "trophy", "trophic" ] ]
#32 Mr. Spell. sm r = MOOList [ "", "aeiouy", [ ] ]
#32 Mr. Spell. sn r = MOOList [ "", "aeiouy", [ ] ]
#32 Mr. Spell. run r = MOOList [ "", "agnt", [ "Runyon", "runway", "runoff", "runic", "rune", "rundown", "run" ] ]
#32 Mr. Spell. so r = MOOList [ "", "abcdfilmnopruvwy", [ "sojourn", "soggy", "so" ] ]
#32 Mr. Spell. sp r = MOOList [ "", "aehiloruy", [ ] ]
#32 Mr. Spell. rup r = MOOList [ "", "", [ "rupture", "rupee" ] ]
#32 Mr. Spell. preparati r = MOOList [ "", "", [ "preparative", "preparation" ] ]
#32 Mr. Spell. sq r = MOOList [ "u", "aei", [ ] ]
#32 Mr. Spell. pois r = MOOList [ "", "o", [ "Poisson", "poise" ] ]
#32 Mr. Spell. ata r = MOOList [ "", "v", [ "Atalanta" ] ]
#32 Mr. Spell. Erne r = MOOList [ "st", "", [ "Ernestine", "Ernest" ] ]
#32 Mr. Spell. aud r = MOOList [ "", "ai", [ "Audubon", "Audrey" ] ]
#32 Mr. Spell. st r = MOOList [ "", "aeioruy", [ "St" ] ]
#32 Mr. Spell. su r = MOOList [ "", "bcdefgilmnprstz", [ "suave" ] ]
#32 Mr. Spell. Pale r = MOOList [ "", "o", [ "palette", "Palestine", "Palermo", "pale" ] ]
#32 Mr. Spell. commissa r = MOOList [ "r", "", [ "commissary", "commissariat" ] ]
#32 Mr. Spell. sw r = MOOList [ "", "aeiou", [ "SW" ] ]
#32 Mr. Spell. Itali r = MOOList [ "", "", [ "italic", "Italian" ] ]
#32 Mr. Spell. incom r = MOOList [ "", "mp", [ "income", "incombustible" ] ]
#32 Mr. Spell. aun r = MOOList [ "t", "", [ "auntie", "aunt" ] ]
#32 Mr. Spell. sunde r = MOOList [ "", "", [ "sundew", "sunder" ] ]
#32 Mr. Spell. nice r = MOOList [ "", "", [ "nicety", "nice" ] ]
#32 Mr. Spell. incon r = MOOList [ "", "cgstv", [ "incondensable" ] ]
#32 Mr. Spell. ta r = MOOList [ "", "bcdfghiklmnoprstuvwx", [ "Taylor", "TA" ] ]
#32 Mr. Spell. aur r = MOOList [ "", "aeio", [ ] ]
#32 Mr. Spell. aus r = MOOList [ "", "pt", [ "Auschwitz" ] ]
#32 Mr. Spell. wallo r = MOOList [ "", "", [ "wallow", "wallop" ] ]
#32 Mr. Spell. te r = MOOList [ "", "acdehklmnprstx", [ "Teutonic", "Tegucigalpa", "Teflon" ] ]
#32 Mr. Spell. runt r = MOOList [ "", "", [ "runty", "runt" ] ]
#32 Mr. Spell. att r = MOOList [ "", "aeir", [ "attune", "attorney" ] ]
#32 Mr. Spell. dispa r = MOOList [ "ra", "", [ "disparate", "disparage" ] ]
#32 Mr. Spell. miner r = MOOList [ "", "a", [ "Minerva" ] ]
#32 Mr. Spell. quirk r = MOOList [ "", "", [ "quirky", "quirk" ] ]
#32 Mr. Spell. Vienn r = MOOList [ "", "", [ "Viennese", "Vienna" ] ]
#32 Mr. Spell. to r = MOOList [ "", "abdEfgiklmnoprstwuxy", [ "toccata", "to" ] ]
#32 Mr. Spell. Palo r = MOOList [ "", "", [ "Palomar", "Palo" ] ]
#32 Mr. Spell. tr r = MOOList [ "", "auyeio", [ "TRW" ] ]
#32 Mr. Spell. ts r = MOOList [ "", "a", [ "tsunami" ] ]
#32 Mr. Spell. auc r = MOOList [ "", "t", [ "Auckland" ] ]
#32 Mr. Spell. guns r = MOOList [ "", "", [ "gunsling", "gunshot" ] ]
#32 Mr. Spell. dispo r = MOOList [ "sa", "", [ "disposal", "disposable" ] ]
#32 Mr. Spell. ave r = MOOList [ "", "nr", [ "Avesta", "Ave" ] ]
#32 Mr. Spell. tu r = MOOList [ "", "rbcfglmnpst", [ "tuxedo", "tuition", "Tudor", "tuesday" ] ]
#32 Mr. Spell. Mick r = MOOList [ "", "e", [ "Micky" ] ]
#32 Mr. Spell. gunp r = MOOList [ "", "", [ "gunpowder", "gunplay" ] ]
#32 Mr. Spell. Pto r = MOOList [ "lem", "", [ "Ptolemy", "Ptolemaic" ] ]
#32 Mr. Spell. doubl r = MOOList [ "", "e", [ "doubloon" ] ]
#32 Mr. Spell. avi r = MOOList [ "", "a", [ "Aviv", "Avis", "avionic", "avid" ] ]
#32 Mr. Spell. ty r = MOOList [ "", "pr", [ "Tyson", "Tyndall", "Tyler", "tying", "tycoon", "Tyburn" ] ]
#32 Mr. Spell. Mich r = MOOList [ "", "ae", [ "michigan" ] ]
#32 Mr. Spell. intra r = MOOList [ "", "n", [ "intractable" ] ]
#32 Mr. Spell. avo r = MOOList [ "", "ci", [ "avow", "Avon", "Avogadro" ] ]
#32 Mr. Spell. mines r = MOOList [ "", "", [ "minesweeper", "minestrone" ] ]
#32 Mr. Spell. doubt r = MOOList [ "", "", [ "doubtful", "doubt" ] ]
#32 Mr. Spell. ub r = MOOList [ "iquit", "", [ "ubiquity", "ubiquitous" ] ]
#32 Mr. Spell. runa r = MOOList [ "", "", [ "runaway", "runabout" ] ]
#32 Mr. Spell. dispe r = MOOList [ "", "lnr", [ ] ]
#32 Mr. Spell. aut r = MOOList [ "", "hiou", [ ] ]
#32 Mr. Spell. ug r = MOOList [ "", "", [ "ugly", "ugh", "Uganda" ] ]
#32 Mr. Spell. Pub r = MOOList [ "", "el", [ "pub" ] ]
#32 Mr. Spell. fain r = MOOList [ "", "", [ "faint", "fain" ] ]
#32 Mr. Spell. fait r = MOOList [ "h", "", [ "faithful", "faith" ] ]
#32 Mr. Spell. gunf r = MOOList [ "", "i", [ "gunflint" ] ]
#32 Mr. Spell. ul r = MOOList [ "", "ct", [ "Ulysses", "Ulster", "Ullman", "Ulan" ] ]
#32 Mr. Spell. incor r = MOOList [ "", "pr", [ ] ]
#32 Mr. Spell. um r = MOOList [ "", "b", [ "umpire", "umlaut" ] ]
#32 Mr. Spell. gunk r = MOOList [ "", "", [ "gunky", "gunk" ] ]
#32 Mr. Spell. un r = MOOList [ "", "iabcdksf", [ "unless", "unwieldy", "unruly", "UNESCO", "until", "UN" ] ]
#32 Mr. Spell. up r = MOOList [ "", "bdhlprstw", [ "upkeep", "upgrade", "upend", "upcome", "upon", "up" ] ]
#32 Mr. Spell. rumm r = MOOList [ "", "", [ "rummy", "rummage" ] ]
#32 Mr. Spell. olds r = MOOList [ "", "", [ "oldster", "Oldsmobile" ] ]
#32 Mr. Spell. ur r = MOOList [ "", "abegis", [ "Uruguay", "urn", "urchin" ] ]
#32 Mr. Spell. gunn r = MOOList [ "", "", [ "gunny", "gunnery" ] ]
#32 Mr. Spell. urina r = MOOList [ "", "", [ "urinary", "urinal" ] ]
#32 Mr. Spell. us r = MOOList [ "", "euaCI", [ "USSR", "USPS", "USN", "usher", "USGS", "USDA", "us" ] ]
#32 Mr. Spell. rump r = MOOList [ "", "", [ "rumpus", "rumple", "rump" ] ]
#32 Mr. Spell. Plain r = MOOList [ "", "t", [ "Plainfield", "plain" ] ]
#32 Mr. Spell. gunm r = MOOList [ "", "", [ "gunmen", "gunman" ] ]
#32 Mr. Spell. dispu r = MOOList [ "t", "", [ "dispute", "disputant" ] ]
#32 Mr. Spell. pillo r = MOOList [ "", "", [ "pillow", "pillory" ] ]
#32 Mr. Spell. carbi r = MOOList [ "", "", [ "carbine", "carbide" ] ]
#32 Mr. Spell. bests r = MOOList [ "ell", "", [ "bestselling", "bestseller" ] ]
#32 Mr. Spell. Pus r = MOOList [ "", "hs", [ "Pusey", "Pusan", "pus" ] ]
#32 Mr. Spell. raise r = MOOList [ "", "", [ "raises", "raised", "raise" ] ]
#32 Mr. Spell. intru r = MOOList [ "", "s", [ "intrude" ] ]
#32 Mr. Spell. besto r = MOOList [ "w", "", [ "bestowal", "bestow" ] ]
#32 Mr. Spell. barten r = MOOList [ "d", "", [ "bartender", "bartend" ] ]
#32 Mr. Spell. eupho r = MOOList [ "r", "i", [ "euphorbia" ] ]
#32 Mr. Spell. Pul r = MOOList [ "", "lps", [ "pulverable", "pulmonary", "Pulitzer", "Pulaski" ] ]
#32 Mr. Spell. besti r = MOOList [ "", "r", [ "bestial" ] ]
#32 Mr. Spell. va r = MOOList [ "", "cdgilmnprstu", [ "VA" ] ]
#32 Mr. Spell. Franco r = MOOList [ "", "", [ "Francoise", "franco" ] ]
#32 Mr. Spell. fail r = MOOList [ "", "sei", [ "failure", "fail" ] ]
#32 Mr. Spell. Pug r = MOOList [ "", "", [ "Pugh", "pug" ] ]
#32 Mr. Spell. interfere r = MOOList [ "", "", [ "interference", "interfere" ] ]
#32 Mr. Spell. ve r = MOOList [ "", "ceghilnrstx", [ "Veda", "veal" ] ]
#32 Mr. Spell. intri r = MOOList [ "", "c", [ "intrinsic", "intrigue" ] ]
#32 Mr. Spell. vi r = MOOList [ "", "eabcdgilnorstv", [ "viz", "vixen", "Viking", "vi" ] ]
#32 Mr. Spell. vo r = MOOList [ "", "icglrtuw", [ "voyage", "Voss", "voodoo", "von", "vomit" ] ]
#32 Mr. Spell. sinuso r = MOOList [ "id", "", [ "sinusoidal", "sinusoid" ] ]
#32 Mr. Spell. intro r = MOOList [ "", "dv", [ "introspect", "introject", "introit" ] ]
#32 Mr. Spell. awa r = MOOList [ "", "kr", [ "away", "awash", "await" ] ]
#32 Mr. Spell. pilla r = MOOList [ "", "", [ "pillar", "pillage" ] ]
#32 Mr. Spell. vu r = MOOList [ "l", "", [ "vulture", "vulpine", "vulnerable", "vulgar", "Vulcan" ] ]
#32 Mr. Spell. raisi r = MOOList [ "n", "", [ "raising", "raisin" ] ]
#32 Mr. Spell. awe r = MOOList [ "", "", [ "awesome", "awe" ] ]
#32 Mr. Spell. axi r = MOOList [ "", "os", [ "axial" ] ]
#32 Mr. Spell. frit r = MOOList [ "", "", [ "Fritz", "fritter", "fritillary" ] ]
#32 Mr. Spell. fris r = MOOList [ "", "", [ "frisbee", "frisky" ] ]
#32 Mr. Spell. incre r = MOOList [ "", "ad", [ "increment" ] ]
#32 Mr. Spell. axo r = MOOList [ "", "", [ "axon", "axolotl" ] ]
#32 Mr. Spell. Tyranni r = MOOList [ "c", "", [ "tyrannicide", "tyrannic" ] ]
#32 Mr. Spell. wa r = MOOList [ "", "nsycdfghiklprtvx", [ "Wabash", "Waals", "WA" ] ]
#32 Mr. Spell. friv r = MOOList [ "ol", "", [ "frivolous", "frivolity" ] ]
#32 Mr. Spell. Maced r = MOOList [ "on", "", [ "Macedonia", "Macedon" ] ]
#32 Mr. Spell. pluto r = MOOList [ "", "n", [ "Pluto" ] ]
#32 Mr. Spell. troub r = MOOList [ "", "l", [ "troubador" ] ]
#32 Mr. Spell. snipp r = MOOList [ "", "", [ "snippy", "snippet" ] ]
#32 Mr. Spell. walle r = MOOList [ "", "", [ "wallet", "Waller" ] ]
#32 Mr. Spell. we r = MOOList [ "", "esab'dilnrt", [ "Weyerhauser", "wept", "Wehr", "WECo", "we" ] ]
#32 Mr. Spell. wh r = MOOList [ "", "eioa", [ "whup", "why" ] ]
#32 Mr. Spell. Franci r = MOOList [ "", "s", [ "francium", "Francine" ] ]
#32 Mr. Spell. wi r = MOOList [ "", "tcdeglnrs", [ "wizard", "wive", "wipe", "wife", "WI" ] ]
#32 Mr. Spell. Clem r = MOOList [ "", "", [ "Clemson", "clement" ] ]
#32 Mr. Spell. walko r = MOOList [ "", "", [ "walkover", "walkout" ] ]
#32 Mr. Spell. eventu r = MOOList [ "a", "", [ "eventuate", "eventual" ] ]
#32 Mr. Spell. frid r = MOOList [ "", "", [ "fridge", "Friday" ] ]
#32 Mr. Spell. France r = MOOList [ "", "", [ "Frances", "France" ] ]
#32 Mr. Spell. fria r = MOOList [ "", "", [ "friar", "friable" ] ]
#32 Mr. Spell. wo r = MOOList [ "", "mreklnouv", [ "wow", "Wotan", "wop", "wobble" ] ]
#32 Mr. Spell. poet r = MOOList [ "", "", [ "poetry", "poetic", "poet" ] ]
#32 Mr. Spell. marsha r = MOOList [ "", "l", [ "Marsha" ] ]
#32 Mr. Spell. wr r = MOOList [ "", "aeio", [ "wry" ] ]
#32 Mr. Spell. fril r = MOOList [ "l", "", [ "frilly", "frill" ] ]
#32 Mr. Spell. euphe r = MOOList [ "mis", "", [ "euphemist", "euphemism" ] ]
#32 Mr. Spell. cheru r = MOOList [ "b", "", [ "cherubim", "cherub" ] ]
#32 Mr. Spell. Pain r = MOOList [ "", "t", [ "painstaking", "painful", "Paine", "pain" ] ]
#32 Mr. Spell. lambd r = MOOList [ "a", "", [ "lambdahouse", "lambda" ] ]
#32 Mr. Spell. weight r = MOOList [ "", "", [ "weighty", "weight" ] ]
#32 Mr. Spell. performa r = MOOList [ "nce", "", [ "performances", "performance" ] ]
#32 Mr. Spell. chevr r = MOOList [ "o", "", [ "chevron", "Chevrolet" ] ]
#32 Mr. Spell. dissi r = MOOList [ "", "", [ "dissipate", "dissident" ] ]
#32 Mr. Spell. xe r = MOOList [ "", "nr", [ ] ]
#32 Mr. Spell. disse r = MOOList [ "", "m", [ "dissertation", "dissension" ] ]
#32 Mr. Spell. burea r = MOOList [ "u", "c", [ "bureau" ] ]
#32 Mr. Spell. podi r = MOOList [ "", "", [ "podium", "podia" ] ]
#32 Mr. Spell. complementa r = MOOList [ "", "r", [ "complementation" ] ]
#32 Mr. Spell. dista r = MOOList [ "", "", [ "distant", "distal", "distaff" ] ]
#32 Mr. Spell. burde r = MOOList [ "n", "", [ "burdensome", "burden" ] ]
#32 Mr. Spell. asym r = MOOList [ "", "p", [ "asymmetry" ] ]
#32 Mr. Spell. asyn r = MOOList [ "chron", "", [ "asynchrony", "asynchronous" ] ]
#32 Mr. Spell. varia r = MOOList [ "", "n", [ "variate", "variac", "variable" ] ]
#32 Mr. Spell. astero r = MOOList [ "id", "", [ "asteroidal", "asteroid" ] ]
#32 Mr. Spell. delphin r = MOOList [ "", "", [ "Delphinus", "delphinium", "delphine" ] ]
#32 Mr. Spell. quiet r = MOOList [ "", "", [ "quietus", "quiet" ] ]
#32 Mr. Spell. azi r = MOOList [ "muth", "", [ "azimuthal", "azimuth" ] ]
#32 Mr. Spell. xy r = MOOList [ "l", "e", [ "xylophone" ] ]
#32 Mr. Spell. distr r = MOOList [ "", "i", [ "distraught" ] ]
#32 Mr. Spell. carci r = MOOList [ "no", "g", [ "carcinoma" ] ]
#32 Mr. Spell. distu r = MOOList [ "rb", "", [ "disturbance", "disturb" ] ]
#32 Mr. Spell. Eric r = MOOList [ "", "", [ "Ericsson", "Erickson", "Erich", "Eric" ] ]
#32 Mr. Spell. varie r = MOOList [ "", "", [ "variety", "variegate" ] ]
#32 Mr. Spell. ya r = MOOList [ "", "cklmnprw", [ "Yates", "Yaqui", "Yaounde", "yah" ] ]
#32 Mr. Spell. ye r = MOOList [ "", "alos", [ "Yerkes", "yen", "Yemen", "yet", "ye" ] ]
#32 Mr. Spell. disti r = MOOList [ "", "ln", [ ] ]
#32 Mr. Spell. yi r = MOOList [ "", "p", [ "yin", "yield", "Yiddish" ] ]
#32 Mr. Spell. Pyg r = MOOList [ "m", "", [ "pygmy", "Pygmalion" ] ]
#32 Mr. Spell. excelle r = MOOList [ "", "", [ "excellent", "excelled" ] ]
#32 Mr. Spell. yo r = MOOList [ "", "udgknrs", [ "yow", "yolk" ] ]
#32 Mr. Spell. legate r = MOOList [ "", "", [ "legatee", "legate" ] ]
#32 Mr. Spell. Prie r = MOOList [ "st", "", [ "Priestley", "priest" ] ]
#32 Mr. Spell. yt r = MOOList [ "t", "", [ "yttrium", "ytterbium" ] ]
#32 Mr. Spell. yu r = MOOList [ "", "cgk", [ "yule", "yuh" ] ]
#32 Mr. Spell. carbu r = MOOList [ "", "", [ "carburetor", "carbuncle" ] ]
#32 Mr. Spell. guil r = MOOList [ "", "dlt", [ "Guilford", "guile" ] ]
#32 Mr. Spell. confere r = MOOList [ "", "", [ "conference", "conferee" ] ]
#32 Mr. Spell. Clay r = MOOList [ "", "", [ "Clayton", "clay" ] ]
#32 Mr. Spell. equat r = MOOList [ "", "", [ "equatorial", "equate" ] ]
#32 Mr. Spell. Pyt r = MOOList [ "h", "a", [ "python" ] ]
#32 Mr. Spell. za r = MOOList [ "", "gn", [ "zazen", "zap", "Zambia", "Zaire", "Zachary" ] ]
#32 Mr. Spell. spoke r = MOOList [ "", "s", [ "spoken", "spoke" ] ]
#32 Mr. Spell. homic r = MOOList [ "id", "", [ "homicide", "homicidal" ] ]
#32 Mr. Spell. burge r = MOOList [ "", "", [ "burgess", "burgeon" ] ]
#32 Mr. Spell. pleas r = MOOList [ "", "e", [ "pleasure", "pleasant" ] ]
#32 Mr. Spell. zi r = MOOList [ "", "noprg", [ "Ziegler", "Zimmerman", "zilch" ] ]
#32 Mr. Spell. abut r = MOOList [ "", "t", [ "abut" ] ]
#32 Mr. Spell. zo r = MOOList [ "", "dmor", [ "zounds", "zone", "Zoe" ] ]
#32 Mr. Spell. caret r = MOOList [ "", "", [ "caretaker", "caret" ] ]
#32 Mr. Spell. guid r = MOOList [ "", "e", [ "guidance" ] ]
#32 Mr. Spell. asteri r = MOOList [ "", "", [ "asterisk", "asteria" ] ]
#32 Mr. Spell. justic r = MOOList [ "", "", [ "justiciable", "justice" ] ]
#32 Mr. Spell. fres r = MOOList [ "", "chn", [ ] ]
#32 Mr. Spell. fade r = MOOList [ "", "", [ "fadeout", "fade" ] ]
#32 Mr. Spell. caref r = MOOList [ "", "u", [ "carefree" ] ]
#32 Mr. Spell. caree r = MOOList [ "", "", [ "career", "careen" ] ]
#32 Mr. Spell. abus r = MOOList [ "", "", [ "abusive", "abuse", "abusable" ] ]
#32 Mr. Spell. faci r = MOOList [ "", "l", [ "facial" ] ]
#32 Mr. Spell. indiscre r = MOOList [ "", "", [ "indiscretion", "indiscreet" ] ]
#32 Mr. Spell. attributi r = MOOList [ "", "", [ "attributive", "attribution" ] ]
#32 Mr. Spell. conferr r = MOOList [ "", "", [ "conferring", "conferred", "conferrable" ] ]
#32 Mr. Spell. buret r = MOOList [ "", "", [ "burette", "buret" ] ]
#32 Mr. Spell. Clar r = MOOList [ "", "eik", [ "Clara" ] ]
#32 Mr. Spell. frea r = MOOList [ "k", "", [ "freakish", "freak" ] ]
#32 Mr. Spell. experienc r = MOOList [ "e", "", [ "experiences", "experience" ] ]
#32 Mr. Spell. fact r = MOOList [ "", "o", [ "factual", "factious", "fact" ] ]
#32 Mr. Spell. Clau r = MOOList [ "", "ds", [ ] ]
#32 Mr. Spell. free r = MOOList [ "", "dhmtw", [ "freeze", "freestone", "Freeport", "freeing", "freeboot", "free" ] ]
#32 Mr. Spell. dodecahedra r = MOOList [ "", "", [ "dodecahedral", "dodecahedra" ] ]
#32 Mr. Spell. brandy r = MOOList [ "", "", [ "brandywine", "brandy" ] ]
#32 Mr. Spell. bewi r = MOOList [ "", "", [ "bewitch", "bewilder" ] ]
#32 Mr. Spell. satisfa r = MOOList [ "ct", "", [ "satisfactory", "satisfaction" ] ]
#32 Mr. Spell. Promet r = MOOList [ "h", "e", [ "promethium" ] ]
#32 Mr. Spell. litto r = MOOList [ "", "", [ "littoral", "Litton" ] ]
#32 Mr. Spell. magneti r = MOOList [ "", "", [ "magnetite", "magnetic" ] ]
#32 Mr. Spell. face r = MOOList [ "", "t", [ "faces", "faceplate", "face" ] ]
#32 Mr. Spell. admira r = MOOList [ "", "l", [ "admiration" ] ]
#32 Mr. Spell. littl r = MOOList [ "e", "", [ "Littleton", "littleneck", "little" ] ]
#32 Mr. Spell. abst r = MOOList [ "", "r", [ "abstinent", "abstention", "abstain" ] ]
#32 Mr. Spell. thron r = MOOList [ "", "", [ "throng", "throne" ] ]
#32 Mr. Spell. Pret r = MOOList [ "", "", [ "pretty", "Pretoria", "pretentious" ] ]
#32 Mr. Spell. regulat r = MOOList [ "", "", [ "regulatory", "regulate" ] ]
#32 Mr. Spell. Pres r = MOOList [ "", "ceistu", [ "Presbyterian" ] ]
#32 Mr. Spell. fabr r = MOOList [ "ic", "", [ "fabricate", "fabric" ] ]
#32 Mr. Spell. ruff r = MOOList [ "", "", [ "ruffle", "ruffian" ] ]
#32 Mr. Spell. bewa r = MOOList [ "", "", [ "beware", "bewail" ] ]
#32 Mr. Spell. throa r = MOOList [ "t", "", [ "throaty", "throat" ] ]
#32 Mr. Spell. covera r = MOOList [ "", "", [ "coverall", "coverage" ] ]
#32 Mr. Spell. astr r = MOOList [ "", "aio", [ ] ]
#32 Mr. Spell. absc r = MOOList [ "", "i", [ "abscess" ] ]
#32 Mr. Spell. thall r = MOOList [ "", "", [ "thallophyte", "thallium" ] ]
#32 Mr. Spell. beve r = MOOList [ "", "r", [ "bevel" ] ]
#32 Mr. Spell. abse r = MOOList [ "nt", "e", [ "absentminded", "absentia", "absent" ] ]
#32 Mr. Spell. sab r = MOOList [ "", "bi", [ "sabra", "sabotage", "sable" ] ]
#32 Mr. Spell. sac r = MOOList [ "", "hr", [ "sack", "saccharine", "sac" ] ]
#32 Mr. Spell. sad r = MOOList [ "", "di", [ "Sadler", "sad" ] ]
#32 Mr. Spell. cargo r = MOOList [ "", "", [ "cargoes", "cargo" ] ]
#32 Mr. Spell. solid r = MOOList [ "", "i", [ "solidus", "solidarity", "solid" ] ]
#32 Mr. Spell. saf r = MOOList [ "", "e", [ "saffron", "safari" ] ]
#32 Mr. Spell. chancel r = MOOList [ "", "", [ "chancellor", "chancel" ] ]
#32 Mr. Spell. solic r = MOOList [ "it", "o", [ "solicitude", "solicitation", "solicit" ] ]
#32 Mr. Spell. sag r = MOOList [ "", "aei", [ "saguaro", "sago", "sagging", "sag" ] ]
#32 Mr. Spell. sniff r = MOOList [ "", "", [ "sniffle", "sniff" ] ]
#32 Mr. Spell. abso r = MOOList [ "", "lr", [ ] ]
#32 Mr. Spell. sam r = MOOList [ "", "opu", [ "Samson", "Sammy", "same", "samba", "samarium", "Sam" ] ]
#32 Mr. Spell. reduc r = MOOList [ "", "e", [ "reducible" ] ]
#32 Mr. Spell. burgl r = MOOList [ "ar", "", [ "burglary", "burglarproof", "burglar" ] ]
#32 Mr. Spell. aste r = MOOList [ "r", "io", [ "astern", "aster" ] ]
#32 Mr. Spell. Prea r = MOOList [ "ch", "", [ "preachy", "preach" ] ]
#32 Mr. Spell. asti r = MOOList [ "gmat", "", [ "astigmatic", "astigmat" ] ]
#32 Mr. Spell. solit r = MOOList [ "", "a", [ "solitude", "soliton" ] ]
#32 Mr. Spell. disrupti r = MOOList [ "", "", [ "disruptive", "disruption" ] ]
#32 Mr. Spell. omnip r = MOOList [ "", "", [ "omnipresent", "omnipotent" ] ]
#32 Mr. Spell. metr r = MOOList [ "", "o", [ "metric" ] ]
#32 Mr. Spell. abra r = MOOList [ "", "ms", [ "Abraham", "abrade" ] ]
#32 Mr. Spell. assu r = MOOList [ "", "mr", [ "assuage" ] ]
#32 Mr. Spell. abre r = MOOList [ "a", "", [ "abreast", "abreact" ] ]
#32 Mr. Spell. flirta r = MOOList [ "tio", "", [ "flirtatious", "flirtation" ] ]
#32 Mr. Spell. homem r = MOOList [ "a", "", [ "homemake", "homemade" ] ]
#32 Mr. Spell. guer r = MOOList [ "", "", [ "guerrilla", "guernsey", "guerdon" ] ]
#32 Mr. Spell. abri r = MOOList [ "dg", "", [ "abridgment", "abridge" ] ]
#32 Mr. Spell. spook r = MOOList [ "", "", [ "spooky", "spook" ] ]
#32 Mr. Spell. Levi r = MOOList [ "", "nt", [ "Levis", "Levi" ] ]
#32 Mr. Spell. homeb r = MOOList [ "", "u", [ "homebound" ] ]
#32 Mr. Spell. mett r = MOOList [ "le", "", [ "mettlesome", "mettle" ] ]
#32 Mr. Spell. abro r = MOOList [ "", "", [ "abrogate", "abroad" ] ]
#32 Mr. Spell. gues r = MOOList [ "", "s", [ "guest" ] ]
#32 Mr. Spell. asta r = MOOList [ "", "", [ "astatine", "Astarte" ] ]
#32 Mr. Spell. rudi r = MOOList [ "ment", "", [ "rudimentary", "rudiment" ] ]
#32 Mr. Spell. homew r = MOOList [ "", "", [ "homework", "homeward" ] ]
#32 Mr. Spell. betr r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. assa r = MOOList [ "", "is", [ "assay", "assault", "Assam" ] ]
#32 Mr. Spell. sap r = MOOList [ "", "ip", [ "sapsucker", "saponify", "sapling", "sap" ] ]
#32 Mr. Spell. bett r = MOOList [ "", "e", [ "Betty", "bettor" ] ]
#32 Mr. Spell. meta r = MOOList [ "", "blmp", [ ] ]
#32 Mr. Spell. frau r = MOOList [ "", "d", [ "fraught", "Frau" ] ]
#32 Mr. Spell. asse r = MOOList [ "", "ms", [ "asset", "assert", "assent" ] ]
#32 Mr. Spell. spoon r = MOOList [ "", "", [ "spoonful", "spoon" ] ]
#32 Mr. Spell. sas r = MOOList [ "", "hk", [ "sassafras" ] ]
#32 Mr. Spell. sat r = MOOList [ "", "aiu", [ "satyr", "satellite", "sat" ] ]
#32 Mr. Spell. fraz r = MOOList [ "", "", [ "frazzle", "Frazier" ] ]
#32 Mr. Spell. sau r = MOOList [ "", "cdlt", [ "sausage", "Saunders", "sauerkraut" ] ]
#32 Mr. Spell. betw r = MOOList [ "", "", [ "betwixt", "between" ] ]
#32 Mr. Spell. sav r = MOOList [ "", "aoi", [ "savvy", "save" ] ]
#32 Mr. Spell. homeo r = MOOList [ "", "m", [ "homeowner", "homeopath" ] ]
#32 Mr. Spell. assi r = MOOList [ "", "dgms", [ ] ]
#32 Mr. Spell. saw r = MOOList [ "", "ft", [ "sawyer", "sawmill", "sawdust", "sawbelly", "saw" ] ]
#32 Mr. Spell. fraction r = MOOList [ "", "", [ "fractionate", "fraction" ] ]
#32 Mr. Spell. sax r = MOOList [ "", "o", [ "saxifrage", "sax" ] ]
#32 Mr. Spell. meth r = MOOList [ "", "aouy", [ "methionine" ] ]
#32 Mr. Spell. say r = MOOList [ "", "", [ "says", "saying", "say" ] ]
#32 Mr. Spell. rudd r = MOOList [ "", "", [ "ruddy", "rudder" ] ]
#32 Mr. Spell. meti r = MOOList [ "", "", [ "metier", "meticulous" ] ]
#32 Mr. Spell. homes r = MOOList [ "", "", [ "homestead", "homesick" ] ]
#32 Mr. Spell. asso r = MOOList [ "", "c", [ "assort", "assonant" ] ]
#32 Mr. Spell. admitt r = MOOList [ "", "", [ "admitting", "admitted", "admittance" ] ]
#32 Mr. Spell. mete r = MOOList [ "", "o", [ "meter", "mete" ] ]
#32 Mr. Spell. sca r = MOOList [ "", "blmnprt", [ "scavenge", "scaup", "scaffold" ] ]
#32 Mr. Spell. frag r = MOOList [ "", "m", [ "fragrant", "fragile" ] ]
#32 Mr. Spell. beta r = MOOList [ "", "", [ "betatron", "beta" ] ]
#32 Mr. Spell. bap r = MOOList [ "tis", "mt", [ ] ]
#32 Mr. Spell. meso r = MOOList [ "", "", [ "Mesozoic", "Mesopotamia", "meson", "mesoderm" ] ]
#32 Mr. Spell. bar r = MOOList [ "", "bcegiklnort", [ "barycentric", "Barstow", "barfly", "bard", "bar" ] ]
#32 Mr. Spell. thank r = MOOList [ "", "", [ "thanksgiving", "thankful", "thank" ] ]
#32 Mr. Spell. clothes r = MOOList [ "", "m", [ "clothesline", "clotheshorse", "clothesbrush" ] ]
#32 Mr. Spell. bas r = MOOList [ "", "aehikst", [ "basophilic" ] ]
#32 Mr. Spell. sculpt r = MOOList [ "", "u", [ "sculptor", "sculpt" ] ]
#32 Mr. Spell. sce r = MOOList [ "", "n", [ "sceptic" ] ]
#32 Mr. Spell. colloqui r = MOOList [ "", "a", [ "colloquium" ] ]
#32 Mr. Spell. tempera r = MOOList [ "", "t", [ "temperance", "tempera" ] ]
#32 Mr. Spell. beth r = MOOList [ "", "e", [ "bethought", "Bethlehem", "beth" ] ]
#32 Mr. Spell. bau r = MOOList [ "", "d", [ "bauxite", "Bausch", "Bauhaus", "Bauer", "bauble" ] ]
#32 Mr. Spell. vocabu r = MOOList [ "lar", "", [ "vocabulary", "vocabularian" ] ]
#32 Mr. Spell. frai r = MOOList [ "l", "", [ "frailty", "frail" ] ]
#32 Mr. Spell. throw r = MOOList [ "", "", [ "thrown", "throwback", "throwaway", "throw" ] ]
#32 Mr. Spell. baw r = MOOList [ "", "d", [ "bawl" ] ]
#32 Mr. Spell. sci r = MOOList [ "", "e", [ "scissor", "scion", "scintillate", "scimitar", "sciatica", "Sci" ] ]
#32 Mr. Spell. throu r = MOOList [ "gh", "", [ "throughput", "throughout", "through" ] ]
#32 Mr. Spell. fran r = MOOList [ "", "ck", [ "Franz", "frantic", "frangipani", "Fran" ] ]
#32 Mr. Spell. chartr r = MOOList [ "", "e", [ "chartroom" ] ]
#32 Mr. Spell. bay r = MOOList [ "", "o", [ "Bayreuth", "Bayport", "Baylor", "Bayesian", "Bayda", "bayberry", "bay" ] ]
#32 Mr. Spell. fram r = MOOList [ "", "e", [ "frambesia" ] ]
#32 Mr. Spell. scl r = MOOList [ "ero", "", [ "sclerotic", "sclerosis" ] ]
#32 Mr. Spell. frat r = MOOList [ "ern", "", [ "fraternity", "fraternal" ] ]
#32 Mr. Spell. mess r = MOOList [ "", "ia", [ "messy", "Messrs", "messenger", "mess" ] ]
#32 Mr. Spell. spong r = MOOList [ "", "", [ "spongy", "sponge" ] ]
#32 Mr. Spell. sco r = MOOList [ "", "oprtu", [ "scowl", "scold", "scoff" ] ]
#32 Mr. Spell. quill r = MOOList [ "", "", [ "quillwort", "quill" ] ]
#32 Mr. Spell. beto r = MOOList [ "", "", [ "betony", "betoken" ] ]
#32 Mr. Spell. satisfy r = MOOList [ "", "", [ "satisfying", "satisfy" ] ]
#32 Mr. Spell. exclus r = MOOList [ "i", "o", [ "exclusive" ] ]
#32 Mr. Spell. eleve r = MOOList [ "n", "", [ "eleventh", "eleven" ] ]
#32 Mr. Spell. besp r = MOOList [ "", "e", [ "bespoke" ] ]
#32 Mr. Spell. bab r = MOOList [ "", "bey", [ "baboon", "Babcock" ] ]
#32 Mr. Spell. bac r = MOOList [ "", "chikt", [ "bacon" ] ]
#32 Mr. Spell. best r = MOOList [ "", "ios", [ "bestubble", "best" ] ]
#32 Mr. Spell. bad r = MOOList [ "", "e", [ "badminton", "badland", "badinage", "badge", "bad" ] ]
#32 Mr. Spell. carib r = MOOList [ "", "", [ "caribou", "Caribbean", "Carib" ] ]
#32 Mr. Spell. baf r = MOOList [ "f", "", [ "baffle", "Baffin" ] ]
#32 Mr. Spell. bag r = MOOList [ "", "g", [ "bagpipe", "Bagley", "Baghdad", "bagatelle", "bag" ] ]
#32 Mr. Spell. Frankf r = MOOList [ "", "u", [ "Frankfort" ] ]
#32 Mr. Spell. spont r = MOOList [ "ane", "", [ "spontaneous", "spontaneity" ] ]
#32 Mr. Spell. frac r = MOOList [ "t", "i", [ "fracture" ] ]
#32 Mr. Spell. mesc r = MOOList [ "al", "", [ "mescaline", "mescal" ] ]
#32 Mr. Spell. reci r = MOOList [ "", "pt", [ "Recife" ] ]
#32 Mr. Spell. reck r = MOOList [ "", "", [ "reckon", "reck" ] ]
#32 Mr. Spell. recl r = MOOList [ "", "", [ "recluse", "recline", "reclamation" ] ]
#32 Mr. Spell. recei r = MOOList [ "", "v", [ "receipt" ] ]
#32 Mr. Spell. acre r = MOOList [ "", "", [ "acreage", "acre" ] ]
#32 Mr. Spell. reco r = MOOList [ "", "nr", [ "recovery", "recompense" ] ]
#32 Mr. Spell. recen r = MOOList [ "t", "", [ "recently", "recent" ] ]
#32 Mr. Spell. recep r = MOOList [ "t", "i", [ "receptor", "receptacle" ] ]
#32 Mr. Spell. rece r = MOOList [ "", "ipsn", [ ] ]
#32 Mr. Spell. reces r = MOOList [ "s", "i", [ "recess" ] ]
#32 Mr. Spell. acro r = MOOList [ "", "b", [ "across", "acropolis", "acronym" ] ]
#32 Mr. Spell. scr r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. despot r = MOOList [ "", "", [ "despotic", "despot" ] ]
#32 Mr. Spell. scu r = MOOList [ "", "flrt", [ "scum", "scud", "scuba" ] ]
#32 Mr. Spell. shep r = MOOList [ "", "", [ "Sheppard", "shepherd", "Shepard" ] ]
#32 Mr. Spell. scy r = MOOList [ "", "t", [ "Scylla" ] ]
#32 Mr. Spell. sher r = MOOList [ "", "irw", [ "Sherman", "Sherlock", "sherbet", "Sheraton" ] ]
#32 Mr. Spell. Rolli r = MOOList [ "", "n", [ "rollick" ] ]
#32 Mr. Spell. rebu r = MOOList [ "", "t", [ "rebuke" ] ]
#32 Mr. Spell. atro r = MOOList [ "", "cp", [ ] ]
#32 Mr. Spell. aspir r = MOOList [ "", "a", [ "aspirin", "aspire" ] ]
#32 Mr. Spell. sec r = MOOList [ "", "elortu", [ "secant", "sec" ] ]
#32 Mr. Spell. sed r = MOOList [ "", "aeiu", [ "sedge" ] ]
#32 Mr. Spell. see r = MOOList [ "", "dpm", [ "seethe", "seersucker", "seen", "seek", "seeing", "seeable", "see" ] ]
#32 Mr. Spell. seg r = MOOList [ "", "mr", [ "Segundo", "Segovia" ] ]
#32 Mr. Spell. shen r = MOOList [ "an", "", [ "shenanigan", "Shenandoah" ] ]
#32 Mr. Spell. sei r = MOOList [ "", "sz", [ "Seidel" ] ]
#32 Mr. Spell. hygr r = MOOList [ "o", "", [ "hygroscopic", "hygrometer" ] ]
#32 Mr. Spell. shea r = MOOList [ "", "rt", [ "sheave", "sheaf", "Shea" ] ]
#32 Mr. Spell. sel r = MOOList [ "", "efl", [ "Selwyn", "selves", "seltzer", "Selma", "Selkirk", "seldom" ] ]
#32 Mr. Spell. sem r = MOOList [ "", "ai", [ "semper", "semester", "semblance" ] ]
#32 Mr. Spell. permitt r = MOOList [ "", "", [ "permitting", "permitted" ] ]
#32 Mr. Spell. sen r = MOOList [ "", "aeiostd", [ "sen" ] ]
#32 Mr. Spell. despon r = MOOList [ "d", "", [ "despondent", "despond" ] ]
#32 Mr. Spell. shee r = MOOList [ "", "p", [ "sheet", "sheer", "sheen", "Sheehan" ] ]
#32 Mr. Spell. sep r = MOOList [ "", "atu", [ "Sepoy", "sepia" ] ]
#32 Mr. Spell. rebe r = MOOList [ "", "l", [ "Rebecca" ] ]
#32 Mr. Spell. seq r = MOOList [ "", "u", [ "seq" ] ]
#32 Mr. Spell. Brookl r = MOOList [ "", "", [ "Brooklyn", "Brookline" ] ]
#32 Mr. Spell. polon r = MOOList [ "", "", [ "polonium", "polonaise" ] ]
#32 Mr. Spell. restra r = MOOList [ "in", "", [ "restraint", "restrain" ] ]
#32 Mr. Spell. Esch r = MOOList [ "e", "", [ "eschew", "Escherichia", "escheat" ] ]
#32 Mr. Spell. patho r = MOOList [ "", "g", [ "pathos", "pathology" ] ]
#32 Mr. Spell. reas r = MOOList [ "on", "a", [ "reasons", "reason" ] ]
#32 Mr. Spell. locom r = MOOList [ "ot", "io", [ "locomote" ] ]
#32 Mr. Spell. sea r = MOOList [ "", "fglmnrstw", [ "seaquake", "seaport", "seahorse", "seacoast", "seaboard", "sea" ] ]
#32 Mr. Spell. memoran r = MOOList [ "d", "", [ "memorandum", "memoranda" ] ]
#32 Mr. Spell. ignor r = MOOList [ "", "a", [ "ignore" ] ]
#32 Mr. Spell. impai r = MOOList [ "r", "", [ "impaired", "impair" ] ]
#32 Mr. Spell. impal r = MOOList [ "", "", [ "impalpable", "impale" ] ]
#32 Mr. Spell. Hanov r = MOOList [ "er", "", [ "Hanoverian", "Hanover" ] ]
#32 Mr. Spell. real r = MOOList [ "", "t", [ "really", "realm", "realisable", "real" ] ]
#32 Mr. Spell. Micron r = MOOList [ "", "", [ "Micronesia", "micron" ] ]
#32 Mr. Spell. impar r = MOOList [ "t", "", [ "impartial", "impartation", "impart" ] ]
#32 Mr. Spell. civi r = MOOList [ "", "l", [ "civic" ] ]
#32 Mr. Spell. retic r = MOOList [ "", "u", [ "reticent" ] ]
#32 Mr. Spell. impas r = MOOList [ "s", "i", [ "impasse", "impassable" ] ]
#32 Mr. Spell. getty r = MOOList [ "", "", [ "Gettysburg", "Getty" ] ]
#32 Mr. Spell. reac r = MOOList [ "", "th", [ ] ]
#32 Mr. Spell. read r = MOOList [ "", "", [ "ready", "readout", "read" ] ]
#32 Mr. Spell. bea r = MOOList [ "", "cdrstu", [ "beaver", "bean", "beam", "beak" ] ]
#32 Mr. Spell. ser r = MOOList [ "", "aegipv", [ "serum", "serology", "sermon", "serf", "Serbia" ] ]
#32 Mr. Spell. ses r = MOOList [ "", "", [ "session", "sesame" ] ]
#32 Mr. Spell. set r = MOOList [ "", "t", [ "setup", "setscrew", "Seton", "Seth", "setback", "set" ] ]
#32 Mr. Spell. sev r = MOOList [ "", "e", [ "Seville" ] ]
#32 Mr. Spell. monet r = MOOList [ "ar", "", [ "monetary", "monetarism" ] ]
#32 Mr. Spell. sew r = MOOList [ "", "a", [ "sewn", "sewerage", "sew" ] ]
#32 Mr. Spell. unip r = MOOList [ "", "", [ "uniprocessor", "unipolar", "uniplex" ] ]
#32 Mr. Spell. unis r = MOOList [ "", "", [ "unison", "unisex" ] ]
#32 Mr. Spell. decree r = MOOList [ "", "", [ "decreeing", "decree" ] ]
#32 Mr. Spell. slate r = MOOList [ "", "", [ "slater", "slate" ] ]
#32 Mr. Spell. Linds r = MOOList [ "", "", [ "Lindstrom", "Lindsey", "Lindsay" ] ]
#32 Mr. Spell. unit r = MOOList [ "", "ae", [ "unity", "unit" ] ]
#32 Mr. Spell. bes r = MOOList [ "", "eipst", [ "besotted", "besmirch" ] ]
#32 Mr. Spell. insen r = MOOList [ "si", "", [ "insensitive", "insensible" ] ]
#32 Mr. Spell. bet r = MOOList [ "", "aehorstw", [ "betide", "bet" ] ]
#32 Mr. Spell. bev r = MOOList [ "", "e", [ "bevy" ] ]
#32 Mr. Spell. unim r = MOOList [ "od", "", [ "unimodular", "unimodal" ] ]
#32 Mr. Spell. bew r = MOOList [ "", "ai", [ "bewhisker" ] ]
#32 Mr. Spell. unio r = MOOList [ "n", "", [ "unions", "union" ] ]
#32 Mr. Spell. capit r = MOOList [ "", "ao", [ "capitulate" ] ]
#32 Mr. Spell. bey r = MOOList [ "", "", [ "beyond", "bey" ] ]
#32 Mr. Spell. tally r = MOOList [ "", "", [ "tallyho", "tally" ] ]
#32 Mr. Spell. uproa r = MOOList [ "r", "", [ "uproarious", "uproar" ] ]
#32 Mr. Spell. Febr r = MOOList [ "", "", [ "February", "febrile" ] ]
#32 Mr. Spell. occurre r = MOOList [ "", "", [ "occurrent", "occurred" ] ]
#32 Mr. Spell. henri r = MOOList [ "", "", [ "Henrietta", "Henri" ] ]
#32 Mr. Spell. inser r = MOOList [ "t", "", [ "insertion", "insert" ] ]
#32 Mr. Spell. unid r = MOOList [ "i", "", [ "unidirectional", "unidimensional" ] ]
#32 Mr. Spell. unif r = MOOList [ "", "", [ "unify", "uniform" ] ]
#32 Mr. Spell. she' r = MOOList [ "", "", [ "she'll", "she'd" ] ]
#32 Mr. Spell. nitr r = MOOList [ "", "io", [ "nitrate" ] ]
#32 Mr. Spell. money r = MOOList [ "", "", [ "moneywort", "moneymake", "money" ] ]
#32 Mr. Spell. brothe r = MOOList [ "", "", [ "brother", "brothel" ] ]
#32 Mr. Spell. bec r = MOOList [ "", "ak", [ "become", "Bechtel" ] ]
#32 Mr. Spell. bed r = MOOList [ "", "firs", [ "bedtime", "bedpost", "bedlam", "bedbug", "bedazzle", "bed" ] ]
#32 Mr. Spell. bef r = MOOList [ "", "aio", [ "befuddle", "befell" ] ]
#32 Mr. Spell. Lindb r = MOOList [ "erg", "", [ "Lindbergh", "Lindberg" ] ]
#32 Mr. Spell. beg r = MOOList [ "", "egiou", [ "begrudge", "began", "beg" ] ]
#32 Mr. Spell. citr r = MOOList [ "", "o", [ "citrus", "citric", "citrate" ] ]
#32 Mr. Spell. beh r = MOOList [ "", "ae", [ "behold", "behind" ] ]
#32 Mr. Spell. bei r = MOOList [ "", "", [ "Beirut", "being", "beige", "Beijing" ] ]
#32 Mr. Spell. retin r = MOOList [ "", "a", [ "retinue" ] ]
#32 Mr. Spell. Hanna r = MOOList [ "", "", [ "Hannah", "Hanna" ] ]
#32 Mr. Spell. hypoth r = MOOList [ "", "ae", [ "hypothyroid" ] ]
#32 Mr. Spell. insec r = MOOList [ "", "t", [ "insecure" ] ]
#32 Mr. Spell. city r = MOOList [ "", "", [ "citywide", "cityscape", "city" ] ]
#32 Mr. Spell. bem r = MOOList [ "", "A", [ "bemuse", "bemoan" ] ]
#32 Mr. Spell. retir r = MOOList [ "e", "", [ "retiree", "retire" ] ]
#32 Mr. Spell. Green r = MOOList [ "", "besw", [ "Greenland", "greenish", "greenhouse", "greengrocer", "Greenfield", "green" ] ]
#32 Mr. Spell. descend r = MOOList [ "", "", [ "descendent", "descendant", "descend" ] ]
#32 Mr. Spell. ben r = MOOList [ "", "cdegintz", [ "Benson", "Benjamin", "Ben" ] ]
#32 Mr. Spell. beq r = MOOList [ "ue", "", [ "bequest", "bequeath" ] ]
#32 Mr. Spell. ber r = MOOList [ "", "egiklmnrty", [ "Berwick", "berserk", "berate" ] ]
#32 Mr. Spell. atom r = MOOList [ "", "", [ "atomic", "atom" ] ]
#32 Mr. Spell. cita r = MOOList [ "", "", [ "citation", "citadel" ] ]
#32 Mr. Spell. aton r = MOOList [ "", "", [ "atone", "atonal" ] ]
#32 Mr. Spell. pater r = MOOList [ "", "n", [ "Paterson", "pater" ] ]
#32 Mr. Spell. intens r = MOOList [ "", "i", [ "intense" ] ]
#32 Mr. Spell. shi r = MOOList [ "", "flmnprv", [ "shitepoke", "shish", "shield", "shibboleth" ] ]
#32 Mr. Spell. intent r = MOOList [ "", "", [ "intention", "intent" ] ]
#32 Mr. Spell. Woodl r = MOOList [ "", "a", [ "woodlot" ] ]
#32 Mr. Spell. interrupti r = MOOList [ "", "", [ "interruption", "interruptible" ] ]
#32 Mr. Spell. recip r = MOOList [ "", "r", [ "recipient", "recipe" ] ]
#32 Mr. Spell. pollo r = MOOList [ "", "", [ "polloi", "pollock" ] ]
#32 Mr. Spell. sho r = MOOList [ "", "cdeoprtuvw", [ "shone", "shoji", "shoal" ] ]
#32 Mr. Spell. connota r = MOOList [ "ti", "", [ "connotative", "connotation" ] ]
#32 Mr. Spell. citi r = MOOList [ "", "z", [ "cities" ] ]
#32 Mr. Spell. syco r = MOOList [ "phant", "", [ "sycophantic", "sycophant" ] ]
#32 Mr. Spell. recit r = MOOList [ "a", "", [ "recitative", "recital" ] ]
#32 Mr. Spell. McDon r = MOOList [ "", "", [ "McDonnell", "McDonald" ] ]
#32 Mr. Spell. hydr r = MOOList [ "", "ao", [ "hydride" ] ]
#32 Mr. Spell. shr r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. pollu r = MOOList [ "", "t", [ "Pollux" ] ]
#32 Mr. Spell. shat r = MOOList [ "t", "e", [ "Shattuck" ] ]
#32 Mr. Spell. shav r = MOOList [ "e", "", [ "shaven", "shave" ] ]
#32 Mr. Spell. shaw r = MOOList [ "", "", [ "Shawnee", "shawl", "shaw" ] ]
#32 Mr. Spell. intend r = MOOList [ "", "", [ "intended", "intendant", "intend" ] ]
#32 Mr. Spell. slave r = MOOList [ "", "", [ "slavery", "slave" ] ]
#32 Mr. Spell. Inju r = MOOList [ "", "nr", [ "injustice", "injudicious" ] ]
#32 Mr. Spell. marque r = MOOList [ "", "", [ "Marquette", "marquess", "marquee", "marque" ] ]
#32 Mr. Spell. shal r = MOOList [ "", "l", [ "shalom", "shale" ] ]
#32 Mr. Spell. Algeb r = MOOList [ "ra", "", [ "algebraic", "algebra" ] ]
#32 Mr. Spell. slavi r = MOOList [ "", "", [ "slavish", "Slavic" ] ]
#32 Mr. Spell. sham r = MOOList [ "", "e", [ "shamrock", "shampoo", "shamble", "sham" ] ]
#32 Mr. Spell. shan r = MOOList [ "", "t", [ "shan't", "Shannon", "shank", "Shanghai" ] ]
#32 Mr. Spell. sha r = MOOList [ "", "cdfgklmnprtvw", [ "shay", "Shasta", "shah", "shabby" ] ]
#32 Mr. Spell. shar r = MOOList [ "", "ep", [ "Sharon", "shark", "Shari", "shard" ] ]
#32 Mr. Spell. paten r = MOOList [ "t", "", [ "patentee", "patent" ] ]
#32 Mr. Spell. shad r = MOOList [ "", "o", [ "shady", "shadflower", "shade", "shadbush", "shad" ] ]
#32 Mr. Spell. Irish r = MOOList [ "", "m", [ "Irish" ] ]
#32 Mr. Spell. sig r = MOOList [ "", "hmn", [ ] ]
#32 Mr. Spell. shag r = MOOList [ "", "g", [ "shagbark", "shag" ] ]
#32 Mr. Spell. stile r = MOOList [ "", "", [ "stiletto", "stile" ] ]
#32 Mr. Spell. sil r = MOOList [ "", "aikltv", [ "silo", "silhouette", "silent" ] ]
#32 Mr. Spell. sim r = MOOList [ "", "imopu", [ "Sims", "sima" ] ]
#32 Mr. Spell. shak r = MOOList [ "", "e", [ "shaky", "shako" ] ]
#32 Mr. Spell. osteop r = MOOList [ "", "a", [ "osteoporosis" ] ]
#32 Mr. Spell. sir r = MOOList [ "", "e", [ "sirs", "Sirius", "sir" ] ]
#32 Mr. Spell. still r = MOOList [ "", "", [ "stillwater", "stillbirth", "still" ] ]
#32 Mr. Spell. sis r = MOOList [ "", "ty", [ "siskin", "sisal", "sis" ] ]
#32 Mr. Spell. sit r = MOOList [ "", "u", [ "site", "sit" ] ]
#32 Mr. Spell. shac r = MOOList [ "k", "", [ "shackle", "shack" ] ]
#32 Mr. Spell. shu r = MOOList [ "", "dfnt", [ "Shulman", "shuck", "Shu" ] ]
#32 Mr. Spell. David r = MOOList [ "", "", [ "Davidson", "David" ] ]
#32 Mr. Spell. swath r = MOOList [ "", "", [ "swathe", "swath" ] ]
#32 Mr. Spell. polka r = MOOList [ "", "", [ "polkadot", "polka" ] ]
#32 Mr. Spell. sia r = MOOList [ "", "m", [ "Sian", "sial" ] ]
#32 Mr. Spell. sid r = MOOList [ "", "e", [ "Sidney", "sidle" ] ]
#32 Mr. Spell. panthei r = MOOList [ "s", "", [ "pantheist", "pantheism" ] ]
#32 Mr. Spell. chaper r = MOOList [ "on", "", [ "chaperone", "chaperon" ] ]
#32 Mr. Spell. monad r = MOOList [ "", "", [ "monadic", "monad" ] ]
#32 Mr. Spell. memorab r = MOOList [ "", "", [ "memorable", "memorabilia" ] ]
#32 Mr. Spell. Bism r = MOOList [ "", "a", [ "bismuth" ] ]
#32 Mr. Spell. Davis r = MOOList [ "", "", [ "Davison", "Davis" ] ]
#32 Mr. Spell. fanta r = MOOList [ "s", "i", [ "fantasy", "fantastic" ] ]
#32 Mr. Spell. chlorop r = MOOList [ "", "l", [ "chlorophyll" ] ]
#32 Mr. Spell. Valer r = MOOList [ "", "", [ "Valery", "Valerie" ] ]
#32 Mr. Spell. adden r = MOOList [ "d", "", [ "addendum", "addenda", "addend" ] ]
#32 Mr. Spell. bia r = MOOList [ "", "", [ "biaxial", "bias", "bianco", "Bialystok" ] ]
#32 Mr. Spell. bib r = MOOList [ "", "l", [ "bibb", "bib" ] ]
#32 Mr. Spell. bic r = MOOList [ "", "ao", [ "bicycle", "bicker", "bichromate", "bicep" ] ]
#32 Mr. Spell. bid r = MOOList [ "", "di", [ "bide", "bid" ] ]
#32 Mr. Spell. Newto r = MOOList [ "n", "", [ "Newtonian", "newton" ] ]
#32 Mr. Spell. bie r = MOOList [ "n", "n", [ "bien" ] ]
#32 Mr. Spell. whole r = MOOList [ "", "s", [ "wholehearted", "whole" ] ]
#32 Mr. Spell. bif r = MOOList [ "", "", [ "bifurcate", "bifocal" ] ]
#32 Mr. Spell. devou r = MOOList [ "", "", [ "devout", "devour" ] ]
#32 Mr. Spell. Physic r = MOOList [ "", "", [ "physician", "physic" ] ]
#32 Mr. Spell. monas r = MOOList [ "", "t", [ "Monash" ] ]
#32 Mr. Spell. devot r = MOOList [ "", "e", [ "devotion" ] ]
#32 Mr. Spell. six r = MOOList [ "", "t", [ "sixgun", "sixfold", "six" ] ]
#32 Mr. Spell. monar r = MOOList [ "ch", "", [ "monarchy", "monarchic", "monarch" ] ]
#32 Mr. Spell. siz r = MOOList [ "", "e", [ "sizzle" ] ]
#32 Mr. Spell. inactiv r = MOOList [ "", "", [ "inactive", "inactivate" ] ]
#32 Mr. Spell. ackn r = MOOList [ "owledge", "", [ "acknowledgeable", "acknowledge" ] ]
#32 Mr. Spell. shrink r = MOOList [ "", "", [ "shrinkage", "shrink" ] ]
#32 Mr. Spell. powe r = MOOList [ "", "r", [ "Powell" ] ]
#32 Mr. Spell. powd r = MOOList [ "er", "", [ "powdery", "powderpuff", "powder" ] ]
#32 Mr. Spell. dramati r = MOOList [ "", "", [ "dramatist", "dramatic" ] ]
#32 Mr. Spell. stink r = MOOList [ "", "", [ "stinky", "stinkpot", "stink" ] ]
#32 Mr. Spell. enthusiast r = MOOList [ "", "", [ "enthusiastic", "enthusiast" ] ]
#32 Mr. Spell. ski r = MOOList [ "", "dlmnprt", [ "skiff", "ski" ] ]
#32 Mr. Spell. polit r = MOOList [ "", "i", [ "polity", "polite", "Politburo" ] ]
#32 Mr. Spell. crosswa r = MOOList [ "", "", [ "crossway", "crosswalk" ] ]
#32 Mr. Spell. biz r = MOOList [ "", "", [ "Bizet", "bizarre", "biz" ] ]
#32 Mr. Spell. sting r = MOOList [ "", "", [ "stingy", "sting" ] ]
#32 Mr. Spell. astrop r = MOOList [ "hysic", "", [ "astrophysics", "astrophysical" ] ]
#32 Mr. Spell. bless r = MOOList [ "", "", [ "blessed", "bless" ] ]
#32 Mr. Spell. polio r = MOOList [ "", "", [ "poliomyelitis", "polio" ] ]
#32 Mr. Spell. bacteria r = MOOList [ "", "", [ "bacterial", "bacteria" ] ]
#32 Mr. Spell. sku r = MOOList [ "", "l", [ "skunk" ] ]
#32 Mr. Spell. polis r = MOOList [ "", "", [ "polish", "polis" ] ]
#32 Mr. Spell. receiv r = MOOList [ "", "e", [ "receiving" ] ]
#32 Mr. Spell. bij r = MOOList [ "", "e", [ "bijouterie" ] ]
#32 Mr. Spell. bil r = MOOList [ "", "ail", [ "Biltmore", "bilk", "bilharziasis", "bilge", "bile" ] ]
#32 Mr. Spell. bim r = MOOList [ "", "eo", [ "Bimini" ] ]
#32 Mr. Spell. Sharp r = MOOList [ "", "e", [ "sharpshoot", "sharp" ] ]
#32 Mr. Spell. bin r = MOOList [ "", "adgo", [ "binuclear", "Bini", "bin" ] ]
#32 Mr. Spell. astron r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. Albani r = MOOList [ "a", "", [ "Albanian", "Albania" ] ]
#32 Mr. Spell. bio r = MOOList [ "", "mt", [ "biopsy", "biology", "biography", "biochemic" ] ]
#32 Mr. Spell. ska r = MOOList [ "t", "e", [ "skat" ] ]
#32 Mr. Spell. bip r = MOOList [ "", "a", [ "bipolar", "biplane" ] ]
#32 Mr. Spell. starli r = MOOList [ "", "", [ "starling", "starlight" ] ]
#32 Mr. Spell. bir r = MOOList [ "", "dt", [ "Birmingham", "Birgit", "birefringent", "birch", "biracial" ] ]
#32 Mr. Spell. sports r = MOOList [ "", "mw", [ ] ]
#32 Mr. Spell. bis r = MOOList [ "", "ehmt", [ "Bissau", "bisque", "bison", "biscuit" ] ]
#32 Mr. Spell. ske r = MOOList [ "", "lt", [ "skew", "skeptic", "skeet" ] ]
#32 Mr. Spell. bit r = MOOList [ "", "tu", [ "bits", "bitwise", "bitnet", "bite", "bitch", "bit" ] ]
#32 Mr. Spell. polic r = MOOList [ "", "e", [ "policies", "policy" ] ]
#32 Mr. Spell. biv r = MOOList [ "", "a", [ "bivouac" ] ]
#32 Mr. Spell. sli r = MOOList [ "", "cdmnptvg", [ ] ]
#32 Mr. Spell. poul r = MOOList [ "t", "", [ "poultry", "poultice" ] ]
#32 Mr. Spell. territ r = MOOList [ "or", "", [ "territory", "territorial" ] ]
#32 Mr. Spell. polyg r = MOOList [ "", "o", [ "polygynous" ] ]
#32 Mr. Spell. interv r = MOOList [ "", "e", [ "interviewee", "interval" ] ]
#32 Mr. Spell. unde r = MOOList [ "r", "c", [ "understand", "underling", "under" ] ]
#32 Mr. Spell. polyh r = MOOList [ "", "e", [ "Polyhymnia" ] ]
#32 Mr. Spell. monom r = MOOList [ "", "e", [ "monomial" ] ]
#32 Mr. Spell. monol r = MOOList [ "", "o", [ "monolith" ] ]
#32 Mr. Spell. patri r = MOOList [ "", "acmo", [ "patristic" ] ]
#32 Mr. Spell. interm r = MOOList [ "", "i", [ "intermediary" ] ]
#32 Mr. Spell. intern r = MOOList [ "", "a", [ "internescine", "intern" ] ]
#32 Mr. Spell. sanitar r = MOOList [ "", "", [ "sanitary", "sanitarium" ] ]
#32 Mr. Spell. monog r = MOOList [ "am", "", [ "monogamy", "monogamous" ] ]
#32 Mr. Spell. slu r = MOOList [ "", "gmr", [ "slung", "sluice", "sludge" ] ]
#32 Mr. Spell. interp r = MOOList [ "", "or", [ ] ]
#32 Mr. Spell. nympho r = MOOList [ "mania", "", [ "nymphomaniac", "nymphomania" ] ]
#32 Mr. Spell. interr r = MOOList [ "", "ou", [ "interregnum" ] ]
#32 Mr. Spell. poun r = MOOList [ "", "", [ "pound", "pounce" ] ]
#32 Mr. Spell. monoc r = MOOList [ "", "", [ "monocular", "monochromator", "Monoceros" ] ]
#32 Mr. Spell. inters r = MOOList [ "", "te", [ "intersperse" ] ]
#32 Mr. Spell. terrif r = MOOList [ "", "", [ "terrify", "terrific" ] ]
#32 Mr. Spell. intere r = MOOList [ "st", "", [ "interesting", "interest" ] ]
#32 Mr. Spell. interf r = MOOList [ "", "e", [ "interface" ] ]
#32 Mr. Spell. interi r = MOOList [ "", "", [ "interior", "interim" ] ]
#32 Mr. Spell. sla r = MOOList [ "", "cnptuv", [ "slay", "slash", "slam", "slake", "slain", "slag", "sladang", "slab" ] ]
#32 Mr. Spell. uncl r = MOOList [ "e", "", [ "unclear", "uncle" ] ]
#32 Mr. Spell. sle r = MOOList [ "", "dei", [ "slew", "sleuth", "slept", "slender" ] ]
#32 Mr. Spell. monot r = MOOList [ "", "", [ "monotreme", "monotonous" ] ]
#32 Mr. Spell. partic r = MOOList [ "", "iu", [ "particle" ] ]
#32 Mr. Spell. interc r = MOOList [ "", "e", [ "interchangeably", "intercom", "intercalate" ] ]
#32 Mr. Spell. nine r = MOOList [ "", "t", [ "Nineveh", "ninefold", "ninebark", "nine" ] ]
#32 Mr. Spell. smo r = MOOList [ "", "ko", [ "smother", "smolder", "smog" ] ]
#32 Mr. Spell. pote r = MOOList [ "nt", "i", [ "potentate", "potent" ] ]
#32 Mr. Spell. bla r = MOOList [ "", "cdimnstz", [ "blare", "Blake", "blab" ] ]
#32 Mr. Spell. smu r = MOOList [ "", "dgt", [ "Smucker" ] ]
#32 Mr. Spell. ble r = MOOList [ "", "aens", [ "blew", "blemish", "bled" ] ]
#32 Mr. Spell. bli r = MOOList [ "", "nst", [ "blizzard", "blip", "blimp", "blight" ] ]
#32 Mr. Spell. wirem r = MOOList [ "", "", [ "wiremen", "wireman" ] ]
#32 Mr. Spell. Hippoc r = MOOList [ "rat", "", [ "Hippocratic", "Hippocrates" ] ]
#32 Mr. Spell. wiret r = MOOList [ "ap", "p", [ "wiretap" ] ]
#32 Mr. Spell. sma r = MOOList [ "", "l", [ "smattering", "smash", "smart", "smack" ] ]
#32 Mr. Spell. post r = MOOList [ "", "acemopu", [ "postwar", "postscript", "postlude", "posthumous", "postgraduate", "postfix", "postdoctoral", "post" ] ]
#32 Mr. Spell. cinn r = MOOList [ "a", "", [ "cinnamon", "cinnabar" ] ]
#32 Mr. Spell. Barba r = MOOList [ "", "r", [ "Barbados" ] ]
#32 Mr. Spell. expans r = MOOList [ "", "i", [ "expanse" ] ]
#32 Mr. Spell. potb r = MOOList [ "", "", [ "potboil", "potbelly" ] ]
#32 Mr. Spell. sme r = MOOList [ "", "l", [ "smear" ] ]
#32 Mr. Spell. pota r = MOOList [ "", "st", [ "potable" ] ]
#32 Mr. Spell. anach r = MOOList [ "ronis", "", [ "anachronistic", "anachronism" ] ]
#32 Mr. Spell. smi r = MOOList [ "", "t", [ "smirk", "smile" ] ]
#32 Mr. Spell. shipbu r = MOOList [ "ild", "", [ "shipbuilding", "shipbuild" ] ]
#32 Mr. Spell. faul r = MOOList [ "", "t", [ "Faulkner" ] ]
#32 Mr. Spell. posi r = MOOList [ "t", "i", [ "positron", "posit" ] ]
#32 Mr. Spell. sulfa r = MOOList [ "", "", [ "sulfate", "sulfanilamide", "sulfa" ] ]
#32 Mr. Spell. Inde r = MOOList [ "", "cflnst", [ "index", "independent", "indemnity", "indeed", "indebted" ] ]
#32 Mr. Spell. sno r = MOOList [ "", "borw", [ "snout", "snotty" ] ]
#32 Mr. Spell. Mins r = MOOList [ "", "kt", [ ] ]
#32 Mr. Spell. faun r = MOOList [ "", "", [ "fauna", "faun" ] ]
#32 Mr. Spell. infantrym r = MOOList [ "", "", [ "infantrymen", "infantryman" ] ]
#32 Mr. Spell. poss r = MOOList [ "", "ei", [ "possum" ] ]
#32 Mr. Spell. progra r = MOOList [ "m", "m", [ "programs", "program" ] ]
#32 Mr. Spell. snu r = MOOList [ "", "fg", [ "snub" ] ]
#32 Mr. Spell. cinc r = MOOList [ "", "", [ "Cincinnati", "cinch" ] ]
#32 Mr. Spell. sulfi r = MOOList [ "", "", [ "sulfite", "sulfide" ] ]
#32 Mr. Spell. cine r = MOOList [ "", "m", [ "Cinerama" ] ]
#32 Mr. Spell. addit r = MOOList [ "i", "o", [ "additive" ] ]
#32 Mr. Spell. progre r = MOOList [ "ss", "i", [ "progress" ] ]
#32 Mr. Spell. subsume r = MOOList [ "", "", [ "subsumed", "subsume" ] ]
#32 Mr. Spell. Indi r = MOOList [ "", "acgrsv", [ "indium", "indifferent", "Indies" ] ]
#32 Mr. Spell. impressi r = MOOList [ "", "", [ "impressive", "impression", "impressible" ] ]
#32 Mr. Spell. ceremoni r = MOOList [ "", "", [ "ceremonious", "ceremonial" ] ]
#32 Mr. Spell. Masoni r = MOOList [ "", "", [ "Masonite", "Masonic" ] ]
#32 Mr. Spell. blo r = MOOList [ "", "cmnotw", [ "blouse", "blossom", "bloke", "blob", "bloat" ] ]
#32 Mr. Spell. sna r = MOOList [ "", "gkpr", [ "snazzy", "snatch", "snail", "snafu", "snack" ] ]
#32 Mr. Spell. port r = MOOList [ "", "aeiru", [ "Portsmouth", "Porto", "portmanteau", "portland", "portfolio", "port" ] ]
#32 Mr. Spell. olivi r = MOOList [ "", "", [ "olivine", "Olivia" ] ]
#32 Mr. Spell. sne r = MOOList [ "", "ae", [ "snell" ] ]
#32 Mr. Spell. blu r = MOOList [ "", "emnrs", [ "blutwurst", "bluish", "bluff", "bludgeon", "blubber" ] ]
#32 Mr. Spell. equita r = MOOList [ "", "", [ "equitation", "equitable" ] ]
#32 Mr. Spell. unan r = MOOList [ "im", "", [ "unanimous", "unanimity" ] ]
#32 Mr. Spell. sulfu r = MOOList [ "r", "", [ "sulfurous", "sulfuric", "sulfur" ] ]
#32 Mr. Spell. sol r = MOOList [ "", "adeiouv", [ "solstice", "Sol" ] ]
#32 Mr. Spell. Paul r = MOOList [ "", "is", [ "Paulus", "Paulo", "Paulette", "Paula", "Paul" ] ]
#32 Mr. Spell. athe r = MOOList [ "", "in", [ ] ]
#32 Mr. Spell. som r = MOOList [ "", "abem", [ "somnolent" ] ]
#32 Mr. Spell. son r = MOOList [ "", "agno", [ "Sony", "sonic", "son" ] ]
#32 Mr. Spell. soo r = MOOList [ "", "t", [ "soon" ] ]
#32 Mr. Spell. retar r = MOOList [ "d", "a", [ "retard" ] ]
#32 Mr. Spell. berea r = MOOList [ "", "", [ "bereave", "Berea" ] ]
#32 Mr. Spell. sor r = MOOList [ "", "ert", [ "sorption", "sorority", "sorghum", "sordid", "sorcery", "sorb", "sora" ] ]
#32 Mr. Spell. porc r = MOOList [ "", "", [ "porcupine", "porcine", "porch", "porcelain" ] ]
#32 Mr. Spell. athl r = MOOList [ "et", "", [ "athletic", "athlete" ] ]
#32 Mr. Spell. Alger r = MOOList [ "", "", [ "Algeria", "Alger" ] ]
#32 Mr. Spell. sou r = MOOList [ "", "glnrt", [ "souvenir", "Sousa", "soup", "souffle", "sou" ] ]
#32 Mr. Spell. fatt r = MOOList [ "", "", [ "fatty", "fatten" ] ]
#32 Mr. Spell. sov r = MOOList [ "", "ei", [ "sovkhoz" ] ]
#32 Mr. Spell. porp r = MOOList [ "", "", [ "porpoise", "porphyry" ] ]
#32 Mr. Spell. sow r = MOOList [ "", "", [ "sown", "sowbelly", "sow" ] ]
#32 Mr. Spell. poro r = MOOList [ "", "", [ "porous", "porosity" ] ]
#32 Mr. Spell. porn r = MOOList [ "ograph", "", [ "pornography", "pornographer" ] ]
#32 Mr. Spell. liber r = MOOList [ "", "at", [ "Liberia" ] ]
#32 Mr. Spell. beach r = MOOList [ "", "", [ "beachhead", "beach" ] ]
#32 Mr. Spell. soy r = MOOList [ "", "", [ "soybean", "soya", "soy" ] ]
#32 Mr. Spell. deers r = MOOList [ "", "", [ "deerstalker", "deerskin" ] ]
#32 Mr. Spell. humid r = MOOList [ "", "i", [ "humid" ] ]
#32 Mr. Spell. libel r = MOOList [ "", "", [ "libelous", "libel" ] ]
#32 Mr. Spell. frui r = MOOList [ "t", "", [ "fruition", "fruitful", "fruit" ] ]
#32 Mr. Spell. soa r = MOOList [ "", "p", [ "soar", "soak" ] ]
#32 Mr. Spell. Mind r = MOOList [ "", "", [ "mindful", "Mindanao", "mind" ] ]
#32 Mr. Spell. sob r = MOOList [ "", "r", [ "sober", "sob" ] ]
#32 Mr. Spell. soc r = MOOList [ "", "ikr", [ "soccer", "Soc" ] ]
#32 Mr. Spell. sod r = MOOList [ "", "", [ "sodium", "sodden", "soda", "sod" ] ]
#32 Mr. Spell. retai r = MOOList [ "", "", [ "retain", "retail" ] ]
#32 Mr. Spell. frus r = MOOList [ "t", "r", [ "frustum" ] ]
#32 Mr. Spell. sof r = MOOList [ "", "t", [ "Sofia", "soffit", "sofa" ] ]
#32 Mr. Spell. Minn r = MOOList [ "", "e", [ "minnow", "Minnie" ] ]
#32 Mr. Spell. soi r = MOOList [ "", "", [ "soiree", "soil", "soignee" ] ]
#32 Mr. Spell. retal r = MOOList [ "iat", "", [ "retaliatory", "retaliate" ] ]
#32 Mr. Spell. fath r = MOOList [ "", "", [ "fathom", "father" ] ]
#32 Mr. Spell. locus r = MOOList [ "", "", [ "locust", "locus" ] ]
#32 Mr. Spell. fate r = MOOList [ "", "", [ "fateful", "fate" ] ]
#32 Mr. Spell. acet r = MOOList [ "", "", [ "acetylene", "acetone", "acetic", "acetate" ] ]
#32 Mr. Spell. spo r = MOOList [ "", "iknortu", [ ] ]
#32 Mr. Spell. Milt r = MOOList [ "", "o", [ "milt" ] ]
#32 Mr. Spell. circulat r = MOOList [ "", "", [ "circulatory", "circulate" ] ]
#32 Mr. Spell. boa r = MOOList [ "", "rst", [ "boa" ] ]
#32 Mr. Spell. spr r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. direc r = MOOList [ "t", "or", [ "directed", "directly", "direct" ] ]
#32 Mr. Spell. boc r = MOOList [ "", "", [ "bock", "Boca" ] ]
#32 Mr. Spell. bod r = MOOList [ "", "y", [ "Bodleian", "bodice", "bodhisattva", "bode" ] ]
#32 Mr. Spell. spu r = MOOList [ "", "mnrt", [ "spud" ] ]
#32 Mr. Spell. monke r = MOOList [ "y", "", [ "monkeyflower", "monkey" ] ]
#32 Mr. Spell. bog r = MOOList [ "", "eg", [ "bogy", "bogus", "Bogota", "bog" ] ]
#32 Mr. Spell. spy r = MOOList [ "", "", [ "spyglass", "spy" ] ]
#32 Mr. Spell. fast r = MOOList [ "", "e", [ "fastidious", "fast" ] ]
#32 Mr. Spell. bol r = MOOList [ "", "deiost", [ ] ]
#32 Mr. Spell. popu r = MOOList [ "l", "ai", [ "populous" ] ]
#32 Mr. Spell. Mime r = MOOList [ "", "", [ "mimetic", "mimesis", "mimeograph" ] ]
#32 Mr. Spell. spa r = MOOList [ "", "cnrsty", [ "spawn", "spavin", "Spaulding", "spalding", "Spain", "spaghetti", "spade", "spa" ] ]
#32 Mr. Spell. spe r = MOOList [ "", "acelnr", [ "spew", "sped" ] ]
#32 Mr. Spell. Patt r = MOOList [ "", "e", [ "patty", "Patton", "Patti" ] ]
#32 Mr. Spell. fasc r = MOOList [ "i", "cs", [ "fascinate" ] ]
#32 Mr. Spell. foxho r = MOOList [ "", "", [ "foxhound", "foxhole" ] ]
#32 Mr. Spell. sph r = MOOList [ "", "ae", [ "sphinx" ] ]
#32 Mr. Spell. spi r = MOOList [ "", "cdklnrt", [ "spigot", "Spiegel" ] ]
#32 Mr. Spell. sland r = MOOList [ "er", "", [ "slanderous", "slander" ] ]
#32 Mr. Spell. capti r = MOOList [ "", "ov", [ ] ]
#32 Mr. Spell. spl r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. Zoro r = MOOList [ "ast", "", [ "Zoroastrian", "Zoroaster" ] ]
#32 Mr. Spell. acer r = MOOList [ "bi", "", [ "acerbity", "acerbic" ] ]
#32 Mr. Spell. Dori r = MOOList [ "", "", [ "Doris", "Doric", "Doria" ] ]
#32 Mr. Spell. sedimenta r = MOOList [ "", "", [ "sedimentation", "sedimentary" ] ]
#32 Mr. Spell. Regula r = MOOList [ "", "t", [ "regular" ] ]
#32 Mr. Spell. farm r = MOOList [ "", "", [ "farmland", "Farmington", "farmhouse", "farm" ] ]
#32 Mr. Spell. capta r = MOOList [ "in", "", [ "captaincy", "captain" ] ]
#32 Mr. Spell. exclusio r = MOOList [ "n", "", [ "exclusionary", "exclusion" ] ]
#32 Mr. Spell. capst r = MOOList [ "", "", [ "capstone", "capstan" ] ]
#32 Mr. Spell. Doro r = MOOList [ "th", "", [ "Dorothy", "Dorothea" ] ]
#32 Mr. Spell. popl r = MOOList [ "", "", [ "poplin", "poplar" ] ]
#32 Mr. Spell. fart r = MOOList [ "he", "", [ "farthest", "farther" ] ]
#32 Mr. Spell. bom r = MOOList [ "b", "a", [ "bombproof", "bomb" ] ]
#32 Mr. Spell. equino r = MOOList [ "", "", [ "equinox", "equinoctial" ] ]
#32 Mr. Spell. bon r = MOOList [ "", "adginu", [ "bonze", "bony", "bonfire", "bone", "bon" ] ]
#32 Mr. Spell. boo r = MOOList [ "", "kmnrt", [ "booze", "boost", "boolean", "boogie", "booby", "boo" ] ]
#32 Mr. Spell. bor r = MOOList [ "", "adeinor", [ "Borg" ] ]
#32 Mr. Spell. Johnst r = MOOList [ "o", "", [ "Johnstown", "Johnston" ] ]
#32 Mr. Spell. bot r = MOOList [ "", "ahtu", [ "Botswana", "botfly", "botch" ] ]
#32 Mr. Spell. bou r = MOOList [ "", "glnrt", [ "boustrophedon", "bouquet", "bouffant", "Boucher" ] ]
#32 Mr. Spell. thought r = MOOList [ "", "", [ "thoughts", "thoughtful", "thought" ] ]
#32 Mr. Spell. Mill r = MOOList [ "", "ei", [ "millstone", "Millard", "mill" ] ]
#32 Mr. Spell. box r = MOOList [ "", "", [ "boxy", "boxwood", "boxcar", "box" ] ]
#32 Mr. Spell. adult r = MOOList [ "", "e", [ "adult" ] ]
#32 Mr. Spell. fare r = MOOList [ "", "", [ "farewell", "fare" ] ]
#32 Mr. Spell. boy r = MOOList [ "", "cl", [ "boyish", "Boyd", "boyar", "boy" ] ]
#32 Mr. Spell. Bime r = MOOList [ "talli", "", [ "bimetallism", "bimetallic" ] ]
#32 Mr. Spell. farc r = MOOList [ "", "", [ "farcical", "farce" ] ]
#32 Mr. Spell. impen r = MOOList [ "", "", [ "impenetrable", "impend" ] ]
#32 Mr. Spell. watchma r = MOOList [ "", "", [ "watchman", "watchmake" ] ]
#32 Mr. Spell. accr r = MOOList [ "", "eu", [ "Accra" ] ]
#32 Mr. Spell. Park r = MOOList [ "", "i", [ "parkway", "parkland", "Parke", "park" ] ]
#32 Mr. Spell. accu r = MOOList [ "", "rs", [ "accumulate", "acculturate" ] ]
#32 Mr. Spell. impel r = MOOList [ "", "l", [ "impel" ] ]
#32 Mr. Spell. collegi r = MOOList [ "a", "", [ "collegiate", "collegian" ] ]
#32 Mr. Spell. alleg r = MOOList [ "", "or", [ "allegiant", "Allegheny", "allege", "allegate" ] ]
#32 Mr. Spell. monic r = MOOList [ "", "", [ "Monica", "monic" ] ]
#32 Mr. Spell. deduct r = MOOList [ "", "", [ "deductible", "deduct" ] ]
#32 Mr. Spell. aller r = MOOList [ "g", "", [ "allergy", "allergic" ] ]
#32 Mr. Spell. imper r = MOOList [ "", "cimst", [ "impervious", "imperfect", "imperate" ] ]
#32 Mr. Spell. impet r = MOOList [ "u", "", [ "impetus", "impetuous" ] ]
#32 Mr. Spell. Hanso r = MOOList [ "", "", [ "Hanson", "hansom" ] ]
#32 Mr. Spell. aviat r = MOOList [ "", "", [ "aviatrix", "aviate" ] ]
#32 Mr. Spell. equipo r = MOOList [ "", "", [ "equipotent", "equipoise" ] ]
#32 Mr. Spell. alley r = MOOList [ "", "", [ "alleyway", "alley" ] ]
#32 Mr. Spell. referee r = MOOList [ "", "", [ "refereeing", "referee" ] ]
#32 Mr. Spell. diabe r = MOOList [ "t", "", [ "diabetic", "diabetes" ] ]
#32 Mr. Spell. acce r = MOOList [ "", "lnps", [ "accede" ] ]
#32 Mr. Spell. intensi r = MOOList [ "", "", [ "intensive", "intensify" ] ]
#32 Mr. Spell. habit r = MOOList [ "", "au", [ "habit" ] ]
#32 Mr. Spell. countrym r = MOOList [ "", "", [ "countrymen", "countryman" ] ]
#32 Mr. Spell. monit r = MOOList [ "or", "", [ "monitoring", "monitory", "monitor" ] ]
#32 Mr. Spell. Hanse r = MOOList [ "", "", [ "Hansen", "Hansel" ] ]
#32 Mr. Spell. acci r = MOOList [ "", "d", [ "accipiter" ] ]
#32 Mr. Spell. Parr r = MOOList [ "", "", [ "parry", "parrot", "Parrish", "Parr" ] ]
#32 Mr. Spell. Dora r = MOOList [ "", "", [ "Dorado", "Dora" ] ]
#32 Mr. Spell. Pars r = MOOList [ "", "ioe", [ "parsnip", "parsley" ] ]
#32 Mr. Spell. referen r = MOOList [ "", "dt", [ "reference" ] ]
#32 Mr. Spell. petrol r = MOOList [ "", "", [ "petrology", "petroleum", "petrol" ] ]
#32 Mr. Spell. accl r = MOOList [ "", "a", [ "acclimate" ] ]
#32 Mr. Spell. fluorid r = MOOList [ "", "", [ "fluoride", "fluoridate" ] ]
#32 Mr. Spell. imped r = MOOList [ "", "", [ "impediment", "impede", "impedance" ] ]
#32 Mr. Spell. acco r = MOOList [ "", "mru", [ "accost", "accolade" ] ]
#32 Mr. Spell. Dorc r = MOOList [ "", "", [ "Dorchester", "Dorcas" ] ]
#32 Mr. Spell. bra r = MOOList [ "", "cdghiknsvz", [ "bray", "brawl", "Braun", "bratwurst", "bramble", "brae" ] ]
#32 Mr. Spell. pond r = MOOList [ "", "e", [ "pond" ] ]
#32 Mr. Spell. ponc r = MOOList [ "", "h", [ "Ponce" ] ]
#32 Mr. Spell. textu r = MOOList [ "", "r", [ "textual" ] ]
#32 Mr. Spell. insin r = MOOList [ "", "", [ "insinuate", "insincere" ] ]
#32 Mr. Spell. bre r = MOOList [ "", "aemntvw", [ "Brest", "bred", "breccia" ] ]
#32 Mr. Spell. punct r = MOOList [ "u", "a", [ "puncture" ] ]
#32 Mr. Spell. committeem r = MOOList [ "", "", [ "committeemen", "committeeman" ] ]
#32 Mr. Spell. swamp r = MOOList [ "", "", [ "swampy", "swamp" ] ]
#32 Mr. Spell. bri r = MOOList [ "", "abcdeglmnst", [ ] ]
#32 Mr. Spell. nihi r = MOOList [ "lis", "", [ "nihilist", "nihilism" ] ]
#32 Mr. Spell. committeew r = MOOList [ "om", "", [ "committeewomen", "committeewoman" ] ]
#32 Mr. Spell. stiff r = MOOList [ "", "", [ "stiffen", "stiff" ] ]
#32 Mr. Spell. insis r = MOOList [ "t", "", [ "insisting", "insistent", "insist" ] ]
#32 Mr. Spell. sportswr r = MOOList [ "it", "e", [ "sportswriting" ] ]
#32 Mr. Spell. ruth r = MOOList [ "", "e", [ "ruthless", "Ruth" ] ]
#32 Mr. Spell. bro r = MOOList [ "", "ackmnotuw", [ "broil", "Broglie" ] ]
#32 Mr. Spell. equipp r = MOOList [ "", "", [ "equipping", "equipped" ] ]
#32 Mr. Spell. pomp r = MOOList [ "", "aeo", [ "pomp" ] ]
#32 Mr. Spell. insig r = MOOList [ "", "hn", [ ] ]
#32 Mr. Spell. rust r = MOOList [ "", "", [ "rusty", "rustproof", "rustle", "rustic", "rust" ] ]
#32 Mr. Spell. swank r = MOOList [ "", "", [ "swanky", "swank" ] ]
#32 Mr. Spell. insid r = MOOList [ "", "", [ "insidious", "inside" ] ]
#32 Mr. Spell. str r = MOOList [ "", "aeiou", [ "strychnine" ] ]
#32 Mr. Spell. investi r = MOOList [ "gat", "", [ "investigatory", "investigate" ] ]
#32 Mr. Spell. impos r = MOOList [ "", "t", [ "impossible", "imposition", "impose" ] ]
#32 Mr. Spell. sty r = MOOList [ "", "lr", [ "Styx", "stymie", "Stygian" ] ]
#32 Mr. Spell. resp r = MOOList [ "", "eio", [ "resplendent" ] ]
#32 Mr. Spell. diagr r = MOOList [ "am", "", [ "diagrammatic", "diagram" ] ]
#32 Mr. Spell. rest r = MOOList [ "", "aior", [ "restful", "rest" ] ]
#32 Mr. Spell. investo r = MOOList [ "r", "", [ "investors", "investor" ] ]
#32 Mr. Spell. resu r = MOOList [ "", "lmr", [ "resuscitate" ] ]
#32 Mr. Spell. krau r = MOOList [ "", "", [ "kraut", "Krause" ] ]
#32 Mr. Spell. diagn r = MOOList [ "os", "t", [ "diagnosis", "diagnose", "diagnosable" ] ]
#32 Mr. Spell. sta r = MOOList [ "", "bcdfgilmnprstuy", [ "stave", "stake", "Stahl" ] ]
#32 Mr. Spell. resi r = MOOList [ "", "dgns", [ "resilient" ] ]
#32 Mr. Spell. analo r = MOOList [ "g", "", [ "analogy", "analogue", "analogous" ] ]
#32 Mr. Spell. scriptu r = MOOList [ "r", "", [ "scripture", "scriptural" ] ]
#32 Mr. Spell. Forte r = MOOList [ "", "", [ "Fortescue", "forte" ] ]
#32 Mr. Spell. ste r = MOOList [ "", "aeilnprtvw", [ "Steuben", "stem", "Stegosaurus", "Stefan" ] ]
#32 Mr. Spell. bru r = MOOList [ "", "cinst", [ "Brumidi", "Bruegel" ] ]
#32 Mr. Spell. reso r = MOOList [ "", "lnru", [ ] ]
#32 Mr. Spell. sti r = MOOList [ "", "cfglmnpr", [ "stitch" ] ]
#32 Mr. Spell. impor r = MOOList [ "t", "au", [ "import" ] ]
#32 Mr. Spell. gymnast r = MOOList [ "", "", [ "gymnastic", "gymnast" ] ]
#32 Mr. Spell. resc r = MOOList [ "", "", [ "rescue", "rescind" ] ]
#32 Mr. Spell. impol r = MOOList [ "it", "", [ "impolitic", "impolite" ] ]
#32 Mr. Spell. rese r = MOOList [ "", "mnr", [ "research" ] ]
#32 Mr. Spell. recur r = MOOList [ "", "r", [ "recursion", "recur" ] ]
#32 Mr. Spell. legat r = MOOList [ "", "e", [ "legato" ] ]
#32 Mr. Spell. sto r = MOOList [ "", "ciklmnoprw", [ "stove", "stout", "stodgy" ] ]
#32 Mr. Spell. recus r = MOOList [ "", "", [ "recuse", "recusant" ] ]
#32 Mr. Spell. departm r = MOOList [ "ent", "", [ "departments", "department" ] ]
#32 Mr. Spell. sur r = MOOList [ "", "cefgjmprtv", [ "surname" ] ]
#32 Mr. Spell. auda r = MOOList [ "ci", "", [ "audacity", "audacious" ] ]
#32 Mr. Spell. luck r = MOOList [ "", "", [ "lucky", "luck" ] ]
#32 Mr. Spell. demons r = MOOList [ "tra", "", [ "demonstrate", "demonstrable" ] ]
#32 Mr. Spell. suz r = MOOList [ "", "e", [ "Suzuki", "Suzanne" ] ]
#32 Mr. Spell. inste r = MOOList [ "", "", [ "instep", "instead" ] ]
#32 Mr. Spell. audi r = MOOList [ "", "ot", [ "audience", "audible" ] ]
#32 Mr. Spell. shut r = MOOList [ "", "ot", [ "shutdown", "shut" ] ]
#32 Mr. Spell. lucr r = MOOList [ "", "e", [ "lucrative" ] ]
#32 Mr. Spell. insta r = MOOList [ "", "ln", [ "instable" ] ]
#32 Mr. Spell. epoc r = MOOList [ "h", "", [ "epochal", "epoch" ] ]
#32 Mr. Spell. hydrochl r = MOOList [ "ori", "", [ "hydrochloride", "hydrochloric" ] ]
#32 Mr. Spell. sub r = MOOList [ "", "jlmstuv", [ "subrogation", "subpoena", "sub" ] ]
#32 Mr. Spell. suc r = MOOList [ "", "ck", [ "suction", "sucrose", "such" ] ]
#32 Mr. Spell. geru r = MOOList [ "nd", "i", [ "gerund" ] ]
#32 Mr. Spell. sue r = MOOList [ "", "", [ "Suez", "suey", "sue" ] ]
#32 Mr. Spell. suf r = MOOList [ "f", "ior", [ "suffuse", "suffer" ] ]
#32 Mr. Spell. sug r = MOOList [ "", "g", [ "sugar" ] ]
#32 Mr. Spell. auct r = MOOList [ "ion", "", [ "auctioneer", "auction" ] ]
#32 Mr. Spell. shun r = MOOList [ "", "", [ "shunt", "shun" ] ]
#32 Mr. Spell. sui r = MOOList [ "", "ct", [ ] ]
#32 Mr. Spell. schiz r = MOOList [ "o", "p", [ "schizomycetes", "schizoid" ] ]
#32 Mr. Spell. sul r = MOOList [ "", "fklt", [ "sulphur" ] ]
#32 Mr. Spell. sum r = MOOList [ "", "aem", [ "Sumter", "sumptuous", "Sumner", "sum" ] ]
#32 Mr. Spell. Este r = MOOList [ "", "", [ "Estes", "ester", "Estella", "esteem" ] ]
#32 Mr. Spell. sun r = MOOList [ "", "bdfgklnst", [ "SUNY", "sunrise", "sun" ] ]
#32 Mr. Spell. shud r = MOOList [ "der", "", [ "shuddery", "shudder" ] ]
#32 Mr. Spell. schis r = MOOList [ "", "", [ "schist", "schism" ] ]
#32 Mr. Spell. sup r = MOOList [ "", "epr", [ "supine", "sup" ] ]
#32 Mr. Spell. shuf r = MOOList [ "fle", "", [ "shuffleboard", "shuffle" ] ]
#32 Mr. Spell. attai r = MOOList [ "n", "", [ "attainder", "attain" ] ]
#32 Mr. Spell. exclam r = MOOList [ "at", "", [ "exclamatory", "exclamation" ] ]
#32 Mr. Spell. adap r = MOOList [ "t", "", [ "adaptive", "adaptation", "adapt" ] ]
#32 Mr. Spell. buf r = MOOList [ "f", "e", [ "buffoon", "bufflehead", "buffalo", "buff" ] ]
#32 Mr. Spell. bug r = MOOList [ "", "g", [ "bugle", "bugeyed", "bugaboo", "bug" ] ]
#32 Mr. Spell. bui r = MOOList [ "", "l", [ "Buick" ] ]
#32 Mr. Spell. insuf r = MOOList [ "f", "", [ "insufficient", "insufferable" ] ]
#32 Mr. Spell. bul r = MOOList [ "", "bgkl", [ "bulwark", "bulrush" ] ]
#32 Mr. Spell. impre r = MOOList [ "", "cgs", [ ] ]
#32 Mr. Spell. bum r = MOOList [ "", "bp", [ "bum" ] ]
#32 Mr. Spell. bun r = MOOList [ "", "dgk", [ "Bunyan", "bunt", "Bunsen", "bunny", "bunch", "bun" ] ]
#32 Mr. Spell. attac r = MOOList [ "", "h", [ "attack" ] ]
#32 Mr. Spell. lubr r = MOOList [ "ic", "ai", [ ] ]
#32 Mr. Spell. buo r = MOOList [ "y", "", [ "buoyant", "buoy" ] ]
#32 Mr. Spell. swa r = MOOList [ "", "bglmnrt", [ "Swaziland", "sway", "swastika", "swap", "swain", "Swahili" ] ]
#32 Mr. Spell. insub r = MOOList [ "", "", [ "insubstantial", "insubordinate" ] ]
#32 Mr. Spell. equili r = MOOList [ "br", "i", [ "equilibrate" ] ]
#32 Mr. Spell. impra r = MOOList [ "ctica", "", [ "impractical", "impracticable" ] ]
#32 Mr. Spell. insti r = MOOList [ "", "lnt", [ "instigate" ] ]
#32 Mr. Spell. simult r = MOOList [ "ane", "", [ "simultaneous", "simultaneity" ] ]
#32 Mr. Spell. adag r = MOOList [ "", "", [ "adagio", "adage" ] ]
#32 Mr. Spell. instr r = MOOList [ "u", "cm", [ ] ]
#32 Mr. Spell. cannon r = MOOList [ "", "", [ "cannonball", "cannon" ] ]
#32 Mr. Spell. gerb r = MOOList [ "", "", [ "gerbil", "Gerber" ] ]
#32 Mr. Spell. omit r = MOOList [ "", "t", [ "omit" ] ]
#32 Mr. Spell. adam r = MOOList [ "", "", [ "Adamson", "adamant", "Adam" ] ]
#32 Mr. Spell. repu r = MOOList [ "", "blt", [ "repugnant", "repudiate" ] ]
#32 Mr. Spell. swu r = MOOList [ "", "", [ "swung", "swum" ] ]
#32 Mr. Spell. acrob r = MOOList [ "a", "t", [ "acrobacy" ] ]
#32 Mr. Spell. analy r = MOOList [ "", "s", [ "analyze", "analytic" ] ]
#32 Mr. Spell. celes r = MOOList [ "t", "", [ "celestial", "celesta" ] ]
#32 Mr. Spell. repo r = MOOList [ "", "r", [ "repository" ] ]
#32 Mr. Spell. celer r = MOOList [ "", "", [ "celery", "celerity" ] ]
#32 Mr. Spell. repr r = MOOList [ "", "ei", [ "reproach" ] ]
#32 Mr. Spell. rept r = MOOList [ "il", "", [ "reptilian", "reptile" ] ]
#32 Mr. Spell. repe r = MOOList [ "", "alnrt", [ ] ]
#32 Mr. Spell. bus r = MOOList [ "", "hit", [ "busy", "buss", "Busch", "busboy", "bus" ] ]
#32 Mr. Spell. swe r = MOOList [ "", "adel", [ "swerve", "swept", "Swenson" ] ]
#32 Mr. Spell. but r = MOOList [ "", "acety", [ "butler", "but" ] ]
#32 Mr. Spell. chunk r = MOOList [ "", "", [ "chunky", "chunk" ] ]
#32 Mr. Spell. insul r = MOOList [ "", "a", [ "insult", "insulin" ] ]
#32 Mr. Spell. transshipp r = MOOList [ "", "", [ "transshipping", "transshipped" ] ]
#32 Mr. Spell. swi r = MOOList [ "", "gmnrst", [ "swizzle", "swivel", "swipe", "swift" ] ]
#32 Mr. Spell. buy r = MOOList [ "", "", [ "buys", "buy" ] ]
#32 Mr. Spell. impri r = MOOList [ "", "", [ "imprison", "imprint", "imprimatur" ] ]
#32 Mr. Spell. wakef r = MOOList [ "", "", [ "wakeful", "Wakefield" ] ]
#32 Mr. Spell. repl r = MOOList [ "", "ei", [ "replaceable" ] ]
#32 Mr. Spell. prefe r = MOOList [ "", "cr", [ ] ]
#32 Mr. Spell. celeb r = MOOList [ "", "r", [ "Celebes" ] ]
#32 Mr. Spell. swo r = MOOList [ "", "r", [ "swoop", "swollen" ] ]
#32 Mr. Spell. repa r = MOOList [ "", "ir", [ ] ]
#32 Mr. Spell. impro r = MOOList [ "", "pv", [ "impromptu", "improbable" ] ]
#32 Mr. Spell. insur r = MOOList [ "", "", [ "insurrect", "insurmountable", "insurgent", "insure", "insurance" ] ]
#32 Mr. Spell. insup r = MOOList [ "", "p", [ "insuperable" ] ]
#32 Mr. Spell. shru r = MOOList [ "", "bgn", [ ] ]
#32 Mr. Spell. sensu r = MOOList [ "", "", [ "sensuous", "sensual" ] ]
#32 Mr. Spell. trades r = MOOList [ "m", "", [ "tradesmen", "tradesman" ] ]
#32 Mr. Spell. monst r = MOOList [ "", "r", [ "monster" ] ]
#32 Mr. Spell. prefa r = MOOList [ "", "", [ "prefatory", "prefab" ] ]
#32 Mr. Spell. senso r = MOOList [ "r", "", [ "sensory", "sensor" ] ]
#32 Mr. Spell. humil r = MOOList [ "i", "", [ "humility", "humiliate" ] ]
#32 Mr. Spell. shro r = MOOList [ "", "", [ "shrove", "shroud" ] ]
#32 Mr. Spell. syb r = MOOList [ "", "", [ "Sybil", "sybarite" ] ]
#32 Mr. Spell. syc r = MOOList [ "", "o", [ "sycamore" ] ]
#32 Mr. Spell. sensi r = MOOList [ "", "", [ "sensitive", "sensible" ] ]
#32 Mr. Spell. Que r = MOOList [ "", "ers", [ "Quezon", "queue", "quetzal", "quench", "quell", "Quebec", "queasy" ] ]
#32 Mr. Spell. preem r = MOOList [ "pt", "i", [ "preemptor", "preempt" ] ]
#32 Mr. Spell. defau r = MOOList [ "lt", "", [ "defaults", "default" ] ]
#32 Mr. Spell. shri r = MOOList [ "", "lnv", [ "shrimp", "shrike", "shrift", "shriek" ] ]
#32 Mr. Spell. diale r = MOOList [ "ct", "", [ "dialectic", "dialect" ] ]
#32 Mr. Spell. tamar r = MOOList [ "", "", [ "tamarind", "tamarack" ] ]
#32 Mr. Spell. Ferr r = MOOList [ "", "eiou", [ "ferry" ] ]
#32 Mr. Spell. shra r = MOOList [ "", "", [ "shrapnel", "shrank" ] ]
#32 Mr. Spell. multiplicat r = MOOList [ "i", "", [ "multiplicative", "multiplication" ] ]
#32 Mr. Spell. Fern r = MOOList [ "", "", [ "fernery", "Fernando", "fern" ] ]
#32 Mr. Spell. geod r = MOOList [ "", "e", [ "geoduck" ] ]
#32 Mr. Spell. rent r = MOOList [ "", "", [ "rental", "rent" ] ]
#32 Mr. Spell. geoc r = MOOList [ "", "h", [ "geocentric" ] ]
#32 Mr. Spell. regret r = MOOList [ "", "t", [ "regretful", "regret" ] ]
#32 Mr. Spell. regres r = MOOList [ "s", "i", [ "regress" ] ]
#32 Mr. Spell. geog r = MOOList [ "raph", "", [ "geography", "geographer" ] ]
#32 Mr. Spell. chloro r = MOOList [ "", "p", [ "chloroform" ] ]
#32 Mr. Spell. influe r = MOOList [ "n", "t", [ "influenza", "influence" ] ]
#32 Mr. Spell. reno r = MOOList [ "", "", [ "renown", "renovate", "renounce", "Renoir" ] ]
#32 Mr. Spell. geop r = MOOList [ "", "h", [ "geopolitic" ] ]
#32 Mr. Spell. crank r = MOOList [ "", "", [ "cranky", "crankshaft", "crankcase", "crank" ] ]
#32 Mr. Spell. senti r = MOOList [ "", "", [ "sentinel", "sentiment", "sentient" ] ]
#32 Mr. Spell. crani r = MOOList [ "", "", [ "cranium", "crania" ] ]
#32 Mr. Spell. month r = MOOList [ "", "", [ "months", "month" ] ]
#32 Mr. Spell. geom r = MOOList [ "et", "", [ "geometrician", "geometer" ] ]
#32 Mr. Spell. comprehens r = MOOList [ "i", "", [ "comprehensive", "comprehension", "comprehensible" ] ]
#32 Mr. Spell. syru r = MOOList [ "p", "", [ "syrupy", "syrup" ] ]
#32 Mr. Spell. imple r = MOOList [ "ment", "", [ "implementing", "implementor", "implementer", "implementation", "implement" ] ]
#32 Mr. Spell. rend r = MOOList [ "", "e", [ "rendition", "rend" ] ]
#32 Mr. Spell. sente r = MOOList [ "n", "", [ "sentential", "sentence" ] ]
#32 Mr. Spell. rene r = MOOList [ "", "", [ "renewal", "renegotiable", "Rene" ] ]
#32 Mr. Spell. predi r = MOOList [ "", "c", [ "predilect" ] ]
#32 Mr. Spell. gorge r = MOOList [ "", "", [ "gorgeous", "gorge" ] ]
#32 Mr. Spell. Brazi r = MOOList [ "", "l", [ "brazier" ] ]
#32 Mr. Spell. impla r = MOOList [ "", "n", [ "implausible", "implacable" ] ]
#32 Mr. Spell. booki r = MOOList [ "", "", [ "bookish", "bookie" ] ]
#32 Mr. Spell. syl r = MOOList [ "", "lv", [ "Sylow" ] ]
#32 Mr. Spell. genu r = MOOList [ "", "", [ "genus", "genuine" ] ]
#32 Mr. Spell. sym r = MOOList [ "", "bp", [ "symmetry" ] ]
#32 Mr. Spell. gent r = MOOList [ "", "il", [ "gentry", "genteel", "gent" ] ]
#32 Mr. Spell. syn r = MOOList [ "", "acdeot", [ "Synge" ] ]
#32 Mr. Spell. perspicu r = MOOList [ "", "", [ "perspicuous", "perspicuity" ] ]
#32 Mr. Spell. insom r = MOOList [ "nia", "", [ "insomniac", "insomnia" ] ]
#32 Mr. Spell. impli r = MOOList [ "", "c", [ "implied" ] ]
#32 Mr. Spell. propert r = MOOList [ "", "", [ "properties", "property" ] ]
#32 Mr. Spell. sys r = MOOList [ "tem", "i", [ "systemwide", "systematic", "system" ] ]
#32 Mr. Spell. insol r = MOOList [ "", "v", [ "insoluble", "insolent" ] ]
#32 Mr. Spell. diama r = MOOList [ "gneti", "", [ "diamagnetism", "diamagnetic" ] ]
#32 Mr. Spell. rena r = MOOList [ "", "", [ "Renault", "renal", "renaissance", "Rena" ] ]
#32 Mr. Spell. books r = MOOList [ "", "h", [ "bookstore", "bookseller" ] ]
#32 Mr. Spell. epip r = MOOList [ "h", "y", [ "Epiphany" ] ]
#32 Mr. Spell. Knowled r = MOOList [ "ge", "", [ "knowledgeable", "knowledge" ] ]
#32 Mr. Spell. atten r = MOOList [ "", "dt", [ "attenuate" ] ]
#32 Mr. Spell. syri r = MOOList [ "", "n", [ "Syria" ] ]
#32 Mr. Spell. epit r = MOOList [ "", "ah", [ "epitome" ] ]
#32 Mr. Spell. byl r = MOOList [ "", "", [ "byline", "bylaw" ] ]
#32 Mr. Spell. schoo r = MOOList [ "", "l", [ "schooner" ] ]
#32 Mr. Spell. gene r = MOOList [ "", "rsv", [ "genetic", "genealogy", "gene" ] ]
#32 Mr. Spell. attes r = MOOList [ "t", "", [ "attestation", "attest" ] ]
#32 Mr. Spell. byp r = MOOList [ "", "a", [ "byproduct" ] ]
#32 Mr. Spell. smell r = MOOList [ "", "", [ "smelly", "smell" ] ]
#32 Mr. Spell. geni r = MOOList [ "", "t", [ "genius", "genii", "genie", "genial" ] ]
#32 Mr. Spell. schol r = MOOList [ "a", "", [ "scholastic", "scholar" ] ]
#32 Mr. Spell. geno r = MOOList [ "", "", [ "genotype", "Genoa" ] ]
#32 Mr. Spell. remo r = MOOList [ "", "rv", [ "remote", "remonstrate" ] ]
#32 Mr. Spell. decryp r = MOOList [ "t", "", [ "decryption", "decrypt" ] ]
#32 Mr. Spell. inspi r = MOOList [ "r", "", [ "inspire", "inspiration" ] ]
#32 Mr. Spell. reme r = MOOList [ "", "dm", [ ] ]
#32 Mr. Spell. preci r = MOOList [ "", "ps", [ "precious", "precinct" ] ]
#32 Mr. Spell. epid r = MOOList [ "e", "mr", [ ] ]
#32 Mr. Spell. preco r = MOOList [ "ci", "", [ "precocity", "precocious" ] ]
#32 Mr. Spell. inspe r = MOOList [ "ct", "", [ "inspector", "inspect" ] ]
#32 Mr. Spell. remi r = MOOList [ "", "nst", [ ] ]
#32 Mr. Spell. epic r = MOOList [ "", "uy", [ "epic" ] ]
#32 Mr. Spell. Claudi r = MOOList [ "", "", [ "Claudio", "Claudia" ] ]
#32 Mr. Spell. preca r = MOOList [ "", "", [ "precarious", "Precambrian" ] ]
#32 Mr. Spell. epig r = MOOList [ "", "r", [ "epigenetic" ] ]
#32 Mr. Spell. epil r = MOOList [ "", "", [ "epilogue", "epileptic" ] ]
#32 Mr. Spell. prece r = MOOList [ "", "", [ "precess", "precept", "precedent" ] ]
#32 Mr. Spell. shor r = MOOList [ "", "et", [ ] ]
#32 Mr. Spell. shot r = MOOList [ "", "", [ "shotgun", "shotbush", "shot" ] ]
#32 Mr. Spell. suspen r = MOOList [ "", "s", [ "suspend" ] ]
#32 Mr. Spell. shou r = MOOList [ "", "l", [ "shout" ] ]
#32 Mr. Spell. Donal r = MOOList [ "d", "", [ "Donaldson", "Donald" ] ]
#32 Mr. Spell. shov r = MOOList [ "e", "", [ "shovel", "shove" ] ]
#32 Mr. Spell. show r = MOOList [ "", "mp", [ "showy", "showroom", "shown", "showdown", "showcase", "showboat", "show" ] ]
#32 Mr. Spell. reli r = MOOList [ "", "ceg", [ "relish", "reliquary", "relinquish", "reliant" ] ]
#32 Mr. Spell. haste r = MOOList [ "", "", [ "hasten", "haste" ] ]
#32 Mr. Spell. battlef r = MOOList [ "", "", [ "battlefront", "battlefield" ] ]
#32 Mr. Spell. Agai r = MOOList [ "n", "", [ "against", "again" ] ]
#32 Mr. Spell. shoo r = MOOList [ "", "", [ "shoot", "shook", "shoofly", "shoo" ] ]
#32 Mr. Spell. shop r = MOOList [ "", "", [ "shopworn", "shopkeep", "shop" ] ]
#32 Mr. Spell. rela r = MOOList [ "", "t", [ "relaxation" ] ]
#32 Mr. Spell. byw r = MOOList [ "", "", [ "byword", "byway" ] ]
#32 Mr. Spell. polyt r = MOOList [ "", "", [ "polytypy", "polytope", "polytechnic" ] ]
#32 Mr. Spell. shod r = MOOList [ "", "", [ "shoddy", "shod" ] ]
#32 Mr. Spell. shoe r = MOOList [ "", "", [ "shoestring", "shoemake", "shoelace", "shoehorn", "shoe" ] ]
#32 Mr. Spell. patro r = MOOList [ "", "ln", [ ] ]
#32 Mr. Spell. rele r = MOOList [ "", "a", [ "relevant" ] ]
#32 Mr. Spell. polym r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. Agat r = MOOList [ "", "", [ "Agatha", "agate" ] ]
#32 Mr. Spell. Cochr r = MOOList [ "an", "", [ "Cochrane", "Cochran" ] ]
#32 Mr. Spell. churc r = MOOList [ "h", "gimw", [ "churchyard", "church" ] ]
#32 Mr. Spell. Aristote r = MOOList [ "l", "", [ "Aristotelian", "Aristotelean" ] ]
#32 Mr. Spell. gela r = MOOList [ "", "t", [ "gelable" ] ]
#32 Mr. Spell. automati r = MOOList [ "c", "", [ "automatically", "automatic" ] ]
#32 Mr. Spell. allot r = MOOList [ "", "t", [ "allotropic", "allot" ] ]
#32 Mr. Spell. hypo r = MOOList [ "", "ct", [ "hypophyseal", "hypodermic", "hypoactive" ] ]
#32 Mr. Spell. defen r = MOOList [ "", "ds", [ ] ]
#32 Mr. Spell. evang r = MOOList [ "el", "", [ "evangelic", "evangel" ] ]
#32 Mr. Spell. defec r = MOOList [ "", "t", [ "defecate" ] ]
#32 Mr. Spell. anato r = MOOList [ "", "m", [ "Anatole" ] ]
#32 Mr. Spell. allow r = MOOList [ "", "", [ "allowed", "allows", "allowance", "allow" ] ]
#32 Mr. Spell. cellu r = MOOList [ "l", "o", [ "cellular" ] ]
#32 Mr. Spell. hype r = MOOList [ "r", "b", [ "hypertensive" ] ]
#32 Mr. Spell. indispo r = MOOList [ "s", "", [ "indisposition", "indispose" ] ]
#32 Mr. Spell. diaph r = MOOList [ "", "", [ "diaphragm", "diaphanous" ] ]
#32 Mr. Spell. defer r = MOOList [ "", "r", [ "deferent", "defer" ] ]
#32 Mr. Spell. hypn r = MOOList [ "o", "", [ "hypnotic", "hypnosis" ] ]
#32 Mr. Spell. hyph r = MOOList [ "en", "", [ "hyphenate", "hyphen" ] ]
#32 Mr. Spell. rejo r = MOOList [ "i", "", [ "rejoinder", "rejoice" ] ]
#32 Mr. Spell. Fairf r = MOOList [ "", "", [ "Fairfield", "Fairfax" ] ]
#32 Mr. Spell. Rhod r = MOOList [ "", "eo", [ "rhodium", "Rhoda" ] ]
#32 Mr. Spell. night r = MOOList [ "", "cm", [ "nighttime", "nightshirt", "nightingale", "nighthawk", "nightgown", "nightfall", "nightdress", "night" ] ]
#32 Mr. Spell. orthodox r = MOOList [ "", "", [ "orthodoxy", "orthodox" ] ]
#32 Mr. Spell. legis r = MOOList [ "lat", "", [ "legislature", "legislate" ] ]
#32 Mr. Spell. legit r = MOOList [ "ima", "", [ "legitimate", "legitimacy" ] ]
#32 Mr. Spell. abori r = MOOList [ "gin", "", [ "aborigine", "aboriginal" ] ]
#32 Mr. Spell. unsc r = MOOList [ "rew", "", [ "unscrew", "unscrews" ] ]
#32 Mr. Spell. sulta r = MOOList [ "n", "", [ "sultanate", "sultan" ] ]
#32 Mr. Spell. alloc r = MOOList [ "a", "", [ "allocate", "allocable" ] ]
#32 Mr. Spell. synt r = MOOList [ "", "ah", [ ] ]
#32 Mr. Spell. prepo r = MOOList [ "", "n", [ "preposterous" ] ]
#32 Mr. Spell. orthodon r = MOOList [ "ti", "", [ "orthodontist", "orthodontic" ] ]
#32 Mr. Spell. syno r = MOOList [ "", "np", [ "synod" ] ]
#32 Mr. Spell. meado r = MOOList [ "w", "", [ "meadowsweet", "meadowland", "meadow" ] ]
#32 Mr. Spell. syna r = MOOList [ "", "p", [ "synagogue" ] ]
#32 Mr. Spell. rein r = MOOList [ "", "", [ "reinstate", "Reinhold", "reinforce", "reindeer", "rein" ] ]
#32 Mr. Spell. sync r = MOOList [ "", "h", [ "syncopate" ] ]
#32 Mr. Spell. recor r = MOOList [ "d", "", [ "records", "record" ] ]
#32 Mr. Spell. syne r = MOOList [ "rg", "i", [ "synergy" ] ]
#32 Mr. Spell. synd r = MOOList [ "", "i", [ "syndrome" ] ]
#32 Mr. Spell. contrav r = MOOList [ "", "e", [ "contravariant" ] ]
#32 Mr. Spell. nitrog r = MOOList [ "", "e", [ "nitroglycerine" ] ]
#32 Mr. Spell. contrar r = MOOList [ "", "", [ "contrary", "contrariety" ] ]
#32 Mr. Spell. prepa r = MOOList [ "r", "a", [ "prepare" ] ]
#32 Mr. Spell. reim r = MOOList [ "burs", "", [ "reimburse", "reimbursable" ] ]
#32 Mr. Spell. symp r = MOOList [ "", "ahot", [ "symplectic" ] ]
#32 Mr. Spell. beaut r = MOOList [ "", "i", [ "beauty", "beauteous" ] ]
#32 Mr. Spell. Feld r = MOOList [ "", "", [ "feldspar", "Feldman" ] ]
#32 Mr. Spell. merch r = MOOList [ "an", "", [ "merchant", "merchandise" ] ]
#32 Mr. Spell. merce r = MOOList [ "", "", [ "mercer", "mercenary", "Mercedes" ] ]
#32 Mr. Spell. contral r = MOOList [ "", "", [ "contralto", "contralateral" ] ]
#32 Mr. Spell. opera r = MOOList [ "", "nt", [ "operable", "opera" ] ]
#32 Mr. Spell. Feli r = MOOList [ "", "c", [ "Felix", "feline" ] ]
#32 Mr. Spell. chlori r = MOOList [ "", "", [ "chlorine", "chloride" ] ]
#32 Mr. Spell. contrab r = MOOList [ "a", "", [ "contrabass", "contraband" ] ]
#32 Mr. Spell. contrac r = MOOList [ "", "et", [ ] ]
#32 Mr. Spell. recon r = MOOList [ "", "", [ "reconnaissance", "recondite", "reconcile" ] ]
#32 Mr. Spell. contrad r = MOOList [ "i", "cs", [ ] ]
#32 Mr. Spell. glutami r = MOOList [ "", "", [ "glutamic", "glutamine" ] ]
#32 Mr. Spell. beate r = MOOList [ "", "", [ "beater", "beaten" ] ]
#32 Mr. Spell. tickl r = MOOList [ "", "", [ "ticklish", "tickle" ] ]
#32 Mr. Spell. symb r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. tab r = MOOList [ "", "lu", [ "taboo", "tabernacle", "tab" ] ]
#32 Mr. Spell. Nosta r = MOOList [ "lgi", "", [ "nostalgic", "nostalgia" ] ]
#32 Mr. Spell. tac r = MOOList [ "", "hikt", [ "Tacoma" ] ]
#32 Mr. Spell. mercu r = MOOList [ "r", "i", [ "mercury" ] ]
#32 Mr. Spell. hymn r = MOOList [ "", "", [ "hymnal", "hymn" ] ]
#32 Mr. Spell. tad r = MOOList [ "", "", [ "tadpole", "tad" ] ]
#32 Mr. Spell. rehe r = MOOList [ "ars", "", [ "rehearse", "rehearsal" ] ]
#32 Mr. Spell. taf r = MOOList [ "", "f", [ "Taft" ] ]
#32 Mr. Spell. retri r = MOOList [ "", "e", [ "retribution" ] ]
#32 Mr. Spell. tag r = MOOList [ "", "", [ "tagging", "tag" ] ]
#32 Mr. Spell. tai r = MOOList [ "", "l", [ "Taiwan", "Taipei", "taint" ] ]
#32 Mr. Spell. tak r = MOOList [ "", "e", [ "taking" ] ]
#32 Mr. Spell. tal r = MOOList [ "", "ceikl", [ "talus", "talon", "Talmud" ] ]
#32 Mr. Spell. retro r = MOOList [ "", "fg", [ "retrovision", "retrospect", "retrorocket", "retroactive" ] ]
#32 Mr. Spell. geig r = MOOList [ "", "", [ "Geigy", "Geiger" ] ]
#32 Mr. Spell. attic r = MOOList [ "", "", [ "Attica", "attic" ] ]
#32 Mr. Spell. juris r = MOOList [ "", "p", [ "jurisdiction" ] ]
#32 Mr. Spell. Donne r = MOOList [ "", "", [ "Donner", "Donnelly" ] ]
#32 Mr. Spell. regu r = MOOList [ "", "l", [ "regurgitate" ] ]
#32 Mr. Spell. acrobat r = MOOList [ "", "", [ "acrobatic", "acrobat" ] ]
#32 Mr. Spell. beati r = MOOList [ "", "f", [ "beatitude" ] ]
#32 Mr. Spell. accred r = MOOList [ "it", "", [ "accreditate", "accredit" ] ]
#32 Mr. Spell. louds r = MOOList [ "peak", "", [ "loudspeaking", "loudspeaker" ] ]
#32 Mr. Spell. defin r = MOOList [ "", "ie", [ ] ]
#32 Mr. Spell. affirma r = MOOList [ "ti", "", [ "affirmative", "affirmation" ] ]
#32 Mr. Spell. regr r = MOOList [ "e", "st", [ ] ]
#32 Mr. Spell. floor r = MOOList [ "", "", [ "floorboard", "floor" ] ]
#32 Mr. Spell. Nostr r = MOOList [ "", "a", [ "nostril" ] ]
#32 Mr. Spell. regi r = MOOList [ "", "mnso", [ ] ]
#32 Mr. Spell. tam r = MOOList [ "", "ap", [ "Tammany", "tame", "tambourine", "tam" ] ]
#32 Mr. Spell. gnomo r = MOOList [ "n", "", [ "gnomonic", "gnomon" ] ]
#32 Mr. Spell. coinc r = MOOList [ "ide", "n", [ "coincide" ] ]
#32 Mr. Spell. tan r = MOOList [ "", "agt", [ "Tanzania", "Tanya", "tansy", "tannin", "tank", "tanh", "tandem", "tan" ] ]
#32 Mr. Spell. tap r = MOOList [ "", "eip", [ "tapa", "tap" ] ]
#32 Mr. Spell. tar r = MOOList [ "", "aprt", [ "Tarzan", "tarnish", "tariff", "target", "tardy", "Tarbell", "tar" ] ]
#32 Mr. Spell. rega r = MOOList [ "", "l", [ "regatta", "regard" ] ]
#32 Mr. Spell. metaboli r = MOOList [ "", "", [ "metabolite", "metabolism", "metabolic" ] ]
#32 Mr. Spell. boots r = MOOList [ "trap", "", [ "bootstrapping", "bootstrap" ] ]
#32 Mr. Spell. tas r = MOOList [ "", "kst", [ "Tasmania" ] ]
#32 Mr. Spell. tat r = MOOList [ "", "et", [ "tat" ] ]
#32 Mr. Spell. Atlanti r = MOOList [ "", "c", [ "Atlantis" ] ]
#32 Mr. Spell. arseni r = MOOList [ "", "", [ "arsenide", "arsenic" ] ]
#32 Mr. Spell. tau r = MOOList [ "", "t", [ "Taurus", "taunt", "taught", "tau" ] ]
#32 Mr. Spell. tav r = MOOList [ "ern", "", [ "taverna", "tavern" ] ]
#32 Mr. Spell. taw r = MOOList [ "", "", [ "tawny", "tawdry" ] ]
#32 Mr. Spell. shiv r = MOOList [ "", "e", [ "shiv" ] ]
#32 Mr. Spell. refu r = MOOList [ "", "gt", [ "refusal" ] ]
#32 Mr. Spell. diato r = MOOList [ "", "m", [ "diatonic" ] ]
#32 Mr. Spell. tax r = MOOList [ "", "iop", [ "taxes", "taxation", "tax" ] ]
#32 Mr. Spell. Harves r = MOOList [ "t", "", [ "harvestman", "harvest" ] ]
#32 Mr. Spell. diath r = MOOList [ "e", "", [ "diathesis", "diathermy" ] ]
#32 Mr. Spell. arsena r = MOOList [ "", "", [ "arsenate", "arsenal" ] ]
#32 Mr. Spell. shim r = MOOList [ "", "", [ "shimmy", "shim" ] ]
#32 Mr. Spell. refl r = MOOList [ "e", "c", [ "reflexive" ] ]
#32 Mr. Spell. shin r = MOOList [ "", "", [ "shiny", "Shinto", "shingle", "shine", "shinbone", "shin" ] ]
#32 Mr. Spell. crave r = MOOList [ "", "", [ "craven", "crave" ] ]
#32 Mr. Spell. cap r = MOOList [ "", "aeirst", [ "capybara", "Caputo", "capo", "cap" ] ]
#32 Mr. Spell. ship r = MOOList [ "", "blm", [ "shipyard", "shipwreck", "shipshape", "ship" ] ]
#32 Mr. Spell. car r = MOOList [ "", "abcdegilmnoprtv", [ "Caruso", "Carson", "car" ] ]
#32 Mr. Spell. premi r = MOOList [ "", "e", [ "premium", "premise" ] ]
#32 Mr. Spell. cas r = MOOList [ "", "cehkstu", [ "casino", "casbah", "Casanova" ] ]
#32 Mr. Spell. shir r = MOOList [ "", "t", [ "Shirley", "shirk", "shire" ] ]
#32 Mr. Spell. cat r = MOOList [ "", "acehist", [ "catnip", "catkin", "catfish", "catbird", "cat" ] ]
#32 Mr. Spell. refr r = MOOList [ "", "a", [ "refrigerate" ] ]
#32 Mr. Spell. cav r = MOOList [ "", "aei", [ "cavort" ] ]
#32 Mr. Spell. shif r = MOOList [ "t", "", [ "shifty", "shift" ] ]
#32 Mr. Spell. refe r = MOOList [ "", "r", [ "refectory" ] ]
#32 Mr. Spell. legen r = MOOList [ "d", "", [ "Legendre", "legendary", "legend" ] ]
#32 Mr. Spell. bootl r = MOOList [ "eg", "g", [ "bootleg" ] ]
#32 Mr. Spell. Lucret r = MOOList [ "i", "", [ "Lucretius", "Lucretia" ] ]
#32 Mr. Spell. actu r = MOOList [ "a", "l", [ "actuate", "actuarial" ] ]
#32 Mr. Spell. cab r = MOOList [ "", "ai", [ "Cabot", "cable", "cabdriver", "cabbage", "cab" ] ]
#32 Mr. Spell. flood r = MOOList [ "", "l", [ "floodgate", "flood" ] ]
#32 Mr. Spell. cac r = MOOList [ "", "hot", [ "CACM", "cackle", "cacao" ] ]
#32 Mr. Spell. cad r = MOOList [ "", "ade", [ "Cady", "cadre", "cadmium", "Cadillac" ] ]
#32 Mr. Spell. caf r = MOOList [ "e", "", [ "cafeteria", "cafe" ] ]
#32 Mr. Spell. cag r = MOOList [ "e", "", [ "cagey", "cage" ] ]
#32 Mr. Spell. cah r = MOOList [ "", "", [ "cahoot", "Cahill" ] ]
#32 Mr. Spell. schem r = MOOList [ "", "a", [ "scheme" ] ]
#32 Mr. Spell. cam r = MOOList [ "", "beip", [ "camouflage", "Camden", "camaraderie", "cam" ] ]
#32 Mr. Spell. Steven r = MOOList [ "", "s", [ "Steven" ] ]
#32 Mr. Spell. acquitt r = MOOList [ "", "", [ "acquitting", "acquittal" ] ]
#32 Mr. Spell. Melan r = MOOList [ "", "i", [ "melanoma", "melange", "Melanesia", "melancholy" ] ]
#32 Mr. Spell. alluv r = MOOList [ "i", "", [ "alluvium", "alluvial" ] ]
#32 Mr. Spell. mimic r = MOOList [ "", "k", [ "mimic" ] ]
#32 Mr. Spell. acti r = MOOList [ "", "nov", [ ] ]
#32 Mr. Spell. reed r = MOOList [ "", "", [ "reedy", "reedbuck", "reed" ] ]
#32 Mr. Spell. recta r = MOOList [ "ng", "", [ "rectangular", "rectangle" ] ]
#32 Mr. Spell. acto r = MOOList [ "", "", [ "actor", "Acton" ] ]
#32 Mr. Spell. demoni r = MOOList [ "", "", [ "demonic", "demoniac" ] ]
#32 Mr. Spell. Ram r = MOOList [ "", "ap", [ "Ramsey", "ramrod", "Ramo", "ramify", "ramble", "ram" ] ]
#32 Mr. Spell. impul r = MOOList [ "s", "", [ "impulsive", "impulse" ] ]
#32 Mr. Spell. Raf r = MOOList [ "", "f", [ "raft", "Rafael" ] ]
#32 Mr. Spell. redr r = MOOList [ "aw", "", [ "redraw", "redraws" ] ]
#32 Mr. Spell. integr r = MOOList [ "", "a", [ "integrity" ] ]
#32 Mr. Spell. liste r = MOOList [ "", "", [ "listed", "listen" ] ]
#32 Mr. Spell. reds r = MOOList [ "", "t", [ "redshank" ] ]
#32 Mr. Spell. Rad r = MOOList [ "", "i", [ "radon", "Radcliffe", "radar" ] ]
#32 Mr. Spell. telephon r = MOOList [ "", "e", [ "telephony", "telephonic" ] ]
#32 Mr. Spell. redu r = MOOList [ "", "c", [ "redundant" ] ]
#32 Mr. Spell. imput r = MOOList [ "", "", [ "impute", "imputation" ] ]
#32 Mr. Spell. tea r = MOOList [ "", "ckmrs", [ "teat", "teapot", "teal", "teahouse", "tea" ] ]
#32 Mr. Spell. attr r = MOOList [ "", "i", [ "attract" ] ]
#32 Mr. Spell. tec r = MOOList [ "", "h", [ "tecum", "tectonic" ] ]
#32 Mr. Spell. tee r = MOOList [ "", "nt", [ "teem", "teeing", "tee" ] ]
#32 Mr. Spell. Ray r = MOOList [ "", "", [ "Raytheon", "Raymond", "Rayleigh", "ray" ] ]
#32 Mr. Spell. punctua r = MOOList [ "", "", [ "punctuate", "punctual" ] ]
#32 Mr. Spell. libre r = MOOList [ "", "t", [ "Libreville" ] ]
#32 Mr. Spell. reda r = MOOList [ "ct", "", [ "redactor", "redact" ] ]
#32 Mr. Spell. redb r = MOOList [ "", "", [ "redbud", "redbird" ] ]
#32 Mr. Spell. Rau r = MOOList [ "", "", [ "Raul", "raucous" ] ]
#32 Mr. Spell. libra r = MOOList [ "", "r", [ "librate" ] ]
#32 Mr. Spell. tel r = MOOList [ "", "el", [ "Tel" ] ]
#32 Mr. Spell. redd r = MOOList [ "", "", [ "reddish", "redden" ] ]
#32 Mr. Spell. tem r = MOOList [ "", "p", [ "temerity" ] ]
#32 Mr. Spell. rede r = MOOList [ "", "mf", [ ] ]
#32 Mr. Spell. ten r = MOOList [ "", "adenostu", [ "tenfold", "ten" ] ]
#32 Mr. Spell. liquef r = MOOList [ "", "", [ "liquefy", "liquefaction" ] ]
#32 Mr. Spell. AaA r = MOOList [ "", "", [ "AAAS", "AAA" ] ]
#32 Mr. Spell. tep r = MOOList [ "", "", [ "tepid", "tepee" ] ]
#32 Mr. Spell. coffee r = MOOList [ "", "", [ "coffeepot", "coffeecup", "coffee" ] ]
#32 Mr. Spell. Scanda r = MOOList [ "l", "", [ "scandalous", "scandal" ] ]
#32 Mr. Spell. atta r = MOOList [ "", "ci", [ ] ]
#32 Mr. Spell. locomoto r = MOOList [ "r", "", [ "locomotory", "locomotor" ] ]
#32 Mr. Spell. defic r = MOOList [ "i", "", [ "deficit", "deficient" ] ]
#32 Mr. Spell. atte r = MOOList [ "", "ns", [ "attempt" ] ]
#32 Mr. Spell. recti r = MOOList [ "", "f", [ "rectitude", "rectilinear" ] ]
#32 Mr. Spell. locomoti r = MOOList [ "", "", [ "locomotive", "locomotion" ] ]
#32 Mr. Spell. Julie r = MOOList [ "", "", [ "Juliet", "Julie" ] ]
#32 Mr. Spell. acry r = MOOList [ "l", "", [ "acrylic", "acrylate" ] ]
#32 Mr. Spell. recr r = MOOList [ "", "", [ "recruit", "recriminate" ] ]
#32 Mr. Spell. propell r = MOOList [ "", "e", [ "propelling", "propellant" ] ]
#32 Mr. Spell. recto r = MOOList [ "r", "", [ "rectory", "rector" ] ]
#32 Mr. Spell. allus r = MOOList [ "i", "", [ "allusive", "allusion" ] ]
#32 Mr. Spell. rect r = MOOList [ "", "aio", [ ] ]
#32 Mr. Spell. recu r = MOOList [ "", "rs", [ "recuperate", "recumbent" ] ]
#32 Mr. Spell. screwb r = MOOList [ "", "", [ "screwbean", "screwball" ] ]
#32 Mr. Spell. airli r = MOOList [ "", "", [ "airline", "airlift" ] ]
#32 Mr. Spell. inflam r = MOOList [ "", "m", [ "inflame" ] ]
#32 Mr. Spell. Marko r = MOOList [ "v", "", [ "Markovian", "Markov" ] ]
#32 Mr. Spell. ille r = MOOList [ "g", "i", [ "illegal" ] ]
#32 Mr. Spell. inflat r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. cogna r = MOOList [ "", "", [ "cognate", "cognac" ] ]
#32 Mr. Spell. hydroxy r = MOOList [ "", "l", [ "hydroxy" ] ]
#32 Mr. Spell. ter r = MOOList [ "", "amnpr", [ "tertiary", "terse", "Teresa", "tercel", "terbium" ] ]
#32 Mr. Spell. Marlb r = MOOList [ "oro", "", [ "Marlborough", "Marlboro" ] ]
#32 Mr. Spell. tes r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. tet r = MOOList [ "", "r", [ "tether", "tete", "tetanus" ] ]
#32 Mr. Spell. syllabi r = MOOList [ "", "", [ "syllabify", "syllabic", "syllabi" ] ]
#32 Mr. Spell. protrus r = MOOList [ "i", "", [ "protrusive", "protrusion" ] ]
#32 Mr. Spell. Ursu r = MOOList [ "l", "", [ "Ursuline", "Ursula" ] ]
#32 Mr. Spell. Tops r = MOOList [ "", "", [ "Topsy", "topsoil" ] ]
#32 Mr. Spell. gesta r = MOOList [ "", "", [ "Gestapo", "gestalt" ] ]
#32 Mr. Spell. cogni r = MOOList [ "", "tz", [ ] ]
#32 Mr. Spell. sheep r = MOOList [ "", "", [ "sheepskin", "sheep" ] ]
#32 Mr. Spell. airma r = MOOList [ "", "", [ "airmass", "airman", "airmail" ] ]
#32 Mr. Spell. Aar r = MOOList [ "", "", [ "Aaron", "Aarhus" ] ]
#32 Mr. Spell. cer r = MOOList [ "", "aeitv", [ "cerulean", "CERN", "Cerberus" ] ]
#32 Mr. Spell. ces r = MOOList [ "", "s", [ "cesium", "Cesare" ] ]
#32 Mr. Spell. sign r = MOOList [ "", "aio", [ "signpost", "signet", "signboard", "sign" ] ]
#32 Mr. Spell. autu r = MOOList [ "mn", "", [ "autumnal", "autumn" ] ]
#32 Mr. Spell. Abi r = MOOList [ "", "d", [ "abilities", "Abigail" ] ]
#32 Mr. Spell. textur r = MOOList [ "", "", [ "texture", "textural" ] ]
#32 Mr. Spell. sigh r = MOOList [ "", "t", [ "sigh" ] ]
#32 Mr. Spell. lute r = MOOList [ "", "", [ "lutetium", "lute" ] ]
#32 Mr. Spell. high r = MOOList [ "", "blw", [ "high-level", "higher", "hightail", "highroad", "highhanded", "highfalutin", "high" ] ]
#32 Mr. Spell. ced r = MOOList [ "", "", [ "Cedric", "cedilla", "cede", "cedar" ] ]
#32 Mr. Spell. Cyclop r = MOOList [ "", "", [ "Cyclops", "cyclopean" ] ]
#32 Mr. Spell. hardb r = MOOList [ "", "o", [ "hardbake" ] ]
#32 Mr. Spell. Gille r = MOOList [ "", "", [ "Gillette", "Gillespie" ] ]
#32 Mr. Spell. harde r = MOOList [ "", "", [ "harder", "harden" ] ]
#32 Mr. Spell. resen r = MOOList [ "t", "", [ "resentful", "resent" ] ]
#32 Mr. Spell. auth r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. resem r = MOOList [ "bl", "", [ "resembling", "resemble", "resemblant" ] ]
#32 Mr. Spell. auti r = MOOList [ "s", "", [ "autistic", "autism" ] ]
#32 Mr. Spell. cem r = MOOList [ "e", "", [ "cemetery", "cement" ] ]
#32 Mr. Spell. vani r = MOOList [ "", "", [ "vanity", "vanish", "vanilla" ] ]
#32 Mr. Spell. reser r = MOOList [ "", "v", [ "reserpine" ] ]
#32 Mr. Spell. cen r = MOOList [ "", "st", [ "Cenozoic" ] ]
#32 Mr. Spell. Abr r = MOOList [ "", "aeio", [ "abrupt" ] ]
#32 Mr. Spell. lust r = MOOList [ "", "", [ "lusty", "lustrous", "lustful", "lust" ] ]
#32 Mr. Spell. auto r = MOOList [ "", "cmn", [ "autotransformer", "autosuggestible", "autopsy", "autograph", "autobiography", "auto" ] ]
#32 Mr. Spell. Reb r = MOOList [ "", "eu", [ "reb" ] ]
#32 Mr. Spell. ausp r = MOOList [ "ic", "", [ "auspicious", "auspices" ] ]
#32 Mr. Spell. diversi r = MOOList [ "", "o", [ "diversify" ] ]
#32 Mr. Spell. thi r = MOOList [ "", "cemnors", [ "thither", "thigh", "thiamin" ] ]
#32 Mr. Spell. aust r = MOOList [ "", "er", [ "Austin" ] ]
#32 Mr. Spell. rebel r = MOOList [ "", "l", [ "rebel" ] ]
#32 Mr. Spell. plasti r = MOOList [ "", "", [ "plastisol", "plastic" ] ]
#32 Mr. Spell. Bened r = MOOList [ "i", "c", [ "Benedikt" ] ]
#32 Mr. Spell. Ack r = MOOList [ "", "n", [ "Ackley", "Ackerman" ] ]
#32 Mr. Spell. materi r = MOOList [ "", "", [ "materiel", "material" ] ]
#32 Mr. Spell. hardt r = MOOList [ "", "", [ "hardtop", "hardtack" ] ]
#32 Mr. Spell. thr r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. hardw r = MOOList [ "", "o", [ "hardware" ] ]
#32 Mr. Spell. trilli r = MOOList [ "on", "", [ "trillionth", "trillion" ] ]
#32 Mr. Spell. mandat r = MOOList [ "", "", [ "mandatory", "mandate" ] ]
#32 Mr. Spell. pacifi r = MOOList [ "", "s", [ "pacific" ] ]
#32 Mr. Spell. joll r = MOOList [ "", "", [ "jolly", "Jolla" ] ]
#32 Mr. Spell. hemor r = MOOList [ "rh", "", [ "hemorrhoid", "hemorrhage" ] ]
#32 Mr. Spell. Rei r = MOOList [ "", "mn", [ "Reilly", "reign", "Reid", "Reich" ] ]
#32 Mr. Spell. severa r = MOOList [ "l", "", [ "severalty", "severalfold", "several" ] ]
#32 Mr. Spell. coerci r = MOOList [ "", "", [ "coercive", "coercion", "coercible" ] ]
#32 Mr. Spell. tha r = MOOList [ "", "ilnt", [ "Thayer", "thaw" ] ]
#32 Mr. Spell. Act r = MOOList [ "", "iou", [ "actress", "Actaeon", "act" ] ]
#32 Mr. Spell. severe r = MOOList [ "", "", [ "severely", "severe" ] ]
#32 Mr. Spell. tie r = MOOList [ "", "", [ "tier", "Tientsin", "tied", "tie" ] ]
#32 Mr. Spell. tif r = MOOList [ "", "", [ "tift", "Tiffany" ] ]
#32 Mr. Spell. auro r = MOOList [ "", "", [ "aurora", "aurochs" ] ]
#32 Mr. Spell. tig r = MOOList [ "", "hr", [ "tiger" ] ]
#32 Mr. Spell. til r = MOOList [ "", "t", [ "till", "tile", "tilde", "til" ] ]
#32 Mr. Spell. sien r = MOOList [ "", "", [ "sienna", "Siena" ] ]
#32 Mr. Spell. tim r = MOOList [ "", "beo", [ "timid", "Tim" ] ]
#32 Mr. Spell. Rey r = MOOList [ "", "", [ "Reynolds", "Reykjavik" ] ]
#32 Mr. Spell. tip r = MOOList [ "", "p", [ "tiptoe", "tipsy", "tipoff", "tip" ] ]
#32 Mr. Spell. cha r = MOOList [ "", "dfilmnoprstu", [ "chaw", "chagrin", "Chablis" ] ]
#32 Mr. Spell. Reu r = MOOList [ "", "b", [ "Reuters" ] ]
#32 Mr. Spell. Ade r = MOOList [ "", "lnq", [ "adept" ] ]
#32 Mr. Spell. valu r = MOOList [ "", "", [ "valuate", "value" ] ]
#32 Mr. Spell. alkali r = MOOList [ "", "", [ "alkaline", "alkali" ] ]
#32 Mr. Spell. penny r = MOOList [ "", "", [ "pennyroyal", "penny" ] ]
#32 Mr. Spell. vall r = MOOList [ "e", "", [ "valley", "Valletta" ] ]
#32 Mr. Spell. thu r = MOOList [ "", "glmnr", [ "thus", "thud", "Thuban" ] ]
#32 Mr. Spell. vali r = MOOList [ "", "d", [ "valine", "valiant" ] ]
#32 Mr. Spell. thw r = MOOList [ "a", "", [ "thwart", "thwack" ] ]
#32 Mr. Spell. thy r = MOOList [ "", "mr", [ "thy" ] ]
#32 Mr. Spell. matern r = MOOList [ "", "", [ "maternity", "maternal" ] ]
#32 Mr. Spell. aure r = MOOList [ "", "", [ "aureomycin", "Aurelius" ] ]
#32 Mr. Spell. vale r = MOOList [ "", "dnr", [ "valeur", "valet", "vale" ] ]
#32 Mr. Spell. tic r = MOOList [ "", "k", [ "tic" ] ]
#32 Mr. Spell. Rigg r = MOOList [ "", "", [ "Riggs", "rigging" ] ]
#32 Mr. Spell. tid r = MOOList [ "", "e", [ "tidy", "tidbit", "tidal", "tid" ] ]
#32 Mr. Spell. chu r = MOOList [ "", "bcgmnrt", [ "chuff" ] ]
#32 Mr. Spell. Aeo r = MOOList [ "l", "", [ "Aeolus", "aeolian" ] ]
#32 Mr. Spell. Aen r = MOOList [ "e", "", [ "Aeneid", "Aeneas" ] ]
#32 Mr. Spell. electora r = MOOList [ "", "", [ "electorate", "electoral" ] ]
#32 Mr. Spell. Jane r = MOOList [ "", "", [ "Janet", "Janeiro", "Jane" ] ]
#32 Mr. Spell. atrop r = MOOList [ "", "h", [ "Atropos" ] ]
#32 Mr. Spell. resid r = MOOList [ "", "eu", [ ] ]
#32 Mr. Spell. Aeg r = MOOList [ "", "", [ "aegis", "Aegean" ] ]
#32 Mr. Spell. side r = MOOList [ "", "blmrsw", [ "sidetrack", "sidecar", "sidearm", "side" ] ]
#32 Mr. Spell. resig r = MOOList [ "n", "", [ "resignation", "resign" ] ]
#32 Mr. Spell. che r = MOOList [ "", "acemnrsv", [ "Cheyenne", "chew", "chelate", "chef" ] ]
#32 Mr. Spell. secretari r = MOOList [ "a", "", [ "secretariat", "secretarial" ] ]
#32 Mr. Spell. hide r = MOOList [ "", "o", [ "hideaway", "hide" ] ]
#32 Mr. Spell. adop r = MOOList [ "t", "i", [ "adopt" ] ]
#32 Mr. Spell. ador r = MOOList [ "", "", [ "adorn", "adore" ] ]
#32 Mr. Spell. chl r = MOOList [ "or", "io", [ "chlordane", "chlorate" ] ]
#32 Mr. Spell. penna r = MOOList [ "", "", [ "pennant", "penna" ] ]
#32 Mr. Spell. Janu r = MOOList [ "", "", [ "Janus", "January" ] ]
#32 Mr. Spell. kale r = MOOList [ "", "i", [ "kale" ] ]
#32 Mr. Spell. cho r = MOOList [ "", "ciklmoprsw", [ "Chou" ] ]
#32 Mr. Spell. Winte r = MOOList [ "r", "", [ "wintertime", "Winters", "winter" ] ]
#32 Mr. Spell. hemis r = MOOList [ "pher", "", [ "hemispheric", "hemisphere" ] ]
#32 Mr. Spell. Rhe r = MOOList [ "", "notu", [ "rhesus", "Rhea" ] ]
#32 Mr. Spell. civ r = MOOList [ "", "i", [ "civet" ] ]
#32 Mr. Spell. indiscr r = MOOList [ "", "e", [ "indiscriminate" ] ]
#32 Mr. Spell. husbandm r = MOOList [ "", "", [ "husbandmen", "husbandman" ] ]
#32 Mr. Spell. Rha r = MOOList [ "psod", "", [ "rhapsody", "rhapsodic" ] ]
#32 Mr. Spell. sick r = MOOList [ "", "l", [ "sickroom", "sickish", "sicken", "sick" ] ]
#32 Mr. Spell. Jame r = MOOList [ "s", "", [ "Jamestown", "James" ] ]
#32 Mr. Spell. Afg r = MOOList [ "han", "", [ "Afghanistan", "Afghan" ] ]
#32 Mr. Spell. Age r = MOOList [ "", "n", [ "Agee", "age" ] ]
#32 Mr. Spell. cig r = MOOList [ "ar", "", [ "cigarette", "cigar" ] ]
#32 Mr. Spell. Pragm r = MOOList [ "ati", "s", [ "pragmatic" ] ]
#32 Mr. Spell. styli r = MOOList [ "", "", [ "stylites", "stylish", "styli" ] ]
#32 Mr. Spell. resin r = MOOList [ "", "", [ "resiny", "resin" ] ]
#32 Mr. Spell. Rho r = MOOList [ "", "dm", [ "rho" ] ]
#32 Mr. Spell. liqui r = MOOList [ "d", "", [ "liquidate", "liquid" ] ]
#32 Mr. Spell. cil r = MOOList [ "ia", "", [ "ciliate", "cilia" ] ]
#32 Mr. Spell. style r = MOOList [ "", "", [ "styles", "style" ] ]
#32 Mr. Spell. sibl r = MOOList [ "", "", [ "sibling", "Sibley" ] ]
#32 Mr. Spell. lique r = MOOList [ "", "f", [ "liqueur" ] ]
#32 Mr. Spell. resis r = MOOList [ "t", "i", [ "resistor", "resistant", "resist" ] ]
#32 Mr. Spell. atroc r = MOOList [ "i", "", [ "atrocity", "atrocious" ] ]
#32 Mr. Spell. whiteh r = MOOList [ "", "", [ "Whitehorse", "whitehead", "Whitehall" ] ]
#32 Mr. Spell. existent r = MOOList [ "", "", [ "existential", "existent" ] ]
#32 Mr. Spell. synergi r = MOOList [ "s", "", [ "synergistic", "synergism" ] ]
#32 Mr. Spell. cit r = MOOList [ "", "airy", [ "cite", "cit" ] ]
#32 Mr. Spell. uphols r = MOOList [ "ter", "", [ "upholstery", "upholster" ] ]
#32 Mr. Spell. Rie r = MOOList [ "mann", "", [ "Riemannian", "Riemann" ] ]
#32 Mr. Spell. Calve r = MOOList [ "", "", [ "Calvert", "calve" ] ]
#32 Mr. Spell. Gidd r = MOOList [ "", "", [ "giddy", "giddap" ] ]
#32 Mr. Spell. spectr r = MOOList [ "", "ao", [ "spectrum" ] ]
#32 Mr. Spell. beginn r = MOOList [ "", "", [ "beginning", "beginner" ] ]
#32 Mr. Spell. Agn r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. vain r = MOOList [ "", "", [ "vainglorious", "vain" ] ]
#32 Mr. Spell. substituti r = MOOList [ "on", "", [ "substitutionary", "substitution" ] ]
#32 Mr. Spell. admo r = MOOList [ "ni", "", [ "admonition", "admonish" ] ]
#32 Mr. Spell. Rio r = MOOList [ "", "t", [ "Riordan", "Rio" ] ]
#32 Mr. Spell. lung r = MOOList [ "", "", [ "lunge", "lung" ] ]
#32 Mr. Spell. blust r = MOOList [ "er", "", [ "blustery", "bluster" ] ]
#32 Mr. Spell. Rig r = MOOList [ "", "gho", [ "rigid", "Rigel", "Riga", "rig" ] ]
#32 Mr. Spell. duplica r = MOOList [ "", "", [ "duplicate", "duplicable" ] ]
#32 Mr. Spell. cla r = MOOList [ "", "dimnprstuy", [ "claw" ] ]
#32 Mr. Spell. luna r = MOOList [ "", "rt", [ "lunacy" ] ]
#32 Mr. Spell. precipita r = MOOList [ "", "", [ "precipitate", "precipitable" ] ]
#32 Mr. Spell. lunc r = MOOList [ "h", "", [ "lunchtime", "lunchroom", "luncheon", "lunch" ] ]
#32 Mr. Spell. differenti r = MOOList [ "a", "", [ "differentiate", "differential", "differentiable" ] ]
#32 Mr. Spell. sevent r = MOOList [ "", "e", [ "seventy", "seventieth", "seventh" ] ]
#32 Mr. Spell. cle r = MOOList [ "", "amrv", [ "clench", "cleft" ] ]
#32 Mr. Spell. electroencephalograp r = MOOList [ "h", "", [ "electroencephalography", "electroencephalograph" ] ]
#32 Mr. Spell. admi r = MOOList [ "", "nrstx", [ ] ]
#32 Mr. Spell. lumi r = MOOList [ "n", "ao", [ "luminescent" ] ]
#32 Mr. Spell. define r = MOOList [ "", "", [ "defined", "defines", "define" ] ]
#32 Mr. Spell. jogg r = MOOList [ "", "", [ "joggle", "jogging" ] ]
#32 Mr. Spell. gymna r = MOOList [ "s", "t", [ "gymnasium" ] ]
#32 Mr. Spell. Mulle r = MOOList [ "", "", [ "Mullen", "mullein" ] ]
#32 Mr. Spell. Aid r = MOOList [ "", "e", [ "Aida", "aid" ] ]
#32 Mr. Spell. defini r = MOOList [ "t", "ie", [ ] ]
#32 Mr. Spell. Rich r = MOOList [ "", "a", [ "Richter", "Richmond", "Richfield", "rich" ] ]
#32 Mr. Spell. Marsh r = MOOList [ "", "a", [ "marshmallow", "marshland", "marsh" ] ]
#32 Mr. Spell. paranoia r = MOOList [ "", "", [ "paranoiac", "paranoia" ] ]
#32 Mr. Spell. lump r = MOOList [ "", "", [ "lumpy", "Lumpur", "lumpish", "lump" ] ]
#32 Mr. Spell. monast r = MOOList [ "", "", [ "monastic", "monastery" ] ]
#32 Mr. Spell. thoug r = MOOList [ "h", "t", [ "though" ] ]
#32 Mr. Spell. artifi r = MOOList [ "c", "e", [ "artificial" ] ]
#32 Mr. Spell. Marce r = MOOList [ "", "l", [ "Marceau" ] ]
#32 Mr. Spell. Ain r = MOOList [ "", "", [ "Ainu", "ain't" ] ]
#32 Mr. Spell. lumb r = MOOList [ "", "e", [ "lumbar" ] ]
#32 Mr. Spell. worse r = MOOList [ "", "", [ "worsen", "worse" ] ]
#32 Mr. Spell. cli r = MOOList [ "", "cefmnp", [ "Clive", "clitoris", "clique", "Clio" ] ]
#32 Mr. Spell. worsh r = MOOList [ "ip", "", [ "worshipful", "worship" ] ]
#32 Mr. Spell. iodin r = MOOList [ "", "", [ "iodine", "iodinate" ] ]
#32 Mr. Spell. ambrosi r = MOOList [ "a", "", [ "ambrosial", "ambrosia" ] ]
#32 Mr. Spell. clo r = MOOList [ "", "acdgnstu", [ "cloy", "clown", "clove", "clomp", "cloister", "clobber" ] ]
#32 Mr. Spell. vagi r = MOOList [ "na", "", [ "vaginal", "vagina" ] ]
#32 Mr. Spell. thous r = MOOList [ "and", "", [ "thousandth", "thousandfold", "thousand" ] ]
#32 Mr. Spell. roundh r = MOOList [ "", "", [ "roundhouse", "roundhead" ] ]
#32 Mr. Spell. lull r = MOOList [ "", "", [ "lullaby", "lull" ] ]
#32 Mr. Spell. clu r = MOOList [ "", "bmt", [ "cluster", "clung", "Cluj", "clue", "cluck" ] ]
#32 Mr. Spell. certif r = MOOList [ "", "", [ "certify", "certificate" ] ]
#32 Mr. Spell. vaga r = MOOList [ "", "", [ "vagary", "vagabond" ] ]
#32 Mr. Spell. tok r = MOOList [ "", "", [ "Tokyo", "token", "tokamak" ] ]
#32 Mr. Spell. tom r = MOOList [ "", "abmo", [ "Tompkins", "Tomlinson", "tome", "Tom" ] ]
#32 Mr. Spell. ton r = MOOList [ "", "gis", [ "tony", "tonnage", "tonk", "tone", "tonal", "ton" ] ]
#32 Mr. Spell. too r = MOOList [ "", "lt", [ "took", "toodle", "too" ] ]
#32 Mr. Spell. top r = MOOList [ "", "osi", [ "topple", "topnotch", "topmost", "topgallant", "Topeka", "topcoat", "topaz", "top" ] ]
#32 Mr. Spell. tos r = MOOList [ "", "", [ "toss", "Toshiba" ] ]
#32 Mr. Spell. tot r = MOOList [ "", "ae", [ "tot" ] ]
#32 Mr. Spell. tou r = MOOList [ "", "crg", [ "tout", "tousle" ] ]
#32 Mr. Spell. tow r = MOOList [ "", "aehn", [ "towboat", "tow" ] ]
#32 Mr. Spell. tox r = MOOList [ "i", "c", [ "toxin" ] ]
#32 Mr. Spell. transcende r = MOOList [ "nt", "", [ "transcendental", "transcendent" ] ]
#32 Mr. Spell. toa r = MOOList [ "", "ds", [ ] ]
#32 Mr. Spell. lighth r = MOOList [ "", "", [ "lighthouse", "lighthearted" ] ]
#32 Mr. Spell. Angeli r = MOOList [ "", "cn", [ ] ]
#32 Mr. Spell. adjo r = MOOList [ "", "i", [ "adjourn" ] ]
#32 Mr. Spell. tod r = MOOList [ "", "ad", [ ] ]
#32 Mr. Spell. tof r = MOOList [ "", "", [ "tofu", "toffee" ] ]
#32 Mr. Spell. tog r = MOOList [ "", "g", [ "togs", "Togo", "together", "tog" ] ]
#32 Mr. Spell. toi r = MOOList [ "l", "e", [ "toilsome", "toil" ] ]
#32 Mr. Spell. adju r = MOOList [ "", "d", [ "adjutant", "adjust", "adjunct" ] ]
#32 Mr. Spell. strata r = MOOList [ "", "", [ "stratagem", "strata" ] ]
#32 Mr. Spell. coa r = MOOList [ "", "cglrstx", [ "coauthor", "coadjutor" ] ]
#32 Mr. Spell. coc r = MOOList [ "", "ahko", [ "coccidiosis" ] ]
#32 Mr. Spell. cod r = MOOList [ "", "deio", [ "Cody", "codpiece", "codfish", "coda", "cod" ] ]
#32 Mr. Spell. spring r = MOOList [ "", "t", [ "springy", "Springfield", "springe", "springboard", "spring" ] ]
#32 Mr. Spell. coe r = MOOList [ "", "drx", [ "coequal", "coefficient" ] ]
#32 Mr. Spell. cof r = MOOList [ "", "f", [ "cofactor" ] ]
#32 Mr. Spell. cog r = MOOList [ "", "n", [ "cogitate", "cogent", "cog" ] ]
#32 Mr. Spell. coh r = MOOList [ "", "eo", [ "Cohn" ] ]
#32 Mr. Spell. coi r = MOOList [ "", "n", [ "coil", "coiffure" ] ]
#32 Mr. Spell. convert r = MOOList [ "", "", [ "convertible", "convert" ] ]
#32 Mr. Spell. adje r = MOOList [ "ct", "", [ "adjectival", "adject" ] ]
#32 Mr. Spell. convers r = MOOList [ "", "a", [ "conversion", "converse" ] ]
#32 Mr. Spell. Ale r = MOOList [ "", "cx", [ "alewife", "alert", "aleph", "ale" ] ]
#32 Mr. Spell. Santa r = MOOList [ "", "", [ "Santayana", "Santa" ] ]
#32 Mr. Spell. harmo r = MOOList [ "n", "i", [ "harmony", "Harmon" ] ]
#32 Mr. Spell. Ala r = MOOList [ "", "bm", [ "Alaska", "alarm", "alan", "alai", "alacrity", "ala" ] ]
#32 Mr. Spell. converg r = MOOList [ "e", "", [ "convergent", "converge" ] ]
#32 Mr. Spell. jocu r = MOOList [ "", "", [ "jocund", "jocular" ] ]
#32 Mr. Spell. Alv r = MOOList [ "", "ae", [ "Alvin" ] ]
#32 Mr. Spell. possessi r = MOOList [ "", "", [ "possessive", "possession" ] ]
#32 Mr. Spell. nebula r = MOOList [ "", "", [ "nebular", "nebulae", "nebula" ] ]
#32 Mr. Spell. specif r = MOOList [ "", "i", [ "specify" ] ]
#32 Mr. Spell. specie r = MOOList [ "", "", [ "species", "specie" ] ]
#32 Mr. Spell. Alm r = MOOList [ "", "ao", [ "almighty" ] ]
#32 Mr. Spell. All r = MOOList [ "", "aeiosuy", [ "all" ] ]
#32 Mr. Spell. col r = MOOList [ "", "aeilotu", [ "colza", "Colgate", "cold", "Colby", "col" ] ]
#32 Mr. Spell. machine r = MOOList [ "", "", [ "machinery", "machine" ] ]
#32 Mr. Spell. coo r = MOOList [ "", "klpr", [ "coot", "coon", "coo" ] ]
#32 Mr. Spell. cop r = MOOList [ "", "epry", [ "copter", "copolymer", "coplanar", "copious", "cop" ] ]
#32 Mr. Spell. coq r = MOOList [ "u", "", [ "coquina", "coquette" ] ]
#32 Mr. Spell. cor r = MOOList [ "", "abdeiknoprtuv", [ "corsage", "cormorant", "Corcoran" ] ]
#32 Mr. Spell. strato r = MOOList [ "spher", "", [ "stratospheric", "stratosphere" ] ]
#32 Mr. Spell. cos r = MOOList [ "", "emt", [ "cosy", "Cossack", "cosponsor", "cosine", "cosh", "Cosgrove", "cos" ] ]
#32 Mr. Spell. cot r = MOOList [ "", "t", [ "cotyledon", "cotoneaster", "cotman", "cotillion", "cotangent", "cot" ] ]
#32 Mr. Spell. jock r = MOOList [ "", "", [ "jockstrap", "jockey", "jock" ] ]
#32 Mr. Spell. cou r = MOOList [ "", "glnprs", [ "couturier", "couch" ] ]
#32 Mr. Spell. cov r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. Ama r = MOOList [ "", "lnrtz", [ "amass", "Amadeus", "AMA" ] ]
#32 Mr. Spell. cox r = MOOList [ "", "", [ "coxcomb", "cox" ] ]
#32 Mr. Spell. strate r = MOOList [ "g", "i", [ "strategy" ] ]
#32 Mr. Spell. Marga r = MOOList [ "r", "", [ "margarine", "Margaret" ] ]
#32 Mr. Spell. coy r = MOOList [ "", "", [ "coypu", "coyote", "coy" ] ]
#32 Mr. Spell. coz r = MOOList [ "", "", [ "cozy", "cozen" ] ]
#32 Mr. Spell. tro r = MOOList [ "", "dlmpu", [ "troy", "trot", "troop", "Trojan", "troika", "troglodyte" ] ]
#32 Mr. Spell. psychiatri r = MOOList [ "", "", [ "psychiatrist", "psychiatric" ] ]
#32 Mr. Spell. takeo r = MOOList [ "", "", [ "takeover", "takeoff" ] ]
#32 Mr. Spell. panick r = MOOList [ "", "", [ "panicky", "panicked" ] ]
#32 Mr. Spell. vacu r = MOOList [ "", "o", [ "vacuum", "vacua" ] ]
#32 Mr. Spell. tru r = MOOList [ "", "acdmnst", [ "truism", "truly", "true" ] ]
#32 Mr. Spell. inacc r = MOOList [ "", "u", [ "inaccessible" ] ]
#32 Mr. Spell. try r = MOOList [ "", "", [ "trytophan", "trypsin", "trying", "try" ] ]
#32 Mr. Spell. gerundi r = MOOList [ "", "", [ "gerundive", "gerundial" ] ]
#32 Mr. Spell. Amm r = MOOList [ "", "eo", [ "ammunition", "Amman" ] ]
#32 Mr. Spell. propagan r = MOOList [ "d", "", [ "propagandist", "propaganda" ] ]
#32 Mr. Spell. permis r = MOOList [ "si", "", [ "permissive", "permission", "permissible" ] ]
#32 Mr. Spell. vacc r = MOOList [ "in", "", [ "vaccine", "vaccinate" ] ]
#32 Mr. Spell. permit r = MOOList [ "", "t", [ "permit" ] ]
#32 Mr. Spell. Toda r = MOOList [ "y", "", [ "today'll", "today" ] ]
#32 Mr. Spell. vaca r = MOOList [ "", "t", [ "vacant" ] ]
#32 Mr. Spell. tra r = MOOList [ "", "dicfgmnpsuv", [ "tray", "trawl", "trajectory" ] ]
#32 Mr. Spell. griev r = MOOList [ "", "", [ "grievous", "grieve", "grievance" ] ]
#32 Mr. Spell. Anh r = MOOList [ "", "y", [ "Anheuser", "anharmonic" ] ]
#32 Mr. Spell. Ang r = MOOList [ "", "eilosu", [ "angry" ] ]
#32 Mr. Spell. tre r = MOOList [ "", "aemns", [ "Trevelyan", "trepidation", "trellis", "trek", "trefoil", "treble" ] ]
#32 Mr. Spell. Rot r = MOOList [ "", "ahou", [ "rotten", "rotenone", "ROTC", "rot" ] ]
#32 Mr. Spell. close r = MOOList [ "", "", [ "closed", "closes", "closeup", "closet", "close" ] ]
#32 Mr. Spell. And r = MOOList [ "", "eor", [ "Andy", "and" ] ]
#32 Mr. Spell. Ros r = MOOList [ "", "aet", [ "rosy", "Ross" ] ]
#32 Mr. Spell. tri r = MOOList [ "", "abcdefglmnopstuv", [ "trihedral" ] ]
#32 Mr. Spell. Ana r = MOOList [ "", "bcglrst", [ "anaplasmosis", "anamorphic", "Anaheim", "anaerobic", "ana" ] ]
#32 Mr. Spell. Ron r = MOOList [ "", "", [ "Ronnie", "rondo", "Ronald", "Ron" ] ]
#32 Mr. Spell. Triangula r = MOOList [ "", "", [ "triangulate", "triangular" ] ]
#32 Mr. Spell. penur r = MOOList [ "", "", [ "penury", "penurious" ] ]
#32 Mr. Spell. cra r = MOOList [ "", "bcfgmnpstvwyz", [ "Craig", "cradle" ] ]
#32 Mr. Spell. cre r = MOOList [ "", "ademopstw", [ "crevice", "creche" ] ]
#32 Mr. Spell. Ans r = MOOList [ "", "e", [ "answer", "ANSI" ] ]
#32 Mr. Spell. cri r = MOOList [ "", "mnst", [ "cripple", "cricket", "crib" ] ]
#32 Mr. Spell. revv r = MOOList [ "", "", [ "revving", "revved" ] ]
#32 Mr. Spell. inade r = MOOList [ "qua", "", [ "inadequate", "inadequacy" ] ]
#32 Mr. Spell. driver r = MOOList [ "", "", [ "drivers", "driver" ] ]
#32 Mr. Spell. guardi r = MOOList [ "a", "", [ "guardian", "Guardia" ] ]
#32 Mr. Spell. Ann r = MOOList [ "", "aeiou", [ "Ann" ] ]
#32 Mr. Spell. tsa r = MOOList [ "r", "", [ "tsarina", "tsar" ] ]
#32 Mr. Spell. luge r = MOOList [ "", "", [ "luger", "luge" ] ]
#32 Mr. Spell. augu r = MOOList [ "", "s", [ "augur" ] ]
#32 Mr. Spell. articu r = MOOList [ "lat", "", [ "articulatory", "articulate" ] ]
#32 Mr. Spell. Maria r = MOOList [ "", "", [ "Marianne", "maria" ] ]
#32 Mr. Spell. revo r = MOOList [ "", "l", [ "revoke", "revocable" ] ]
#32 Mr. Spell. strang r = MOOList [ "", "", [ "strangulate", "strangle", "strange" ] ]
#32 Mr. Spell. reve r = MOOList [ "", "lnr", [ "revet", "reveal" ] ]
#32 Mr. Spell. cloth r = MOOList [ "", "e", [ "Clotho", "clothier", "clothbound", "cloth" ] ]
#32 Mr. Spell. inact r = MOOList [ "i", "v", [ "inaction" ] ]
#32 Mr. Spell. lugg r = MOOList [ "", "", [ "lugging", "luggage" ] ]
#32 Mr. Spell. revi r = MOOList [ "", "sve", [ "revile" ] ]
#32 Mr. Spell. Marie r = MOOList [ "", "", [ "Marietta", "Marie" ] ]
#32 Mr. Spell. Winni r = MOOList [ "", "p", [ "Winnie" ] ]
#32 Mr. Spell. sophist r = MOOList [ "", "", [ "sophistry", "sophisticate" ] ]
#32 Mr. Spell. Mario r = MOOList [ "", "n", [ "Mario" ] ]
#32 Mr. Spell. Indian r = MOOList [ "a", "", [ "Indianapolis", "Indiana" ] ]
#32 Mr. Spell. substitut r = MOOList [ "", "i", [ "substitute" ] ]
#32 Mr. Spell. auge r = MOOList [ "", "", [ "auger", "Augean" ] ]
#32 Mr. Spell. Victo r = MOOList [ "r", "i", [ "victory", "victor" ] ]
#32 Mr. Spell. Jacq r = MOOList [ "ue", "", [ "Jacques", "Jacqueline" ] ]
#32 Mr. Spell. bonds r = MOOList [ "m", "", [ "bondsmen", "bondsman" ] ]
#32 Mr. Spell. Jaco r = MOOList [ "b", "is", [ "Jacobus", "Jacobean", "Jacob" ] ]
#32 Mr. Spell. convent r = MOOList [ "", "", [ "convention", "convent" ] ]
#32 Mr. Spell. augm r = MOOList [ "ent", "", [ "augmentation", "augment" ] ]
#32 Mr. Spell. impost r = MOOList [ "", "", [ "imposture", "impost" ] ]
#32 Mr. Spell. Toba r = MOOList [ "", "", [ "Tobago", "tobacco" ] ]
#32 Mr. Spell. conveni r = MOOList [ "ent", "", [ "conveniently", "convenient" ] ]
#32 Mr. Spell. penta r = MOOList [ "", "g", [ "pentane" ] ]
#32 Mr. Spell. cru r = MOOList [ "", "cdeims", [ "Cruz", "crux", "crutch", "crupper", "crunch" ] ]
#32 Mr. Spell. inadv r = MOOList [ "", "", [ "inadvisable", "inadvertent" ] ]
#32 Mr. Spell. cry r = MOOList [ "", "ops", [ "cry" ] ]
#32 Mr. Spell. frustr r = MOOList [ "ate", "", [ "frustrater", "frustrate" ] ]
#32 Mr. Spell. aden r = MOOList [ "", "o", [ "adenine", "Aden" ] ]
#32 Mr. Spell. pente r = MOOList [ "cost", "", [ "pentecostal", "Pentecost" ] ]
#32 Mr. Spell. adeq r = MOOList [ "ua", "", [ "adequate", "adequacy" ] ]
#32 Mr. Spell. tur r = MOOList [ "", "nbikpt", [ "turvy", "turret", "turquoise", "turmoil", "turgid", "turf" ] ]
#32 Mr. Spell. addr r = MOOList [ "ess", "", [ "Addressograph", "addressee", "address" ] ]
#32 Mr. Spell. tut r = MOOList [ "", "o", [ "tutu", "Tuttle", "tutelage" ] ]
#32 Mr. Spell. sheat r = MOOList [ "h", "", [ "sheathe", "sheath" ] ]
#32 Mr. Spell. retr r = MOOList [ "", "io", [ "retract" ] ]
#32 Mr. Spell. retu r = MOOList [ "rn", "", [ "returning", "returned", "return" ] ]
#32 Mr. Spell. Apr r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. reti r = MOOList [ "", "cnr", [ ] ]
#32 Mr. Spell. tub r = MOOList [ "", "eu", [ "tuba", "tub" ] ]
#32 Mr. Spell. adde r = MOOList [ "", "n", [ "added" ] ]
#32 Mr. Spell. tuf r = MOOList [ "", "", [ "tuft", "tuff" ] ]
#32 Mr. Spell. tug r = MOOList [ "", "", [ "tugging", "tug" ] ]
#32 Mr. Spell. reta r = MOOList [ "", "ilr", [ ] ]
#32 Mr. Spell. tul r = MOOList [ "", "a", [ "Tulsa", "tulle", "tulip" ] ]
#32 Mr. Spell. pensi r = MOOList [ "", "", [ "pensive", "pension" ] ]
#32 Mr. Spell. tum r = MOOList [ "", "bu", [ "tum" ] ]
#32 Mr. Spell. rete r = MOOList [ "nti", "", [ "retentive", "retention" ] ]
#32 Mr. Spell. tun r = MOOList [ "", "egi", [ "tunnel", "tundra", "tuna", "tun" ] ]
#32 Mr. Spell. tup r = MOOList [ "", "", [ "tuple", "tupelo" ] ]
#32 Mr. Spell. cub r = MOOList [ "", "", [ "cubic", "cube", "cubbyhole", "Cuba", "cub" ] ]
#32 Mr. Spell. cuc r = MOOList [ "", "", [ "cucumber", "cuckoo" ] ]
#32 Mr. Spell. cud r = MOOList [ "", "d", [ "cudgel", "cud" ] ]
#32 Mr. Spell. cuf r = MOOList [ "f", "", [ "cufflink", "cuff" ] ]
#32 Mr. Spell. resul r = MOOList [ "t", "", [ "results", "resultant", "result" ] ]
#32 Mr. Spell. nausea r = MOOList [ "", "", [ "nauseate", "nausea" ] ]
#32 Mr. Spell. recurr r = MOOList [ "", "", [ "recurring", "recurred" ] ]
#32 Mr. Spell. Gauge r = MOOList [ "", "", [ "gaugeable", "gauge" ] ]
#32 Mr. Spell. resum r = MOOList [ "", "", [ "resumption", "resume" ] ]
#32 Mr. Spell. sixt r = MOOList [ "", "e", [ "sixty", "sixtieth", "sixth" ] ]
#32 Mr. Spell. cul r = MOOList [ "", "ptv", [ "culminate", "cull", "culinary", "Culbertson" ] ]
#32 Mr. Spell. cum r = MOOList [ "", "bmu", [ "cumin" ] ]
#32 Mr. Spell. resur r = MOOList [ "", "", [ "resurrect", "resurgent" ] ]
#32 Mr. Spell. cun r = MOOList [ "", "n", [ "CUNY", "Cunard" ] ]
#32 Mr. Spell. twa r = MOOList [ "", "", [ "twain", "twaddle", "TWA" ] ]
#32 Mr. Spell. cup r = MOOList [ "", "ir", [ "cupful", "cupboard", "cup" ] ]
#32 Mr. Spell. straig r = MOOList [ "ht", "", [ "straightway", "straightforward", "straighten", "straightaway", "straight" ] ]
#32 Mr. Spell. miles r = MOOList [ "", "", [ "milestone", "Miles" ] ]
#32 Mr. Spell. Arl r = MOOList [ "", "e", [ "Arlington" ] ]
#32 Mr. Spell. handicappe r = MOOList [ "", "", [ "handicapper", "handicapped" ] ]
#32 Mr. Spell. Ark r = MOOList [ "", "a", [ "ark" ] ]
#32 Mr. Spell. travel r = MOOList [ "", "", [ "travelogue", "travel" ] ]
#32 Mr. Spell. diatom r = MOOList [ "", "", [ "diatomic", "diatomaceous", "diatom" ] ]
#32 Mr. Spell. Ari r = MOOList [ "", "as", [ "Arizona", "arithmetic", "Aries", "arid" ] ]
#32 Mr. Spell. Fires r = MOOList [ "", "", [ "Firestone", "fireside" ] ]
#32 Mr. Spell. pumpk r = MOOList [ "in", "", [ "pumpkinseed", "pumpkin" ] ]
#32 Mr. Spell. screen r = MOOList [ "", "", [ "screenplay", "screen" ] ]
#32 Mr. Spell. Keen r = MOOList [ "", "", [ "Keenan", "keen" ] ]
#32 Mr. Spell. larges r = MOOList [ "", "", [ "largest", "largesse" ] ]
#32 Mr. Spell. inapp r = MOOList [ "", "r", [ "inapplicable", "inappeasable" ] ]
#32 Mr. Spell. screec r = MOOList [ "h", "", [ "screechy", "screech" ] ]
#32 Mr. Spell. Art r = MOOList [ "", "ehi", [ "arty", "artwork", "Arturo", "artful", "art" ] ]
#32 Mr. Spell. sarco r = MOOList [ "", "", [ "sarcoma", "sarcophagus" ] ]
#32 Mr. Spell. nucleol r = MOOList [ "", "", [ "nucleolus", "nucleoli" ] ]
#32 Mr. Spell. Arr r = MOOList [ "", "aeio", [ "Arrhenius" ] ]
#32 Mr. Spell. cur r = MOOList [ "", "bdilrstve", [ "curfew", "curate", "cur" ] ]
#32 Mr. Spell. cus r = MOOList [ "", "ht", [ "cusp" ] ]
#32 Mr. Spell. urgen r = MOOList [ "", "", [ "urgent", "urgency" ] ]
#32 Mr. Spell. twe r = MOOList [ "", "eln", [ "tweak" ] ]
#32 Mr. Spell. cut r = MOOList [ "", "lot", [ "cutworm", "cutset", "cute", "cutback", "cutaneous", "cut" ] ]
#32 Mr. Spell. aver r = MOOList [ "", "rsa", [ "Avery", "avert", "aver" ] ]
#32 Mr. Spell. onlo r = MOOList [ "ok", "", [ "onlooking", "onlooker" ] ]
#32 Mr. Spell. twi r = MOOList [ "", "glnrst", [ "twiddle", "twice" ] ]
#32 Mr. Spell. Asi r = MOOList [ "", "a", [ "asinine", "Asilomar", "aside" ] ]
#32 Mr. Spell. two r = MOOList [ "", "", [ "twosome", "Twombly", "twofold", "two" ] ]
#32 Mr. Spell. sarca r = MOOList [ "s", "", [ "sarcastic", "sarcasm" ] ]
#32 Mr. Spell. lect r = MOOList [ "", "", [ "lecture", "lectionary" ] ]
#32 Mr. Spell. barret r = MOOList [ "t", "", [ "barrette", "Barrett" ] ]
#32 Mr. Spell. hypocr r = MOOList [ "i", "t", [ "hypocrisy" ] ]
#32 Mr. Spell. Hiero r = MOOList [ "", "", [ "Hieronymus", "hieroglyphic" ] ]
#32 Mr. Spell. Rum r = MOOList [ "", "mp", [ "ruminant", "Rumford", "rumen", "rumble", "Rumania", "rum" ] ]
#32 Mr. Spell. illusio r = MOOList [ "n", "", [ "illusionary", "illusion" ] ]
#32 Mr. Spell. hypoch r = MOOList [ "lor", "", [ "hypochlorous", "hypochlorite" ] ]
#32 Mr. Spell. lech r = MOOList [ "er", "", [ "lechery", "lecher" ] ]
#32 Mr. Spell. tablea r = MOOList [ "u", "", [ "tableaux", "tableau" ] ]
#32 Mr. Spell. middlem r = MOOList [ "", "", [ "middlemen", "middleman" ] ]
#32 Mr. Spell. cloud r = MOOList [ "", "", [ "cloudy", "cloudburst", "cloud" ] ]
#32 Mr. Spell. inapt r = MOOList [ "", "", [ "inaptitude", "inapt" ] ]
#32 Mr. Spell. Atk r = MOOList [ "ins", "", [ "Atkinson", "Atkins" ] ]
#32 Mr. Spell. weat r = MOOList [ "her", "s", [ "weatherproof", "weatherbeaten", "weather" ] ]
#32 Mr. Spell. rebut r = MOOList [ "", "t", [ "rebut" ] ]
#32 Mr. Spell. convulsi r = MOOList [ "", "", [ "convulsive", "convulsion" ] ]
#32 Mr. Spell. Aub r = MOOList [ "", "", [ "auburn", "Aubrey", "Auberge" ] ]
#32 Mr. Spell. weak r = MOOList [ "", "", [ "weaken", "weak" ] ]
#32 Mr. Spell. weal r = MOOList [ "", "t", [ "weal" ] ]
#32 Mr. Spell. communicat r = MOOList [ "", "i", [ "communicate" ] ]
#32 Mr. Spell. sidewal r = MOOList [ "", "", [ "sidewall", "sidewalk" ] ]
#32 Mr. Spell. wear r = MOOList [ "", "i", [ "wearable", "weary", "wear" ] ]
#32 Mr. Spell. weap r = MOOList [ "on", "", [ "weaponry", "weapon" ] ]
#32 Mr. Spell. harve r = MOOList [ "", "s", [ "Harvey" ] ]
#32 Mr. Spell. Atw r = MOOList [ "", "", [ "Atwood", "Atwater" ] ]
#32 Mr. Spell. traver r = MOOList [ "", "s", [ "travertine" ] ]
#32 Mr. Spell. prosper r = MOOList [ "", "", [ "prosperous", "prosper" ] ]
#32 Mr. Spell. leba r = MOOList [ "n", "", [ "Lebanon", "Lebanese" ] ]
#32 Mr. Spell. pastu r = MOOList [ "re", "", [ "pastures", "pasture" ] ]
#32 Mr. Spell. prospec r = MOOList [ "t", "", [ "prospectus", "prospector", "prospect" ] ]
#32 Mr. Spell. guani r = MOOList [ "", "", [ "guanine", "guanidine" ] ]
#32 Mr. Spell. blackbo r = MOOList [ "", "", [ "blackbody", "blackboard" ] ]
#32 Mr. Spell. leak r = MOOList [ "", "", [ "leaky", "leakage", "leak" ] ]
#32 Mr. Spell. leat r = MOOList [ "her", "", [ "leathery", "leatherwork", "leatherneck", "leatherback", "leather" ] ]
#32 Mr. Spell. leav r = MOOList [ "e", "n", [ "leaves", "leave" ] ]
#32 Mr. Spell. Aug r = MOOList [ "", "emu", [ "augite", "Aug" ] ]
#32 Mr. Spell. tyr r = MOOList [ "", "a", [ "tyrosine" ] ]
#32 Mr. Spell. leap r = MOOList [ "", "", [ "leapt", "leapfrog", "leap" ] ]
#32 Mr. Spell. leas r = MOOList [ "", "e", [ "least", "leash" ] ]
#32 Mr. Spell. lear r = MOOList [ "", "", [ "learn", "Lear" ] ]
#32 Mr. Spell. paste r = MOOList [ "", "u", [ "pastel", "pasteboard", "paste" ] ]
#32 Mr. Spell. Whea r = MOOList [ "t", "", [ "Wheatstone", "wheat" ] ]
#32 Mr. Spell. Ava r = MOOList [ "", "ri", [ "avalanche" ] ]
#32 Mr. Spell. pasti r = MOOList [ "", "", [ "pastime", "pastiche" ] ]
#32 Mr. Spell. cyl r = MOOList [ "ind", "", [ "cylindric", "cylinder" ] ]
#32 Mr. Spell. provocati r = MOOList [ "", "", [ "provocative", "provocation" ] ]
#32 Mr. Spell. lead r = MOOList [ "", "es", [ "leading", "lead" ] ]
#32 Mr. Spell. hypocrit r = MOOList [ "", "", [ "hypocritic", "hypocrite" ] ]
#32 Mr. Spell. leaf r = MOOList [ "", "", [ "leafy", "leaflet", "leaf" ] ]
#32 Mr. Spell. cys r = MOOList [ "t", "", [ "cysteine", "cyst" ] ]
#32 Mr. Spell. pasto r = MOOList [ "r", "", [ "pastoral", "pastor" ] ]
#32 Mr. Spell. leac r = MOOList [ "h", "", [ "leachate", "leach" ] ]
#32 Mr. Spell. cyt r = MOOList [ "o", "", [ "cytosine", "cytoplasm", "cytolysis", "cytochemistry" ] ]
#32 Mr. Spell. situ r = MOOList [ "", "a", [ "situs", "situ" ] ]
#32 Mr. Spell. grind r = MOOList [ "", "", [ "grindstone", "grind" ] ]
#32 Mr. Spell. Winch r = MOOList [ "", "", [ "Winchester", "winch" ] ]
#32 Mr. Spell. cya r = MOOList [ "n", "ai", [ ] ]
#32 Mr. Spell. allegr r = MOOList [ "", "", [ "allegro", "Allegra" ] ]
#32 Mr. Spell. allego r = MOOList [ "r", "", [ "allegory", "allegoric" ] ]
#32 Mr. Spell. Barne r = MOOList [ "", "t", [ "Barney", "Barnes" ] ]
#32 Mr. Spell. quinti r = MOOList [ "", "", [ "quintillion", "quintic" ] ]
#32 Mr. Spell. passa r = MOOList [ "", "g", [ "Passaic" ] ]
#32 Mr. Spell. immodes r = MOOList [ "t", "", [ "immodesty", "immodest" ] ]
#32 Mr. Spell. migrat r = MOOList [ "", "", [ "migratory", "migrate" ] ]
#32 Mr. Spell. haploi r = MOOList [ "d", "", [ "haploidy", "haploid" ] ]
#32 Mr. Spell. hith r = MOOList [ "er", "", [ "hitherto", "hither" ] ]
#32 Mr. Spell. passe r = MOOList [ "", "", [ "passed", "passerby", "passenger", "passe" ] ]
#32 Mr. Spell. passi r = MOOList [ "", "ov", [ "passing" ] ]
#32 Mr. Spell. hist r = MOOList [ "", "o", [ "histrionic", "histidine", "histamine" ] ]
#32 Mr. Spell. Ryd r = MOOList [ "", "", [ "Ryder", "Rydberg" ] ]
#32 Mr. Spell. avar r = MOOList [ "ic", "", [ "avaricious", "avarice" ] ]
#32 Mr. Spell. organiz r = MOOList [ "ation", "", [ "organizations", "organization" ] ]
#32 Mr. Spell. cza r = MOOList [ "r", "", [ "czarina", "czar" ] ]
#32 Mr. Spell. tables r = MOOList [ "", "p", [ "tables" ] ]
#32 Mr. Spell. uppercl r = MOOList [ "assm", "", [ "upperclassmen", "upperclassman" ] ]
#32 Mr. Spell. Winds r = MOOList [ "", "", [ "windsurf", "windstorm", "Windsor", "windshield" ] ]
#32 Mr. Spell. avai r = MOOList [ "l", "", [ "available", "avail" ] ]
#32 Mr. Spell. myco r = MOOList [ "", "", [ "mycology", "mycobacteria" ] ]
#32 Mr. Spell. barrac r = MOOList [ "", "", [ "barracuda", "barrack" ] ]
#32 Mr. Spell. sire r = MOOList [ "", "", [ "siren", "sire" ] ]
#32 Mr. Spell. hirs r = MOOList [ "", "", [ "hirsute", "Hirsch" ] ]
#32 Mr. Spell. monstr r = MOOList [ "o", "", [ "monstrous", "monstrosity" ] ]
#32 Mr. Spell. myce r = MOOList [ "nae", "", [ "Mycenaean", "Mycenae" ] ]
#32 Mr. Spell. Econ r = MOOList [ "om", "ei", [ "economy" ] ]
#32 Mr. Spell. illit r = MOOList [ "era", "", [ "illiterate", "illiteracy" ] ]
#32 Mr. Spell. Aye r = MOOList [ "", "", [ "Ayers", "aye" ] ]
#32 Mr. Spell. respirato r = MOOList [ "r", "", [ "respiratory", "respirator" ] ]
#32 Mr. Spell. hire r = MOOList [ "", "", [ "hireling", "hire" ] ]
#32 Mr. Spell. Steel r = MOOList [ "", "", [ "steely", "steelmake", "Steele", "steel" ] ]
#32 Mr. Spell. upperc r = MOOList [ "", "l", [ "uppercut" ] ]
#32 Mr. Spell. Whar r = MOOList [ "", "", [ "wharves", "Wharton", "wharf" ] ]
#32 Mr. Spell. overt r = MOOList [ "", "", [ "overture", "overt" ] ]
#32 Mr. Spell. Siege r = MOOList [ "", "", [ "Siegel", "siege" ] ]
#32 Mr. Spell. harri r = MOOList [ "", "s", [ "Harrington", "Harriman", "Harriet" ] ]
#32 Mr. Spell. caliph r = MOOList [ "", "", [ "caliphate", "caliph" ] ]
#32 Mr. Spell. Polarog r = MOOList [ "ra", "p", [ "polarogram" ] ]
#32 Mr. Spell. Calde r = MOOList [ "r", "", [ "caldera", "Calder" ] ]
#32 Mr. Spell. guard r = MOOList [ "", "i", [ "guardhouse", "guard" ] ]
#32 Mr. Spell. plumba r = MOOList [ "", "", [ "plumbate", "plumbago" ] ]
#32 Mr. Spell. guara r = MOOList [ "nt", "e", [ "guaranty" ] ]
#32 Mr. Spell. numera r = MOOList [ "", "", [ "numerate", "numeral", "numerable" ] ]
#32 Mr. Spell. oliga r = MOOList [ "rch", "", [ "oligarchy", "oligarchic" ] ]
#32 Mr. Spell. glyce r = MOOList [ "r", "i", [ "glycerol" ] ]
#32 Mr. Spell. Whal r = MOOList [ "e", "", [ "Whalen", "whale" ] ]
#32 Mr. Spell. Azt r = MOOList [ "ec", "", [ "Aztecan", "Aztec" ] ]
#32 Mr. Spell. acqua r = MOOList [ "int", "", [ "acquaintance", "acquaint" ] ]
#32 Mr. Spell. headlin r = MOOList [ "e", "", [ "headlines", "headline" ] ]
#32 Mr. Spell. numero r = MOOList [ "", "", [ "numerous", "numerology" ] ]
#32 Mr. Spell. oligo r = MOOList [ "", "", [ "oligopoly", "oligoclase" ] ]
#32 Mr. Spell. obliv r = MOOList [ "io", "", [ "oblivious", "oblivion" ] ]
#32 Mr. Spell. registra r = MOOList [ "", "", [ "registration", "registrar", "registrant", "registrable" ] ]
#32 Mr. Spell. Barry r = MOOList [ "", "", [ "Barrymore", "Barry" ] ]
#32 Mr. Spell. jour r = MOOList [ "n", "ae", [ ] ]
#32 Mr. Spell. sinu r = MOOList [ "", "s", [ "sinuous" ] ]
#32 Mr. Spell. cohes r = MOOList [ "i", "", [ "cohesive", "cohesion" ] ]
#32 Mr. Spell. armat r = MOOList [ "", "", [ "armature", "Armata" ] ]
#32 Mr. Spell. sini r = MOOList [ "st", "", [ "sinistral", "sinister" ] ]
#32 Mr. Spell. Calcul r = MOOList [ "", "a", [ "calculus", "calculi" ] ]
#32 Mr. Spell. sink r = MOOList [ "", "", [ "sinkhole", "sink" ] ]
#32 Mr. Spell. coher r = MOOList [ "e", "", [ "coherent", "cohere" ] ]
#32 Mr. Spell. calibr r = MOOList [ "", "", [ "calibre", "calibrate" ] ]
#32 Mr. Spell. resol r = MOOList [ "", "u", [ "resolve" ] ]
#32 Mr. Spell. reson r = MOOList [ "a", "", [ "resonate", "resonant" ] ]
#32 Mr. Spell. pragmatis r = MOOList [ "", "", [ "pragmatist", "pragmatism" ] ]
#32 Mr. Spell. oblig r = MOOList [ "", "a", [ "oblige" ] ]
#32 Mr. Spell. sinc r = MOOList [ "", "e", [ "Sinclair" ] ]
#32 Mr. Spell. hint r = MOOList [ "", "", [ "hinterland", "hint" ] ]
#32 Mr. Spell. sine r = MOOList [ "", "w", [ "sine" ] ]
#32 Mr. Spell. sing r = MOOList [ "", "al", [ "singular", "singsong", "singe", "sing" ] ]
#32 Mr. Spell. recessi r = MOOList [ "", "", [ "recessive", "recession" ] ]
#32 Mr. Spell. onco r = MOOList [ "", "", [ "oncoming", "oncology" ] ]
#32 Mr. Spell. grammar r = MOOList [ "", "", [ "grammarian", "grammar" ] ]
#32 Mr. Spell. dam r = MOOList [ "", "anp", [ "damsel", "Damon", "dame", "dam" ] ]
#32 Mr. Spell. simp r = MOOList [ "", "l", [ "Simpson", "simper" ] ]
#32 Mr. Spell. dap r = MOOList [ "", "p", [ "Daphne" ] ]
#32 Mr. Spell. acqui r = MOOList [ "", "est", [ "acquire" ] ]
#32 Mr. Spell. respe r = MOOList [ "ct", "", [ "respectful", "respect" ] ]
#32 Mr. Spell. mille r = MOOList [ "", "n", [ "millet" ] ]
#32 Mr. Spell. dar r = MOOList [ "", "klrtw", [ "DARPA", "darn", "Darius", "dare", "Dar" ] ]
#32 Mr. Spell. simu r = MOOList [ "l", "t", [ "simulcast", "simulate" ] ]
#32 Mr. Spell. das r = MOOList [ "", "h", [ "dastard" ] ]
#32 Mr. Spell. dat r = MOOList [ "", "ae", [ "datum", "Datsun" ] ]
#32 Mr. Spell. archet r = MOOList [ "yp", "", [ "archetypical", "archetype" ] ]
#32 Mr. Spell. respi r = MOOList [ "", "r", [ "respite" ] ]
#32 Mr. Spell. occlus r = MOOList [ "i", "", [ "occlusive", "occlusion" ] ]
#32 Mr. Spell. dav r = MOOList [ "", "ei", [ "Davy" ] ]
#32 Mr. Spell. simi r = MOOList [ "l", "", [ "similitude", "simile", "similar" ] ]
#32 Mr. Spell. academi r = MOOList [ "", "c", [ "academia" ] ]
#32 Mr. Spell. day r = MOOList [ "", "bt", [ "days", "daylight", "daydream", "day" ] ]
#32 Mr. Spell. daz r = MOOList [ "", "", [ "dazzle", "daze" ] ]
#32 Mr. Spell. respo r = MOOList [ "n", "ds", [ ] ]
#32 Mr. Spell. resor r = MOOList [ "", "", [ "resort", "resorcinol" ] ]
#32 Mr. Spell. illus r = MOOList [ "", "it", [ "illusory" ] ]
#32 Mr. Spell. illum r = MOOList [ "", "i", [ "illume" ] ]
#32 Mr. Spell. dac r = MOOList [ "", "t", [ "dachshund", "Dacca" ] ]
#32 Mr. Spell. resou r = MOOList [ "rce", "", [ "resources", "resource", "resourceful" ] ]
#32 Mr. Spell. quantit r = MOOList [ "", "", [ "quantities", "quantity", "quantitative" ] ]
#32 Mr. Spell. daf r = MOOList [ "f", "", [ "daffy", "daffodil" ] ]
#32 Mr. Spell. Sande r = MOOList [ "r", "", [ "Sanderson", "sanderling" ] ]
#32 Mr. Spell. nomina r = MOOList [ "", "", [ "nominate", "nominal" ] ]
#32 Mr. Spell. dah r = MOOList [ "", "l", [ "Dahomey" ] ]
#32 Mr. Spell. patrolm r = MOOList [ "", "", [ "patrolmen", "patrolman" ] ]
#32 Mr. Spell. patroll r = MOOList [ "", "", [ "patrolling", "patrolled" ] ]
#32 Mr. Spell. Gins r = MOOList [ "", "b", [ "ginseng" ] ]
#32 Mr. Spell. silt r = MOOList [ "", "", [ "silty", "siltstone", "siltation", "silt" ] ]
#32 Mr. Spell. devia r = MOOList [ "", "", [ "deviate", "deviant" ] ]
#32 Mr. Spell. sili r = MOOList [ "c", "aio", [ "siliceous" ] ]
#32 Mr. Spell. local r = MOOList [ "", "", [ "locale", "local" ] ]
#32 Mr. Spell. silk r = MOOList [ "", "", [ "silky", "silkworm", "silken", "silk" ] ]
#32 Mr. Spell. sill r = MOOList [ "", "", [ "silly", "sill" ] ]
#32 Mr. Spell. ingrati r = MOOList [ "", "", [ "ingratitude", "ingratiate" ] ]
#32 Mr. Spell. Sal r = MOOList [ "", "aeilmotuv", [ "salsify", "Salk", "Sal" ] ]
#32 Mr. Spell. hill r = MOOList [ "", "m", [ "hilly", "hilltop", "hillside", "hillock", "Hillel", "Hillcrest", "hillbilly", "hill" ] ]
#32 Mr. Spell. hench r = MOOList [ "m", "", [ "henchmen", "henchman" ] ]
#32 Mr. Spell. locat r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. sila r = MOOList [ "", "", [ "Silas", "silane", "silage" ] ]
#32 Mr. Spell. luxu r = MOOList [ "r", "i", [ "luxury" ] ]
#32 Mr. Spell. devil r = MOOList [ "", "", [ "devilish", "devil" ] ]
#32 Mr. Spell. Sai r = MOOList [ "", "l", [ "saint", "Saigon", "said" ] ]
#32 Mr. Spell. devis r = MOOList [ "e", "", [ "devisee", "devise" ] ]
#32 Mr. Spell. milit r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. hence r = MOOList [ "", "", [ "henceforth", "hence" ] ]
#32 Mr. Spell. vase r = MOOList [ "", "", [ "vasectomy", "vase" ] ]
#32 Mr. Spell. Sar r = MOOList [ "", "acds", [ "sari", "Sargent" ] ]
#32 Mr. Spell. asper r = MOOList [ "", "", [ "aspersion", "asperity" ] ]
#32 Mr. Spell. San r = MOOList [ "", "acdgit", [ "sans", "sank", "Sanhedrin", "Sanford", "sane", "Sanborn", "San" ] ]
#32 Mr. Spell. madri r = MOOList [ "", "", [ "madrigal", "Madrid" ] ]
#32 Mr. Spell. vari r = MOOList [ "", "ae", [ "Varitype", "varistor", "various" ] ]
#32 Mr. Spell. trenche r = MOOList [ "rm", "", [ "trenchermen", "trencherman" ] ]
#32 Mr. Spell. heteroge r = MOOList [ "ne", "", [ "heterogeneous", "heterogeneity" ] ]
#32 Mr. Spell. semin r = MOOList [ "", "a", [ "Seminole" ] ]
#32 Mr. Spell. Ban r = MOOList [ "", "adegikt", [ "banshee", "banquet", "banjo", "Banbury", "ban" ] ]
#32 Mr. Spell. Bam r = MOOList [ "", "b", [ "Bamako", "bam" ] ]
#32 Mr. Spell. superf r = MOOList [ "", "l", [ "superficial" ] ]
#32 Mr. Spell. Bal r = MOOList [ "", "deiklmst", [ "Balzac", "balustrade", "Balfour", "balcony", "Balboa", "balance" ] ]
#32 Mr. Spell. adve r = MOOList [ "", "nr", [ ] ]
#32 Mr. Spell. Bak r = MOOList [ "", "e", [ "Baku", "baklava", "Bakhtiari" ] ]
#32 Mr. Spell. Bai r = MOOList [ "", "l", [ "bait", "Baird", "bainite" ] ]
#32 Mr. Spell. Gill r = MOOList [ "", "e", [ "Gilligan", "gill" ] ]
#32 Mr. Spell. Bah r = MOOList [ "", "", [ "Bahrein", "Bahama", "bah" ] ]
#32 Mr. Spell. advi r = MOOList [ "", "s", [ "advice" ] ]
#32 Mr. Spell. superi r = MOOList [ "", "", [ "superior", "superintendent" ] ]
#32 Mr. Spell. triumpha r = MOOList [ "", "", [ "triumphant", "triumphal" ] ]
#32 Mr. Spell. Etha r = MOOList [ "n", "", [ "ethanol", "ethane", "Ethan" ] ]
#32 Mr. Spell. advo r = MOOList [ "ca", "", [ "advocate", "advocacy" ] ]
#32 Mr. Spell. superb r = MOOList [ "", "", [ "superbly", "superb" ] ]
#32 Mr. Spell. Torr r = MOOList [ "", "", [ "torrid", "torrent", "Torrance", "torr" ] ]
#32 Mr. Spell. supers r = MOOList [ "", "t", [ "supersede" ] ]
#32 Mr. Spell. superv r = MOOList [ "", "", [ "supervisory", "supervene" ] ]
#32 Mr. Spell. Ethi r = MOOList [ "", "", [ "Ethiopia", "ethic" ] ]
#32 Mr. Spell. Sch r = MOOList [ "", "aeilmnoruw", [ ] ]
#32 Mr. Spell. superl r = MOOList [ "", "", [ "superlunary", "superlative" ] ]
#32 Mr. Spell. inaug r = MOOList [ "ura", "", [ "inaugurate", "inaugural" ] ]
#32 Mr. Spell. footpa r = MOOList [ "", "", [ "footpath", "footpad" ] ]
#32 Mr. Spell. supern r = MOOList [ "", "", [ "supernovae", "supernatant" ] ]
#32 Mr. Spell. Bat r = MOOList [ "", "cehot", [ "batwing", "batik", "Batavia", "bat" ] ]
#32 Mr. Spell. questi r = MOOList [ "on", "", [ "questions", "questionnaire", "question" ] ]
#32 Mr. Spell. archai r = MOOList [ "", "", [ "archaism", "archaic" ] ]
#32 Mr. Spell. adva r = MOOList [ "n", "t", [ "advance" ] ]
#32 Mr. Spell. der r = MOOList [ "", "abeior", [ "dervish" ] ]
#32 Mr. Spell. des r = MOOList [ "", "ceiopstu", [ "Desmond", "desk", "Des" ] ]
#32 Mr. Spell. det r = MOOList [ "", "aeor", [ ] ]
#32 Mr. Spell. resti r = MOOList [ "", "", [ "restive", "restitution" ] ]
#32 Mr. Spell. grist r = MOOList [ "", "", [ "gristmill", "grist" ] ]
#32 Mr. Spell. deu r = MOOList [ "", "t", [ "deus", "deuce" ] ]
#32 Mr. Spell. Barto r = MOOList [ "", "", [ "Barton", "Bartok" ] ]
#32 Mr. Spell. dev r = MOOList [ "", "ioe", [ "devastate" ] ]
#32 Mr. Spell. dew r = MOOList [ "", "", [ "dewy", "Dewitt", "Dewey", "dewdrop", "dewar", "dew" ] ]
#32 Mr. Spell. sheri r = MOOList [ "", "", [ "sheriff", "Sheridan" ] ]
#32 Mr. Spell. polar r = MOOList [ "", "io", [ "polar" ] ]
#32 Mr. Spell. dex r = MOOList [ "t", "er", [ ] ]
#32 Mr. Spell. resto r = MOOList [ "rati", "", [ "restorative", "restoration" ] ]
#32 Mr. Spell. Barth r = MOOList [ "", "", [ "Bartholomew", "Barth" ] ]
#32 Mr. Spell. Barte r = MOOList [ "", "n", [ "barter" ] ]
#32 Mr. Spell. Annal r = MOOList [ "", "e", [ "annal" ] ]
#32 Mr. Spell. restr r = MOOList [ "", "a", [ "restroom", "restrict" ] ]
#32 Mr. Spell. sherr r = MOOList [ "", "", [ "sherry", "Sherrill" ] ]
#32 Mr. Spell. dea r = MOOList [ "", "cdflnrt", [ ] ]
#32 Mr. Spell. deb r = MOOList [ "", "abiortu", [ "debenture" ] ]
#32 Mr. Spell. dec r = MOOList [ "", "aeilor", [ "deck", "Decca", "Dec" ] ]
#32 Mr. Spell. ded r = MOOList [ "", "u", [ "dedicate" ] ]
#32 Mr. Spell. illi r = MOOList [ "", "t", [ "Illinois", "illimitable", "illicit" ] ]
#32 Mr. Spell. dee r = MOOList [ "", "pr", [ "deem", "deed", "Dee" ] ]
#32 Mr. Spell. def r = MOOList [ "", "aeilor", [ "defy", "defunct", "deft" ] ]
#32 Mr. Spell. deg r = MOOList [ "", "aeru", [ ] ]
#32 Mr. Spell. deh r = MOOList [ "", "", [ "dehydrate", "dehumidify" ] ]
#32 Mr. Spell. illu r = MOOList [ "", "ms", [ ] ]
#32 Mr. Spell. dei r = MOOList [ "", "", [ "deity", "deign", "deify" ] ]
#32 Mr. Spell. glyco r = MOOList [ "", "", [ "glycol", "glycogen" ] ]
#32 Mr. Spell. dej r = MOOList [ "", "", [ "deject", "deja" ] ]
#32 Mr. Spell. Calla r = MOOList [ "", "", [ "callable", "Callahan", "Callaghan", "calla" ] ]
#32 Mr. Spell. resta r = MOOList [ "ura", "", [ "restaurateur", "restaurant" ] ]
#32 Mr. Spell. Gilb r = MOOList [ "ert", "", [ "Gilbertson", "gilbert" ] ]
#32 Mr. Spell. dem r = MOOList [ "", "aeiou", [ "demystify", "Dempsey" ] ]
#32 Mr. Spell. den r = MOOList [ "", "deinostu", [ "deny", "Denver", "Denmark", "denature", "den" ] ]
#32 Mr. Spell. deo r = MOOList [ "", "x", [ "deodorant" ] ]
#32 Mr. Spell. Gile r = MOOList [ "", "", [ "Giles", "Gilead" ] ]
#32 Mr. Spell. dep r = MOOList [ "", "aeloru", [ "depth", "depict" ] ]
#32 Mr. Spell. bolsh r = MOOList [ "", "e", [ "Bolshoi" ] ]
#32 Mr. Spell. candl r = MOOList [ "e", "", [ "candlewick", "candlestick", "candlelight", "candle" ] ]
#32 Mr. Spell. explica r = MOOList [ "", "", [ "explicate", "explicable" ] ]
#32 Mr. Spell. quer r = MOOList [ "", "", [ "query", "querulous" ] ]
#32 Mr. Spell. ques r = MOOList [ "t", "i", [ "quest" ] ]
#32 Mr. Spell. cande r = MOOList [ "la", "", [ "candelabra", "candela" ] ]
#32 Mr. Spell. candi r = MOOList [ "d", "a", [ "Candide", "candid" ] ]
#32 Mr. Spell. place r = MOOList [ "", "n", [ "places", "placeholder", "placebo", "placeable", "place" ] ]
#32 Mr. Spell. compel r = MOOList [ "", "l", [ "compel" ] ]
#32 Mr. Spell. dynam r = MOOList [ "", "i", [ "dynamo" ] ]
#32 Mr. Spell. secret r = MOOList [ "", "ai", [ "secrete", "secret" ] ]
#32 Mr. Spell. immo r = MOOList [ "", "bdr", [ "immovable" ] ]
#32 Mr. Spell. Dolom r = MOOList [ "it", "", [ "dolomitic", "dolomite" ] ]
#32 Mr. Spell. placa r = MOOList [ "te", "", [ "placater", "placate" ] ]
#32 Mr. Spell. immi r = MOOList [ "", "g", [ "imminent", "immiscible" ] ]
#32 Mr. Spell. arbitr r = MOOList [ "a", "", [ "arbitrate", "arbitrary", "arbitrage" ] ]
#32 Mr. Spell. backb r = MOOList [ "o", "", [ "backbone", "backboard" ] ]
#32 Mr. Spell. mackina r = MOOList [ "", "", [ "Mackinaw", "Mackinac" ] ]
#32 Mr. Spell. immu r = MOOList [ "", "n", [ "immutable" ] ]
#32 Mr. Spell. compet r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. paren r = MOOList [ "t", "ah", [ "parent" ] ]
#32 Mr. Spell. germani r = MOOList [ "", "", [ "germanium", "Germanic" ] ]
#32 Mr. Spell. quee r = MOOList [ "", "", [ "queer", "queen" ] ]
#32 Mr. Spell. Edge r = MOOList [ "", "", [ "edgewise", "Edgerton", "edge" ] ]
#32 Mr. Spell. compen r = MOOList [ "", "ds", [ ] ]
#32 Mr. Spell. dynas r = MOOList [ "t", "", [ "dynasty", "dynastic", "dynast" ] ]
#32 Mr. Spell. Collie r = MOOList [ "", "", [ "Collier", "collie" ] ]
#32 Mr. Spell. House r = MOOList [ "", "bw", [ "houses", "housekeep", "household", "housefly", "house" ] ]
#32 Mr. Spell. imme r = MOOList [ "", "dr", [ "immense", "immemorial", "immeasurable" ] ]
#32 Mr. Spell. consig r = MOOList [ "n", "", [ "consignor", "consignee", "consign" ] ]
#32 Mr. Spell. Sex r = MOOList [ "", "t", [ "sexy", "sexual", "sex" ] ]
#32 Mr. Spell. introduct r = MOOList [ "", "", [ "introductory", "introduction" ] ]
#32 Mr. Spell. consid r = MOOList [ "er", "", [ "considering", "considered", "considerate", "consider" ] ]
#32 Mr. Spell. lett r = MOOList [ "", "e", [ "letting", "lettuce" ] ]
#32 Mr. Spell. imma r = MOOList [ "", "t", [ "immanent", "immaculate" ] ]
#32 Mr. Spell. pray r = MOOList [ "", "", [ "prayerful", "pray" ] ]
#32 Mr. Spell. Hutchi r = MOOList [ "", "n", [ "Hutchison" ] ]
#32 Mr. Spell. decid r = MOOList [ "", "e", [ "deciding", "deciduous" ] ]
#32 Mr. Spell. pran r = MOOList [ "", "", [ "prank", "prance" ] ]
#32 Mr. Spell. leth r = MOOList [ "", "a", [ "Lethe" ] ]
#32 Mr. Spell. tantal r = MOOList [ "u", "", [ "Tantalus", "tantalum" ] ]
#32 Mr. Spell. Collin r = MOOList [ "", "", [ "Collins", "collinear" ] ]
#32 Mr. Spell. stream r = MOOList [ "", "", [ "streamside", "streamline", "stream" ] ]
#32 Mr. Spell. consis r = MOOList [ "t", "", [ "consistent", "consist" ] ]
#32 Mr. Spell. Coat r = MOOList [ "", "", [ "coattail", "Coates", "coat" ] ]
#32 Mr. Spell. prai r = MOOList [ "", "s", [ "prairie" ] ]
#32 Mr. Spell. prag r = MOOList [ "", "m", [ "Prague" ] ]
#32 Mr. Spell. falla r = MOOList [ "c", "", [ "fallacy", "fallacious" ] ]
#32 Mr. Spell. decen r = MOOList [ "", "", [ "decent", "decennial" ] ]
#32 Mr. Spell. erad r = MOOList [ "ica", "", [ "eradicate", "eradicable" ] ]
#32 Mr. Spell. reach r = MOOList [ "", "e", [ "reaching", "reach" ] ]
#32 Mr. Spell. contempt r = MOOList [ "", "", [ "contemptuous", "contemptible", "contempt" ] ]
#32 Mr. Spell. Beo r = MOOList [ "", "", [ "Beowulf", "Beograd" ] ]
#32 Mr. Spell. epigram r = MOOList [ "", "", [ "epigrammatic", "epigram" ] ]
#32 Mr. Spell. contempo r = MOOList [ "ra", "", [ "contemporary", "contemporaneous" ] ]
#32 Mr. Spell. teeth r = MOOList [ "", "e", [ "teething", "teeth" ] ]
#32 Mr. Spell. decep r = MOOList [ "ti", "", [ "deceptive", "deception" ] ]
#32 Mr. Spell. Bel r = MOOList [ "", "afgilotv", [ "belying", "Belshazzar", "Belmont", "belch", "bel" ] ]
#32 Mr. Spell. incidenta r = MOOList [ "l", "", [ "incidentally", "incidental" ] ]
#32 Mr. Spell. less r = MOOList [ "", "eo", [ "less" ] ]
#32 Mr. Spell. dia r = MOOList [ "", "bcglmnpt", [ "diary", "diadem" ] ]
#32 Mr. Spell. eras r = MOOList [ "", "", [ "erasure", "Erastus", "Erasmus", "erase", "erasable" ] ]
#32 Mr. Spell. decei r = MOOList [ "", "t", [ "deceive" ] ]
#32 Mr. Spell. Bee r = MOOList [ "", "bcft", [ "beer", "beep", "been", "beehive", "bee" ] ]
#32 Mr. Spell. dic r = MOOList [ "", "hkt", [ "dicotyledon", "dice" ] ]
#32 Mr. Spell. react r = MOOList [ "", "", [ "reactionary", "reactant" ] ]
#32 Mr. Spell. polyhedra r = MOOList [ "", "", [ "polyhedral", "polyhedra" ] ]
#32 Mr. Spell. did r = MOOList [ "", "", [ "Dido", "didn't", "diddle", "didactic", "did" ] ]
#32 Mr. Spell. helms r = MOOList [ "m", "", [ "helmsmen", "helmsman" ] ]
#32 Mr. Spell. fallo r = MOOList [ "", "", [ "fallow", "fallout", "falloff" ] ]
#32 Mr. Spell. aest r = MOOList [ "het", "", [ "aesthetic", "aesthete" ] ]
#32 Mr. Spell. autom r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. auton r = MOOList [ "om", "", [ "autonomy", "autonomous", "autonomic" ] ]
#32 Mr. Spell. Puer r = MOOList [ "", "", [ "Puerto", "puerile" ] ]
#32 Mr. Spell. autoc r = MOOList [ "", "or", [ "autoclave" ] ]
#32 Mr. Spell. sight r = MOOList [ "", "s", [ "sight" ] ]
#32 Mr. Spell. increase r = MOOList [ "", "", [ "increases", "increased", "increase" ] ]
#32 Mr. Spell. isomo r = MOOList [ "rph", "", [ "isomorphic", "isomorph" ] ]
#32 Mr. Spell. div r = MOOList [ "", "aeio", [ "divulge" ] ]
#32 Mr. Spell. backs r = MOOList [ "", "t", [ "backspace", "backside" ] ]
#32 Mr. Spell. dix r = MOOList [ "", "i", [ "Dixon" ] ]
#32 Mr. Spell. cross r = MOOList [ "", "bw", [ "crosstalk", "crossroad", "crosspoint", "crossover", "crosslink", "crosshatch", "crosscut", "crossarm", "cross" ] ]
#32 Mr. Spell. fuck r = MOOList [ "", "e", [ "fucks", "fucking", "fuck" ] ]
#32 Mr. Spell. backp r = MOOList [ "", "l", [ "backpack" ] ]
#32 Mr. Spell. fuch r = MOOList [ "s", "", [ "Fuchsia", "Fuchs" ] ]
#32 Mr. Spell. backl r = MOOList [ "", "", [ "backlog", "backlash" ] ]
#32 Mr. Spell. dif r = MOOList [ "", "f", [ "difluoride" ] ]
#32 Mr. Spell. aero r = MOOList [ "", "bs", [ "aeronautic", "aerogene", "aerodynamic" ] ]
#32 Mr. Spell. dig r = MOOList [ "", "einr", [ "digging", "dig" ] ]
#32 Mr. Spell. dil r = MOOList [ "", "aelu", [ "dilogarithm", "diligent" ] ]
#32 Mr. Spell. Bernie r = MOOList [ "", "", [ "Berniece", "Bernie" ] ]
#32 Mr. Spell. dim r = MOOList [ "", "ei", [ "dimple", "dim" ] ]
#32 Mr. Spell. wholes r = MOOList [ "", "", [ "wholesome", "wholesale" ] ]
#32 Mr. Spell. dio r = MOOList [ "", "cnpr", [ "dioxide", "diode" ] ]
#32 Mr. Spell. dip r = MOOList [ "", "hl", [ "dipole", "dip" ] ]
#32 Mr. Spell. dir r = MOOList [ "", "et", [ "Dirichlet", "dirge", "Dirac" ] ]
#32 Mr. Spell. backw r = MOOList [ "", "a", [ "backwood" ] ]
#32 Mr. Spell. Garri r = MOOList [ "son", "", [ "Garrisonian", "garrison" ] ]
#32 Mr. Spell. dis r = MOOList [ "", "acdghmnpqrst", [ "disyllable", "disulfide", "disk", "disjunct", "disembowel", "disburse", "Dis" ] ]
#32 Mr. Spell. She r = MOOList [ "", "adeil'npr", [ "Sheffield", "she" ] ]
#32 Mr. Spell. dit r = MOOList [ "", "t", [ "dither", "ditch" ] ]
#32 Mr. Spell. Sie r = MOOList [ "", "gn", [ "sieve", "siesta", "sierra", "Siemens" ] ]
#32 Mr. Spell. paras r = MOOList [ "", "i", [ "parasympathetic", "parasol" ] ]
#32 Mr. Spell. Sic r = MOOList [ "", "ik", [ "sic" ] ]
#32 Mr. Spell. Domini r = MOOList [ "", "c", [ "Dominique", "dominion" ] ]
#32 Mr. Spell. Sib r = MOOList [ "", "l", [ "sibyl", "sibilant", "Siberia", "sib" ] ]
#32 Mr. Spell. parap r = MOOList [ "", "h", [ "parapsychology", "parapet" ] ]
#32 Mr. Spell. Vero r = MOOList [ "n", "", [ "Veronica", "Verona" ] ]
#32 Mr. Spell. quan r = MOOList [ "", "t", [ "quandary" ] ]
#32 Mr. Spell. Verd r = MOOList [ "", "i", [ "Verde", "verdant" ] ]
#32 Mr. Spell. Shy r = MOOList [ "", "", [ "Shylock", "shy" ] ]
#32 Mr. Spell. cycli r = MOOList [ "", "", [ "cyclist", "cyclic" ] ]
#32 Mr. Spell. Angelin r = MOOList [ "", "", [ "Angeline", "Angelina" ] ]
#32 Mr. Spell. ult r = MOOList [ "", "i", [ "ultra", "ulterior" ] ]
#32 Mr. Spell. quar r = MOOList [ "", "rt", [ "quark", "quarantine" ] ]
#32 Mr. Spell. quas r = MOOList [ "", "i", [ "quash", "quasar" ] ]
#32 Mr. Spell. quat r = MOOList [ "", "", [ "quatrain", "quaternary" ] ]
#32 Mr. Spell. parab r = MOOList [ "ol", "o", [ "parabolic", "parabola" ] ]
#32 Mr. Spell. quai r = MOOList [ "", "", [ "quaint", "quail" ] ]
#32 Mr. Spell. parag r = MOOList [ "", "o", [ "Paraguay", "paragraph" ] ]
#32 Mr. Spell. decli r = MOOList [ "", "n", [ "declivity" ] ]
#32 Mr. Spell. cyclo r = MOOList [ "", "pt", [ "cyclorama", "cyclone" ] ]
#32 Mr. Spell. Sin r = MOOList [ "", "cegiku", [ "sinter", "sinh", "sinful", "Sinai", "sin" ] ]
#32 Mr. Spell. qual r = MOOList [ "", "i", [ "qualm" ] ]
#32 Mr. Spell. parad r = MOOList [ "", "io", [ "parade" ] ]
#32 Mr. Spell. immun r = MOOList [ "", "", [ "immunoelectrophoresis", "immune" ] ]
#32 Mr. Spell. oceani r = MOOList [ "", "", [ "oceanic", "Oceania" ] ]
#32 Mr. Spell. Vers r = MOOList [ "", "a", [ "versus", "version", "verse" ] ]
#32 Mr. Spell. synthes r = MOOList [ "", "", [ "synthesis", "syntheses" ] ]
#32 Mr. Spell. ulc r = MOOList [ "er", "", [ "ulcerate", "ulcer" ] ]
#32 Mr. Spell. decla r = MOOList [ "", "mr", [ "declassify", "declaim" ] ]
#32 Mr. Spell. paran r = MOOList [ "o", "i", [ "paranormal" ] ]
#32 Mr. Spell. quac r = MOOList [ "k", "", [ "quackery", "quack" ] ]
#32 Mr. Spell. param r = MOOList [ "", "a", [ "Paramus", "paramount", "paramilitary", "parameter" ] ]
#32 Mr. Spell. quad r = MOOList [ "", "r", [ "quad" ] ]
#32 Mr. Spell. paral r = MOOList [ "", "l", [ "paralysis", "paralinguistic" ] ]
#32 Mr. Spell. reveren r = MOOList [ "", "", [ "reverent", "reverend" ] ]
#32 Mr. Spell. Angelic r = MOOList [ "", "", [ "Angelica", "angelic" ] ]
#32 Mr. Spell. typog r = MOOList [ "raph", "", [ "typography", "typographer" ] ]
#32 Mr. Spell. umb r = MOOList [ "", "ir", [ "umber" ] ]
#32 Mr. Spell. lipsc r = MOOList [ "", "", [ "Lipscomb", "Lipschitz" ] ]
#32 Mr. Spell. Eucl r = MOOList [ "id", "", [ "Euclidean", "Euclid" ] ]
#32 Mr. Spell. uni r = MOOList [ "", "odfmpstv", [ "Unix", "Uniroyal", "unique", "uninominal", "unilateral", "unicorn", "uniaxial" ] ]
#32 Mr. Spell. unk r = MOOList [ "", "", [ "unknown", "unkempt" ] ]
#32 Mr. Spell. optimi r = MOOList [ "s", "", [ "optimist", "optimism" ] ]
#32 Mr. Spell. portug r = MOOList [ "", "", [ "Portuguese", "Portugal" ] ]
#32 Mr. Spell. compressi r = MOOList [ "", "", [ "compressive", "compression", "compressible" ] ]
#32 Mr. Spell. decis r = MOOList [ "i", "o", [ "decisive" ] ]
#32 Mr. Spell. crowb r = MOOList [ "", "", [ "crowberry", "crowbait" ] ]
#32 Mr. Spell. fluori r = MOOList [ "", "d", [ "fluorite", "fluorine" ] ]
#32 Mr. Spell. uns r = MOOList [ "", "c", [ "unsure" ] ]
#32 Mr. Spell. discipli r = MOOList [ "n", "", [ "discipline", "disciplinary" ] ]
#32 Mr. Spell. helic r = MOOList [ "", "", [ "helicopter", "helical" ] ]
#32 Mr. Spell. fluore r = MOOList [ "sce", "", [ "fluorescent", "fluorescein", "fluoresce" ] ]
#32 Mr. Spell. decim r = MOOList [ "a", "", [ "decimate", "decimal" ] ]
#32 Mr. Spell. Europe r = MOOList [ "", "a", [ "Europe" ] ]
#32 Mr. Spell. Big r = MOOList [ "", "o", [ "Biggs", "Bigelow", "big" ] ]
#32 Mr. Spell. helio r = MOOList [ "", "", [ "heliotrope", "heliocentric" ] ]
#32 Mr. Spell. breas r = MOOList [ "t", "", [ "breastwork", "breastplate", "breast" ] ]
#32 Mr. Spell. Frigi r = MOOList [ "d", "", [ "Frigidaire", "frigid" ] ]
#32 Mr. Spell. una r = MOOList [ "", "n", [ "unary" ] ]
#32 Mr. Spell. unb r = MOOList [ "", "", [ "unbidden", "unbeknownst" ] ]
#32 Mr. Spell. unc r = MOOList [ "", "l", [ "unceremoniously", "unction", "uncouth", "unchristian" ] ]
#32 Mr. Spell. compute r = MOOList [ "", "r", [ "compute" ] ]
#32 Mr. Spell. und r = MOOList [ "", "e", [ "undulate" ] ]
#32 Mr. Spell. optima r = MOOList [ "", "", [ "optimal", "optima" ] ]
#32 Mr. Spell. myst r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. Clint r = MOOList [ "", "", [ "Clinton", "Clint" ] ]
#32 Mr. Spell. breat r = MOOList [ "h", "", [ "breathy", "breathtaking", "breathe", "breath" ] ]
#32 Mr. Spell. unf r = MOOList [ "", "", [ "unfriendly", "unfortunately" ] ]
#32 Mr. Spell. computa r = MOOList [ "tion", "", [ "computations", "computation" ] ]
#32 Mr. Spell. canis r = MOOList [ "", "", [ "canister", "Canis" ] ]
#32 Mr. Spell. compla r = MOOList [ "", "i", [ "complacent" ] ]
#32 Mr. Spell. leng r = MOOList [ "th", "", [ "lengthy", "lengthwise", "lengthen", "length" ] ]
#32 Mr. Spell. cowpo r = MOOList [ "", "", [ "cowpox", "cowpony", "cowpoke" ] ]
#32 Mr. Spell. consol r = MOOList [ "", "", [ "consolidate", "console", "consolation" ] ]
#32 Mr. Spell. consultat r = MOOList [ "i", "", [ "consultative", "consultation" ] ]
#32 Mr. Spell. compli r = MOOList [ "", "cm", [ "compline", "compliant" ] ]
#32 Mr. Spell. break r = MOOList [ "", "a", [ "breakwater", "breakup", "breakthrough", "breakpoint", "breakoff", "breakfast", "breakdown", "break" ] ]
#32 Mr. Spell. bread r = MOOList [ "", "", [ "breadth", "breadroot", "breadfruit", "breadboard", "bread" ] ]
#32 Mr. Spell. Sky r = MOOList [ "", "lw", [ "skyscrape", "skyrocket", "skyjack", "skyhook", "Skye", "sky" ] ]
#32 Mr. Spell. perform r = MOOList [ "", "a", [ "perform" ] ]
#32 Mr. Spell. comple r = MOOList [ "", "mtx", [ ] ]
#32 Mr. Spell. consor r = MOOList [ "t", "", [ "consortium", "consort" ] ]
#32 Mr. Spell. familia r = MOOList [ "", "", [ "familiar", "familial" ] ]
#32 Mr. Spell. seduct r = MOOList [ "i", "", [ "seductive", "seduction" ] ]
#32 Mr. Spell. conson r = MOOList [ "ant", "", [ "consonantal", "consonant" ] ]
#32 Mr. Spell. Slo r = MOOList [ "", "agptuvw", [ "slosh", "sloop", "sloe", "Slocum", "slob" ] ]
#32 Mr. Spell. colloqu r = MOOList [ "", "i", [ "colloquy" ] ]
#32 Mr. Spell. watchm r = MOOList [ "", "a", [ "watchmen" ] ]
#32 Mr. Spell. upho r = MOOList [ "l", "s", [ "uphold" ] ]
#32 Mr. Spell. battl r = MOOList [ "e", "f", [ "battleground", "battle" ] ]
#32 Mr. Spell. Veni r = MOOList [ "", "", [ "venison", "Venice", "venial" ] ]
#32 Mr. Spell. upl r = MOOList [ "", "", [ "uplift", "upland" ] ]
#32 Mr. Spell. uphe r = MOOList [ "", "", [ "upheld", "upheaval" ] ]
#32 Mr. Spell. Keny r = MOOList [ "", "", [ "Kenyon", "Kenya" ] ]
#32 Mr. Spell. upp r = MOOList [ "er", "c", [ "uppermost", "upper" ] ]
#32 Mr. Spell. TOE r = MOOList [ "", "", [ "toenail", "TOEFL", "toe" ] ]
#32 Mr. Spell. Kent r = MOOList [ "", "", [ "Kentucky", "Kenton", "Kent" ] ]
#32 Mr. Spell. chloropl r = MOOList [ "a", "", [ "chloroplatinate", "chloroplast" ] ]
#32 Mr. Spell. upr r = MOOList [ "", "io", [ "upraise" ] ]
#32 Mr. Spell. ups r = MOOList [ "", "eit", [ "upswing", "upsurge", "upslope", "upshot" ] ]
#32 Mr. Spell. doc r = MOOList [ "", "ktu", [ "docile" ] ]
#32 Mr. Spell. doe r = MOOList [ "", "s", [ "doe" ] ]
#32 Mr. Spell. decon r = MOOList [ "", "tv", [ ] ]
#32 Mr. Spell. decom r = MOOList [ "p", "or", [ "decompile" ] ]
#32 Mr. Spell. batte r = MOOList [ "", "", [ "battery", "batten", "Battelle" ] ]
#32 Mr. Spell. upw r = MOOList [ "", "", [ "upwind", "upward" ] ]
#32 Mr. Spell. lemm r = MOOList [ "", "", [ "lemming", "lemma" ] ]
#32 Mr. Spell. dog r = MOOList [ "", "bgmt", [ "dogwood", "dogleg", "doghouse", "dogfish", "Doge", "dog" ] ]
#32 Mr. Spell. lemo r = MOOList [ "n", "", [ "lemonade", "lemon" ] ]
#32 Mr. Spell. decor r = MOOList [ "", "", [ "decorum", "decorticate", "decorous", "decorate", "decor" ] ]
#32 Mr. Spell. statio r = MOOList [ "n", "a", [ "stationmaster", "stationery" ] ]
#32 Mr. Spell. Smy r = MOOList [ "", "", [ "Smythe", "Smyrna" ] ]
#32 Mr. Spell. well r = MOOList [ "", "e", [ "Wells", "wellington", "wellbeing", "well" ] ]
#32 Mr. Spell. upb r = MOOList [ "", "r", [ "upbeat" ] ]
#32 Mr. Spell. upd r = MOOList [ "", "", [ "updraft", "update" ] ]
#32 Mr. Spell. Venu r = MOOList [ "s", "", [ "Venusian", "Venus" ] ]
#32 Mr. Spell. uph r = MOOList [ "", "eo", [ "uphill" ] ]
#32 Mr. Spell. welc r = MOOList [ "", "", [ "welcome", "Welch" ] ]
#32 Mr. Spell. avoi r = MOOList [ "d", "", [ "avoidance", "avoid" ] ]
#32 Mr. Spell. Sni r = MOOList [ "", "fp", [ "snivel", "snigger", "Snider", "snick" ] ]
#32 Mr. Spell. mater r = MOOList [ "", "in", [ "mater" ] ]
#32 Mr. Spell. molli r = MOOList [ "", "", [ "mollify", "Mollie" ] ]
#32 Mr. Spell. detra r = MOOList [ "ct", "", [ "detractor", "detract" ] ]
#32 Mr. Spell. Sny r = MOOList [ "", "", [ "Snyder", "snyaptic" ] ]
#32 Mr. Spell. dol r = MOOList [ "", "elot", [ "dolphin", "doldrum", "dolce", "Dolan" ] ]
#32 Mr. Spell. dom r = MOOList [ "", "ei", [ "domain" ] ]
#32 Mr. Spell. succes r = MOOList [ "s", "i", [ "successor", "successful", "success" ] ]
#32 Mr. Spell. dop r = MOOList [ "", "", [ "Doppler", "dope", "dopant" ] ]
#32 Mr. Spell. molly r = MOOList [ "", "", [ "mollycoddle", "Molly" ] ]
#32 Mr. Spell. dos r = MOOList [ "", "", [ "Dostoevsky", "dossier", "dosimeter", "dose", "dosage" ] ]
#32 Mr. Spell. dot r = MOOList [ "", "", [ "dote", "dot" ] ]
#32 Mr. Spell. drive r = MOOList [ "", "r", [ "driveway", "driven", "drive" ] ]
#32 Mr. Spell. dov r = MOOList [ "e", "", [ "dovetail", "dovekie", "dove" ] ]
#32 Mr. Spell. Kenn r = MOOList [ "", "e", [ "Kennan" ] ]
#32 Mr. Spell. dow r = MOOList [ "", "n", [ "dowry", "Dowling", "dowitcher", "dowel", "dowager", "Dow" ] ]
#32 Mr. Spell. doz r = MOOList [ "e", "n", [ "doze" ] ]
#32 Mr. Spell. parla r = MOOList [ "", "", [ "parlay", "parlance" ] ]
#32 Mr. Spell. photog r = MOOList [ "", "", [ "photography", "photogenic" ] ]
#32 Mr. Spell. compon r = MOOList [ "ent", "", [ "componentry", "component" ] ]
#32 Mr. Spell. photol r = MOOList [ "y", "", [ "photolytic", "photolysis" ] ]
#32 Mr. Spell. canno r = MOOList [ "", "n", [ "cannot" ] ]
#32 Mr. Spell. Missis r = MOOList [ "sippi", "", [ "Mississippian", "Mississippi" ] ]
#32 Mr. Spell. inhibito r = MOOList [ "r", "", [ "inhibitory", "inhibitor" ] ]
#32 Mr. Spell. booksh r = MOOList [ "el", "", [ "bookshelves", "bookshelf" ] ]
#32 Mr. Spell. parli r = MOOList [ "ament", "a", [ "parliament" ] ]
#32 Mr. Spell. onto r = MOOList [ "", "", [ "ontology", "ontogeny", "onto" ] ]
#32 Mr. Spell. canni r = MOOList [ "", "", [ "cannister", "cannibal" ] ]
#32 Mr. Spell. combinato r = MOOList [ "ri", "", [ "combinatoric", "combinatorial" ] ]
#32 Mr. Spell. ura r = MOOList [ "", "n", [ "uracil" ] ]
#32 Mr. Spell. phenomeno r = MOOList [ "", "", [ "phenomenon", "phenomenology" ] ]
#32 Mr. Spell. compos r = MOOList [ "", "i", [ "composure", "compost", "compose" ] ]
#32 Mr. Spell. carboni r = MOOList [ "", "", [ "carbonium", "carbonic" ] ]
#32 Mr. Spell. myoc r = MOOList [ "ardi", "", [ "myocardium", "myocardial" ] ]
#32 Mr. Spell. ure r = MOOList [ "", "t", [ "uremia", "urea" ] ]
#32 Mr. Spell. canna r = MOOList [ "", "", [ "cannabis", "canna" ] ]
#32 Mr. Spell. deton r = MOOList [ "a", "", [ "detonate", "detonable" ] ]
#32 Mr. Spell. bypa r = MOOList [ "", "", [ "bypath", "bypass" ] ]
#32 Mr. Spell. urg r = MOOList [ "", "e", [ "urging" ] ]
#32 Mr. Spell. Sop r = MOOList [ "", "h", [ "soprano", "sop" ] ]
#32 Mr. Spell. myop r = MOOList [ "i", "", [ "myopic", "myopia" ] ]
#32 Mr. Spell. uri r = MOOList [ "", "n", [ "Uris", "Uri" ] ]
#32 Mr. Spell. canne r = MOOList [ "", "", [ "cannery", "cannel" ] ]
#32 Mr. Spell. Bernar r = MOOList [ "d", "", [ "Bernardo", "Bernardino", "Bernard" ] ]
#32 Mr. Spell. carbona r = MOOList [ "", "", [ "carbonate", "carbonaceous" ] ]
#32 Mr. Spell. breez r = MOOList [ "", "", [ "breezy", "breeze" ] ]
#32 Mr. Spell. imbr r = MOOList [ "", "", [ "imbrue", "imbroglio", "Imbrium" ] ]
#32 Mr. Spell. usu r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. tactic r = MOOList [ "", "", [ "tactician", "tactic" ] ]
#32 Mr. Spell. dre r = MOOList [ "", "as", [ "Dreyfuss", "Drexel", "drew", "drench", "dreg", "dredge" ] ]
#32 Mr. Spell. corrupti r = MOOList [ "", "", [ "corruption", "corruptible" ] ]
#32 Mr. Spell. typew r = MOOList [ "rit", "", [ "typewritten", "typewrite" ] ]
#32 Mr. Spell. phenomena r = MOOList [ "", "", [ "phenomenal", "phenomena" ] ]
#32 Mr. Spell. dri r = MOOList [ "", "bpvz", [ "Driscoll", "drink", "drill", "drift" ] ]
#32 Mr. Spell. traito r = MOOList [ "r", "", [ "traitorous", "traitor" ] ]
#32 Mr. Spell. parki r = MOOList [ "", "", [ "parkish", "Parkinson" ] ]
#32 Mr. Spell. weir r = MOOList [ "", "", [ "weird", "weir" ] ]
#32 Mr. Spell. types r = MOOList [ "", "e", [ "typescript", "types" ] ]
#32 Mr. Spell. leit r = MOOList [ "moti", "", [ "leitmotiv", "leitmotif" ] ]
#32 Mr. Spell. scene r = MOOList [ "", "", [ "scenery", "scene" ] ]
#32 Mr. Spell. picker r = MOOList [ "", "", [ "Pickering", "pickerel" ] ]
#32 Mr. Spell. Genev r = MOOList [ "", "", [ "Genevieve", "Geneva" ] ]
#32 Mr. Spell. usa r = MOOList [ "", "", [ "usage", "USAF", "usable", "USA" ] ]
#32 Mr. Spell. Boi r = MOOList [ "", "s", [ "boil" ] ]
#32 Mr. Spell. decol r = MOOList [ "", "l", [ "decolonize" ] ]
#32 Mr. Spell. chimer r = MOOList [ "", "", [ "chimeric", "chimera" ] ]
#32 Mr. Spell. Boh r = MOOList [ "", "", [ "Bohr", "Bohemia" ] ]
#32 Mr. Spell. weig r = MOOList [ "h", "t", [ "weigh" ] ]
#32 Mr. Spell. mantis r = MOOList [ "", "", [ "mantissa", "mantis" ] ]
#32 Mr. Spell. use r = MOOList [ "", "", [ "useless", "uses", "useful", "used", "use" ] ]
#32 Mr. Spell. Boe r = MOOList [ "", "", [ "Boeotia", "Boeing" ] ]
#32 Mr. Spell. consta r = MOOList [ "nt", "i", [ "constant" ] ]
#32 Mr. Spell. Bob r = MOOList [ "", "b", [ "bobolink", "bobcat", "bob" ] ]
#32 Mr. Spell. harmoni r = MOOList [ "", "c", [ "harmonious" ] ]
#32 Mr. Spell. uto r = MOOList [ "pia", "", [ "utopian", "utopia" ] ]
#32 Mr. Spell. consti r = MOOList [ "tu", "t", [ "constituent" ] ]
#32 Mr. Spell. execr r = MOOList [ "a", "", [ "execrate", "execrable" ] ]
#32 Mr. Spell. typho r = MOOList [ "", "", [ "typhoon", "Typhon", "typhoid" ] ]
#32 Mr. Spell. plagu r = MOOList [ "e", "", [ "plaguey", "plague" ] ]
#32 Mr. Spell. utt r = MOOList [ "er", "", [ "uttermost", "utterance", "utter" ] ]
#32 Mr. Spell. conste r = MOOList [ "", "", [ "consternate", "constellate" ] ]
#32 Mr. Spell. Bow r = MOOList [ "", "delm", [ "bowstring", "bowie", "bowfin", "bow" ] ]
#32 Mr. Spell. execu r = MOOList [ "t", "i", [ "executrix", "executor", "execute" ] ]
#32 Mr. Spell. electrol r = MOOList [ "y", "t", [ "electrolysis" ] ]
#32 Mr. Spell. constr r = MOOList [ "", "aiu", [ ] ]
#32 Mr. Spell. Bos r = MOOList [ "", "o", [ "Boswell", "Boston", "boss", "Bose", "Bosch" ] ]
#32 Mr. Spell. electron r = MOOList [ "", "i", [ "electron" ] ]
#32 Mr. Spell. electrop r = MOOList [ "hor", "", [ "electrophorus", "electrophoresis" ] ]
#32 Mr. Spell. plagi r = MOOList [ "", "a", [ "plagioclase" ] ]
#32 Mr. Spell. dro r = MOOList [ "", "opsw", [ "drove", "drought", "drone", "dromedary", "droll" ] ]
#32 Mr. Spell. equi r = MOOList [ "", "lnptv", [ "equidistant" ] ]
#32 Mr. Spell. ute r = MOOList [ "", "r", [ "utensil" ] ]
#32 Mr. Spell. dru r = MOOList [ "", "dgmn", [ "Drury", "druid", "drub" ] ]
#32 Mr. Spell. paris r = MOOList [ "", "h", [ "Parisian", "Paris" ] ]
#32 Mr. Spell. uti r = MOOList [ "", "l", [ "Utica" ] ]
#32 Mr. Spell. dry r = MOOList [ "", "", [ "Dryden", "dryad", "dry" ] ]
#32 Mr. Spell. xyle r = MOOList [ "", "", [ "xylene", "xylem" ] ]
#32 Mr. Spell. compre r = MOOList [ "", "hs", [ ] ]
#32 Mr. Spell. Lync r = MOOList [ "h", "", [ "Lynchburg", "lynch" ] ]
#32 Mr. Spell. Hallo r = MOOList [ "w", "", [ "Halloween", "hallow" ] ]
#32 Mr. Spell. equa r = MOOList [ "", "t", [ "equanimity", "equal", "equable" ] ]
#32 Mr. Spell. consum r = MOOList [ "", "pe", [ "consumable", "consuming", "consummate" ] ]
#32 Mr. Spell. Smal r = MOOList [ "l", "e", [ "smalltime", "smallpox", "smallish", "small" ] ]
#32 Mr. Spell. consul r = MOOList [ "", "at", [ "consul" ] ]
#32 Mr. Spell. earthmo r = MOOList [ "v", "", [ "earthmoving", "earthmover" ] ]
#32 Mr. Spell. upbr r = MOOList [ "", "", [ "upbring", "upbraid" ] ]
#32 Mr. Spell. legu r = MOOList [ "m", "", [ "leguminous", "legume" ] ]
#32 Mr. Spell. Halle r = MOOList [ "", "", [ "Halley", "hallelujah" ] ]
#32 Mr. Spell. stater r = MOOList [ "", "", [ "stateroom", "stater" ] ]
#32 Mr. Spell. canon r = MOOList [ "", "", [ "canonic", "canon" ] ]
#32 Mr. Spell. benefice r = MOOList [ "", "", [ "beneficent", "benefice" ] ]
#32 Mr. Spell. states r = MOOList [ "", "m", [ "states" ] ]
#32 Mr. Spell. incurre r = MOOList [ "", "", [ "incurrer", "incurred" ] ]
#32 Mr. Spell. debugg r = MOOList [ "", "e", [ "debugging" ] ]
#32 Mr. Spell. draftsm r = MOOList [ "", "", [ "draftsmen", "draftsman" ] ]
#32 Mr. Spell. lege r = MOOList [ "", "n", [ "legerdemain" ] ]
#32 Mr. Spell. duc r = MOOList [ "", "kt", [ "duchess", "ducat" ] ]
#32 Mr. Spell. tyrann r = MOOList [ "", "i", [ "tyranny", "Tyrannosaurus" ] ]
#32 Mr. Spell. due r = MOOList [ "", "", [ "dues", "duet", "duel", "due" ] ]
#32 Mr. Spell. duf r = MOOList [ "f", "", [ "Duffy", "duffel", "duff" ] ]
#32 Mr. Spell. lega r = MOOList [ "", "t", [ "legal", "legacy" ] ]
#32 Mr. Spell. molec r = MOOList [ "ul", "", [ "molecule", "molecular" ] ]
#32 Mr. Spell. benefici r = MOOList [ "a", "", [ "beneficiary", "beneficial" ] ]
#32 Mr. Spell. dul r = MOOList [ "", "l", [ "duly", "Duluth", "dulse", "dulcet" ] ]
#32 Mr. Spell. legg r = MOOList [ "", "", [ "leggy", "legging" ] ]
#32 Mr. Spell. invers r = MOOList [ "", "", [ "inversion", "inverse" ] ]
#32 Mr. Spell. dum r = MOOList [ "", "bp", [ "dummy", "Duma" ] ]
#32 Mr. Spell. legi r = MOOList [ "", "st", [ "legion", "legible" ] ]
#32 Mr. Spell. duo r = MOOList [ "pol", "", [ "duopoly", "duopolist" ] ]
#32 Mr. Spell. invert r = MOOList [ "", "", [ "invertible", "invertebrate", "invert" ] ]
#32 Mr. Spell. dup r = MOOList [ "", "l", [ "DuPont", "dupe" ] ]
#32 Mr. Spell. introduce r = MOOList [ "", "", [ "introduced", "introduces", "introduce" ] ]
#32 Mr. Spell. size r = MOOList [ "", "", [ "sizes", "size" ] ]
#32 Mr. Spell. avia r = MOOList [ "", "t", [ "aviary" ] ]
#32 Mr. Spell. decre r = MOOList [ "", "e", [ "decrement", "decrease" ] ]
#32 Mr. Spell. decry r = MOOList [ "", "p", [ "decry" ] ]
#32 Mr. Spell. housew r = MOOList [ "", "i", [ "housework" ] ]
#32 Mr. Spell. Bry r = MOOList [ "", "ao", [ "Bryn", "Bryce" ] ]
#32 Mr. Spell. bomba r = MOOList [ "", "s", [ "Bombay", "bombard" ] ]
#32 Mr. Spell. civil r = MOOList [ "", "", [ "civilian", "civil" ] ]
#32 Mr. Spell. week r = MOOList [ "", "", [ "weekend", "weekday", "weeks", "week" ] ]
#32 Mr. Spell. houseb r = MOOList [ "", "r", [ "houseboat" ] ]
#32 Mr. Spell. dur r = MOOList [ "", "aek", [ "Durward", "Durrell", "during", "Durham" ] ]
#32 Mr. Spell. leer r = MOOList [ "", "", [ "leery", "leer" ] ]
#32 Mr. Spell. dut r = MOOList [ "", "ci", [ "duty", "Dutton" ] ]
#32 Mr. Spell. weed r = MOOList [ "", "", [ "weedy", "weed" ] ]
#32 Mr. Spell. retarda r = MOOList [ "", "", [ "retardation", "retardant" ] ]
#32 Mr. Spell. JACk r = MOOList [ "", "as", [ "Jacky", "jackpot", "Jackman", "jackknife", "Jackie", "jacket", "jackdaw", "jackboot", "jack" ] ]
#32 Mr. Spell. Stu r = MOOList [ "", "bcdfmnprt", [ "Stuyvesant", "stultify", "Stuart", "Stu" ] ]
#32 Mr. Spell. reserv r = MOOList [ "", "", [ "reservoir", "reserve", "reservation" ] ]
#32 Mr. Spell. leew r = MOOList [ "a", "", [ "leeway", "leeward" ] ]
#32 Mr. Spell. workm r = MOOList [ "", "a", [ "workmen" ] ]
#32 Mr. Spell. shutt r = MOOList [ "le", "", [ "shuttlecock", "shuttle" ] ]
#32 Mr. Spell. Cori r = MOOList [ "", "n", [ "Coriolanus", "coriander" ] ]
#32 Mr. Spell. compul r = MOOList [ "s", "i", [ "compulsory" ] ]
#32 Mr. Spell. plate r = MOOList [ "", "", [ "platen", "platelet", "plateau", "plate" ] ]
#32 Mr. Spell. macke r = MOOList [ "", "", [ "Mackey", "mackerel", "MacKenzie" ] ]
#32 Mr. Spell. agricu r = MOOList [ "ltur", "", [ "agriculture", "agricultural" ] ]
#32 Mr. Spell. dwe r = MOOList [ "l", "", [ "dwelt", "dwell" ] ]
#32 Mr. Spell. workp r = MOOList [ "", "", [ "workplace", "workpiece" ] ]
#32 Mr. Spell. earl r = MOOList [ "", "", [ "early", "earlier", "earl" ] ]
#32 Mr. Spell. secreta r = MOOList [ "r", "i", [ "secretary" ] ]
#32 Mr. Spell. dwi r = MOOList [ "", "", [ "dwindle", "Dwight" ] ]
#32 Mr. Spell. founta r = MOOList [ "in", "", [ "fountainhead", "fountain" ] ]
#32 Mr. Spell. comput r = MOOList [ "", "ea", [ ] ]
#32 Mr. Spell. Edwa r = MOOList [ "rd", "i", [ "Edward" ] ]
#32 Mr. Spell. earn r = MOOList [ "", "i", [ "earnest", "earn" ] ]
#32 Mr. Spell. Blom r = MOOList [ "", "", [ "Blomquist", "Blomberg" ] ]
#32 Mr. Spell. eart r = MOOList [ "h", "em", [ "earthy", "earthworm", "earthquake", "earth" ] ]
#32 Mr. Spell. workb r = MOOList [ "", "", [ "workbook", "workbench" ] ]
#32 Mr. Spell. Sud r = MOOList [ "", "a", [ "suds", "sudden", "sud" ] ]
#32 Mr. Spell. secreti r = MOOList [ "", "", [ "secretive", "secretion" ] ]
#32 Mr. Spell. plati r = MOOList [ "", "t", [ "platinum" ] ]
#32 Mr. Spell. zool r = MOOList [ "og", "", [ "zoologist", "zoology" ] ]
#32 Mr. Spell. penal r = MOOList [ "", "", [ "penalty", "penal" ] ]
#32 Mr. Spell. canto r = MOOList [ "", "n", [ "cantor", "canto" ] ]
#32 Mr. Spell. plast r = MOOList [ "", "i", [ "plastron", "plaster" ] ]
#32 Mr. Spell. Edwi r = MOOList [ "n", "", [ "Edwina", "Edwin" ] ]
#32 Mr. Spell. optio r = MOOList [ "n", "a", [ "option" ] ]
#32 Mr. Spell. bije r = MOOList [ "cti", "", [ "bijective", "bijection" ] ]
#32 Mr. Spell. Norm r = MOOList [ "", "a", [ "norm" ] ]
#32 Mr. Spell. Lila r = MOOList [ "", "", [ "lilac", "Lila" ] ]
#32 Mr. Spell. Lill r = MOOList [ "", "i", [ "Lilly" ] ]
#32 Mr. Spell. Nord r = MOOList [ "", "", [ "Nordstrom", "Nordhoff" ] ]
#32 Mr. Spell. optim r = MOOList [ "", "ai", [ "optimum" ] ]
#32 Mr. Spell. Sut r = MOOList [ "", "", [ "suture", "Sutton", "Sutherland" ] ]
#32 Mr. Spell. Sus r = MOOList [ "", "acpt", [ "Sussex", "Susie", "sushi", "Sus" ] ]
#32 Mr. Spell. dwa r = MOOList [ "r", "", [ "dwarves", "dwarf" ] ]
#32 Mr. Spell. canti r = MOOList [ "", "", [ "cantilever", "canticle" ] ]
#32 Mr. Spell. Bub r = MOOList [ "", "", [ "bubble", "bub" ] ]
#32 Mr. Spell. Darw r = MOOList [ "in", "", [ "Darwinian", "Darwin" ] ]
#32 Mr. Spell. affr r = MOOList [ "", "", [ "affront", "affricate" ] ]
#32 Mr. Spell. papp r = MOOList [ "", "", [ "pappy", "Pappas" ] ]
#32 Mr. Spell. canta r = MOOList [ "", "", [ "cantaloupe", "Cantabrigian" ] ]
#32 Mr. Spell. plasm r = MOOList [ "", "", [ "plasmon", "plasma", "plasm" ] ]
#32 Mr. Spell. Pitts r = MOOList [ "", "", [ "Pittston", "Pittsfield", "Pittsburgh" ] ]
#32 Mr. Spell. Swarth r = MOOList [ "", "", [ "swarthy", "Swarthout", "Swarthmore" ] ]
#32 Mr. Spell. papy r = MOOList [ "r", "", [ "papyrus", "papyri" ] ]
#32 Mr. Spell. Bur r = MOOList [ "", "deglmnrst", [ "bury", "Burundi", "burp", "Burke", "burial", "Burch", "burbank" ] ]
#32 Mr. Spell. affa r = MOOList [ "", "", [ "affair", "affable" ] ]
#32 Mr. Spell. pape r = MOOList [ "r", "w", [ "papers", "papery", "paperback", "paper" ] ]
#32 Mr. Spell. circumstanc r = MOOList [ "e", "", [ "circumstances", "circumstance" ] ]
#32 Mr. Spell. affe r = MOOList [ "", "c", [ "afferent" ] ]
#32 Mr. Spell. papa r = MOOList [ "", "", [ "papaw", "papal", "papa" ] ]
#32 Mr. Spell. protesta r = MOOList [ "", "", [ "protestation", "protestant" ] ]
#32 Mr. Spell. Lomba r = MOOList [ "rd", "", [ "Lombardy", "Lombard" ] ]
#32 Mr. Spell. erro r = MOOList [ "", "", [ "error", "erroneous", "Errol" ] ]
#32 Mr. Spell. affi r = MOOList [ "", "r", [ "affix", "affine", "affiliate", "affidavit", "affiance" ] ]
#32 Mr. Spell. technoc r = MOOList [ "rat", "", [ "technocratic", "technocrat" ] ]
#32 Mr. Spell. devote r = MOOList [ "", "", [ "devotee", "devote" ] ]
#32 Mr. Spell. shuto r = MOOList [ "", "", [ "shutout", "shutoff" ] ]
#32 Mr. Spell. doom r = MOOList [ "", "", [ "doomsday", "doom" ] ]
#32 Mr. Spell. affl r = MOOList [ "", "", [ "affluent", "afflict" ] ]
#32 Mr. Spell. door r = MOOList [ "", "kms", [ "doorway", "doorbell", "door" ] ]
#32 Mr. Spell. Core r = MOOList [ "", "", [ "Corey", "core" ] ]
#32 Mr. Spell. Bloc r = MOOList [ "", "k", [ "Bloch", "bloc" ] ]
#32 Mr. Spell. accompani r = MOOList [ "", "", [ "accompanist", "accompaniment" ] ]
#32 Mr. Spell. Bue r = MOOList [ "n", "", [ "Buenos", "Buena" ] ]
#32 Mr. Spell. works r = MOOList [ "", "h", [ "workstation", "workspace", "works" ] ]
#32 Mr. Spell. Bud r = MOOList [ "", "dg", [ "Budweiser", "Budapest", "bud" ] ]
#32 Mr. Spell. affo r = MOOList [ "r", "e", [ "afford" ] ]
#32 Mr. Spell. Corb r = MOOList [ "e", "", [ "Corbett", "corbel" ] ]
#32 Mr. Spell. Buc r = MOOList [ "", "hk", [ "bucolic" ] ]
#32 Mr. Spell. dye r = MOOList [ "", "", [ "dyeing", "dye" ] ]
#32 Mr. Spell. Cope r = MOOList [ "", "r", [ "Copenhagen", "Copeland", "cope" ] ]
#32 Mr. Spell. blackb r = MOOList [ "", "o", [ "Blackburn", "blackbird", "blackberry", "blackball" ] ]
#32 Mr. Spell. parti r = MOOList [ "", "c", [ "partition", "partisan", "partial" ] ]
#32 Mr. Spell. Buz r = MOOList [ "z", "", [ "buzzy", "buzzword", "buzzing", "Buzzard", "buzz" ] ]
#32 Mr. Spell. dyn r = MOOList [ "", "a", [ "dyne" ] ]
#32 Mr. Spell. Bux r = MOOList [ "", "t", [ "buxom" ] ]
#32 Mr. Spell. erra r = MOOList [ "", "nt", [ ] ]
#32 Mr. Spell. dys r = MOOList [ "", "p", [ "dystrophy", "dysentery" ] ]
#32 Mr. Spell. Copp r = MOOList [ "er", "", [ "coppery", "copperhead", "Copperfield", "copperas" ] ]
#32 Mr. Spell. migr r = MOOList [ "a", "t", [ "migrant" ] ]
#32 Mr. Spell. dya r = MOOList [ "d", "", [ "dyadic", "dyad" ] ]
#32 Mr. Spell. Dart r = MOOList [ "", "", [ "Dartmouth", "dart" ] ]
#32 Mr. Spell. Darr r = MOOList [ "", "", [ "Darry", "Darrell" ] ]
#32 Mr. Spell. pant r = MOOList [ "", "ho", [ "panty", "pantry", "pant" ] ]
#32 Mr. Spell. parse r = MOOList [ "", "", [ "parsecs", "parse" ] ]
#32 Mr. Spell. placen r = MOOList [ "ta", "", [ "placental", "placenta" ] ]
#32 Mr. Spell. massac r = MOOList [ "", "", [ "massacre", "Massachusetts" ] ]
#32 Mr. Spell. parsi r = MOOList [ "", "m", [ "Parsifal" ] ]
#32 Mr. Spell. pano r = MOOList [ "", "r", [ "panoply" ] ]
#32 Mr. Spell. relate r = MOOList [ "", "", [ "related", "relate" ] ]
#32 Mr. Spell. Johns r = MOOList [ "", "t", [ "Johnson", "Johnsen" ] ]
#32 Mr. Spell. migh r = MOOList [ "t", "", [ "mighty", "mightn't", "might" ] ]
#32 Mr. Spell. relati r = MOOList [ "", "o", [ "relating" ] ]
#32 Mr. Spell. ellipsoi r = MOOList [ "d", "", [ "ellipsoidal", "ellipsoid" ] ]
#32 Mr. Spell. Coor r = MOOList [ "", "", [ "coorespondence", "Coors", "coordinate" ] ]
#32 Mr. Spell. parso r = MOOList [ "n", "", [ "parsonage", "parson" ] ]
#32 Mr. Spell. prot r = MOOList [ "", "aeor", [ "protuberant", "prothonotary" ] ]
#32 Mr. Spell. pros r = MOOList [ "", "ceopt", [ "prosaic" ] ]
#32 Mr. Spell. electroe r = MOOList [ "ncephalogra", "p", [ "electroencephalogram" ] ]
#32 Mr. Spell. pror r = MOOList [ "", "", [ "prorogue", "prorate" ] ]
#32 Mr. Spell. fuse r = MOOList [ "", "", [ "fuselage", "fuse" ] ]
#32 Mr. Spell. pana r = MOOList [ "", "", [ "panama", "panacea" ] ]
#32 Mr. Spell. prop r = MOOList [ "", "aehiory", [ "propulsion", "prop" ] ]
#32 Mr. Spell. proo r = MOOList [ "f", "r", [ "proof" ] ]
#32 Mr. Spell. domi r = MOOList [ "", "n", [ "domicile" ] ]
#32 Mr. Spell. pron r = MOOList [ "", "o", [ "pronunciation", "pronto", "prong", "prone" ] ]
#32 Mr. Spell. miscel r = MOOList [ "lan", "", [ "miscellany", "miscellaneous" ] ]
#32 Mr. Spell. fusi r = MOOList [ "", "", [ "fusion", "fusillade", "fusiform", "fusible" ] ]
#32 Mr. Spell. corporati r = MOOList [ "on", "", [ "corporations", "corporation" ] ]
#32 Mr. Spell. prom r = MOOList [ "", "eiop", [ "promulgate", "prom" ] ]
#32 Mr. Spell. pani r = MOOList [ "c", "k", [ "panicle", "panic" ] ]
#32 Mr. Spell. prox r = MOOList [ "", "i", [ "proxy" ] ]
#32 Mr. Spell. fuss r = MOOList [ "", "", [ "fussy", "fuss" ] ]
#32 Mr. Spell. prow r = MOOList [ "", "", [ "prowl", "prowess", "prow" ] ]
#32 Mr. Spell. phalan r = MOOList [ "", "", [ "phalanx", "phalanger" ] ]
#32 Mr. Spell. prov r = MOOList [ "", "eio", [ ] ]
#32 Mr. Spell. Midwes r = MOOList [ "t", "", [ "Midwestern", "Midwest" ] ]
#32 Mr. Spell. bigo r = MOOList [ "t", "", [ "bigotry", "bigot" ] ]
#32 Mr. Spell. pane r = MOOList [ "", "", [ "panel", "pane" ] ]
#32 Mr. Spell. electroc r = MOOList [ "ardiogra", "", [ "electrocardiograph", "electrocardiogram" ] ]
#32 Mr. Spell. prod r = MOOList [ "", "iu", [ "prod" ] ]
#32 Mr. Spell. erot r = MOOList [ "ic", "", [ "erotica", "erotic" ] ]
#32 Mr. Spell. proc r = MOOList [ "", "elrt", [ "Procyon", "procure", "procaine" ] ]
#32 Mr. Spell. dolt r = MOOList [ "", "", [ "doltish", "dolt" ] ]
#32 Mr. Spell. clip r = MOOList [ "", "b", [ "clip" ] ]
#32 Mr. Spell. Bellin r = MOOList [ "", "", [ "Bellini", "Bellingham" ] ]
#32 Mr. Spell. prob r = MOOList [ "", "al", [ "probe" ] ]
#32 Mr. Spell. furt r = MOOList [ "", "h", [ "furtive" ] ]
#32 Mr. Spell. Syr r = MOOList [ "", "iu", [ "Syracuse" ] ]
#32 Mr. Spell. pamp r = MOOList [ "", "", [ "pamphlet", "pamper", "pampa" ] ]
#32 Mr. Spell. eros r = MOOList [ "", "i", [ "Eros" ] ]
#32 Mr. Spell. prol r = MOOList [ "", "io", [ "prolusion", "proletariat", "prolate" ] ]
#32 Mr. Spell. proj r = MOOList [ "ect", "", [ "projector", "projectile", "project" ] ]
#32 Mr. Spell. proh r = MOOList [ "ibit", "i", [ "prohibitory", "prohibit" ] ]
#32 Mr. Spell. ginsb r = MOOList [ "", "", [ "Ginsburg", "Ginsberg" ] ]
#32 Mr. Spell. dynami r = MOOList [ "", "", [ "dynamite", "dynamism", "dynamic" ] ]
#32 Mr. Spell. prog r = MOOList [ "", "enr", [ ] ]
#32 Mr. Spell. prof r = MOOList [ "", "eiu", [ "profound", "profligate", "proffer", "profane", "Prof" ] ]
#32 Mr. Spell. Conn r = MOOList [ "", "eio", [ "connubial", "Connally", "conn" ] ]
#32 Mr. Spell. totem r = MOOList [ "", "", [ "totemic", "totem" ] ]
#32 Mr. Spell. roose r = MOOList [ "velt", "", [ "Rooseveltian", "Roosevelt" ] ]
#32 Mr. Spell. clic r = MOOList [ "", "", [ "click", "cliche" ] ]
#32 Mr. Spell. crystallo r = MOOList [ "graph", "", [ "crystallography", "crystallographer" ] ]
#32 Mr. Spell. Conr r = MOOList [ "a", "", [ "Conrail", "Conrad" ] ]
#32 Mr. Spell. Corin r = MOOList [ "th", "", [ "Corinthian", "Corinth" ] ]
#32 Mr. Spell. clie r = MOOList [ "nt", "", [ "clientele", "client" ] ]
#32 Mr. Spell. dole r = MOOList [ "", "", [ "doleful", "dole" ] ]
#32 Mr. Spell. clif r = MOOList [ "", "f", [ "Clifton" ] ]
#32 Mr. Spell. furn r = MOOList [ "", "i", [ "furnace" ] ]
#32 Mr. Spell. doll r = MOOList [ "", "a", [ "dolly", "dollop", "doll" ] ]
#32 Mr. Spell. crystalli r = MOOList [ "", "", [ "crystallite", "crystalline" ] ]
#32 Mr. Spell. furl r = MOOList [ "", "o", [ "furl" ] ]
#32 Mr. Spell. furr r = MOOList [ "", "", [ "furry", "furrow", "furrier" ] ]
#32 Mr. Spell. dolo r = MOOList [ "", "m", [ "Dolores" ] ]
#32 Mr. Spell. clim r = MOOList [ "", "a", [ "clime", "climb" ] ]
#32 Mr. Spell. Wigg r = MOOList [ "", "il", [ ] ]
#32 Mr. Spell. clin r = MOOList [ "", "git", [ "clink", "clinch" ] ]
#32 Mr. Spell. palm r = MOOList [ "", "", [ "Palmyra", "Palmolive", "palmetto", "palmate", "palm" ] ]
#32 Mr. Spell. pall r = MOOList [ "", "ai", [ "pallet", "pall" ] ]
#32 Mr. Spell. Danu r = MOOList [ "b", "", [ "Danubian", "Danube" ] ]
#32 Mr. Spell. Comi r = MOOList [ "", "n", [ "comic" ] ]
#32 Mr. Spell. workma r = MOOList [ "n", "", [ "workmanlike", "workman" ] ]
#32 Mr. Spell. matin r = MOOList [ "", "", [ "matins", "matinee", "matinal" ] ]
#32 Mr. Spell. retina r = MOOList [ "", "", [ "retinal", "retina" ] ]
#32 Mr. Spell. Liga r = MOOList [ "", "", [ "ligature", "ligand", "ligament" ] ]
#32 Mr. Spell. plano r = MOOList [ "con", "", [ "planoconvex", "planoconcave" ] ]
#32 Mr. Spell. pala r = MOOList [ "", "tz", [ "palace" ] ]
#32 Mr. Spell. lucia r = MOOList [ "", "", [ "Lucian", "Lucia" ] ]
#32 Mr. Spell. plann r = MOOList [ "", "", [ "planning", "planned" ] ]
#32 Mr. Spell. Byr r = MOOList [ "", "o", [ "Byrne", "Byrd" ] ]
#32 Mr. Spell. plank r = MOOList [ "", "", [ "plankton", "plank" ] ]
#32 Mr. Spell. electric r = MOOList [ "", "", [ "electrician", "electric" ] ]
#32 Mr. Spell. machi r = MOOList [ "", "n", [ "machismo", "Machiavelli" ] ]
#32 Mr. Spell. pali r = MOOList [ "", "n", [ "palisade" ] ]
#32 Mr. Spell. midw r = MOOList [ "", "ei", [ "midway" ] ]
#32 Mr. Spell. Ligg r = MOOList [ "et", "", [ "Liggett", "Ligget" ] ]
#32 Mr. Spell. plant r = MOOList [ "", "a", [ "plants", "plant" ] ]
#32 Mr. Spell. Cona r = MOOList [ "", "", [ "Conant", "Conakry" ] ]
#32 Mr. Spell. mids r = MOOList [ "", "ht", [ "midspan", "midsection", "midscale" ] ]
#32 Mr. Spell. platit r = MOOList [ "ud", "", [ "platitudinous", "platitude" ] ]
#32 Mr. Spell. Euri r = MOOList [ "", "", [ "Euripides", "Euridyce" ] ]
#32 Mr. Spell. Cole r = MOOList [ "", "", [ "coleus", "Colette", "Coleridge", "Coleman", "Cole" ] ]
#32 Mr. Spell. midg r = MOOList [ "e", "", [ "midget", "midge" ] ]
#32 Mr. Spell. Euro r = MOOList [ "p", "e", [ "europium", "Europa" ] ]
#32 Mr. Spell. midd r = MOOList [ "", "l", [ "midday" ] ]
#32 Mr. Spell. plane r = MOOList [ "", "t", [ "planeload", "plane" ] ]
#32 Mr. Spell. Crocke r = MOOList [ "", "", [ "Crockett", "crockery" ] ]
#32 Mr. Spell. Colo r = MOOList [ "", "mnrs", [ "Cologne" ] ]
#32 Mr. Spell. Byz r = MOOList [ "anti", "", [ "Byzantium", "Byzantine" ] ]
#32 Mr. Spell. quot r = MOOList [ "", "ai", [ "quote" ] ]
#32 Mr. Spell. Puri r = MOOList [ "", "nt", [ "purify" ] ]
#32 Mr. Spell. bidd r = MOOList [ "", "", [ "biddy", "bidden" ] ]
#32 Mr. Spell. Compac r = MOOList [ "t", "", [ "compactify", "compact" ] ]
#32 Mr. Spell. offer r = MOOList [ "", "", [ "offers", "offering", "offered", "offertory", "offer" ] ]
#32 Mr. Spell. Dani r = MOOList [ "", "e", [ "Danish" ] ]
#32 Mr. Spell. Yoke r = MOOList [ "", "", [ "yokel", "yoke" ] ]
#32 Mr. Spell. micr r = MOOList [ "o", "n", [ "microscopy", "micrography", "microcosm", "microbial", "micro" ] ]
#32 Mr. Spell. bidi r = MOOList [ "", "", [ "bidirectional", "bidiagonal" ] ]
#32 Mr. Spell. Purc r = MOOList [ "", "h", [ "Purcell" ] ]
#32 Mr. Spell. offen r = MOOList [ "", "", [ "offensive", "offend", "Offenbach" ] ]
#32 Mr. Spell. bico r = MOOList [ "n", "", [ "biconnected", "biconcave" ] ]
#32 Mr. Spell. vac r = MOOList [ "", "acu", [ "vacillate" ] ]
#32 Mr. Spell. vag r = MOOList [ "", "ai", [ "vague", "vagrant" ] ]
#32 Mr. Spell. parol r = MOOList [ "e", "", [ "parolee", "parole" ] ]
#32 Mr. Spell. vai r = MOOList [ "", "n", [ "Vail" ] ]
#32 Mr. Spell. stationa r = MOOList [ "r", "", [ "stationary", "stationarity" ] ]
#32 Mr. Spell. awak r = MOOList [ "e", "", [ "awaken", "awake" ] ]
#32 Mr. Spell. eigenv r = MOOList [ "", "", [ "eigenvector", "eigenvalue" ] ]
#32 Mr. Spell. Dama r = MOOList [ "", "s", [ "damage" ] ]
#32 Mr. Spell. bica r = MOOList [ "", "", [ "bicarbonate", "bicameral" ] ]
#32 Mr. Spell. mathe r = MOOList [ "", "mw", [ ] ]
#32 Mr. Spell. thoro r = MOOList [ "ugh", "", [ "thoroughgoing", "thoroughfare", "thoroughbred", "thorough" ] ]
#32 Mr. Spell. emitte r = MOOList [ "", "", [ "emitter", "emitted" ] ]
#32 Mr. Spell. minute r = MOOList [ "", "m", [ "minute" ] ]
#32 Mr. Spell. awar r = MOOList [ "", "", [ "aware", "award" ] ]
#32 Mr. Spell. contam r = MOOList [ "ina", "", [ "contaminate", "contaminant" ] ]
#32 Mr. Spell. thori r = MOOList [ "", "", [ "thorium", "thoriate" ] ]
#32 Mr. Spell. contai r = MOOList [ "n", "", [ "container", "contain" ] ]
#32 Mr. Spell. argumenta r = MOOList [ "ti", "", [ "argumentative", "argumentation" ] ]
#32 Mr. Spell. eigens r = MOOList [ "", "", [ "eigenstate", "eigenspace" ] ]
#32 Mr. Spell. contag r = MOOList [ "io", "", [ "contagious", "contagion" ] ]
#32 Mr. Spell. viewp r = MOOList [ "o", "", [ "viewport", "viewpoint" ] ]
#32 Mr. Spell. heartb r = MOOList [ "", "", [ "heartbreak", "heartbeat" ] ]
#32 Mr. Spell. bibl r = MOOList [ "", "i", [ "Bible" ] ]
#32 Mr. Spell. Corne r = MOOList [ "", "lr", [ "cornet", "cornea" ] ]
#32 Mr. Spell. offsh r = MOOList [ "o", "", [ "offshore", "offshoot" ] ]
#32 Mr. Spell. signa r = MOOList [ "", "", [ "signature", "signal" ] ]
#32 Mr. Spell. offse r = MOOList [ "t", "", [ "offsetting", "offset" ] ]
#32 Mr. Spell. cler r = MOOList [ "", "g", [ "clerk", "cleric" ] ]
#32 Mr. Spell. clev r = MOOList [ "e", "", [ "clever", "Cleveland" ] ]
#32 Mr. Spell. Aide r = MOOList [ "", "", [ "Aides", "aide" ] ]
#32 Mr. Spell. signi r = MOOList [ "f", "", [ "signify", "significant" ] ]
#32 Mr. Spell. pair r = MOOList [ "", "", [ "pairwise", "pair" ] ]
#32 Mr. Spell. penit r = MOOList [ "ent", "i", [ "penitent" ] ]
#32 Mr. Spell. val r = MOOList [ "", "eilu", [ "valve", "Valparaiso", "Valois", "Valkyrie", "Valhalla" ] ]
#32 Mr. Spell. vam r = MOOList [ "p", "", [ "vampire", "vamp" ] ]
#32 Mr. Spell. van r = MOOList [ "", "cdi", [ "vantage", "vanquish", "vanguard", "vane", "vanadium", "van" ] ]
#32 Mr. Spell. clea r = MOOList [ "", "nrv", [ "cleat" ] ]
#32 Mr. Spell. vap r = MOOList [ "", "", [ "vaporous", "vapid" ] ]
#32 Mr. Spell. rooft r = MOOList [ "", "", [ "rooftree", "rooftop" ] ]
#32 Mr. Spell. fune r = MOOList [ "r", "", [ "funereal", "funeral" ] ]
#32 Mr. Spell. Dale r = MOOList [ "", "", [ "Daley", "dale" ] ]
#32 Mr. Spell. fund r = MOOList [ "", "", [ "funds", "fundamental", "fund" ] ]
#32 Mr. Spell. var r = MOOList [ "", "i", [ "vary", "varsity", "varnish" ] ]
#32 Mr. Spell. Picke r = MOOList [ "", "rt", [ ] ]
#32 Mr. Spell. func r = MOOList [ "t", "io", [ ] ]
#32 Mr. Spell. vas r = MOOList [ "", "es", [ "vast", "Vasquez", "vascular" ] ]
#32 Mr. Spell. mias r = MOOList [ "ma", "", [ "miasmal", "miasma" ] ]
#32 Mr. Spell. blueb r = MOOList [ "", "io", [ "bluebush", "blueberry", "blueback" ] ]
#32 Mr. Spell. Staun r = MOOList [ "", "", [ "Staunton", "staunch" ] ]
#32 Mr. Spell. Oakl r = MOOList [ "", "", [ "Oakley", "Oakland" ] ]
#32 Mr. Spell. fung r = MOOList [ "", "i", [ "fungus", "fungoid", "fungal" ] ]
#32 Mr. Spell. funn r = MOOList [ "", "", [ "funny", "funnel" ] ]
#32 Mr. Spell. improvis r = MOOList [ "", "", [ "improvise", "improvisate" ] ]
#32 Mr. Spell. blueg r = MOOList [ "", "", [ "bluegrass", "bluegill" ] ]
#32 Mr. Spell. Edmo r = MOOList [ "n", "d", [ "Edmonton" ] ]
#32 Mr. Spell. splay r = MOOList [ "", "", [ "splayed", "splay" ] ]
#32 Mr. Spell. dogm r = MOOList [ "a", "t", [ "dogma" ] ]
#32 Mr. Spell. priz r = MOOList [ "e", "", [ "prizewinning", "prize" ] ]
#32 Mr. Spell. persuas r = MOOList [ "i", "", [ "persuasive", "persuasion" ] ]
#32 Mr. Spell. splas r = MOOList [ "h", "", [ "splashy", "splash" ] ]
#32 Mr. Spell. polaro r = MOOList [ "", "g", [ "polaron", "Polaroid" ] ]
#32 Mr. Spell. ear r = MOOList [ "", "ntl", [ "earwig", "earsplitting", "earring", "earphone", "earmark", "eardrum", "ear" ] ]
#32 Mr. Spell. eas r = MOOList [ "", "etyi", [ ] ]
#32 Mr. Spell. demurr r = MOOList [ "", "e", [ "demurring" ] ]
#32 Mr. Spell. eat r = MOOList [ "", "e", [ "Eaton", "eat" ] ]
#32 Mr. Spell. Presto r = MOOList [ "", "", [ "Preston", "presto" ] ]
#32 Mr. Spell. eav r = MOOList [ "e", "s", [ "eave" ] ]
#32 Mr. Spell. dogt r = MOOList [ "", "", [ "dogtrot", "dogtooth" ] ]
#32 Mr. Spell. famili r = MOOList [ "", "a", [ "familism" ] ]
#32 Mr. Spell. employe r = MOOList [ "e", "", [ "employees", "employee" ] ]
#32 Mr. Spell. prin r = MOOList [ "", "ct", [ ] ]
#32 Mr. Spell. prim r = MOOList [ "", "ae", [ "primrose", "primp", "primitive", "prim" ] ]
#32 Mr. Spell. dogb r = MOOList [ "", "", [ "dogberry", "dogbane" ] ]
#32 Mr. Spell. corona r = MOOList [ "", "", [ "coronate", "coronary", "Coronado", "corona" ] ]
#32 Mr. Spell. prig r = MOOList [ "", "", [ "priggish", "prig" ] ]
#32 Mr. Spell. priv r = MOOList [ "", "a", [ "privy", "privilege", "privet" ] ]
#32 Mr. Spell. fumi r = MOOList [ "ga", "", [ "fumigate", "fumigant" ] ]
#32 Mr. Spell. dogg r = MOOList [ "", "", [ "doggone", "dogging" ] ]
#32 Mr. Spell. pris r = MOOList [ "", "m", [ "pristine", "prissy", "prison", "Priscilla" ] ]
#32 Mr. Spell. eag r = MOOList [ "", "e", [ "eagle", "Eagan" ] ]
#32 Mr. Spell. porten r = MOOList [ "", "t", [ "portend" ] ]
#32 Mr. Spell. prio r = MOOList [ "r", "", [ "priory", "priori", "prior" ] ]
#32 Mr. Spell. Dair r = MOOList [ "y", "m", [ "Dairylea", "dairy" ] ]
#32 Mr. Spell. corone r = MOOList [ "", "", [ "coronet", "coroner" ] ]
#32 Mr. Spell. Blee r = MOOList [ "", "", [ "Bleeker", "bleed" ] ]
#32 Mr. Spell. Cohe r = MOOList [ "", "rs", [ "Cohen" ] ]
#32 Mr. Spell. splee r = MOOList [ "n", "", [ "spleenwort", "spleen" ] ]
#32 Mr. Spell. pric r = MOOList [ "", "ke", [ ] ]
#32 Mr. Spell. Epicu r = MOOList [ "re", "", [ "Epicurean", "epicure" ] ]
#32 Mr. Spell. breve r = MOOList [ "", "", [ "brevet", "breve" ] ]
#32 Mr. Spell. Blen r = MOOList [ "", "", [ "Blenheim", "blend" ] ]
#32 Mr. Spell. Tah r = MOOList [ "", "", [ "Tahoe", "Tahiti" ] ]
#32 Mr. Spell. playw r = MOOList [ "ri", "", [ "playwriting", "playwright" ] ]
#32 Mr. Spell. page r = MOOList [ "", "a", [ "page" ] ]
#32 Mr. Spell. optom r = MOOList [ "etr", "", [ "optometry", "optometrist" ] ]
#32 Mr. Spell. Baltim r = MOOList [ "ore", "", [ "Baltimorean", "Baltimore" ] ]
#32 Mr. Spell. luxuria r = MOOList [ "", "", [ "luxuriate", "luxuriant" ] ]
#32 Mr. Spell. excret r = MOOList [ "", "", [ "excretory", "excretion", "excrete" ] ]
#32 Mr. Spell. splen r = MOOList [ "", "", [ "splenetic", "splendid" ] ]
#32 Mr. Spell. full r = MOOList [ "", "", [ "fully", "Fullerton", "fullback", "full" ] ]
#32 Mr. Spell. Hodge r = MOOList [ "", "", [ "Hodges", "hodgepodge", "hodge" ] ]
#32 Mr. Spell. Orin r = MOOList [ "", "", [ "Orinoco", "Orin" ] ]
#32 Mr. Spell. Orio r = MOOList [ "", "", [ "Orion", "oriole" ] ]
#32 Mr. Spell. eco r = MOOList [ "", "ln", [ "ecosystem" ] ]
#32 Mr. Spell. Dahl r = MOOList [ "", "", [ "dahlia", "Dahl" ] ]
#32 Mr. Spell. vec r = MOOList [ "tor", "", [ "vectorial", "vector" ] ]
#32 Mr. Spell. ecs r = MOOList [ "ta", "", [ "ecstatic", "ecstasy" ] ]
#32 Mr. Spell. ammon r = MOOList [ "i", "a", [ "ammonium" ] ]
#32 Mr. Spell. playe r = MOOList [ "r", "", [ "players", "player" ] ]
#32 Mr. Spell. vee r = MOOList [ "", "r", [ "vee" ] ]
#32 Mr. Spell. realt r = MOOList [ "", "", [ "realty", "realtor" ] ]
#32 Mr. Spell. ect r = MOOList [ "o", "", [ "ectopic", "ectoderm" ] ]
#32 Mr. Spell. ecu r = MOOList [ "", "m", [ "Ecuador" ] ]
#32 Mr. Spell. veg r = MOOList [ "", "e", [ "Vega" ] ]
#32 Mr. Spell. eage r = MOOList [ "r", "", [ "eagerly", "eager" ] ]
#32 Mr. Spell. veh r = MOOList [ "", "i", [ "vehement" ] ]
#32 Mr. Spell. vei r = MOOList [ "", "", [ "vein", "veil" ] ]
#32 Mr. Spell. does r = MOOList [ "", "", [ "does", "doesn't" ] ]
#32 Mr. Spell. smalle r = MOOList [ "", "", [ "smaller", "Smalley" ] ]
#32 Mr. Spell. Tao r = MOOList [ "", "", [ "Taos", "Taoist", "tao" ] ]
#32 Mr. Spell. worksh r = MOOList [ "", "", [ "workshop", "worksheet" ] ]
#32 Mr. Spell. ven r = MOOList [ "", "degiotu", [ "venal" ] ]
#32 Mr. Spell. reticu r = MOOList [ "l", "", [ "reticulum", "reticulate" ] ]
#32 Mr. Spell. reversi r = MOOList [ "", "", [ "reversion", "reversible" ] ]
#32 Mr. Spell. ecc r = MOOList [ "", "l", [ "eccentric" ] ]
#32 Mr. Spell. matte r = MOOList [ "", "r", [ "matte" ] ]
#32 Mr. Spell. playb r = MOOList [ "", "", [ "playboy", "playback" ] ]
#32 Mr. Spell. icosahedra r = MOOList [ "", "", [ "icosahedral", "icosahedra" ] ]
#32 Mr. Spell. ech r = MOOList [ "", "io", [ "echelon" ] ]
#32 Mr. Spell. Stark r = MOOList [ "", "", [ "Starkey", "stark" ] ]
#32 Mr. Spell. seismo r = MOOList [ "", "g", [ "seismology" ] ]
#32 Mr. Spell. selen r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. conten r = MOOList [ "", "t", [ "contend" ] ]
#32 Mr. Spell. Middlet r = MOOList [ "o", "", [ "Middletown", "Middleton" ] ]
#32 Mr. Spell. contem r = MOOList [ "p", "ot", [ "contemplate" ] ]
#32 Mr. Spell. ecl r = MOOList [ "", "i", [ "eclogue", "eclectic", "eclat" ] ]
#32 Mr. Spell. compend r = MOOList [ "i", "", [ "compendium", "compendia" ] ]
#32 Mr. Spell. clai r = MOOList [ "", "mr", [ ] ]
#32 Mr. Spell. Cal r = MOOList [ "", "acdefilouv", [ "calypso", "calm", "Calkins", "Calhoun", "Calgary", "Cal" ] ]
#32 Mr. Spell. contex r = MOOList [ "t", "", [ "contextual", "context" ] ]
#32 Mr. Spell. existe r = MOOList [ "n", "t", [ "existence" ] ]
#32 Mr. Spell. clam r = MOOList [ "", "", [ "clamshell", "clamp", "clammy", "clamber", "clam" ] ]
#32 Mr. Spell. Cai r = MOOList [ "", "nr", [ "caiman" ] ]
#32 Mr. Spell. edu r = MOOList [ "", "c", [ "Eduardo" ] ]
#32 Mr. Spell. contes r = MOOList [ "t", "", [ "contestant", "contest" ] ]
#32 Mr. Spell. clan r = MOOList [ "", "", [ "clannish", "clank", "clang", "clandestine", "clan" ] ]
#32 Mr. Spell. pulsa r = MOOList [ "", "", [ "pulsate", "pulsar" ] ]
#32 Mr. Spell. clap r = MOOList [ "", "", [ "Clapeyron", "clapboard", "clap" ] ]
#32 Mr. Spell. clas r = MOOList [ "", "s", [ "clasp", "clash" ] ]
#32 Mr. Spell. quix r = MOOList [ "ot", "", [ "quixotic", "Quixote" ] ]
#32 Mr. Spell. quiz r = MOOList [ "", "z", [ "quiz" ] ]
#32 Mr. Spell. clat r = MOOList [ "ter", "", [ "clattery", "clatter" ] ]
#32 Mr. Spell. generat r = MOOList [ "e", "", [ "generated", "generate" ] ]
#32 Mr. Spell. upto r = MOOList [ "", "", [ "uptown", "Upton" ] ]
#32 Mr. Spell. quin r = MOOList [ "", "t", [ "Quinn", "quinine", "quince" ] ]
#32 Mr. Spell. munic r = MOOList [ "", "", [ "municipal", "Munich" ] ]
#32 Mr. Spell. sixte r = MOOList [ "en", "", [ "sixteenth", "sixteen" ] ]
#32 Mr. Spell. quip r = MOOList [ "", "", [ "quipping", "quip" ] ]
#32 Mr. Spell. audit r = MOOList [ "", "o", [ "audition", "audit" ] ]
#32 Mr. Spell. ves r = MOOList [ "", "t", [ "vessel", "vesper", "vesicular" ] ]
#32 Mr. Spell. Cay r = MOOList [ "", "", [ "Cayuga", "Cayley", "cayenne" ] ]
#32 Mr. Spell. vet r = MOOList [ "", "e", [ "veto", "vetch", "vet" ] ]
#32 Mr. Spell. quir r = MOOList [ "", "k", [ "quirt", "Quirinal" ] ]
#32 Mr. Spell. edd r = MOOList [ "", "", [ "eddy", "Eddie" ] ]
#32 Mr. Spell. general r = MOOList [ "", "", [ "generally", "general" ] ]
#32 Mr. Spell. ede r = MOOList [ "", "", [ "Eden", "edematous", "edelweiss" ] ]
#32 Mr. Spell. quit r = MOOList [ "", "", [ "quitting", "Quito", "quite", "quit" ] ]
#32 Mr. Spell. compens r = MOOList [ "a", "t", [ "compensable" ] ]
#32 Mr. Spell. quie r = MOOList [ "", "t", [ "quiescent" ] ]
#32 Mr. Spell. edg r = MOOList [ "", "e", [ "edgy", "edging", "Edgar" ] ]
#32 Mr. Spell. Cau r = MOOList [ "", "clst", [ "caught" ] ]
#32 Mr. Spell. vex r = MOOList [ "", "a", [ "vex" ] ]
#32 Mr. Spell. edi r = MOOList [ "", "ft", [ "Edison", "Edinburgh", "edict", "edible" ] ]
#32 Mr. Spell. modula r = MOOList [ "", "", [ "modulate", "modular" ] ]
#32 Mr. Spell. penet r = MOOList [ "ra", "", [ "penetrate", "penetrable" ] ]
#32 Mr. Spell. Willia r = MOOList [ "m", "s", [ "William" ] ]
#32 Mr. Spell. expedit r = MOOList [ "", "i", [ "expedite" ] ]
#32 Mr. Spell. clad r = MOOList [ "", "", [ "cladophora", "clad" ] ]
#32 Mr. Spell. dode r = MOOList [ "cahedr", "a", [ "dodecahedron" ] ]
#32 Mr. Spell. audio r = MOOList [ "", "", [ "audiovisual", "audiotape", "audio" ] ]
#32 Mr. Spell. quil r = MOOList [ "", "l", [ "quilt" ] ]
#32 Mr. Spell. Can r = MOOList [ "", "acdiknotv", [ "canyon", "can't", "Canfield", "cane", "Canberra", "can" ] ]
#32 Mr. Spell. dock r = MOOList [ "", "", [ "dockyard", "dockside", "docket", "dock" ] ]
#32 Mr. Spell. eer r = MOOList [ "i", "", [ "eerily", "eerie" ] ]
#32 Mr. Spell. Triplet r = MOOList [ "", "", [ "Triplett", "triplet" ] ]
#32 Mr. Spell. concei r = MOOList [ "", "", [ "conceive", "conceit" ] ]
#32 Mr. Spell. prev r = MOOList [ "", "ae", [ "previous" ] ]
#32 Mr. Spell. upst r = MOOList [ "", "a", [ "upstream" ] ]
#32 Mr. Spell. quic r = MOOList [ "k", "sl", [ "quickie", "quicken", "quick" ] ]
#32 Mr. Spell. padd r = MOOList [ "", "", [ "paddy", "paddock", "paddle" ] ]
#32 Mr. Spell. carpen r = MOOList [ "t", "", [ "carpentry", "carpenter" ] ]
#32 Mr. Spell. emphas r = MOOList [ "", "", [ "emphasis", "emphases" ] ]
#32 Mr. Spell. upsi r = MOOList [ "", "", [ "upsilon", "upside" ] ]
#32 Mr. Spell. Garde r = MOOList [ "n", "", [ "gardenia", "garden" ] ]
#32 Mr. Spell. concer r = MOOList [ "", "t", [ "concern" ] ]
#32 Mr. Spell. Edit r = MOOList [ "", "o", [ "edition", "Edith", "edit" ] ]
#32 Mr. Spell. conces r = MOOList [ "sion", "", [ "concessionaire", "concession" ] ]
#32 Mr. Spell. concep r = MOOList [ "t", "", [ "conceptual", "conception", "concept" ] ]
#32 Mr. Spell. concen r = MOOList [ "tr", "", [ "concentric", "concentrate" ] ]
#32 Mr. Spell. Bloom r = MOOList [ "", "", [ "Bloomington", "Bloomfield", "bloom" ] ]
#32 Mr. Spell. congeni r = MOOList [ "", "", [ "congenital", "congenial" ] ]
#32 Mr. Spell. doct r = MOOList [ "", "or", [ ] ]
#32 Mr. Spell. docu r = MOOList [ "ment", "a", [ "document" ] ]
#32 Mr. Spell. easte r = MOOList [ "rn", "", [ "easternmost", "eastern" ] ]
#32 Mr. Spell. impr r = MOOList [ "", "aeio", [ "imprudent" ] ]
#32 Mr. Spell. upse r = MOOList [ "t", "", [ "upsetting", "upset" ] ]
#32 Mr. Spell. pref r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. impl r = MOOList [ "", "aei", [ "implore" ] ]
#32 Mr. Spell. pree r = MOOList [ "", "m", [ "preen" ] ]
#32 Mr. Spell. matro r = MOOList [ "", "", [ "matron", "matroid" ] ]
#32 Mr. Spell. pred r = MOOList [ "", "i", [ "predecessor", "predatory" ] ]
#32 Mr. Spell. prec r = MOOList [ "", "aeio", [ "preclude" ] ]
#32 Mr. Spell. impo r = MOOList [ "", "lrs", [ "impoverish", "impound", "impotent", "imponderable" ] ]
#32 Mr. Spell. prep r = MOOList [ "", "ao", [ "prep" ] ]
#32 Mr. Spell. prem r = MOOList [ "", "i", [ "premonition" ] ]
#32 Mr. Spell. impu r = MOOList [ "", "lt", [ "impure", "impunity", "impugn", "impudent" ] ]
#32 Mr. Spell. prel r = MOOList [ "", "", [ "prelude", "preliminary" ] ]
#32 Mr. Spell. matri r = MOOList [ "", "acm", [ "matrix" ] ]
#32 Mr. Spell. paci r = MOOList [ "f", "i", [ "pacify" ] ]
#32 Mr. Spell. optiona r = MOOList [ "l", "", [ "optionally", "optional" ] ]
#32 Mr. Spell. upro r = MOOList [ "", "a", [ "uproot" ] ]
#32 Mr. Spell. impa r = MOOList [ "", "lrsi", [ "impatient", "impact" ] ]
#32 Mr. Spell. exerc r = MOOList [ "is", "", [ "exercise", "exercisable" ] ]
#32 Mr. Spell. Socie r = MOOList [ "t", "", [ "society", "Societe", "societal" ] ]
#32 Mr. Spell. revolu r = MOOList [ "tion", "", [ "revolutionary", "revolution" ] ]
#32 Mr. Spell. pace r = MOOList [ "", "", [ "pacesetting", "pacemake", "pace" ] ]
#32 Mr. Spell. Keyn r = MOOList [ "", "e", [ "keynote" ] ]
#32 Mr. Spell. impi r = MOOList [ "", "", [ "impish", "impious", "impinge", "impiety" ] ]
#32 Mr. Spell. emeri r = MOOList [ "t", "", [ "emeritus", "emeriti" ] ]
#32 Mr. Spell. upri r = MOOList [ "", "", [ "upriver", "uprise", "upright" ] ]
#32 Mr. Spell. impe r = MOOList [ "", "dlnrt", [ "impeccable", "impeach" ] ]
#32 Mr. Spell. pack r = MOOList [ "", "a", [ "packet", "pack" ] ]
#32 Mr. Spell. emerg r = MOOList [ "e", "", [ "emergent", "emerge" ] ]
#32 Mr. Spell. ega r = MOOList [ "", "", [ "Egan", "egalitarian" ] ]
#32 Mr. Spell. splin r = MOOList [ "", "t", [ "spline" ] ]
#32 Mr. Spell. Blai r = MOOList [ "", "", [ "Blair", "Blaine" ] ]
#32 Mr. Spell. describe r = MOOList [ "", "", [ "described", "describe" ] ]
#32 Mr. Spell. Tek r = MOOList [ "t", "", [ "Tektronix", "tektite" ] ]
#32 Mr. Spell. eff r = MOOList [ "", "aeilo", [ "effusive" ] ]
#32 Mr. Spell. lever r = MOOList [ "", "", [ "leverage", "lever" ] ]
#32 Mr. Spell. Teh r = MOOList [ "", "", [ "Tehran", "Teheran" ] ]
#32 Mr. Spell. dobb r = MOOList [ "", "", [ "Dobbs", "Dobbin" ] ]
#32 Mr. Spell. Coron r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. compell r = MOOList [ "", "", [ "compelling", "compelled", "compellable" ] ]
#32 Mr. Spell. annull r = MOOList [ "", "", [ "annulling", "annulled" ] ]
#32 Mr. Spell. Ted r = MOOList [ "", "i", [ "Teddy", "Ted" ] ]
#32 Mr. Spell. Cliff r = MOOList [ "", "", [ "Clifford", "cliffhang", "cliff" ] ]
#32 Mr. Spell. vic r = MOOList [ "", "aeikt", [ "Vichy" ] ]
#32 Mr. Spell. egr r = MOOList [ "e", "", [ "egret", "egress", "egregious" ] ]
#32 Mr. Spell. vid r = MOOList [ "", "e", [ "Vida" ] ]
#32 Mr. Spell. vie r = MOOList [ "", "wnt", [ "vie" ] ]
#32 Mr. Spell. Cornel r = MOOList [ "", "i", [ "Cornell" ] ]
#32 Mr. Spell. euphori r = MOOList [ "", "", [ "euphoric", "euphoria" ] ]
#32 Mr. Spell. vig r = MOOList [ "", "i", [ "vigorous", "vignette" ] ]
#32 Mr. Spell. vii r = MOOList [ "", "", [ "viii", "vii" ] ]
#32 Mr. Spell. Tex r = MOOList [ "", "at", [ ] ]
#32 Mr. Spell. vil r = MOOList [ "", "l", [ "vilify", "vile" ] ]
#32 Mr. Spell. Manse r = MOOList [ "", "", [ "manservant", "manse" ] ]
#32 Mr. Spell. vin r = MOOList [ "", "det", [ "vinyl", "Vinson", "Vincent" ] ]
#32 Mr. Spell. rebutt r = MOOList [ "", "", [ "rebutting", "rebutted", "rebuttal" ] ]
#32 Mr. Spell. vio r = MOOList [ "l", "ae", [ "violin" ] ]
#32 Mr. Spell. submitt r = MOOList [ "", "", [ "submitting", "submitted", "submittal" ] ]
#32 Mr. Spell. Oreg r = MOOList [ "", "", [ "Oregon", "oregano" ] ]
#32 Mr. Spell. vir r = MOOList [ "", "gtu", [ "virile" ] ]
#32 Mr. Spell. contin r = MOOList [ "", "eu", [ "contingent" ] ]
#32 Mr. Spell. Corneli r = MOOList [ "", "", [ "Cornelius", "Cornelia" ] ]
#32 Mr. Spell. famil r = MOOList [ "", "i", [ "family" ] ]
#32 Mr. Spell. raffi r = MOOList [ "", "", [ "raffish", "raffia" ] ]
#32 Mr. Spell. egg r = MOOList [ "", "", [ "eggshell", "eggplant", "egghead", "egg" ] ]
#32 Mr. Spell. inqui r = MOOList [ "", "rs", [ ] ]
#32 Mr. Spell. plato r = MOOList [ "", "n", [ "platoon", "Plato" ] ]
#32 Mr. Spell. contig r = MOOList [ "u", "", [ "contiguous", "contiguity" ] ]
#32 Mr. Spell. Ores r = MOOList [ "te", "", [ "Orestes", "Oresteia" ] ]
#32 Mr. Spell. leve r = MOOList [ "", "r", [ "level", "levee" ] ]
#32 Mr. Spell. ego r = MOOList [ "", "t", [ "egocentric", "ego" ] ]
#32 Mr. Spell. via r = MOOList [ "", "", [ "vial", "viaduct", "via" ] ]
#32 Mr. Spell. vib r = MOOList [ "", "r", [ "viburnum" ] ]
#32 Mr. Spell. cambr r = MOOList [ "i", "", [ "Cambridge", "cambric", "Cambrian" ] ]
#32 Mr. Spell. Cel r = MOOList [ "", "ael", [ "Celtic", "Celsius", "Celia" ] ]
#32 Mr. Spell. highwaym r = MOOList [ "", "", [ "highwaymen", "highwayman" ] ]
#32 Mr. Spell. epithel r = MOOList [ "i", "", [ "epithelium", "epithelial" ] ]
#32 Mr. Spell. Cec r = MOOList [ "", "i", [ "Cecropia" ] ]
#32 Mr. Spell. vis r = MOOList [ "", "aci", [ "visual", "vista", "visor", "Vishnu", "vise", "vis" ] ]
#32 Mr. Spell. vit r = MOOList [ "", "ar", [ "Vito", "vitiate" ] ]
#32 Mr. Spell. Argon r = MOOList [ "", "", [ "Argonne", "Argonaut", "argon" ] ]
#32 Mr. Spell. inop r = MOOList [ "", "e", [ "inopportune" ] ]
#32 Mr. Spell. viv r = MOOList [ "", "ai", [ "vivo" ] ]
#32 Mr. Spell. Manage r = MOOList [ "", "r", [ "manages", "management", "managed", "manageable", "manage" ] ]
#32 Mr. Spell. statesma r = MOOList [ "n", "", [ "statesmanlike", "statesman" ] ]
#32 Mr. Spell. fragmenta r = MOOList [ "", "", [ "fragmentation", "fragmentary" ] ]
#32 Mr. Spell. astrono r = MOOList [ "m", "", [ "astronomy", "astronomic", "astronomer" ] ]
#32 Mr. Spell. scurr r = MOOList [ "", "", [ "scurry", "scurrilous" ] ]
#32 Mr. Spell. opal r = MOOList [ "", "", [ "opalescent", "opal" ] ]
#32 Mr. Spell. inor r = MOOList [ "", "", [ "inorganic", "inordinate" ] ]
#32 Mr. Spell. Cet r = MOOList [ "", "", [ "Cetus", "cetera" ] ]
#32 Mr. Spell. basic r = MOOList [ "", "", [ "basically", "basic" ] ]
#32 Mr. Spell. astrona r = MOOList [ "ut", "", [ "astronautic", "astronaut" ] ]
#32 Mr. Spell. backst r = MOOList [ "", "", [ "backstop", "backstitch", "backstage" ] ]
#32 Mr. Spell. eid r = MOOList [ "e", "", [ "eidetic", "eider" ] ]
#32 Mr. Spell. benth r = MOOList [ "", "", [ "benthic", "Bentham" ] ]
#32 Mr. Spell. inno r = MOOList [ "", "c", [ "innovate" ] ]
#32 Mr. Spell. infern r = MOOList [ "", "", [ "inferno", "infernal" ] ]
#32 Mr. Spell. eig r = MOOList [ "", "eh", [ ] ]
#32 Mr. Spell. Tho r = MOOList [ "", "mru", [ "those", "thong" ] ]
#32 Mr. Spell. feel r = MOOList [ "", "", [ "feels", "feel" ] ]
#32 Mr. Spell. collag r = MOOList [ "e", "", [ "collagen", "collage" ] ]
#32 Mr. Spell. inferr r = MOOList [ "", "", [ "inferring", "inferred" ] ]
#32 Mr. Spell. innu r = MOOList [ "", "", [ "innumerable", "innuendo" ] ]
#32 Mr. Spell. collat r = MOOList [ "e", "", [ "collateral", "collate" ] ]
#32 Mr. Spell. basil r = MOOList [ "", "", [ "basilisk", "basilar", "basil" ] ]
#32 Mr. Spell. collar r = MOOList [ "", "", [ "collard", "collarbone", "collar" ] ]
#32 Mr. Spell. Pegg r = MOOList [ "", "", [ "Peggy", "pegging" ] ]
#32 Mr. Spell. collap r = MOOList [ "s", "", [ "collapsible", "collapse" ] ]
#32 Mr. Spell. annul r = MOOList [ "", "l", [ "annulus", "annuli", "annular", "annul" ] ]
#32 Mr. Spell. The r = MOOList [ "", "aimnorsty", [ "Thelma", "theft", "thee", "Thebes", "the" ] ]
#32 Mr. Spell. excre r = MOOList [ "", "t", [ "excrescent" ] ]
#32 Mr. Spell. Tib r = MOOList [ "", "e", [ "tibia" ] ]
#32 Mr. Spell. conserva r = MOOList [ "t", "io", [ ] ]
#32 Mr. Spell. potenti r = MOOList [ "", "", [ "potentiometer", "potential" ] ]
#32 Mr. Spell. Hammo r = MOOList [ "", "", [ "Hammond", "hammock" ] ]
#32 Mr. Spell. babysi r = MOOList [ "t", "", [ "babysitting", "babysit" ] ]
#32 Mr. Spell. inna r = MOOList [ "", "", [ "innate", "innards" ] ]
#32 Mr. Spell. feed r = MOOList [ "", "", [ "feedback", "feed" ] ]
#32 Mr. Spell. escr r = MOOList [ "", "", [ "escrow", "escritoire" ] ]
#32 Mr. Spell. Tit r = MOOList [ "", "aiu", [ "titrate", "titmouse", "title", "tithe", "tit" ] ]
#32 Mr. Spell. telepro r = MOOList [ "", "", [ "teleprompter", "teleprocessing" ] ]
#32 Mr. Spell. eje r = MOOList [ "ct", "", [ "ejector", "eject" ] ]
#32 Mr. Spell. Tir r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. fede r = MOOList [ "ra", "", [ "federate", "federal" ] ]
#32 Mr. Spell. deser r = MOOList [ "", "", [ "deserve", "desert" ] ]
#32 Mr. Spell. Tin r = MOOList [ "", "gkt", [ "tiny", "tinsel", "tinfoil", "tine", "tinder", "tincture", "Tina", "tin" ] ]
#32 Mr. Spell. skir r = MOOList [ "", "", [ "skirt", "skirmish" ] ]
#32 Mr. Spell. junke r = MOOList [ "", "", [ "junketeer", "junkerdom" ] ]
#32 Mr. Spell. skit r = MOOList [ "", "", [ "skittle", "skit" ] ]
#32 Mr. Spell. desec r = MOOList [ "rate", "", [ "desecrater", "desecrate" ] ]
#32 Mr. Spell. esca r = MOOList [ "", "p", [ "escalate", "escadrille" ] ]
#32 Mr. Spell. Chr r = MOOList [ "", "ioy", [ ] ]
#32 Mr. Spell. skil r = MOOList [ "l", "", [ "skillful", "skillet", "skill" ] ]
#32 Mr. Spell. baske r = MOOList [ "t", "", [ "basketball", "basket" ] ]
#32 Mr. Spell. skim r = MOOList [ "", "p", [ "skimmer", "skim" ] ]
#32 Mr. Spell. skin r = MOOList [ "", "", [ "skinny", "skindive", "skin" ] ]
#32 Mr. Spell. extru r = MOOList [ "", "s", [ "extrude" ] ]
#32 Mr. Spell. crossw r = MOOList [ "", "a", [ "crosswort", "crosswise" ] ]
#32 Mr. Spell. skip r = MOOList [ "", "", [ "Skippy", "skipjack", "skip" ] ]
#32 Mr. Spell. struct r = MOOList [ "ur", "", [ "structure", "structural" ] ]
#32 Mr. Spell. skid r = MOOList [ "", "", [ "skiddy", "skid" ] ]
#32 Mr. Spell. elb r = MOOList [ "", "", [ "elbow", "Elba" ] ]
#32 Mr. Spell. Chi r = MOOList [ "", "aceglmnprstv", [ "chiffon", "chide", "chi" ] ]
#32 Mr. Spell. portent r = MOOList [ "", "", [ "portentous", "portent" ] ]
#32 Mr. Spell. housewi r = MOOList [ "", "", [ "housewives", "housewife" ] ]
#32 Mr. Spell. Whitt r = MOOList [ "", "", [ "whittle", "Whittier", "Whittaker" ] ]
#32 Mr. Spell. eld r = MOOList [ "", "e", [ "Eldon" ] ]
#32 Mr. Spell. McClu r = MOOList [ "", "", [ "McCluskey", "McClure" ] ]
#32 Mr. Spell. yourse r = MOOList [ "l", "", [ "yourselves", "yourself" ] ]
#32 Mr. Spell. Cic r = MOOList [ "", "e", [ "cicada" ] ]
#32 Mr. Spell. crossb r = MOOList [ "", "", [ "crossbill", "crossbar" ] ]
#32 Mr. Spell. rheo r = MOOList [ "", "", [ "rheostat", "rheology" ] ]
#32 Mr. Spell. recepti r = MOOList [ "", "", [ "receptive", "reception" ] ]
#32 Mr. Spell. menda r = MOOList [ "ci", "", [ "mendacity", "mendacious" ] ]
#32 Mr. Spell. rhet r = MOOList [ "oric", "", [ "rhetorician", "rhetoric" ] ]
#32 Mr. Spell. mende r = MOOList [ "l", "", [ "Mendelssohn", "mendelevium", "Mendel" ] ]
#32 Mr. Spell. rheu r = MOOList [ "m", "a", [ "rheum" ] ]
#32 Mr. Spell. Libera r = MOOList [ "", "", [ "liberate", "liberal" ] ]
#32 Mr. Spell. Cir r = MOOList [ "c", "lu", [ "Circe", "circa" ] ]
#32 Mr. Spell. fishe r = MOOList [ "r", "m", [ "fishery" ] ]
#32 Mr. Spell. clothesm r = MOOList [ "", "", [ "clothesmen", "clothesman" ] ]
#32 Mr. Spell. afte r = MOOList [ "r", "w", [ "afterthought", "afternoon", "aftermath", "afterlife", "afterimage", "afterglow", "aftereffect", "after" ] ]
#32 Mr. Spell. rhen r = MOOList [ "i", "", [ "rhenium", "Rhenish" ] ]
#32 Mr. Spell. Cin r = MOOList [ "", "cden", [ "cinquefoil" ] ]
#32 Mr. Spell. Belgi r = MOOList [ "", "", [ "Belgium", "Belgian" ] ]
#32 Mr. Spell. willow r = MOOList [ "", "", [ "willowy", "willow" ] ]
#32 Mr. Spell. ema r = MOOList [ "", "nc", [ "emasculate" ] ]
#32 Mr. Spell. emb r = MOOList [ "", "aelor", [ ] ]
#32 Mr. Spell. marty r = MOOList [ "", "r", [ "Marty" ] ]
#32 Mr. Spell. eme r = MOOList [ "", "r", [ "emendable" ] ]
#32 Mr. Spell. inla r = MOOList [ "", "", [ "inlay", "inland", "inlaid" ] ]
#32 Mr. Spell. debil r = MOOList [ "it", "", [ "debility", "debilitate" ] ]
#32 Mr. Spell. eli r = MOOList [ "", "szm", [ "elite", "Eliot", "Elinor", "Elijah", "eligible", "elide", "elicit", "Eli" ] ]
#32 Mr. Spell. elo r = MOOList [ "", "", [ "eloquent", "elope", "elongate", "Eloise" ] ]
#32 Mr. Spell. ethno r = MOOList [ "", "", [ "ethnology", "ethnography" ] ]
#32 Mr. Spell. declarati r = MOOList [ "", "", [ "declarative", "declaration" ] ]
#32 Mr. Spell. elu r = MOOList [ "", "t", [ "elusive", "elude", "elucidate", "eluate" ] ]
#32 Mr. Spell. voi r = MOOList [ "", "c", [ "void" ] ]
#32 Mr. Spell. feat r = MOOList [ "", "h", [ "feature", "feat" ] ]
#32 Mr. Spell. sunshi r = MOOList [ "n", "", [ "sunshiny", "sunshine" ] ]
#32 Mr. Spell. polaris r = MOOList [ "", "", [ "polariscope", "Polaris" ] ]
#32 Mr. Spell. fear r = MOOList [ "", "", [ "fearsome", "fearful", "fear" ] ]
#32 Mr. Spell. vol r = MOOList [ "", "cltu", [ "Volvo", "Volstead", "Volkswagen", "volition", "volatile" ] ]
#32 Mr. Spell. feas r = MOOList [ "", "", [ "feast", "feasible" ] ]
#32 Mr. Spell. biva r = MOOList [ "", "", [ "bivariate", "bivalve" ] ]
#32 Mr. Spell. camer r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. colleg r = MOOList [ "", "i", [ "college" ] ]
#32 Mr. Spell. vor r = MOOList [ "", "at", [ ] ]
#32 Mr. Spell. enc r = MOOList [ "", "oru", [ "encyclopedic", "enclave", "enchantress", "encephalitis", "encapsulate" ] ]
#32 Mr. Spell. vot r = MOOList [ "", "", [ "votive", "vote", "votary" ] ]
#32 Mr. Spell. end r = MOOList [ "", "o", [ "endure", "endpoint", "Endicott", "endgame", "end" ] ]
#32 Mr. Spell. vou r = MOOList [ "", "c", [ "Vought" ] ]
#32 Mr. Spell. ene r = MOOList [ "", "r", [ "enemy" ] ]
#32 Mr. Spell. collec r = MOOList [ "t", "", [ "collector", "collectible", "collect" ] ]
#32 Mr. Spell. enf r = MOOList [ "", "o", [ "enfant" ] ]
#32 Mr. Spell. camel r = MOOList [ "", "o", [ "camellia", "camelback", "camel" ] ]
#32 Mr. Spell. vow r = MOOList [ "", "", [ "vowel", "vow" ] ]
#32 Mr. Spell. eng r = MOOList [ "", "il", [ "Engel", "engage", "Eng" ] ]
#32 Mr. Spell. Adolp r = MOOList [ "h", "", [ "Adolphus", "Adolph" ] ]
#32 Mr. Spell. emi r = MOOList [ "", "glst", [ "emirate", "eminent" ] ]
#32 Mr. Spell. Cypri r = MOOList [ "", "", [ "Cypriot", "Cyprian" ] ]
#32 Mr. Spell. junct r = MOOList [ "", "", [ "juncture", "junctor", "junction" ] ]
#32 Mr. Spell. floodl r = MOOList [ "i", "", [ "floodlit", "floodlight" ] ]
#32 Mr. Spell. quadrill r = MOOList [ "", "", [ "quadrillion", "quadrille" ] ]
#32 Mr. Spell. emp r = MOOList [ "", "hilo", [ "empyrean", "empty", "empress", "emperor", "empathy" ] ]
#32 Mr. Spell. voc r = MOOList [ "", "a", [ "vociferous" ] ]
#32 Mr. Spell. Ever r = MOOList [ "", "egy", [ "everlasting", "Everhart", "ever" ] ]
#32 Mr. Spell. associati r = MOOList [ "on", "", [ "associations", "association" ] ]
#32 Mr. Spell. emu r = MOOList [ "l", "s", [ "emulate" ] ]
#32 Mr. Spell. vog r = MOOList [ "", "", [ "vogue", "Vogel" ] ]
#32 Mr. Spell. mito r = MOOList [ "", "", [ "mitosis", "mitochondria" ] ]
#32 Mr. Spell. enz r = MOOList [ "ym", "", [ "enzymology", "enzyme", "enzymatic" ] ]
#32 Mr. Spell. torto r = MOOList [ "ise", "", [ "tortoiseshell", "tortoise" ] ]
#32 Mr. Spell. init r = MOOList [ "ia", "l", [ "initiate" ] ]
#32 Mr. Spell. Brain r = MOOList [ "", "", [ "brainy", "brainwash", "brainstorm", "Brainard", "brain" ] ]
#32 Mr. Spell. backpl r = MOOList [ "a", "", [ "backplate", "backplane" ] ]
#32 Mr. Spell. rhino r = MOOList [ "", "", [ "rhinoceros", "rhino" ] ]
#32 Mr. Spell. epA r = MOOList [ "", "", [ "epaulet", "EPA" ] ]
#32 Mr. Spell. desid r = MOOList [ "erat", "", [ "desideratum", "desiderata" ] ]
#32 Mr. Spell. Peal r = MOOList [ "", "", [ "Peale", "peal" ] ]
#32 Mr. Spell. tortu r = MOOList [ "", "", [ "torture", "tortuous" ] ]
#32 Mr. Spell. mitt r = MOOList [ "", "", [ "mitten", "mitt" ] ]
#32 Mr. Spell. McCon r = MOOList [ "nel", "", [ "McConnell", "McConnel" ] ]
#32 Mr. Spell. mitr r = MOOList [ "", "", [ "mitre", "mitral" ] ]
#32 Mr. Spell. Pear r = MOOList [ "", "l", [ "Pearson", "Pearce", "pear" ] ]
#32 Mr. Spell. Peas r = MOOList [ "", "", [ "Pease", "peasant" ] ]
#32 Mr. Spell. eni r = MOOList [ "", "g", [ "Enid" ] ]
#32 Mr. Spell. desir r = MOOList [ "", "", [ "desirous", "desire" ] ]
#32 Mr. Spell. Numeri r = MOOList [ "", "", [ "Numerische", "numeric" ] ]
#32 Mr. Spell. eno r = MOOList [ "", "r", [ "enough", "Enos", "enol", "Enoch" ] ]
#32 Mr. Spell. bitt r = MOOList [ "", "e", [ "bitt" ] ]
#32 Mr. Spell. Livi r = MOOList [ "", "n", [ "livid" ] ]
#32 Mr. Spell. crypto r = MOOList [ "gra", "p", [ "cryptogram" ] ]
#32 Mr. Spell. rhine r = MOOList [ "", "", [ "rhinestone", "Rhine" ] ]
#32 Mr. Spell. Francis r = MOOList [ "", "c", [ "Francis" ] ]
#32 Mr. Spell. enq r = MOOList [ "uir", "", [ "enquiry", "enquire" ] ]
#32 Mr. Spell. avers r = MOOList [ "", "", [ "aversion", "averse" ] ]
#32 Mr. Spell. iniq r = MOOList [ "uit", "", [ "iniquity", "iniquitous" ] ]
#32 Mr. Spell. enr r = MOOList [ "", "", [ "enrollee", "Enrico" ] ]
#32 Mr. Spell. bitu r = MOOList [ "m", "", [ "bituminous", "bitumen" ] ]
#32 Mr. Spell. averr r = MOOList [ "", "", [ "averring", "averred" ] ]
#32 Mr. Spell. ens r = MOOList [ "", "", [ "enstatite", "ensemble", "ensconce" ] ]
#32 Mr. Spell. mite r = MOOList [ "", "", [ "miterwort", "mite" ] ]
#32 Mr. Spell. ent r = MOOList [ "", "ehior", [ ] ]
#32 Mr. Spell. desig r = MOOList [ "n", "", [ "designs", "designed", "designate", "design" ] ]
#32 Mr. Spell. jacka r = MOOList [ "", "", [ "jackass", "jackanapes" ] ]
#32 Mr. Spell. enu r = MOOList [ "", "mn", [ ] ]
#32 Mr. Spell. inim r = MOOList [ "i", "", [ "inimitable", "inimical" ] ]
#32 Mr. Spell. env r = MOOList [ "", "ei", [ "envy", "envoy" ] ]
#32 Mr. Spell. sket r = MOOList [ "ch", "", [ "sketchy", "sketchpad", "sketchbook", "sketch" ] ]
#32 Mr. Spell. Wilso r = MOOList [ "n", "", [ "Wilsonian", "Wilson" ] ]
#32 Mr. Spell. impelle r = MOOList [ "", "", [ "impeller", "impelled" ] ]
#32 Mr. Spell. declarato r = MOOList [ "r", "", [ "declaratory", "declarator" ] ]
#32 Mr. Spell. excul r = MOOList [ "pat", "", [ "exculpatory", "exculpate" ] ]
#32 Mr. Spell. crypta r = MOOList [ "naly", "s", [ "cryptanalytic" ] ]
#32 Mr. Spell. inhu r = MOOList [ "man", "", [ "inhumane", "inhuman" ] ]
#32 Mr. Spell. skel r = MOOList [ "et", "", [ "skeleton", "skeletal" ] ]
#32 Mr. Spell. marte r = MOOList [ "n", "", [ "martensite", "marten" ] ]
#32 Mr. Spell. miss r = MOOList [ "", "iop", [ "missed", "Missy", "misshapen", "miss" ] ]
#32 Mr. Spell. mist r = MOOList [ "", "", [ "mistaken", "misty", "mistress", "mistletoe", "mist" ] ]
#32 Mr. Spell. excus r = MOOList [ "", "", [ "excuse", "excusable" ] ]
#32 Mr. Spell. eph r = MOOList [ "", "e", [ "Ephraim" ] ]
#32 Mr. Spell. miso r = MOOList [ "gyn", "", [ "misogyny", "misogynist" ] ]
#32 Mr. Spell. epi r = MOOList [ "", "cdglpst", [ "epimorphism" ] ]
#32 Mr. Spell. excur r = MOOList [ "s", "", [ "excursus", "excursion" ] ]
#32 Mr. Spell. mulli r = MOOList [ "", "g", [ "mullion" ] ]
#32 Mr. Spell. heathe r = MOOList [ "n", "", [ "heathenish", "heathen" ] ]
#32 Mr. Spell. inhi r = MOOList [ "bit", "o", [ "inhibition", "inhibit" ] ]
#32 Mr. Spell. avera r = MOOList [ "ge", "", [ "averages", "average" ] ]
#32 Mr. Spell. inhe r = MOOList [ "r", "ei", [ ] ]
#32 Mr. Spell. mise r = MOOList [ "r", "", [ "misery", "miser" ] ]
#32 Mr. Spell. inho r = MOOList [ "", "m", [ "inhospitable", "inholding" ] ]
#32 Mr. Spell. bist r = MOOList [ "a", "", [ "bistate", "bistable" ] ]
#32 Mr. Spell. benze r = MOOList [ "", "", [ "benzene", "Benzedrine" ] ]
#32 Mr. Spell. sword r = MOOList [ "", "", [ "swordtail", "swordplay", "swordfish", "sword" ] ]
#32 Mr. Spell. misc r = MOOList [ "", "e", [ "miscreant", "mischievous", "miscible" ] ]
#32 Mr. Spell. misa r = MOOList [ "nthrop", "", [ "misanthropic", "misanthrope" ] ]
#32 Mr. Spell. Cly r = MOOList [ "", "", [ "Clytemnestra", "Clyde" ] ]
#32 Mr. Spell. Willi r = MOOList [ "", "a", [ "Willis", "Willie" ] ]
#32 Mr. Spell. omitt r = MOOList [ "", "", [ "omitting", "omitted" ] ]
#32 Mr. Spell. ingr r = MOOList [ "", "a", [ "ingrown", "ingredient" ] ]
#32 Mr. Spell. desol r = MOOList [ "ate", "", [ "desolater", "desolate" ] ]
#32 Mr. Spell. Tob r = MOOList [ "", "a", [ "Toby" ] ]
#32 Mr. Spell. bise r = MOOList [ "", "", [ "bisexual", "bisect" ] ]
#32 Mr. Spell. immat r = MOOList [ "", "", [ "immature", "immaterial" ] ]
#32 Mr. Spell. inha r = MOOList [ "", "bl", [ "inharmonious" ] ]
#32 Mr. Spell. companio r = MOOList [ "n", "", [ "companionship", "companionway", "companion" ] ]
#32 Mr. Spell. expecto r = MOOList [ "ra", "", [ "expectorate", "expectorant" ] ]
#32 Mr. Spell. bish r = MOOList [ "op", "", [ "bishopric", "bishop" ] ]
#32 Mr. Spell. absente r = MOOList [ "e", "", [ "absenteeism", "absentee" ] ]
#32 Mr. Spell. video r = MOOList [ "", "", [ "videotape", "video" ] ]
#32 Mr. Spell. lette r = MOOList [ "r", "m", [ "letterhead" ] ]
#32 Mr. Spell. clum r = MOOList [ "", "", [ "clumsy", "clump" ] ]
#32 Mr. Spell. Toy r = MOOList [ "", "", [ "Toyota", "toy" ] ]
#32 Mr. Spell. expecta r = MOOList [ "", "", [ "expectation", "expectant" ] ]
#32 Mr. Spell. Harris r = MOOList [ "", "", [ "Harrison", "Harrisburg", "Harris" ] ]
#32 Mr. Spell. epo r = MOOList [ "", "c", [ "epoxy" ] ]
#32 Mr. Spell. nicot r = MOOList [ "in", "", [ "nicotine", "nicotinamide" ] ]
#32 Mr. Spell. inge r = MOOList [ "", "ns", [ "Ingersoll" ] ]
#32 Mr. Spell. Tor r = MOOList [ "", "noprst", [ "tory", "torus", "torque", "tori", "tore", "torch", "Torah", "tor" ] ]
#32 Mr. Spell. McCar r = MOOList [ "t", "", [ "McCarty", "McCarthy" ] ]
#32 Mr. Spell. birt r = MOOList [ "h", "", [ "birthright", "birthplace", "birthday", "birth" ] ]
#32 Mr. Spell. afor r = MOOList [ "e", "", [ "aforethought", "aforesaid", "aforementioned" ] ]
#32 Mr. Spell. Willa r = MOOList [ "", "", [ "Willard", "Willa" ] ]
#32 Mr. Spell. clut r = MOOList [ "", "", [ "clutter", "clutch" ] ]
#32 Mr. Spell. mira r = MOOList [ "", "c", [ "Miranda", "mirage", "Mira" ] ]
#32 Mr. Spell. Tol r = MOOList [ "", "el", [ "toluene", "Tolstoy", "told" ] ]
#32 Mr. Spell. McCal r = MOOList [ "l", "", [ "McCallum", "McCall" ] ]
#32 Mr. Spell. infu r = MOOList [ "", "s", [ "infuriate" ] ]
#32 Mr. Spell. despi r = MOOList [ "", "", [ "despite", "despise", "despicable" ] ]
#32 Mr. Spell. weste r = MOOList [ "r", "n", [ "westerly" ] ]
#32 Mr. Spell. presiden r = MOOList [ "t", "", [ "presidential", "president" ] ]
#32 Mr. Spell. era r = MOOList [ "", "dst", [ "era" ] ]
#32 Mr. Spell. infr r = MOOList [ "", "a", [ "infringe", "infrequent" ] ]
#32 Mr. Spell. club r = MOOList [ "", "", [ "clubroom", "clubhouse", "club" ] ]
#32 Mr. Spell. ere r = MOOList [ "", "", [ "erect", "ere" ] ]
#32 Mr. Spell. bird r = MOOList [ "", "", [ "birdwatch", "birdseed", "birdie", "birdbath", "bird" ] ]
#32 Mr. Spell. nitri r = MOOList [ "", "", [ "nitrite", "nitride", "nitric" ] ]
#32 Mr. Spell. erg r = MOOList [ "", "", [ "ergodic", "ergative", "erg" ] ]
#32 Mr. Spell. nitro r = MOOList [ "", "g", [ "nitrous" ] ]
#32 Mr. Spell. despe r = MOOList [ "ra", "", [ "desperate", "desperado" ] ]
#32 Mr. Spell. infe r = MOOList [ "", "clrs", [ "infeasible" ] ]
#32 Mr. Spell. down r = MOOList [ "", "pstw", [ "downright", "downhill", "downgrade", "downfall", "Downey", "downdraft", "downcast", "downbeat", "down" ] ]
#32 Mr. Spell. infa r = MOOList [ "", "mn", [ "infatuate", "infarct", "infallible" ] ]
#32 Mr. Spell. Brand r = MOOList [ "", "ey", [ "Brandt", "Brandon", "brandish", "brand" ] ]
#32 Mr. Spell. Cob r = MOOList [ "", "b", [ "cobweb", "cobra", "Cobol", "cobalt" ] ]
#32 Mr. Spell. info r = MOOList [ "rm", "a", [ "inform" ] ]
#32 Mr. Spell. despo r = MOOList [ "", "nt", [ "despoil" ] ]
#32 Mr. Spell. infi r = MOOList [ "", "mnr", [ "infix", "infiltrate", "infighting", "infield", "infidel" ] ]
#32 Mr. Spell. infl r = MOOList [ "", "aeu", [ "inflow", "inflict" ] ]
#32 Mr. Spell. Blum r = MOOList [ "", "", [ "Blumenthal", "Blum" ] ]
#32 Mr. Spell. hydroxyl r = MOOList [ "", "", [ "hydroxylate", "hydroxyl" ] ]
#32 Mr. Spell. USI r = MOOList [ "", "", [ "USIA", "using" ] ]
#32 Mr. Spell. Cow r = MOOList [ "", "abhlmp", [ "cowslip", "cowry", "coworker", "cow" ] ]
#32 Mr. Spell. circumcis r = MOOList [ "", "", [ "circumcision", "circumcise" ] ]
#32 Mr. Spell. ineq r = MOOList [ "u", "i", [ "inequality" ] ]
#32 Mr. Spell. iner r = MOOList [ "", "t", [ "ineradicable" ] ]
#32 Mr. Spell. ines r = MOOList [ "", "", [ "inestimable", "inescapable" ] ]
#32 Mr. Spell. USC r = MOOList [ "", "", [ "USC&GS", "USC" ] ]
#32 Mr. Spell. inex r = MOOList [ "", "pt", [ "inexorable", "inexhaustible", "inexcusable", "inexact" ] ]
#32 Mr. Spell. Formi r = MOOList [ "", "c", [ "formidable" ] ]
#32 Mr. Spell. Con r = MOOList [ "", "acdefgijnqrstv", [ "cony", "Conway", "conundrum", "Conley", "Conklin", "con" ] ]
#32 Mr. Spell. Com r = MOOList [ "", "abeimp", [ "comrade", "comfort" ] ]
#32 Mr. Spell. sloga r = MOOList [ "n", "", [ "sloganeer", "slogan" ] ]
#32 Mr. Spell. inef r = MOOList [ "f", "ei", [ "ineffable" ] ]
#32 Mr. Spell. ero r = MOOList [ "", "dst", [ ] ]
#32 Mr. Spell. err r = MOOList [ "", "ao", [ "err" ] ]
#32 Mr. Spell. sculp r = MOOList [ "", "t", [ "sculpin" ] ]
#32 Mr. Spell. inel r = MOOList [ "", "", [ "ineluctable", "ineligible", "inelegant", "inelastic" ] ]
#32 Mr. Spell. eru r = MOOList [ "", "dp", [ ] ]
#32 Mr. Spell. doctrina r = MOOList [ "", "", [ "doctrinal", "doctrinaire" ] ]
#32 Mr. Spell. announce r = MOOList [ "", "", [ "announced", "announce" ] ]
#32 Mr. Spell. pawn r = MOOList [ "", "", [ "pawnshop", "pawn" ] ]
#32 Mr. Spell. indu r = MOOList [ "", "cls", [ "indubitable" ] ]
#32 Mr. Spell. indo r = MOOList [ "", "c", [ "indorse", "indoor", "Indonesia", "indomitable", "indolent", "Indoeuropean" ] ]
#32 Mr. Spell. Golds r = MOOList [ "", "t", [ "goldsmith" ] ]
#32 Mr. Spell. etc r = MOOList [ "", "", [ "etch", "etc" ] ]
#32 Mr. Spell. shorts r = MOOList [ "", "", [ "shortstop", "shortsighted" ] ]
#32 Mr. Spell. ete r = MOOList [ "rn", "", [ "eternity", "eternal" ] ]
#32 Mr. Spell. Lips r = MOOList [ "", "c", [ "lipstick" ] ]
#32 Mr. Spell. Bolshe r = MOOList [ "vi", "s", [ "Bolshevik" ] ]
#32 Mr. Spell. bassi r = MOOList [ "", "", [ "bassinet", "bassi" ] ]
#32 Mr. Spell. eth r = MOOList [ "", "aeinoy", [ ] ]
#32 Mr. Spell. bipa r = MOOList [ "rti", "", [ "bipartite", "bipartisan" ] ]
#32 Mr. Spell. eti r = MOOList [ "", "", [ "etiquette", "etiology" ] ]
#32 Mr. Spell. eso r = MOOList [ "", "", [ "esoteric", "esophagi" ] ]
#32 Mr. Spell. esp r = MOOList [ "", "oe", [ "esprit", "esplanade", "espionage" ] ]
#32 Mr. Spell. biom r = MOOList [ "etr", "", [ "biometry", "Biometrika" ] ]
#32 Mr. Spell. shortc r = MOOList [ "", "", [ "shortcut", "shortcoming" ] ]
#32 Mr. Spell. minu r = MOOList [ "", "est", [ ] ]
#32 Mr. Spell.trusted rc = MOOList [ ]
#32 Mr. Spell. est r = MOOList [ "", "aeiou", [ "estrange", "Esther", "EST" ] ]
#32 Mr. Spell. Aire r = MOOList [ "", "", [ "Aires", "airedale" ] ]
#32 Mr. Spell. Dayt r = MOOList [ "", "o", [ "daytime" ] ]
#32 Mr. Spell. shorte r = MOOList [ "", "", [ "shorter", "shorten" ] ]
#32 Mr. Spell. biot r = MOOList [ "", "i", [ "biota" ] ]
#32 Mr. Spell. incr r = MOOList [ "", "e", [ "incriminate" ] ]
#32 Mr. Spell. mini r = MOOList [ "", "ms", [ "minion", "minicomputer", "miniature", "mini" ] ]
#32 Mr. Spell. incu r = MOOList [ "", "blr", [ "incumbent" ] ]
#32 Mr. Spell. Nova r = MOOList [ "", "", [ "Novak", "nova" ] ]
#32 Mr. Spell. mine r = MOOList [ "", "rs", [ "minefield", "mine" ] ]
#32 Mr. Spell. inco r = MOOList [ "", "mnr", [ "incoherent" ] ]
#32 Mr. Spell. minc r = MOOList [ "e", "", [ "mincemeat", "mince" ] ]
#32 Mr. Spell. point r = MOOList [ "", "", [ "points", "pointwise", "point" ] ]
#32 Mr. Spell. behave r = MOOList [ "", "", [ "behaves", "behave" ] ]
#32 Mr. Spell. doub r = MOOList [ "", "lt", [ ] ]
#32 Mr. Spell. mino r = MOOList [ "", "", [ "minot", "Minos", "minor", "Minoan" ] ]
#32 Mr. Spell. behavi r = MOOList [ "or", "", [ "behavior", "behavioral" ] ]
#32 Mr. Spell. virtuo r = MOOList [ "", "s", [ "virtuous" ] ]
#32 Mr. Spell. doug r = MOOList [ "", "hl", [ "Doug" ] ]
#32 Mr. Spell. practica r = MOOList [ "", "", [ "practical", "practicable" ] ]
#32 Mr. Spell. bing r = MOOList [ "", "h", [ "bingle", "binge", "bing" ] ]
#32 Mr. Spell. Novo r = MOOList [ "", "", [ "Novosibirsk", "novo" ] ]
#32 Mr. Spell. ince r = MOOList [ "", "nps", [ ] ]
#32 Mr. Spell. debri r = MOOList [ "", "", [ "debris", "debrief" ] ]
#32 Mr. Spell. inca r = MOOList [ "", "npr", [ "incautious", "incalculable", "Inca" ] ]
#32 Mr. Spell. bino r = MOOList [ "", "", [ "binomial", "binocular" ] ]
#32 Mr. Spell. incl r = MOOList [ "", "iu", [ "inclose", "inclement" ] ]
#32 Mr. Spell. paun r = MOOList [ "ch", "", [ "paunchy", "paunch" ] ]
#32 Mr. Spell. inci r = MOOList [ "", "ds", [ "incite", "incipient", "incinerate" ] ]
#32 Mr. Spell. eva r = MOOList [ "", "lns", [ "evaporate", "evade", "evacuate", "Eva" ] ]
#32 Mr. Spell. inbr r = MOOList [ "e", "", [ "inbreed", "inbred" ] ]
#32 Mr. Spell. inbo r = MOOList [ "", "", [ "inborn", "inboard" ] ]
#32 Mr. Spell. pentag r = MOOList [ "", "o", [ "pentagram" ] ]
#32 Mr. Spell. evi r = MOOList [ "", "dl", [ "evince", "evict" ] ]
#32 Mr. Spell. bina r = MOOList [ "", "", [ "binaural", "binary" ] ]
#32 Mr. Spell. desti r = MOOList [ "", "n", [ "destitute" ] ]
#32 Mr. Spell. bind r = MOOList [ "", "", [ "bindings", "bindweed", "bindle", "bindery", "bind" ] ]
#32 Mr. Spell. mimi r = MOOList [ "", "c", [ "Mimi" ] ]
#32 Mr. Spell. evo r = MOOList [ "", "cl", [ "evoke" ] ]
#32 Mr. Spell. Cro r = MOOList [ "", "acmnostuw", [ "croydon", "crop", "Croix", "croft" ] ]
#32 Mr. Spell. eup r = MOOList [ "h", "eo", [ "Euphrates" ] ]
#32 Mr. Spell. endoga r = MOOList [ "m", "", [ "endogamy", "endogamous" ] ]
#32 Mr. Spell. pati r = MOOList [ "", "", [ "patio", "patina", "patient" ] ]
#32 Mr. Spell. path r = MOOList [ "", "o", [ "pathway", "pathetic", "path" ] ]
#32 Mr. Spell. eur r = MOOList [ "", "io", [ "Eurydice", "eureka", "Eurasia" ] ]
#32 Mr. Spell. contrave r = MOOList [ "n", "", [ "contravention", "contravene" ] ]
#32 Mr. Spell. Wint r = MOOList [ "", "e", [ "wintry", "Winthrop" ] ]
#32 Mr. Spell. operati r = MOOList [ "", "", [ "operation", "operating", "operatic" ] ]
#32 Mr. Spell. pate r = MOOList [ "", "nr", [ "pate" ] ]
#32 Mr. Spell. patc r = MOOList [ "h", "", [ "patchy", "patchwork", "patch" ] ]
#32 Mr. Spell. operate r = MOOList [ "", "", [ "operated", "operate" ] ]
#32 Mr. Spell. patr r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. bimo r = MOOList [ "", "", [ "bimonthly", "bimolecular", "bimodal" ] ]
#32 Mr. Spell. destr r = MOOList [ "", "u", [ "destroy" ] ]
#32 Mr. Spell. Winn r = MOOList [ "", "i", [ "winnow", "Winnetka" ] ]
#32 Mr. Spell. inap r = MOOList [ "", "pt", [ ] ]
#32 Mr. Spell. mild r = MOOList [ "", "", [ "Mildred", "mildew", "mild" ] ]
#32 Mr. Spell. mile r = MOOList [ "", "s", [ "mileage", "mile" ] ]
#32 Mr. Spell. inal r = MOOList [ "", "", [ "inalterable", "inalienable" ] ]
#32 Mr. Spell. past r = MOOList [ "", "eiou", [ "pasty", "pastry", "past" ] ]
#32 Mr. Spell. prud r = MOOList [ "ent", "", [ "prudential", "prudent" ] ]
#32 Mr. Spell. pass r = MOOList [ "", "aei", [ "password", "passport", "Passover", "passband", "pass" ] ]
#32 Mr. Spell. inan r = MOOList [ "", "", [ "inanimate", "inane" ] ]
#32 Mr. Spell. mila r = MOOList [ "", "", [ "Milan", "mila" ] ]
#32 Mr. Spell. inat r = MOOList [ "tenti", "", [ "inattentive", "inattention" ] ]
#32 Mr. Spell. Tuc r = MOOList [ "", "k", [ "Tucson" ] ]
#32 Mr. Spell. milk r = MOOList [ "", "", [ "milky", "milkweed", "milk" ] ]
#32 Mr. Spell. inau r = MOOList [ "", "g", [ "inauspicious", "inaudible" ] ]
#32 Mr. Spell. deform r = MOOList [ "", "", [ "deformation", "deform" ] ]
#32 Mr. Spell. mili r = MOOList [ "", "t", [ "milieu" ] ]
#32 Mr. Spell. Dave r = MOOList [ "", "", [ "davenport", "Dave" ] ]
#32 Mr. Spell. easy r = MOOList [ "", "", [ "easygoing", "easy" ] ]
#32 Mr. Spell. clog r = MOOList [ "", "", [ "clogging", "clog" ] ]
#32 Mr. Spell. inac r = MOOList [ "", "ct", [ ] ]
#32 Mr. Spell. Davi r = MOOList [ "", "ds", [ "davit", "Davies" ] ]
#32 Mr. Spell. stenog r = MOOList [ "raph", "", [ "stenography", "stenographer" ] ]
#32 Mr. Spell. Lind r = MOOList [ "", "bs", [ "Lindquist", "Lindholm", "linden", "Linda", "Lind" ] ]
#32 Mr. Spell. dorm r = MOOList [ "", "", [ "dormitory", "dormant" ] ]
#32 Mr. Spell. bili r = MOOList [ "n", "", [ "bilingual", "bilinear" ] ]
#32 Mr. Spell. pasc r = MOOList [ "", "", [ "paschal", "Pascal" ] ]
#32 Mr. Spell. bill r = MOOList [ "", "i", [ "billy", "billow", "billet", "billboard", "bill" ] ]
#32 Mr. Spell. Lino r = MOOList [ "", "", [ "Linotype", "linoleum" ] ]
#32 Mr. Spell. clon r = MOOList [ "", "", [ "clonic", "clone" ] ]
#32 Mr. Spell. erup r = MOOList [ "t", "", [ "eruption", "erupt" ] ]
#32 Mr. Spell. campa r = MOOList [ "", "", [ "campanile", "campaign" ] ]
#32 Mr. Spell. inad r = MOOList [ "", "ev", [ "inadmissible" ] ]
#32 Mr. Spell. clos r = MOOList [ "", "e", [ "closing", "closure" ] ]
#32 Mr. Spell. Tus r = MOOList [ "", "ck", [ "tussle" ] ]
#32 Mr. Spell. clou r = MOOList [ "", "d", [ "clout" ] ]
#32 Mr. Spell. eate r = MOOList [ "", "", [ "eater", "eaten" ] ]
#32 Mr. Spell. clot r = MOOList [ "", "h", [ "cloture", "clot" ] ]
#32 Mr. Spell. exc r = MOOList [ "", "ehiloru", [ "excavate" ] ]
#32 Mr. Spell. easi r = MOOList [ "", "", [ "easier", "easily" ] ]
#32 Mr. Spell. York r = MOOList [ "", "", [ "Yorktown", "york" ] ]
#32 Mr. Spell. Wilh r = MOOList [ "elm", "", [ "Wilhelmina", "Wilhelm" ] ]
#32 Mr. Spell. exe r = MOOList [ "", "cgmr", [ "Exeter" ] ]
#32 Mr. Spell. part r = MOOList [ "", "i", [ "parts", "party", "partridge", "partook", "partner", "Parthenon", "partake", "part" ] ]
#32 Mr. Spell. exh r = MOOList [ "", "aiou", [ ] ]
#32 Mr. Spell. exi r = MOOList [ "", "s", [ "exit", "exile", "exigent" ] ]
#32 Mr. Spell. Wile r = MOOList [ "", "", [ "Wiley", "wile" ] ]
#32 Mr. Spell. colloq r = MOOList [ "", "u", [ "Colloq" ] ]
#32 Mr. Spell. cloa r = MOOList [ "k", "", [ "cloakroom", "cloak" ] ]
#32 Mr. Spell. Nort r = MOOList [ "", "h", [ "Norton" ] ]
#32 Mr. Spell. exo r = MOOList [ "", "grt", [ "exoskeleton", "exonerate", "exodus" ] ]
#32 Mr. Spell. cloc r = MOOList [ "k", "w", [ "clock" ] ]
#32 Mr. Spell. exp r = MOOList [ "", "aeiloru", [ ] ]
#32 Mr. Spell. bila r = MOOList [ "", "", [ "bilayer", "bilateral", "bilabial" ] ]
#32 Mr. Spell. Wilki r = MOOList [ "", "n", [ "Wilkie" ] ]
#32 Mr. Spell. Norw r = MOOList [ "", "a", [ "Norwich", "Norwegian" ] ]
#32 Mr. Spell. erud r = MOOList [ "it", "", [ "erudition", "erudite" ] ]
#32 Mr. Spell. Cost r = MOOList [ "", "", [ "costs", "costume", "Costello", "Costa", "cost" ] ]
#32 Mr. Spell. east r = MOOList [ "", "ew", [ "Eastman", "Eastland", "eastbound", "east" ] ]
#32 Mr. Spell. clod r = MOOList [ "", "", [ "cloddish", "clod" ] ]
#32 Mr. Spell. Stephe r = MOOList [ "n", "s", [ "Stephen" ] ]
#32 Mr. Spell. pare r = MOOList [ "", "n", [ "Pareto", "paregoric", "pare" ] ]
#32 Mr. Spell. bronchio r = MOOList [ "l", "", [ "bronchiole", "bronchiolar" ] ]
#32 Mr. Spell. Wils r = MOOList [ "", "o", [ "Wilshire" ] ]
#32 Mr. Spell. parc r = MOOList [ "", "", [ "parch", "parcel" ] ]
#32 Mr. Spell. defore r = MOOList [ "st", "", [ "deforestation", "deforest" ] ]
#32 Mr. Spell. para r = MOOList [ "", "bdglmnps", [ "paraxial", "paratroop", "parakeet", "paraffin", "parachute" ] ]
#32 Mr. Spell. paro r = MOOList [ "", "l", [ "parody", "parochial" ] ]
#32 Mr. Spell. parl r = MOOList [ "", "ai", [ "parley" ] ]
#32 Mr. Spell. ease r = MOOList [ "", "", [ "easel", "ease" ] ]
#32 Mr. Spell. Wilk r = MOOList [ "", "i", [ "Wilkes" ] ]
#32 Mr. Spell. Will r = MOOList [ "", "aio", [ "Wills", "willful", "will" ] ]
#32 Mr. Spell. Stepha r = MOOList [ "n", "", [ "stephanotis", "Stephanie" ] ]
#32 Mr. Spell. exa r = MOOList [ "", "clms", [ "exaggerate" ] ]
#32 Mr. Spell. Wilm r = MOOList [ "", "", [ "Wilmington", "Wilma" ] ]
#32 Mr. Spell. pari r = MOOList [ "", "s", [ "parimutuel", "pariah" ] ]
#32 Mr. Spell. theref r = MOOList [ "", "o", [ "therefrom" ] ]
#32 Mr. Spell. physio r = MOOList [ "", "t", [ "physiology", "physiognomy", "physiochemical" ] ]
#32 Mr. Spell. Norwa r = MOOList [ "", "", [ "Norway", "Norwalk" ] ]
#32 Mr. Spell. unita r = MOOList [ "", "r", [ "unital" ] ]
#32 Mr. Spell. inequit r = MOOList [ "", "", [ "inequity", "inequitable" ] ]
#32 Mr. Spell. toad r = MOOList [ "", "", [ "toady", "toad" ] ]
#32 Mr. Spell. thereo r = MOOList [ "", "", [ "thereon", "thereof" ] ]
#32 Mr. Spell. rhyt r = MOOList [ "hm", "", [ "rhythmic", "rhythm" ] ]
#32 Mr. Spell. debut r = MOOList [ "", "", [ "debutante", "debut" ] ]
#32 Mr. Spell. babys r = MOOList [ "", "i", [ "babysat" ] ]
#32 Mr. Spell. ext r = MOOList [ "", "eior", [ "extant" ] ]
#32 Mr. Spell. theret r = MOOList [ "o", "", [ "theretofore", "thereto" ] ]
#32 Mr. Spell. Salis r = MOOList [ "", "", [ "Salish", "Salisbury" ] ]
#32 Mr. Spell. immig r = MOOList [ "ra", "", [ "immigrate", "immigrant" ] ]
#32 Mr. Spell. exu r = MOOList [ "", "dl", [ "exuberant" ] ]
#32 Mr. Spell. thereu r = MOOList [ "", "", [ "thereupon", "thereunder" ] ]
#32 Mr. Spell. tribes r = MOOList [ "m", "", [ "tribesmen", "tribesman" ] ]
#32 Mr. Spell. alias r = MOOList [ "", "", [ "aliases", "alias" ] ]
#32 Mr. Spell. afterw r = MOOList [ "", "", [ "afterword", "afterward" ] ]
#32 Mr. Spell. stonewa r = MOOList [ "", "", [ "stoneware", "stonewall" ] ]
#32 Mr. Spell. shipma r = MOOList [ "", "", [ "shipmate", "shipman" ] ]
#32 Mr. Spell. border r = MOOList [ "", "l", [ "border" ] ]
#32 Mr. Spell. twitc r = MOOList [ "h", "", [ "twitchy", "twitch" ] ]
#32 Mr. Spell. Johann r = MOOList [ "", "e", [ "Johann" ] ]
#32 Mr. Spell. geral r = MOOList [ "d", "", [ "Geraldine", "Gerald" ] ]
#32 Mr. Spell. vivac r = MOOList [ "", "i", [ "vivace" ] ]
#32 Mr. Spell. happe r = MOOList [ "n", "", [ "happened", "happenstance", "happen" ] ]
#32 Mr. Spell. fissi r = MOOList [ "", "", [ "fission", "fissile" ] ]
#32 Mr. Spell. Hobo r = MOOList [ "", "", [ "Hoboken", "hobo" ] ]
#32 Mr. Spell. esti r = MOOList [ "ma", "", [ "estimate", "estimable" ] ]
#32 Mr. Spell. axis r = MOOList [ "", "", [ "axisymmetric", "axis" ] ]
#32 Mr. Spell. Essen r = MOOList [ "", "", [ "essential", "essence", "Essen" ] ]
#32 Mr. Spell. oppr r = MOOList [ "", "e", [ "opprobrium" ] ]
#32 Mr. Spell. fibro r = MOOList [ "", "", [ "fibrous", "fibrosis" ] ]
#32 Mr. Spell. oppo r = MOOList [ "", "s", [ "opportune", "opponent" ] ]
#32 Mr. Spell. Taci r = MOOList [ "t", "", [ "Tacitus", "tacit" ] ]
#32 Mr. Spell. extract r = MOOList [ "", "", [ "extractor", "extract" ] ]
#32 Mr. Spell. esto r = MOOList [ "", "p", [ "Estonia" ] ]
#32 Mr. Spell. Shakes r = MOOList [ "pear", "e", [ "Shakespearian" ] ]
#32 Mr. Spell. estu r = MOOList [ "ar", "", [ "estuary", "estuarine" ] ]
#32 Mr. Spell. therea r = MOOList [ "", "", [ "thereat", "thereafter", "thereabouts" ] ]
#32 Mr. Spell. unive r = MOOList [ "rs", "", [ "universe", "universal", "university" ] ]
#32 Mr. Spell. aggr r = MOOList [ "", "e", [ "aggrieve", "aggravate" ] ]
#32 Mr. Spell. univa r = MOOList [ "", "", [ "univariate", "univalent", "Univac" ] ]
#32 Mr. Spell. Typ r = MOOList [ "", "ehio", [ ] ]
#32 Mr. Spell. Quant r = MOOList [ "", "i", [ "quantum", "quanta" ] ]
#32 Mr. Spell. coexi r = MOOList [ "st", "", [ "coexistent", "coexist" ] ]
#32 Mr. Spell. esta r = MOOList [ "", "bt", [ ] ]
#32 Mr. Spell. axio r = MOOList [ "", "m", [ "axiology" ] ]
#32 Mr. Spell. mensu r = MOOList [ "ra", "", [ "mensuration", "mensurable" ] ]
#32 Mr. Spell. esse r = MOOList [ "", "n", [ "Essex" ] ]
#32 Mr. Spell. uran r = MOOList [ "", "i", [ "uranyl", "Uranus" ] ]
#32 Mr. Spell. actual r = MOOList [ "", "", [ "actually", "actual" ] ]
#32 Mr. Spell. aggl r = MOOList [ "", "u", [ "agglomerate" ] ]
#32 Mr. Spell. menti r = MOOList [ "on", "", [ "mentioned", "mention" ] ]
#32 Mr. Spell. Cyc r = MOOList [ "", "l", [ "cycad" ] ]
#32 Mr. Spell. highb r = MOOList [ "", "", [ "highboy", "highball" ] ]
#32 Mr. Spell. feti r = MOOList [ "", "", [ "fetish", "fetid" ] ]
#32 Mr. Spell. crock r = MOOList [ "", "e", [ "crock" ] ]
#32 Mr. Spell. fett r = MOOList [ "", "", [ "fettle", "fetter" ] ]
#32 Mr. Spell. skyw r = MOOList [ "a", "", [ "skyway", "skywave", "skyward" ] ]
#32 Mr. Spell. highl r = MOOList [ "", "", [ "highly", "highlight", "highland" ] ]
#32 Mr. Spell. croco r = MOOList [ "dil", "", [ "crocodilian", "crocodile" ] ]
#32 Mr. Spell. highw r = MOOList [ "ay", "m", [ "highway" ] ]
#32 Mr. Spell. fest r = MOOList [ "", "i", [ "fest" ] ]
#32 Mr. Spell. skyl r = MOOList [ "", "i", [ "skylark" ] ]
#32 Mr. Spell. Cyr r = MOOList [ "", "i", [ "Cyrus" ] ]
#32 Mr. Spell. Cyp r = MOOList [ "r", "i", [ "Cyprus", "cypress" ] ]
#32 Mr. Spell. Cyn r = MOOList [ "", "i", [ "Cynthia" ] ]
#32 Mr. Spell. unitar r = MOOList [ "", "", [ "unitary", "unitarian" ] ]
#32 Mr. Spell. debug r = MOOList [ "", "g", [ "debug" ] ]
#32 Mr. Spell. corner r = MOOList [ "", "", [ "corner", "cornerstone" ] ]
#32 Mr. Spell. unite r = MOOList [ "", "", [ "unite", "united" ] ]
#32 Mr. Spell. picnick r = MOOList [ "", "e", [ "picnicking" ] ]
#32 Mr. Spell. Cze r = MOOList [ "", "c", [ "Czerniak" ] ]
#32 Mr. Spell. requi r = MOOList [ "", "sr", [ "requited" ] ]
#32 Mr. Spell. immer r = MOOList [ "s", "", [ "immersion", "immerse" ] ]
#32 Mr. Spell. opposi r = MOOList [ "t", "", [ "opposition", "opposite" ] ]
#32 Mr. Spell. Virgi r = MOOList [ "", "n", [ "Virgil" ] ]
#32 Mr. Spell. Pete r = MOOList [ "", "r", [ "Pete" ] ]
#32 Mr. Spell. Aquar r = MOOList [ "iu", "", [ "Aquarius", "aquarium" ] ]
#32 Mr. Spell. emissi r = MOOList [ "", "", [ "emissivity", "emission" ] ]
#32 Mr. Spell. chair r = MOOList [ "", "mw", [ "chairperson", "chairlady", "chair" ] ]
#32 Mr. Spell. immed r = MOOList [ "ia", "", [ "immediate", "immediacy" ] ]
#32 Mr. Spell. cowar r = MOOList [ "d", "", [ "cowardice", "coward" ] ]
#32 Mr. Spell. agen r = MOOList [ "", "", [ "agency", "agent", "agenda" ] ]
#32 Mr. Spell. Urani r = MOOList [ "", "", [ "uranium", "urania" ] ]
#32 Mr. Spell. perpet r = MOOList [ "", "u", [ "perpetrate" ] ]
#32 Mr. Spell. ferm r = MOOList [ "", "ei", [ "Fermat" ] ]
#32 Mr. Spell. wac r = MOOList [ "", "k", [ "Waco", "WAC" ] ]
#32 Mr. Spell. emuls r = MOOList [ "i", "", [ "emulsion", "emulsify" ] ]
#32 Mr. Spell. wad r = MOOList [ "", "", [ "Wadsworth", "wadi", "wade", "waddle", "wad" ] ]
#32 Mr. Spell. waf r = MOOList [ "", "", [ "wafer", "waffle" ] ]
#32 Mr. Spell. wag r = MOOList [ "", "g", [ "wagoneer", "Wagner", "wage", "wag" ] ]
#32 Mr. Spell. Suffo r = MOOList [ "", "", [ "Suffolk", "suffocate" ] ]
#32 Mr. Spell. Juda r = MOOList [ "", "", [ "Judas", "Judaism" ] ]
#32 Mr. Spell. fero r = MOOList [ "ci", "", [ "ferocity", "ferocious" ] ]
#32 Mr. Spell. wai r = MOOList [ "", "nst", [ "waive", "wail" ] ]
#32 Mr. Spell. Caroli r = MOOList [ "n", "", [ "Carolinian", "Carolingian", "Caroline", "Carolina" ] ]
#32 Mr. Spell. espe r = MOOList [ "cial", "", [ "especially", "especial" ] ]
#32 Mr. Spell. Terra r = MOOList [ "", "", [ "terrapin", "terramycin", "terrain", "terrace", "Terra" ] ]
#32 Mr. Spell. premie r = MOOList [ "r", "", [ "premiere", "premier" ] ]
#32 Mr. Spell. espo r = MOOList [ "", "u", [ "Esposito" ] ]
#32 Mr. Spell. calcula r = MOOList [ "", "", [ "calculate", "calculable" ] ]
#32 Mr. Spell. there' r = MOOList [ "", "", [ "there'll", "there'd" ] ]
#32 Mr. Spell. domina r = MOOList [ "", "", [ "dominate", "dominant" ] ]
#32 Mr. Spell. Peri r = MOOList [ "", "clops", [ "periwinkle", "peritectic", "perimeter", "perihelion", "peridotite" ] ]
#32 Mr. Spell. chalk r = MOOList [ "", "", [ "chalky", "chalkline", "chalk" ] ]
#32 Mr. Spell. Abyss r = MOOList [ "", "", [ "Abyssinia", "abyss" ] ]
#32 Mr. Spell. Perk r = MOOList [ "", "", [ "perky", "Perkins", "perk" ] ]
#32 Mr. Spell. democrat r = MOOList [ "", "", [ "democratic", "democrat" ] ]
#32 Mr. Spell. chalc r = MOOList [ "", "", [ "chalcocite", "chalcedony" ] ]
#32 Mr. Spell. wan r = MOOList [ "", "tdg", [ "wane", "wan" ] ]
#32 Mr. Spell. wap r = MOOList [ "", "", [ "Wappinger", "wapiti", "wapato" ] ]
#32 Mr. Spell. war r = MOOList [ "", "demprt", [ "wary", "Warwick", "Warsaw", "warn", "warlike", "Waring", "warhead", "warfare", "warble", "war" ] ]
#32 Mr. Spell. was r = MOOList [ "", "hpt", [ "Wasserman", "wasn't", "was" ] ]
#32 Mr. Spell. Johans r = MOOList [ "", "", [ "Johanson", "Johansen" ] ]
#32 Mr. Spell. LIFe r = MOOList [ "", "bs", [ "lifetime", "lifelong", "lifeguard", "life" ] ]
#32 Mr. Spell. wav r = MOOList [ "", "e", [ "wavy" ] ]
#32 Mr. Spell. cognit r = MOOList [ "i", "", [ "cognitive", "cognition" ] ]
#32 Mr. Spell. wax r = MOOList [ "", "", [ "waxy", "waxwork", "waxen", "wax" ] ]
#32 Mr. Spell. way r = MOOList [ "", "ls", [ "wayward", "Wayne", "waybill", "way" ] ]
#32 Mr. Spell. fak r = MOOList [ "", "", [ "fakir", "fake" ] ]
#32 Mr. Spell. fal r = MOOList [ "", "cls", [ "falter", "Falmouth" ] ]
#32 Mr. Spell. write r = MOOList [ "", "", [ "writeup", "write" ] ]
#32 Mr. Spell. fam r = MOOList [ "", "i", [ "famous", "fame" ] ]
#32 Mr. Spell. fan r = MOOList [ "", "cfgt", [ "fanout", "Fanny", "fanatic", "fan" ] ]
#32 Mr. Spell. far r = MOOList [ "", "acemt", [ "farsighted", "Farrell", "faro", "Farnsworth", "Farley", "Farkas", "farina", "Fargo", "farfetched", "Farber", "far" ] ]
#32 Mr. Spell. cogniz r = MOOList [ "a", "", [ "cognizant", "cognizable" ] ]
#32 Mr. Spell. fas r = MOOList [ "", "ct", [ "fashion" ] ]
#32 Mr. Spell. we' r = MOOList [ "", "", [ "we've", "we'll", "we'd", "we're" ] ]
#32 Mr. Spell. fat r = MOOList [ "", "ehit", [ "fatuous", "fatal", "fat" ] ]
#32 Mr. Spell. South r = MOOList [ "", "ew", [ "southpaw", "southland", "southbound", "Southampton", "south" ] ]
#32 Mr. Spell. felicit r = MOOList [ "", "", [ "felicity", "felicitous" ] ]
#32 Mr. Spell. anoma r = MOOList [ "l", "", [ "anomaly", "anomalous" ] ]
#32 Mr. Spell. skul r = MOOList [ "", "l", [ "skulk" ] ]
#32 Mr. Spell. Lilli r = MOOList [ "", "", [ "Lilliputian", "Lillian" ] ]
#32 Mr. Spell. fac r = MOOList [ "", "eit", [ "faculty", "facsimile", "facade" ] ]
#32 Mr. Spell. fad r = MOOList [ "", "e", [ "fad" ] ]
#32 Mr. Spell. Halve r = MOOList [ "", "", [ "Halverson", "halve" ] ]
#32 Mr. Spell. fai r = MOOList [ "", "lnrt", [ ] ]
#32 Mr. Spell. poiso r = MOOList [ "n", "", [ "poisonous", "poison" ] ]
#32 Mr. Spell. massa r = MOOList [ "", "c", [ "massage" ] ]
#32 Mr. Spell. Blackm r = MOOList [ "a", "", [ "Blackman", "blackmail" ] ]
#32 Mr. Spell. chang r = MOOList [ "", "e", [ "changing", "Chang" ] ]
#32 Mr. Spell. chand r = MOOList [ "", "", [ "chandler", "chandelier" ] ]
#32 Mr. Spell. found r = MOOList [ "", "", [ "foundry", "foundling", "foundation", "found" ] ]
#32 Mr. Spell. chanc r = MOOList [ "", "e", [ "chancy" ] ]
#32 Mr. Spell. Peps r = MOOList [ "i", "", [ "PepsiCo", "Pepsi" ] ]
#32 Mr. Spell. detai r = MOOList [ "", "", [ "detain", "detail" ] ]
#32 Mr. Spell. opin r = MOOList [ "ion", "", [ "opinionate", "opinion" ] ]
#32 Mr. Spell. feminis r = MOOList [ "", "", [ "feminist", "feminism" ] ]
#32 Mr. Spell. isoch r = MOOList [ "ron", "", [ "isochronous", "isochronal" ] ]
#32 Mr. Spell. Blacks r = MOOList [ "", "", [ "Blackstone", "blacksmith" ] ]
#32 Mr. Spell. chron r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. chrom r = MOOList [ "", "ai", [ "chromosphere", "chrome" ] ]
#32 Mr. Spell. massi r = MOOList [ "", "", [ "massive", "massif" ] ]
#32 Mr. Spell. extrus r = MOOList [ "i", "", [ "extrusive", "extrusion" ] ]
#32 Mr. Spell. fount r = MOOList [ "", "a", [ "fount" ] ]
#32 Mr. Spell. chamo r = MOOList [ "", "", [ "chamomile", "chamois" ] ]
#32 Mr. Spell. champ r = MOOList [ "", "a", [ "Champlain", "champion", "champ" ] ]
#32 Mr. Spell. wea r = MOOList [ "", "klprt", [ "weave", "weasel", "wean" ] ]
#32 Mr. Spell. wed r = MOOList [ "", "", [ "wedlock", "wedge", "wed", "wednesday" ] ]
#32 Mr. Spell. fenc r = MOOList [ "e", "", [ "fencepost", "fence" ] ]
#32 Mr. Spell. wee r = MOOList [ "", "kd", [ "weep", "wee" ] ]
#32 Mr. Spell. sloth r = MOOList [ "", "", [ "slothful", "sloth" ] ]
#32 Mr. Spell. earni r = MOOList [ "ng", "", [ "earnings", "earning" ] ]
#32 Mr. Spell. pheny r = MOOList [ "l", "", [ "phenylalanine", "phenyl" ] ]
#32 Mr. Spell. earthm r = MOOList [ "", "o", [ "earthmen" ] ]
#32 Mr. Spell. chamb r = MOOList [ "er", "", [ "chambermaid", "chamberlain", "chamber" ] ]
#32 Mr. Spell. brush r = MOOList [ "", "", [ "brushy", "brushwork", "brushfire", "brush" ] ]
#32 Mr. Spell. gentlem r = MOOList [ "", "", [ "gentlemen", "gentleman" ] ]
#32 Mr. Spell. pheno r = MOOList [ "", "lm", [ "phenotype" ] ]
#32 Mr. Spell. maste r = MOOList [ "r", "", [ "masters", "mastery", "masterpiece", "mastermind", "masterful", "master" ] ]
#32 Mr. Spell. masti r = MOOList [ "", "", [ "mastiff", "mastic" ] ]
#32 Mr. Spell. gyro r = MOOList [ "", "", [ "gyroscope", "gyrocompass", "gyro" ] ]
#32 Mr. Spell. thermi r = MOOList [ "", "", [ "thermistor", "thermionic" ] ]
#32 Mr. Spell. Goldst r = MOOList [ "", "", [ "Goldstine", "Goldstein" ] ]
#32 Mr. Spell. inve r = MOOList [ "", "inrs", [ "inveterate", "invective" ] ]
#32 Mr. Spell. Dal r = MOOList [ "", "el", [ "Dalzell", "Daly", "Dalton", "Dalhousie" ] ]
#32 Mr. Spell. Dak r = MOOList [ "", "", [ "Dakota", "Dakar" ] ]
#32 Mr. Spell. Dai r = MOOList [ "", "rs", [ "dainty", "Daimler", "Dailey" ] ]
#32 Mr. Spell. inva r = MOOList [ "", "lrs", [ "invade" ] ]
#32 Mr. Spell. Dad r = MOOList [ "", "", [ "Dade", "daddy", "Dada", "dad" ] ]
#32 Mr. Spell. femi r = MOOList [ "ni", "s", [ "feminine" ] ]
#32 Mr. Spell. invo r = MOOList [ "", "l", [ "invoke", "invoice", "invocate" ] ]
#32 Mr. Spell. Dab r = MOOList [ "", "", [ "dabble", "dab" ] ]
#32 Mr. Spell. rhom r = MOOList [ "b", "i", [ "rhombus" ] ]
#32 Mr. Spell. invi r = MOOList [ "", "ot", [ "invisible", "invincible", "invigorate", "invidious", "inviable" ] ]
#32 Mr. Spell. chape r = MOOList [ "", "r", [ "chapel" ] ]
#32 Mr. Spell. objec r = MOOList [ "t", "", [ "object's", "objects", "objector", "objectify", "object" ] ]
#32 Mr. Spell. felo r = MOOList [ "n", "", [ "felony", "felonious", "felon" ] ]
#32 Mr. Spell. pneumo r = MOOList [ "", "", [ "pneumonia", "pneumococcus" ] ]
#32 Mr. Spell. wer r = MOOList [ "", "et", [ "Werner" ] ]
#32 Mr. Spell. ghou r = MOOList [ "l", "", [ "ghoulish", "ghoul" ] ]
#32 Mr. Spell. wes r = MOOList [ "", "tl", [ ] ]
#32 Mr. Spell. Daw r = MOOList [ "", "", [ "Dawson", "dawn" ] ]
#32 Mr. Spell. wet r = MOOList [ "", "", [ "wetland", "wet" ] ]
#32 Mr. Spell. Dau r = MOOList [ "", "gp", [ "daunt", "daub" ] ]
#32 Mr. Spell. Dan r = MOOList [ "", "dgiu", [ "Danzig", "Dante", "Danny", "dank", "Dane", "dance", "Danbury", "Dana", "Dan" ] ]
#32 Mr. Spell. splint r = MOOList [ "", "", [ "splintery", "splint" ] ]
#32 Mr. Spell. fes r = MOOList [ "", "t", [ "fescue" ] ]
#32 Mr. Spell. fet r = MOOList [ "", "it", [ "fetus", "fete", "fetch", "fetal" ] ]
#32 Mr. Spell. Canton r = MOOList [ "", "", [ "Cantonese", "canton" ] ]
#32 Mr. Spell. gyps r = MOOList [ "", "", [ "gypsy", "gypsum", "gypsite" ] ]
#32 Mr. Spell. forfei r = MOOList [ "t", "", [ "forfeiture", "forfeit" ] ]
#32 Mr. Spell. feu r = MOOList [ "d", "a", [ "feud" ] ]
#32 Mr. Spell. fev r = MOOList [ "er", "", [ "feverish", "fever" ] ]
#32 Mr. Spell. fell r = MOOList [ "", "", [ "fellow", "fell" ] ]
#32 Mr. Spell. consci r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. intu r = MOOList [ "it", "i", [ "intuitable" ] ]
#32 Mr. Spell. fea r = MOOList [ "", "rst", [ "fealty" ] ]
#32 Mr. Spell. feb r = MOOList [ "", "r", [ "Feb" ] ]
#32 Mr. Spell. into r = MOOList [ "", "lnx", [ "into" ] ]
#32 Mr. Spell. fed r = MOOList [ "", "e", [ "Fedora", "fed" ] ]
#32 Mr. Spell. Capito r = MOOList [ "l", "", [ "Capitoline", "capitol" ] ]
#32 Mr. Spell. fee r = MOOList [ "", "dl", [ "feet", "Feeney", "feeble", "fee" ] ]
#32 Mr. Spell. intr r = MOOList [ "", "aiou", [ "intrepid" ] ]
#32 Mr. Spell. fei r = MOOList [ "", "", [ "feint", "feign" ] ]
#32 Mr. Spell. chant r = MOOList [ "", "", [ "chantry", "Chantilly", "chantey", "chant" ] ]
#32 Mr. Spell. fel r = MOOList [ "", "dilo", [ "felt", "felsite" ] ]
#32 Mr. Spell. fem r = MOOList [ "", "i", [ "femur", "female" ] ]
#32 Mr. Spell. fen r = MOOList [ "", "c", [ "fenugreek", "Fenton", "fennel", "fend" ] ]
#32 Mr. Spell. wha r = MOOList [ "", "lrt", [ "wham", "whack" ] ]
#32 Mr. Spell. fours r = MOOList [ "", "", [ "foursquare", "foursome" ] ]
#32 Mr. Spell. inte r = MOOList [ "", "glmnrs", [ ] ]
#32 Mr. Spell. fourt r = MOOList [ "", "e", [ "fourth" ] ]
#32 Mr. Spell. whe r = MOOList [ "", "aelnrt", [ ] ]
#32 Mr. Spell. teethe r = MOOList [ "", "", [ "teethed", "teethe" ] ]
#32 Mr. Spell. inta r = MOOList [ "", "", [ "intangible", "intake", "intact" ] ]
#32 Mr. Spell. missio r = MOOList [ "n", "", [ "missionary", "mission" ] ]
#32 Mr. Spell. conscr r = MOOList [ "ipt", "", [ "conscription", "conscript" ] ]
#32 Mr. Spell. whi r = MOOList [ "", "cmnprstzl", [ "whig", "whiff" ] ]
#32 Mr. Spell. retrogre r = MOOList [ "ss", "", [ "retrogressive", "retrogress" ] ]
#32 Mr. Spell. chari r = MOOList [ "", "st", [ "chariot" ] ]
#32 Mr. Spell. who r = MOOList [ "", "'lmos", [ "whore", "whop", "whoever", "whoa", "who" ] ]
#32 Mr. Spell. inti r = MOOList [ "m", "a", [ "intimidate" ] ]
#32 Mr. Spell. charg r = MOOList [ "e", "", [ "charges", "chargeable", "charge" ] ]
#32 Mr. Spell. autho r = MOOList [ "r", "i", [ "author" ] ]
#32 Mr. Spell. inst r = MOOList [ "", "aeir", [ ] ]
#32 Mr. Spell. bathr r = MOOList [ "o", "", [ "bathroom", "bathrobe" ] ]
#32 Mr. Spell. insu r = MOOList [ "", "bflpr", [ ] ]
#32 Mr. Spell. inso r = MOOList [ "", "lm", [ "insouciant", "insofar" ] ]
#32 Mr. Spell. chara r = MOOList [ "cter", "", [ "characteristic", "character" ] ]
#32 Mr. Spell. Sales r = MOOList [ "", "m", [ "salesperson", "saleslady", "Salesian", "salesgirl", "sales" ] ]
#32 Mr. Spell. insp r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. backwa r = MOOList [ "", "r", [ "backwater" ] ]
#32 Mr. Spell. deten r = MOOList [ "t", "", [ "detention", "detente", "detent" ] ]
#32 Mr. Spell. oper r = MOOList [ "", "a", [ "operon", "operetta" ] ]
#32 Mr. Spell. detec r = MOOList [ "t", "", [ "detector", "detect" ] ]
#32 Mr. Spell. compan r = MOOList [ "", "i", [ "company" ] ]
#32 Mr. Spell. masoc r = MOOList [ "his", "", [ "masochist", "masochism" ] ]
#32 Mr. Spell. open r = MOOList [ "", "", [ "opens", "opening", "opened", "open" ] ]
#32 Mr. Spell. wic r = MOOList [ "", "k", [ "Wichita" ] ]
#32 Mr. Spell. insc r = MOOList [ "r", "i", [ "inscrutable" ] ]
#32 Mr. Spell. anort r = MOOList [ "h", "i", [ "anorthosite" ] ]
#32 Mr. Spell. wid r = MOOList [ "", "egot", [ ] ]
#32 Mr. Spell. Alexa r = MOOList [ "nd", "r", [ "Alexander" ] ]
#32 Mr. Spell. wie r = MOOList [ "", "", [ "Wier", "wiener", "wield" ] ]
#32 Mr. Spell. inse r = MOOList [ "", "cnr", [ "inset", "inseparable", "inseminate" ] ]
#32 Mr. Spell. EEl r = MOOList [ "", "", [ "eelgrass", "eel" ] ]
#32 Mr. Spell. compat r = MOOList [ "", "", [ "compatriot", "compatible" ] ]
#32 Mr. Spell. wig r = MOOList [ "", "g", [ "wigwam", "wigmake", "Wightman", "wig" ] ]
#32 Mr. Spell. longit r = MOOList [ "ud", "", [ "longitudinal", "longitude" ] ]
#32 Mr. Spell. germi r = MOOList [ "", "cn", [ ] ]
#32 Mr. Spell. evolu r = MOOList [ "tion", "", [ "evolutionary", "evolution" ] ]
#32 Mr. Spell. compar r = MOOList [ "", "a", [ "compartment", "comparison", "compare" ] ]
#32 Mr. Spell. insa r = MOOList [ "", "", [ "insatiable", "insane" ] ]
#32 Mr. Spell. compas r = MOOList [ "s", "i", [ "compass" ] ]
#32 Mr. Spell. consec r = MOOList [ "", "", [ "consecutive", "consecrate" ] ]
#32 Mr. Spell. immob r = MOOList [ "il", "", [ "immobility", "immobile" ] ]
#32 Mr. Spell. detes r = MOOList [ "t", "", [ "detestation", "detest" ] ]
#32 Mr. Spell. immod r = MOOList [ "e", "s", [ "immoderate" ] ]
#32 Mr. Spell. deter r = MOOList [ "", "mr", [ "deteriorate", "detergent", "deter" ] ]
#32 Mr. Spell. win r = MOOList [ "", "cdegknst", [ "winy", "wino", "Winifred", "Winfield", "win" ] ]
#32 Mr. Spell. insi r = MOOList [ "", "dgns", [ "insipid" ] ]
#32 Mr. Spell. authe r = MOOList [ "ntic", "", [ "authenticate", "authentic" ] ]
#32 Mr. Spell. conser r = MOOList [ "v", "a", [ "conserve" ] ]
#32 Mr. Spell. conseq r = MOOList [ "uent", "", [ "consequential", "consequent" ] ]
#32 Mr. Spell. diagnost r = MOOList [ "ic", "", [ "diagnostician", "diagnostic" ] ]
#32 Mr. Spell. consen r = MOOList [ "", "", [ "consent", "consensus" ] ]
#32 Mr. Spell. germa r = MOOList [ "n", "i", [ "Germany", "Germantown", "germane", "German" ] ]
#32 Mr. Spell. gymn r = MOOList [ "", "a", [ "gymnosperm" ] ]
#32 Mr. Spell. Wilkin r = MOOList [ "s", "", [ "Wilkinson", "Wilkins" ] ]
#32 Mr. Spell. chatt r = MOOList [ "", "", [ "chatty", "chattel", "Chattanooga" ] ]
#32 Mr. Spell. Del r = MOOList [ "", "aeilptu", [ "delve", "delouse", "Delmarva", "Delhi", "Delft", "Del" ] ]
#32 Mr. Spell. infere r = MOOList [ "n", "", [ "inferential", "inference" ] ]
#32 Mr. Spell. fia r = MOOList [ "", "n", [ "fiat", "fiasco" ] ]
#32 Mr. Spell. decad r = MOOList [ "e", "", [ "decadent", "decade" ] ]
#32 Mr. Spell. fib r = MOOList [ "", "er", [ "Fibonacci", "fib" ] ]
#32 Mr. Spell. wir r = MOOList [ "", "e", [ "wiry" ] ]
#32 Mr. Spell. wis r = MOOList [ "", "ehp", [ "wistful", "wisdom", "Wisconsin" ] ]
#32 Mr. Spell. wit r = MOOList [ "", "hct", [ "witness", "wit" ] ]
#32 Mr. Spell. chate r = MOOList [ "au", "", [ "chateaux", "chateau" ] ]
#32 Mr. Spell. earthe r = MOOList [ "n", "", [ "earthenware", "earthen" ] ]
#32 Mr. Spell. immor r = MOOList [ "", "", [ "immortal", "immoral" ] ]
#32 Mr. Spell. coffe r = MOOList [ "", "e", [ "Coffey", "coffer" ] ]
#32 Mr. Spell. North r = MOOList [ "", "erw", [ "Northumberland", "northland", "northbound", "Northampton", "north" ] ]
#32 Mr. Spell. contrace r = MOOList [ "pti", "", [ "contraceptive", "contraception" ] ]
#32 Mr. Spell. fiv r = MOOList [ "e", "", [ "fivefold", "five" ] ]
#32 Mr. Spell. chast r = MOOList [ "", "i", [ "chaste" ] ]
#32 Mr. Spell. fix r = MOOList [ "", "", [ "fixed", "fixture", "fixate", "fix" ] ]
#32 Mr. Spell. fiz r = MOOList [ "", "", [ "fizzle", "Fizeau" ] ]
#32 Mr. Spell. fic r = MOOList [ "", "t", [ "fickle", "fiche" ] ]
#32 Mr. Spell. contract r = MOOList [ "", "", [ "contracts", "contractual", "contractor", "contract" ] ]
#32 Mr. Spell. fid r = MOOList [ "", "de", [ "fiducial", "fidget" ] ]
#32 Mr. Spell. Prome r = MOOList [ "", "t", [ "promenade" ] ]
#32 Mr. Spell. fie r = MOOList [ "", "flnr", [ "fiesta" ] ]
#32 Mr. Spell. fig r = MOOList [ "", "u", [ "fight", "figaro", "fig" ] ]
#32 Mr. Spell. zealo r = MOOList [ "", "", [ "zealous", "zealot" ] ]
#32 Mr. Spell. yours r = MOOList [ "", "e", [ "yours" ] ]
#32 Mr. Spell. fil r = MOOList [ "", "aeilmt", [ "filch", "filbert" ] ]
#32 Mr. Spell. fin r = MOOList [ "", "aegilnd", [ "fink", "finch", "fin" ] ]
#32 Mr. Spell. names r = MOOList [ "", "", [ "names", "namesake" ] ]
#32 Mr. Spell. raven r = MOOList [ "", "", [ "ravenous", "raven" ] ]
#32 Mr. Spell. fir r = MOOList [ "", "ems", [ "fir" ] ]
#32 Mr. Spell. stead r = MOOList [ "", "", [ "steady", "steadfast", "stead" ] ]
#32 Mr. Spell. deceit r = MOOList [ "", "", [ "deceitful", "deceit" ] ]
#32 Mr. Spell. deaco r = MOOList [ "n", "", [ "deaconess", "deacon" ] ]
#32 Mr. Spell. shallo r = MOOList [ "", "", [ "shallow", "shallot" ] ]
#32 Mr. Spell. steal r = MOOList [ "", "t", [ "steal" ] ]
#32 Mr. Spell. embro r = MOOList [ "i", "d", [ "embroil" ] ]
#32 Mr. Spell. Switc r = MOOList [ "h", "b", [ "switches", "switchman", "switchgear", "switch" ] ]
#32 Mr. Spell. stear r = MOOList [ "", "", [ "Stearns", "stearic", "stearate" ] ]
#32 Mr. Spell. salvag r = MOOList [ "e", "", [ "salvageable", "salvage" ] ]
#32 Mr. Spell. embra r = MOOList [ "ce", "", [ "embraceable", "embrace" ] ]
#32 Mr. Spell. steam r = MOOList [ "", "", [ "steaming", "steamy", "steamboat", "steam" ] ]
#32 Mr. Spell. hiera r = MOOList [ "", "r", [ "hieratic" ] ]
#32 Mr. Spell. windo r = MOOList [ "w", "", [ "windowsill", "windowpane", "window" ] ]
#32 Mr. Spell. trist r = MOOList [ "a", "", [ "tristate", "Tristan" ] ]
#32 Mr. Spell. transcen r = MOOList [ "d", "e", [ "transcend" ] ]
#32 Mr. Spell. topo r = MOOList [ "", "l", [ "topography", "topocentric" ] ]
#32 Mr. Spell. deadl r = MOOList [ "", "", [ "deadlock", "deadline" ] ]
#32 Mr. Spell. Sore r = MOOList [ "", "n", [ "sore" ] ]
#32 Mr. Spell. Minera r = MOOList [ "l", "", [ "mineralogy", "mineral" ] ]
#32 Mr. Spell. Trud r = MOOList [ "", "", [ "Trudy", "trudge" ] ]
#32 Mr. Spell. fla r = MOOList [ "", "gikmnstux", [ "flaw", "flare", "flap", "flack", "flabbergast" ] ]
#32 Mr. Spell. Hort r = MOOList [ "", "", [ "Horton", "horticulture" ] ]
#32 Mr. Spell. Glor r = MOOList [ "", "i", [ "glory" ] ]
#32 Mr. Spell. topi r = MOOList [ "c", "", [ "topical", "topic" ] ]
#32 Mr. Spell. Task r = MOOList [ "", "", [ "taskmaster", "task" ] ]
#32 Mr. Spell. fle r = MOOList [ "", "ademstx", [ "flew", "fleck" ] ]
#32 Mr. Spell. rattl r = MOOList [ "e", "", [ "rattlesnake", "rattle" ] ]
#32 Mr. Spell. academic r = MOOList [ "", "", [ "academician", "academic" ] ]
#32 Mr. Spell. toot r = MOOList [ "", "h", [ "tootle", "toot" ] ]
#32 Mr. Spell. descrip r = MOOList [ "t", "i", [ "descriptor" ] ]
#32 Mr. Spell. Trum r = MOOList [ "", "p", [ "Trumbull", "Truman" ] ]
#32 Mr. Spell. embry r = MOOList [ "o", "", [ "embryonic", "embryology", "embryo" ] ]
#32 Mr. Spell. winem r = MOOList [ "a", "", [ "winemaster", "winemake" ] ]
#32 Mr. Spell. tool r = MOOList [ "", "", [ "toolsmith", "toolmake", "toolkit", "tool" ] ]
#32 Mr. Spell. fly r = MOOList [ "", "", [ "flyway", "Flynn", "flyer", "flycatcher", "fly" ] ]
#32 Mr. Spell. implan r = MOOList [ "t", "", [ "implantation", "implant" ] ]
#32 Mr. Spell. Din r = MOOList [ "", "gn", [ "dint", "dinosaur", "dine", "Dinah", "din" ] ]
#32 Mr. Spell. Tarr r = MOOList [ "y", "", [ "Tarrytown", "tarry" ] ]
#32 Mr. Spell. applic r = MOOList [ "a", "t", [ "applicant", "applicable" ] ]
#32 Mr. Spell. fracti r = MOOList [ "o", "n", [ "fractious" ] ]
#32 Mr. Spell. describ r = MOOList [ "", "e", [ "describing" ] ]
#32 Mr. Spell. trivi r = MOOList [ "", "a", [ "trivium" ] ]
#32 Mr. Spell. habitat r = MOOList [ "", "", [ "habitation", "habitat" ] ]
#32 Mr. Spell. softw r = MOOList [ "", "", [ "softwood", "software" ] ]
#32 Mr. Spell. Album r = MOOList [ "", "", [ "albumin", "album" ] ]
#32 Mr. Spell. Die r = MOOList [ "", "lt", [ "diesel", "diem", "diehard", "Diego", "Diebold", "die" ] ]
#32 Mr. Spell. trium r = MOOList [ "ph", "a", [ "triumph" ] ]
#32 Mr. Spell. Ukr r = MOOList [ "ain", "", [ "Ukrainian", "Ukraine" ] ]
#32 Mr. Spell. fli r = MOOList [ "", "nprc", [ "flit", "flimsy", "flight" ] ]
#32 Mr. Spell. eccl r = MOOList [ "es", "", [ "ecclesiastic", "Eccles" ] ]
#32 Mr. Spell. tons r = MOOList [ "il", "", [ "tonsillitis", "tonsil" ] ]
#32 Mr. Spell. flo r = MOOList [ "", "cgoprtuw", [ "Floyd", "floe", "float", "Flo" ] ]
#32 Mr. Spell. Apoca r = MOOList [ "lyp", "", [ "apocalyptic", "apocalypse" ] ]
#32 Mr. Spell. vicin r = MOOList [ "", "", [ "vicinity", "vicinal" ] ]
#32 Mr. Spell. flu r = MOOList [ "", "efost", [ "flux", "flurry", "flung", "fluke", "fluid", "fluctuate", "flub", "flu" ] ]
#32 Mr. Spell. calam r = MOOList [ "", "i", [ "calamus" ] ]
#32 Mr. Spell. wok r = MOOList [ "", "", [ "woke", "wok" ] ]
#32 Mr. Spell. windb r = MOOList [ "", "", [ "windbreak", "windbag" ] ]
#32 Mr. Spell. wol r = MOOList [ "", "fv", [ "wold", "Wolcott" ] ]
#32 Mr. Spell. wom r = MOOList [ "", "ab", [ "women" ] ]
#32 Mr. Spell. won r = MOOList [ "", "d", [ "wont", "won't", "Wong", "won" ] ]
#32 Mr. Spell. woo r = MOOList [ "", "dl", [ "Wooster", "woo" ] ]
#32 Mr. Spell. Hopk r = MOOList [ "ins", "", [ "Hopkinsian", "Hopkins" ] ]
#32 Mr. Spell. errat r = MOOList [ "", "", [ "erratum", "erratic", "errata" ] ]
#32 Mr. Spell. wor r = MOOList [ "", "dklmrst", [ "worn", "wore", "Worcester" ] ]
#32 Mr. Spell. indigna r = MOOList [ "", "", [ "indignation", "indignant" ] ]
#32 Mr. Spell. wou r = MOOList [ "", "l", [ "wound" ] ]
#32 Mr. Spell. tong r = MOOList [ "", "", [ "tongue", "tong" ] ]
#32 Mr. Spell. erran r = MOOList [ "", "t", [ "errand" ] ]
#32 Mr. Spell. wov r = MOOList [ "e", "", [ "woven", "wove" ] ]
#32 Mr. Spell. toni r = MOOList [ "", "", [ "tonight", "tonic", "Toni" ] ]
#32 Mr. Spell. membe r = MOOList [ "r", "", [ "members", "member" ] ]
#32 Mr. Spell. celebr r = MOOList [ "", "a", [ "celebrity" ] ]
#32 Mr. Spell. iono r = MOOList [ "spher", "", [ "ionospheric", "ionosphere" ] ]
#32 Mr. Spell. repai r = MOOList [ "rm", "", [ "repairmen", "repairman" ] ]
#32 Mr. Spell. algor r = MOOList [ "ithm", "", [ "algorithmic", "algorithm" ] ]
#32 Mr. Spell. woe r = MOOList [ "", "", [ "woeful", "woebegone", "woe" ] ]
#32 Mr. Spell. reache r = MOOList [ "", "", [ "reaches", "reached" ] ]
#32 Mr. Spell. Soph r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. repar r = MOOList [ "", "", [ "repartee", "reparation" ] ]
#32 Mr. Spell. righ r = MOOList [ "t", "", [ "rightward", "rightmost", "rightful", "righteous", "right" ] ]
#32 Mr. Spell. headli r = MOOList [ "", "n", [ "headlight" ] ]
#32 Mr. Spell. tomm r = MOOList [ "", "", [ "tommy", "Tommie" ] ]
#32 Mr. Spell. tomo r = MOOList [ "", "g", [ "tomorrow" ] ]
#32 Mr. Spell. rigo r = MOOList [ "r", "o", [ "rigor" ] ]
#32 Mr. Spell. foa r = MOOList [ "", "m", [ "foal" ] ]
#32 Mr. Spell. firew r = MOOList [ "", "o", [ "firewall" ] ]
#32 Mr. Spell. tomb r = MOOList [ "", "", [ "tombstone", "tomb" ] ]
#32 Mr. Spell. steep r = MOOList [ "", "l", [ "steepen", "steep" ] ]
#32 Mr. Spell. foc r = MOOList [ "", "u", [ "foci", "focal" ] ]
#32 Mr. Spell. Hoos r = MOOList [ "", "", [ "Hoosier", "hoosegow" ] ]
#32 Mr. Spell. deris r = MOOList [ "i", "", [ "derisive", "derision" ] ]
#32 Mr. Spell. gigg r = MOOList [ "", "", [ "giggle", "gigging" ] ]
#32 Mr. Spell. deriv r = MOOList [ "", "", [ "derive", "derivate" ] ]
#32 Mr. Spell. toma r = MOOList [ "to", "", [ "tomatoes", "tomato" ] ]
#32 Mr. Spell. slip r = MOOList [ "", "p", [ "slip" ] ]
#32 Mr. Spell. keyne r = MOOList [ "s", "", [ "Keynesian", "Keynes" ] ]
#32 Mr. Spell. extric r = MOOList [ "a", "", [ "extricate", "extricable" ] ]
#32 Mr. Spell. calcu r = MOOList [ "", "l", [ "Calcutta" ] ]
#32 Mr. Spell. slit r = MOOList [ "", "", [ "slither", "slit" ] ]
#32 Mr. Spell. counc r = MOOList [ "il", "mw", [ "council" ] ]
#32 Mr. Spell. sliv r = MOOList [ "er", "", [ "slivery", "sliver" ] ]
#32 Mr. Spell. toll r = MOOList [ "", "", [ "tollhouse", "tollgate", "toll" ] ]
#32 Mr. Spell. infinitu r = MOOList [ "", "", [ "infinitum", "infinitude" ] ]
#32 Mr. Spell. slim r = MOOList [ "", "", [ "slimy", "slime", "slim" ] ]
#32 Mr. Spell. rifl r = MOOList [ "e", "m", [ "rifle" ] ]
#32 Mr. Spell. fireb r = MOOList [ "", "", [ "firebug", "firebreak", "fireboat" ] ]
#32 Mr. Spell. slin r = MOOList [ "g", "", [ "slingshot", "sling" ] ]
#32 Mr. Spell. jani r = MOOList [ "", "t", [ "janissary", "Janice" ] ]
#32 Mr. Spell. slic r = MOOList [ "", "", [ "slick", "slice" ] ]
#32 Mr. Spell. slid r = MOOList [ "", "", [ "slide", "slid" ] ]
#32 Mr. Spell. couns r = MOOList [ "el", "", [ "counselor", "counsel" ] ]
#32 Mr. Spell. tole r = MOOList [ "", "r", [ "Toledo" ] ]
#32 Mr. Spell. count r = MOOList [ "", "ery", [ "counting", "countdown", "count" ] ]
#32 Mr. Spell. giga r = MOOList [ "", "", [ "gigawatt", "gigavolt", "gigantic", "gigahertz", "gigacycle" ] ]
#32 Mr. Spell. calci r = MOOList [ "", "", [ "calcium", "calcite", "calcify" ] ]
#32 Mr. Spell. slig r = MOOList [ "ht", "", [ "slightly", "slight" ] ]
#32 Mr. Spell. foi r = MOOList [ "", "", [ "foist", "foil", "foible" ] ]
#32 Mr. Spell. vitri r = MOOList [ "", "o", [ "vitrify" ] ]
#32 Mr. Spell. fol r = MOOList [ "", "dikl", [ "Foley" ] ]
#32 Mr. Spell. firep r = MOOList [ "", "", [ "fireproof", "firepower", "fireplace" ] ]
#32 Mr. Spell. fon r = MOOList [ "", "dt", [ ] ]
#32 Mr. Spell. recipr r = MOOList [ "oc", "a", [ "reciprocity" ] ]
#32 Mr. Spell. foo r = MOOList [ "", "dlt", [ ] ]
#32 Mr. Spell. Sono r = MOOList [ "", "r", [ "Sonoma", "sonogram" ] ]
#32 Mr. Spell. fop r = MOOList [ "", "", [ "foppish", "fop" ] ]
#32 Mr. Spell. commenda r = MOOList [ "t", "", [ "commendatory", "commendation" ] ]
#32 Mr. Spell. oppressi r = MOOList [ "", "", [ "oppressive", "oppression" ] ]
#32 Mr. Spell. for r = MOOList [ "", "abcdefgkmst", [ "forward", "forum", "forlorn", "for" ] ]
#32 Mr. Spell. fos r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. fou r = MOOList [ "", "lnr", [ "fought" ] ]
#32 Mr. Spell. firem r = MOOList [ "", "", [ "firemen", "fireman" ] ]
#32 Mr. Spell. fox r = MOOList [ "", "h", [ "foxy", "foxtail", "foxglove", "fox" ] ]
#32 Mr. Spell. Cheste r = MOOList [ "r", "", [ "Chesterton", "Chester" ] ]
#32 Mr. Spell. invento r = MOOList [ "r", "", [ "inventory", "inventor" ] ]
#32 Mr. Spell. wro r = MOOList [ "", "n", [ "wrought", "wrote" ] ]
#32 Mr. Spell. Tunis r = MOOList [ "", "", [ "Tunisia", "Tunis" ] ]
#32 Mr. Spell. repea r = MOOList [ "", "t", [ "repeal" ] ]
#32 Mr. Spell. Tana r = MOOList [ "", "", [ "Tananarive", "Tanaka", "tanager" ] ]
#32 Mr. Spell. barna r = MOOList [ "", "", [ "Barnard", "barnacle", "Barnabas" ] ]
#32 Mr. Spell. infinite r = MOOList [ "", "", [ "infinitesimal", "infinite" ] ]
#32 Mr. Spell. wra r = MOOList [ "", "pt", [ "wrangle", "wraith", "wrack" ] ]
#32 Mr. Spell. Somm r = MOOList [ "e", "", [ "Sommerfeld", "sommelier" ] ]
#32 Mr. Spell. inventi r = MOOList [ "", "", [ "inventive", "invention" ] ]
#32 Mr. Spell. Tant r = MOOList [ "", "a", [ "tantrum" ] ]
#32 Mr. Spell. wre r = MOOList [ "", "acs", [ "wretch", "wrench" ] ]
#32 Mr. Spell. wri r = MOOList [ "", "gnst", [ ] ]
#32 Mr. Spell. ridg r = MOOList [ "", "e", [ "Ridgway" ] ]
#32 Mr. Spell. Holl r = MOOList [ "", "aeioy", [ ] ]
#32 Mr. Spell. could r = MOOList [ "", "", [ "couldn't", "could" ] ]
#32 Mr. Spell. ridi r = MOOList [ "cul", "", [ "ridiculous", "ridicule" ] ]
#32 Mr. Spell. intric r = MOOList [ "a", "", [ "intricate", "intricacy" ] ]
#32 Mr. Spell. fra r = MOOList [ "", "cgimntuz", [ "fray", "Fraser" ] ]
#32 Mr. Spell. fre r = MOOList [ "", "adensuy", [ "fret", "frequent", "freon", "freight", "freckle" ] ]
#32 Mr. Spell. Hols r = MOOList [ "t", "e", [ "Holst" ] ]
#32 Mr. Spell. fossi r = MOOList [ "l", "", [ "fossiliferous", "fossil" ] ]
#32 Mr. Spell. calen r = MOOList [ "d", "", [ "calendrical", "calendar" ] ]
#32 Mr. Spell. Iron r = MOOList [ "", "s", [ "irony", "ironwood", "ironic", "iron" ] ]
#32 Mr. Spell. Holm r = MOOList [ "", "", [ "holmium", "Holmes", "Holmdel", "Holman", "Holm" ] ]
#32 Mr. Spell. fri r = MOOList [ "", "acegltvsd", [ "frizzle", "fringe" ] ]
#32 Mr. Spell. Switz r = MOOList [ "er", "", [ "Switzerland", "Switzer" ] ]
#32 Mr. Spell. ridd r = MOOList [ "", "", [ "riddle", "ridden", "riddance" ] ]
#32 Mr. Spell. Holo r = MOOList [ "", "cg", [ ] ]
#32 Mr. Spell. Solo r = MOOList [ "", "", [ "Solon", "Solomon", "solo" ] ]
#32 Mr. Spell. repel r = MOOList [ "", "l", [ "repel" ] ]
#32 Mr. Spell. Upt r = MOOList [ "", "o", [ "upturn", "uptrend", "uptake" ] ]
#32 Mr. Spell. Dod r = MOOList [ "", "e", [ "Dodson", "dodo", "dodge", "Dodd", "DOD" ] ]
#32 Mr. Spell. repen r = MOOList [ "t", "", [ "repentant", "repent" ] ]
#32 Mr. Spell. Dob r = MOOList [ "", "b", [ "dobson", "doberman" ] ]
#32 Mr. Spell. Tamp r = MOOList [ "", "", [ "tampon", "Tampa", "tamp" ] ]
#32 Mr. Spell. wingm r = MOOList [ "", "", [ "wingmen", "wingman" ] ]
#32 Mr. Spell. rico r = MOOList [ "", "", [ "ricochet", "Rico" ] ]
#32 Mr. Spell. reper r = MOOList [ "to", "", [ "repertory", "repertoire" ] ]
#32 Mr. Spell. repet r = MOOList [ "iti", "o", [ "repetitive" ] ]
#32 Mr. Spell. nightm r = MOOList [ "ar", "", [ "nightmarish", "nightmare" ] ]
#32 Mr. Spell. Dou r = MOOList [ "", "bg", [ "douse", "dour", "douce" ] ]
#32 Mr. Spell. blank r = MOOList [ "", "", [ "blanket", "blank" ] ]
#32 Mr. Spell. Tall r = MOOList [ "", "y", [ "tallow", "Tallahassee", "tall" ] ]
#32 Mr. Spell. rick r = MOOList [ "", "e", [ "rickshaw", "rick" ] ]
#32 Mr. Spell. Dor r = MOOList [ "", "acimo", [ "Dortmund", "Dorset", "Doreen" ] ]
#32 Mr. Spell. agre r = MOOList [ "e", "", [ "agreement", "agreed", "agreeing", "agreeable", "agree" ] ]
#32 Mr. Spell. Doo r = MOOList [ "", "lmr", [ "doodle" ] ]
#32 Mr. Spell. Don r = MOOList [ "", "aeno", [ "don't", "donkey", "don" ] ]
#32 Mr. Spell. subsid r = MOOList [ "", "", [ "subsidy", "subsidiary" ] ]
#32 Mr. Spell. agri r = MOOList [ "", "c", [ "agrimony" ] ]
#32 Mr. Spell. crucif r = MOOList [ "", "i", [ "crucify" ] ]
#32 Mr. Spell. chemiso r = MOOList [ "r", "", [ "chemisorption", "chemisorb" ] ]
#32 Mr. Spell. fro r = MOOList [ "", "nstwz", [ "from", "frolic", "frog", "frock", "fro" ] ]
#32 Mr. Spell. chemist r = MOOList [ "", "", [ "chemistry", "chemist" ] ]
#32 Mr. Spell. coura r = MOOList [ "ge", "", [ "courageous", "courage" ] ]
#32 Mr. Spell. spina r = MOOList [ "", "", [ "spinal", "spinach" ] ]
#32 Mr. Spell. ribo r = MOOList [ "", "s", [ "ribonucleic", "riboflavin" ] ]
#32 Mr. Spell. organ r = MOOList [ "", "i", [ "organometallic", "organdy", "organ" ] ]
#32 Mr. Spell. subsis r = MOOList [ "t", "", [ "subsistent", "subsist" ] ]
#32 Mr. Spell. blanc r = MOOList [ "", "h", [ "blanc" ] ]
#32 Mr. Spell. nightc r = MOOList [ "", "", [ "nightclub", "nightcap" ] ]
#32 Mr. Spell. bland r = MOOList [ "", "", [ "blandish", "bland" ] ]
#32 Mr. Spell. sled r = MOOList [ "", "g", [ "sled" ] ]
#32 Mr. Spell. sanda r = MOOList [ "l", "", [ "sandalwood", "sandal" ] ]
#32 Mr. Spell. slee r = MOOList [ "", "pt", [ "sleeve", "sleek" ] ]
#32 Mr. Spell. sandb r = MOOList [ "", "", [ "Sandburg", "sandblast", "sandbag" ] ]
#32 Mr. Spell. slei r = MOOList [ "gh", "", [ "sleight", "sleigh" ] ]
#32 Mr. Spell. imagina r = MOOList [ "", "", [ "imaginate", "imaginary" ] ]
#32 Mr. Spell. court r = MOOList [ "", "e", [ "courtyard", "courtroom", "Courtney", "courtier", "courthouse", "court" ] ]
#32 Mr. Spell. Urb r = MOOList [ "an", "", [ "urbanite", "urbane", "Urbana", "urban" ] ]
#32 Mr. Spell. sanct r = MOOList [ "", "i", [ "sanctuary" ] ]
#32 Mr. Spell. gibb r = MOOList [ "", "eo", [ "gibby", "Gibbs" ] ]
#32 Mr. Spell. frontiers r = MOOList [ "m", "", [ "frontiersmen", "frontiersman" ] ]
#32 Mr. Spell. sanch r = MOOList [ "", "", [ "Sancho", "Sanchez" ] ]
#32 Mr. Spell. cyana r = MOOList [ "", "", [ "cyanate", "Cyanamid" ] ]
#32 Mr. Spell. Urs r = MOOList [ "", "u", [ "Ursa" ] ]
#32 Mr. Spell. spokesm r = MOOList [ "", "", [ "spokesmen", "spokesman" ] ]
#32 Mr. Spell. affec r = MOOList [ "t", "", [ "affectionate", "affectate", "affect" ] ]
#32 Mr. Spell. baron r = MOOList [ "", "e", [ "barony", "baronial", "baron" ] ]
#32 Mr. Spell. racke r = MOOList [ "t", "", [ "rackety", "racketeer", "racket" ] ]
#32 Mr. Spell. togg r = MOOList [ "", "", [ "toggle", "togging" ] ]
#32 Mr. Spell. fuc r = MOOList [ "", "hk", [ ] ]
#32 Mr. Spell. barri r = MOOList [ "", "", [ "Barrington", "barrier", "barricade" ] ]
#32 Mr. Spell. fug r = MOOList [ "", "", [ "fugue", "fugitive", "fugal" ] ]
#32 Mr. Spell. barre r = MOOList [ "", "t", [ "barren", "barrel", "barre" ] ]
#32 Mr. Spell. ful r = MOOList [ "", "l", [ "Fulton", "fulsome", "fulminate", "fulfill", "fulcrum" ] ]
#32 Mr. Spell. fum r = MOOList [ "", "i", [ "fume", "fumble", "fum" ] ]
#32 Mr. Spell. sandw r = MOOList [ "ich", "", [ "sandwiches", "sandwich" ] ]
#32 Mr. Spell. fun r = MOOList [ "", "cdegn", [ "funk", "fun" ] ]
#32 Mr. Spell. barra r = MOOList [ "", "c", [ "barrage" ] ]
#32 Mr. Spell. trime r = MOOList [ "", "", [ "trimester", "trimer" ] ]
#32 Mr. Spell. sandp r = MOOList [ "", "i", [ "sandpaper" ] ]
#32 Mr. Spell. techn r = MOOList [ "", "io", [ "technetium" ] ]
#32 Mr. Spell. agon r = MOOList [ "", "", [ "agony", "agone" ] ]
#32 Mr. Spell. urin r = MOOList [ "", "a", [ "urine" ] ]
#32 Mr. Spell. gian r = MOOList [ "t", "", [ "giantess", "giant" ] ]
#32 Mr. Spell. Dra r = MOOList [ "", "fgimpw", [ "drastic", "drank", "drake", "Draco", "drab" ] ]
#32 Mr. Spell. specifi r = MOOList [ "c", "a", [ "specific" ] ]
#32 Mr. Spell. Fibe r = MOOList [ "r", "", [ "Fiberglas", "fiberboard" ] ]
#32 Mr. Spell. June r = MOOList [ "", "", [ "Juneau", "June" ] ]
#32 Mr. Spell. Junc r = MOOList [ "", "t", [ "junco" ] ]
#32 Mr. Spell. autocrat r = MOOList [ "", "", [ "autocratic", "autocrat" ] ]
#32 Mr. Spell. spinn r = MOOList [ "", "", [ "spinneret", "spinnaker" ] ]
#32 Mr. Spell. spino r = MOOList [ "", "", [ "spinoff", "spinodal" ] ]
#32 Mr. Spell. lesso r = MOOList [ "", "", [ "lessor", "lesson" ] ]
#32 Mr. Spell. Glen r = MOOList [ "", "d", [ "Glenn", "glen" ] ]
#32 Mr. Spell. calip r = MOOList [ "", "h", [ "caliper" ] ]
#32 Mr. Spell. lesse r = MOOList [ "", "", [ "lessen", "lessee" ] ]
#32 Mr. Spell. indiges r = MOOList [ "ti", "", [ "indigestion", "indigestible" ] ]
#32 Mr. Spell. calif r = MOOList [ "orni", "", [ "californium", "California" ] ]
#32 Mr. Spell. implic r = MOOList [ "", "a", [ "implicit" ] ]
#32 Mr. Spell. fur r = MOOList [ "", "lnrt", [ "furze", "fury", "Furman", "furious", "furbish", "fur" ] ]
#32 Mr. Spell. fus r = MOOList [ "", "eis", [ "fusty" ] ]
#32 Mr. Spell. extrav r = MOOList [ "agan", "", [ "extravaganza", "extravagant" ] ]
#32 Mr. Spell. fut r = MOOList [ "", "", [ "future", "futile" ] ]
#32 Mr. Spell. agno r = MOOList [ "", "", [ "agnostic", "agnomen" ] ]
#32 Mr. Spell. trill r = MOOList [ "", "i", [ "trill" ] ]
#32 Mr. Spell. fuz r = MOOList [ "z", "", [ "fuzzy", "fuzz" ] ]
#32 Mr. Spell. calib r = MOOList [ "", "r", [ "caliber" ] ]
#32 Mr. Spell. trilo r = MOOList [ "", "", [ "trilogy", "trilobite" ] ]
#32 Mr. Spell. indigen r = MOOList [ "", "", [ "indigent", "indigenous", "indigene" ] ]
#32 Mr. Spell. Baptist r = MOOList [ "", "e", [ "Baptist" ] ]
#32 Mr. Spell. extrac r = MOOList [ "", "t", [ "extracellular" ] ]
#32 Mr. Spell. Tris r = MOOList [ "", "t", [ "trisyllable", "trisodium" ] ]
#32 Mr. Spell. geoche r = MOOList [ "mi", "", [ "geochemistry", "geochemical" ] ]
#32 Mr. Spell. extrad r = MOOList [ "it", "", [ "extradition", "extradite" ] ]
#32 Mr. Spell. Baptism r = MOOList [ "", "", [ "baptismal", "baptism" ] ]
#32 Mr. Spell. Brook r = MOOList [ "", "l", [ "brookside", "Brookhaven", "Brooke", "brook" ] ]
#32 Mr. Spell. affir r = MOOList [ "m", "a", [ "affirm" ] ]
#32 Mr. Spell. agne r = MOOList [ "", "", [ "Agnew", "Agnes" ] ]
#32 Mr. Spell. slap r = MOOList [ "", "", [ "slapstick", "slap" ] ]
#32 Mr. Spell. digita r = MOOList [ "l", "", [ "digitalis", "digital" ] ]
#32 Mr. Spell. calli r = MOOList [ "", "g", [ "calling", "Callisto", "calliope" ] ]
#32 Mr. Spell. bully r = MOOList [ "", "", [ "bullyboy", "bully" ] ]
#32 Mr. Spell. introv r = MOOList [ "er", "", [ "introvert", "introversion" ] ]
#32 Mr. Spell. insolv r = MOOList [ "", "", [ "insolvent", "insolvable" ] ]
#32 Mr. Spell. slat r = MOOList [ "", "e", [ "slat" ] ]
#32 Mr. Spell. slau r = MOOList [ "ghter", "", [ "slaughterhouse", "slaughter" ] ]
#32 Mr. Spell. slav r = MOOList [ "", "ei", [ "Slavonic", "Slav" ] ]
#32 Mr. Spell. psyc r = MOOList [ "h", "io", [ "psyche", "psych" ] ]
#32 Mr. Spell. slan r = MOOList [ "", "d", [ "slant", "slang" ] ]
#32 Mr. Spell. introd r = MOOList [ "uc", "te", [ "introducing" ] ]
#32 Mr. Spell. urge r = MOOList [ "", "n", [ "urge" ] ]
#32 Mr. Spell. todd r = MOOList [ "", "", [ "toddle", "Todd" ] ]
#32 Mr. Spell. Jule r = MOOList [ "", "", [ "Jules", "julep" ] ]
#32 Mr. Spell. slac r = MOOList [ "k", "", [ "slacken", "slack" ] ]
#32 Mr. Spell. bullh r = MOOList [ "", "", [ "bullhide", "bullhead" ] ]
#32 Mr. Spell. simplif r = MOOList [ "", "", [ "simplified", "simplify" ] ]
#32 Mr. Spell. bulle r = MOOList [ "t", "", [ "bulletin", "bullet" ] ]
#32 Mr. Spell. bullf r = MOOList [ "", "", [ "bullfrog", "bullfinch" ] ]
#32 Mr. Spell. Bronc r = MOOList [ "", "h", [ "bronco" ] ]
#32 Mr. Spell. bulld r = MOOList [ "o", "", [ "bulldoze", "bulldog" ] ]
#32 Mr. Spell. Juli r = MOOList [ "", "e", [ "Julius", "Julio", "Julia" ] ]
#32 Mr. Spell. congressw r = MOOList [ "om", "", [ "congresswomen", "congresswoman" ] ]
#32 Mr. Spell. Tric r = MOOList [ "", "hk", [ "Triceratops" ] ]
#32 Mr. Spell. Dun r = MOOList [ "", "cegkl", [ "Dunn", "Dunham", "Dunbar", "dun" ] ]
#32 Mr. Spell. sangu r = MOOList [ "in", "e", [ "sanguinary" ] ]
#32 Mr. Spell. destru r = MOOList [ "ct", "", [ "destructor", "destruct" ] ]
#32 Mr. Spell. trini r = MOOList [ "", "t", [ "Trinidad" ] ]
#32 Mr. Spell. Iris r = MOOList [ "", "h", [ "iris" ] ]
#32 Mr. Spell. Dug r = MOOList [ "", "", [ "dugout", "Dugan", "dug" ] ]
#32 Mr. Spell. expert r = MOOList [ "", "", [ "expertise", "expert" ] ]
#32 Mr. Spell. congressm r = MOOList [ "", "", [ "congressmen", "congressman" ] ]
#32 Mr. Spell. wyn r = MOOList [ "", "", [ "wynn", "Wyner" ] ]
#32 Mr. Spell. Dud r = MOOList [ "", "", [ "Dudley", "dud" ] ]
#32 Mr. Spell. simplic r = MOOList [ "i", "", [ "simplicity", "simplicial" ] ]
#32 Mr. Spell. Dub r = MOOList [ "", "i", [ "Dublin", "Dubhe", "dub" ] ]
#32 Mr. Spell. iodi r = MOOList [ "", "n", [ "iodide" ] ]
#32 Mr. Spell. Dua r = MOOList [ "", "", [ "Duane", "dual" ] ]
#32 Mr. Spell. cyani r = MOOList [ "", "", [ "cyanide", "cyanic" ] ]
#32 Mr. Spell. opti r = MOOList [ "", "mo", [ "optic" ] ]
#32 Mr. Spell. opth r = MOOList [ "alm", "", [ "opthalmology", "opthalmic" ] ]
#32 Mr. Spell. Thermo r = MOOList [ "", "", [ "thermostat", "Thermofax", "thermo" ] ]
#32 Mr. Spell. Scott r = MOOList [ "", "", [ "Scotty", "Scottsdale", "Scottish", "Scott" ] ]
#32 Mr. Spell. utili r = MOOList [ "t", "", [ "utilities", "utility", "utilitarian" ] ]
#32 Mr. Spell. Scots r = MOOList [ "m", "", [ "Scotsmen", "Scotsman" ] ]
#32 Mr. Spell. Taff r = MOOList [ "", "", [ "taffy", "taffeta" ] ]
#32 Mr. Spell. opto r = MOOList [ "", "m", [ "optoisolate", "optoacoustic" ] ]
#32 Mr. Spell. Dus r = MOOList [ "", "ekt", [ "Dusseldorf" ] ]
#32 Mr. Spell. experi r = MOOList [ "", "em", [ ] ]
#32 Mr. Spell. ineffe r = MOOList [ "ct", "", [ "ineffectual", "ineffective" ] ]
#32 Mr. Spell. uret r = MOOList [ "h", "", [ "urethra", "urethane" ] ]
#32 Mr. Spell. ineffi r = MOOList [ "c", "", [ "inefficient", "inefficacy" ] ]
#32 Mr. Spell. spite r = MOOList [ "", "", [ "spiteful", "spite" ] ]
#32 Mr. Spell. someti r = MOOList [ "me", "", [ "sometimes", "sometime" ] ]
#32 Mr. Spell. Socr r = MOOList [ "at", "", [ "Socratic", "Socrates" ] ]
#32 Mr. Spell. stupef r = MOOList [ "", "", [ "stupefy", "stupefaction" ] ]
#32 Mr. Spell. blasp r = MOOList [ "hem", "", [ "blasphemy", "blasphemous", "blaspheme" ] ]
#32 Mr. Spell. spiri r = MOOList [ "t", "", [ "spiritual", "spirit" ] ]
#32 Mr. Spell. ferrom r = MOOList [ "agnet", "", [ "ferromagnetic", "ferromagnet" ] ]
#32 Mr. Spell. blast r = MOOList [ "", "", [ "blastula", "blast" ] ]
#32 Mr. Spell. singlet r = MOOList [ "", "", [ "singleton", "singlet" ] ]
#32 Mr. Spell. tripl r = MOOList [ "", "e", [ "triplicate" ] ]
#32 Mr. Spell. toas r = MOOList [ "t", "", [ "toastmaster", "toast" ] ]
#32 Mr. Spell. sanit r = MOOList [ "a", "r", [ "sanitate" ] ]
#32 Mr. Spell. american r = MOOList [ "", "", [ "american", "Americana" ] ]
#32 Mr. Spell. tripo r = MOOList [ "", "", [ "tripoli", "tripod" ] ]
#32 Mr. Spell. weari r = MOOList [ "", "", [ "wearisome", "wearied" ] ]
#32 Mr. Spell. grandi r = MOOList [ "", "", [ "grandiose", "grandiloquent" ] ]
#32 Mr. Spell. gluta r = MOOList [ "m", "i", [ "glutamate" ] ]
#32 Mr. Spell. exten r = MOOList [ "", "ds", [ "extenuate", "extent" ] ]
#32 Mr. Spell. grandc r = MOOList [ "hild", "", [ "grandchildren", "grandchild" ] ]
#32 Mr. Spell. macros r = MOOList [ "", "", [ "macrostructure", "macroscopic" ] ]
#32 Mr. Spell. extem r = MOOList [ "por", "", [ "extempore", "extemporaneous" ] ]
#32 Mr. Spell. macrom r = MOOList [ "olecul", "", [ "macromolecule", "macromolecular" ] ]
#32 Mr. Spell. exter r = MOOList [ "", "", [ "external", "exterminate", "exterior" ] ]
#32 Mr. Spell. doork r = MOOList [ "", "e", [ "doorknob" ] ]
#32 Mr. Spell. meteorit r = MOOList [ "", "", [ "meteoritic", "meteorite" ] ]
#32 Mr. Spell. doorm r = MOOList [ "", "", [ "doormen", "doorman" ] ]
#32 Mr. Spell. paranoi r = MOOList [ "", "a", [ "paranoid" ] ]
#32 Mr. Spell. stere r = MOOList [ "o", "", [ "stereoscopy", "stereography", "stereo" ] ]
#32 Mr. Spell. vege r = MOOList [ "ta", "", [ "vegetate", "vegetarian", "vegetable" ] ]
#32 Mr. Spell. whiz r = MOOList [ "", "", [ "whizzing", "whiz" ] ]
#32 Mr. Spell. conque r = MOOList [ "", "r", [ "conquest" ] ]
#32 Mr. Spell. Triang r = MOOList [ "", "u", [ "triangle" ] ]
#32 Mr. Spell. whir r = MOOList [ "", "l", [ "whir" ] ]
#32 Mr. Spell. whis r = MOOList [ "", "t", [ "whisper", "whisk", "whish" ] ]
#32 Mr. Spell. marit r = MOOList [ "", "", [ "maritime", "marital" ] ]
#32 Mr. Spell. whip r = MOOList [ "", "p", [ "whipsaw", "whiplash", "whip" ] ]
#32 Mr. Spell. diverg r = MOOList [ "e", "", [ "divergent", "diverge" ] ]
#32 Mr. Spell. ecum r = MOOList [ "eni", "", [ "ecumenist", "ecumenic" ] ]
#32 Mr. Spell. Alber r = MOOList [ "", "t", [ "Alberich" ] ]
#32 Mr. Spell. whit r = MOOList [ "", "et", [ "Whitney", "Whitman", "Whitlock", "whither", "Whitcomb", "Whitaker", "whit" ] ]
#32 Mr. Spell. piggi r = MOOList [ "", "", [ "piggish", "pigging" ] ]
#32 Mr. Spell. cheesec r = MOOList [ "", "", [ "cheesecloth", "cheesecake" ] ]
#32 Mr. Spell. marin r = MOOList [ "", "a", [ "Marino", "marine", "Marin" ] ]
#32 Mr. Spell. whin r = MOOList [ "", "", [ "whinny", "whine" ] ]
#32 Mr. Spell. lingua r = MOOList [ "", "", [ "lingual", "lingua" ] ]
#32 Mr. Spell. whil r = MOOList [ "", "", [ "whilst", "while" ] ]
#32 Mr. Spell. whim r = MOOList [ "", "s", [ "whimper", "whim" ] ]
#32 Mr. Spell. whic r = MOOList [ "h", "", [ "whichever", "which" ] ]
#32 Mr. Spell. repor r = MOOList [ "t", "", [ "reports", "reporting", "reported", "reportorial", "report" ] ]
#32 Mr. Spell. effectu r = MOOList [ "a", "", [ "effectuate", "effectual" ] ]
#32 Mr. Spell. doors r = MOOList [ "", "", [ "doors", "doorstep" ] ]
#32 Mr. Spell. negli r = MOOList [ "g", "e", [ "negligible" ] ]
#32 Mr. Spell. litiga r = MOOList [ "", "", [ "litigate", "litigant" ] ]
#32 Mr. Spell. expens r = MOOList [ "", "", [ "expensive", "expense" ] ]
#32 Mr. Spell. necromanc r = MOOList [ "", "", [ "necromancy", "necromancer" ] ]
#32 Mr. Spell. divers r = MOOList [ "", "i", [ "diverse" ] ]
#32 Mr. Spell. commodi r = MOOList [ "", "", [ "commodity", "commodious" ] ]
#32 Mr. Spell. veer r = MOOList [ "", "", [ "veery", "veer" ] ]
#32 Mr. Spell. Micha r = MOOList [ "el", "", [ "Michaelangelo", "Michael" ] ]
#32 Mr. Spell. professo r = MOOList [ "r", "", [ "professorial", "professor" ] ]
#32 Mr. Spell. Miche r = MOOList [ "l", "", [ "Michelson", "Michelin", "Michele", "Michelangelo", "Michel" ] ]
#32 Mr. Spell. expend r = MOOList [ "", "", [ "expenditure", "expend" ] ]
#32 Mr. Spell. hydra r = MOOList [ "", "n", [ "hydraulic", "hydrate", "hydra" ] ]
#32 Mr. Spell. keep r = MOOList [ "", "", [ "keeps", "keep" ] ]
#32 Mr. Spell. keel r = MOOList [ "", "", [ "keelson", "keel" ] ]
#32 Mr. Spell. syring r = MOOList [ "", "", [ "syringe", "syringa" ] ]
#32 Mr. Spell. hydro r = MOOList [ "", "cglpsx", [ "hydrous", "hydrothermal", "hydronium", "hydrometer", "hydrofluoric", "hydroelectric", "hydrodynamic", "hydro" ] ]
#32 Mr. Spell. citiz r = MOOList [ "en", "", [ "citizenry", "citizen" ] ]
#32 Mr. Spell. repre r = MOOList [ "", "s", [ "reprehensible" ] ]
#32 Mr. Spell. benef r = MOOList [ "", "i", [ "benefactor" ] ]
#32 Mr. Spell. stern r = MOOList [ "", "", [ "sternum", "Sterno", "Sternberg", "sternal", "stern" ] ]
#32 Mr. Spell. repri r = MOOList [ "", "s", [ "reprimand", "reprieve" ] ]
#32 Mr. Spell. icono r = MOOList [ "clas", "", [ "iconoclast", "iconoclasm" ] ]
#32 Mr. Spell. margi r = MOOList [ "n", "a", [ "margin" ] ]
#32 Mr. Spell. kidna r = MOOList [ "p", "p", [ "kidnap" ] ]
#32 Mr. Spell. benedicti r = MOOList [ "", "", [ "benediction", "Benedictine" ] ]
#32 Mr. Spell. executiv r = MOOList [ "e", "", [ "executives", "executive" ] ]
#32 Mr. Spell. expell r = MOOList [ "", "", [ "expelling", "expelled", "expellable" ] ]
#32 Mr. Spell. Knowle r = MOOList [ "", "d", [ "Knowles" ] ]
#32 Mr. Spell. extin r = MOOList [ "", "", [ "extinguish", "extinct" ] ]
#32 Mr. Spell. Otto r = MOOList [ "", "", [ "Ottoman", "Otto" ] ]
#32 Mr. Spell. excha r = MOOList [ "nge", "", [ "exchangeable", "exchange" ] ]
#32 Mr. Spell. Coper r = MOOList [ "nic", "", [ "Copernicus", "Copernican" ] ]
#32 Mr. Spell. memor r = MOOList [ "", "a", [ "memory", "memorial" ] ]
#32 Mr. Spell. snugg r = MOOList [ "l", "", [ "snuggly", "snuggle" ] ]
#32 Mr. Spell. whet r = MOOList [ "", "", [ "whet", "whether" ] ]
#32 Mr. Spell. when r = MOOList [ "", "", [ "whenever", "whence", "when" ] ]
#32 Mr. Spell. whel r = MOOList [ "", "", [ "whelp", "whelm", "Wheller", "whelk", "Whelan" ] ]
#32 Mr. Spell. gal r = MOOList [ "", "aelv", [ "Galway", "Galt", "Galois", "Galilee", "Galbreath", "gal" ] ]
#32 Mr. Spell. wher r = MOOList [ "e", "ao'w", [ "wherever", "whereupon", "wheresoever", "wherein", "wherefore", "whereby", "where" ] ]
#32 Mr. Spell. gan r = MOOList [ "", "gnt", [ "Ganymede", "gander" ] ]
#32 Mr. Spell. gap r = MOOList [ "", "", [ "gape", "gap" ] ]
#32 Mr. Spell. admiral r = MOOList [ "", "", [ "admiralty", "admiral" ] ]
#32 Mr. Spell. commenta r = MOOList [ "", "", [ "commentator", "commentary" ] ]
#32 Mr. Spell. Micke r = MOOList [ "", "", [ "Mickey", "Mickelson" ] ]
#32 Mr. Spell. gar r = MOOList [ "", "bdgilnrt", [ "Gary", "Garvey", "Garfield", "Garcia", "garage", "gar" ] ]
#32 Mr. Spell. physiot r = MOOList [ "herap", "", [ "physiotherapy", "physiotherapist" ] ]
#32 Mr. Spell. whee r = MOOList [ "", "lz", [ "wheedle", "whee" ] ]
#32 Mr. Spell. incontr r = MOOList [ "o", "", [ "incontrovertible", "incontrollable" ] ]
#32 Mr. Spell. gau r = MOOList [ "", "cglns", [ "gauze", "gaur", "gaudy" ] ]
#32 Mr. Spell. gav r = MOOList [ "", "e", [ "gavotte", "Gavin" ] ]
#32 Mr. Spell. gaw r = MOOList [ "k", "", [ "gawky", "gawk" ] ]
#32 Mr. Spell. arise r = MOOList [ "", "", [ "arisen", "arise" ] ]
#32 Mr. Spell. matter r = MOOList [ "", "", [ "matters", "matter" ] ]
#32 Mr. Spell. gab r = MOOList [ "", "br", [ "Gabon", "gable", "Gaberones", "gabardine", "gab" ] ]
#32 Mr. Spell. riva r = MOOList [ "l", "", [ "rivalry", "rival" ] ]
#32 Mr. Spell. gad r = MOOList [ "", "g", [ "gadwall", "gadolinium", "gadfly", "gad" ] ]
#32 Mr. Spell. gaf r = MOOList [ "f", "", [ "gaffe", "gaff" ] ]
#32 Mr. Spell. gag r = MOOList [ "", "g", [ "gagwriter", "gage", "gag" ] ]
#32 Mr. Spell. rive r = MOOList [ "", "r", [ "rivet", "riven" ] ]
#32 Mr. Spell. arist r = MOOList [ "o", "ct", [ ] ]
#32 Mr. Spell. radic r = MOOList [ "", "", [ "radices", "radical" ] ]
#32 Mr. Spell. give r = MOOList [ "", "", [ "gives", "giveth", "given", "giveaway", "give" ] ]
#32 Mr. Spell. radia r = MOOList [ "", "n", [ "radiate", "radial" ] ]
#32 Mr. Spell. inconsi r = MOOList [ "", "d", [ "inconsistent" ] ]
#32 Mr. Spell. repul r = MOOList [ "si", "", [ "repulsive", "repulsion" ] ]
#32 Mr. Spell. Somers r = MOOList [ "", "", [ "Somerset", "somersault", "Somers" ] ]
#32 Mr. Spell. reput r = MOOList [ "", "", [ "repute", "reputation" ] ]
#32 Mr. Spell. gaz r = MOOList [ "e", "", [ "gazette", "gazelle", "gaze" ] ]
#32 Mr. Spell. radio r = MOOList [ "", "ac", [ "radiotherapy", "radiosonde", "radiophysics", "radiometer", "radiology", "radiography", "radio" ] ]
#32 Mr. Spell. Vad r = MOOList [ "", "", [ "Vaduz", "vade" ] ]
#32 Mr. Spell. repub r = MOOList [ "lic", "", [ "republican", "republic" ] ]
#32 Mr. Spell. analys r = MOOList [ "", "", [ "analyst", "analysis", "analyses" ] ]
#32 Mr. Spell. adopti r = MOOList [ "", "", [ "adoptive", "adoption" ] ]
#32 Mr. Spell. qualit r = MOOList [ "", "", [ "quality", "qualitative" ] ]
#32 Mr. Spell. Vau r = MOOList [ "", "dg", [ "vaunt", "vault" ] ]
#32 Mr. Spell. gangli r = MOOList [ "", "", [ "ganglion", "gangling" ] ]
#32 Mr. Spell. Vat r = MOOList [ "", "", [ "Vatican", "vat" ] ]
#32 Mr. Spell. conquer r = MOOList [ "", "", [ "conqueror", "conquer" ] ]
#32 Mr. Spell. incompreh r = MOOList [ "ensi", "", [ "incomprehension", "incomprehensible" ] ]
#32 Mr. Spell. ecol r = MOOList [ "", "", [ "ecology", "Ecole" ] ]
#32 Mr. Spell. stewa r = MOOList [ "r", "d", [ "Stewart" ] ]
#32 Mr. Spell. radiu r = MOOList [ "", "", [ "radius", "radium" ] ]
#32 Mr. Spell. Isab r = MOOList [ "el", "", [ "Isabella", "Isabel" ] ]
#32 Mr. Spell. housebr r = MOOList [ "", "", [ "housebroken", "housebreak" ] ]
#32 Mr. Spell. Isaa r = MOOList [ "c", "", [ "Isaacson", "Isaac" ] ]
#32 Mr. Spell. jurisp r = MOOList [ "rudent", "", [ "jurisprudential", "jurisprudent" ] ]
#32 Mr. Spell. excel r = MOOList [ "", "l", [ "excelsior", "excel" ] ]
#32 Mr. Spell. excep r = MOOList [ "t", "", [ "exception", "except" ] ]
#32 Mr. Spell. exces r = MOOList [ "s", "", [ "excessive", "excess" ] ]
#32 Mr. Spell. excla r = MOOList [ "", "m", [ "exclaim" ] ]
#32 Mr. Spell. commonw r = MOOList [ "eal", "", [ "commonwealth", "commonweal" ] ]
#32 Mr. Spell. featherb r = MOOList [ "", "e", [ "featherbrain" ] ]
#32 Mr. Spell. Jean r = MOOList [ "", "", [ "Jeannie", "jean" ] ]
#32 Mr. Spell. xen r = MOOList [ "o", "", [ "xenophobia", "xenon" ] ]
#32 Mr. Spell. rise r = MOOList [ "", "", [ "rises", "risen", "rise" ] ]
#32 Mr. Spell. oxida r = MOOList [ "", "", [ "oxidate", "oxidant" ] ]
#32 Mr. Spell. Ameri r = MOOList [ "c", "a", [ "americium" ] ]
#32 Mr. Spell. prais r = MOOList [ "e", "", [ "praiseworthy", "praise" ] ]
#32 Mr. Spell. deterre r = MOOList [ "", "", [ "deterrent", "deterred" ] ]
#32 Mr. Spell. Cather r = MOOList [ "", "", [ "Catherwood", "Catherine" ] ]
#32 Mr. Spell. risk r = MOOList [ "", "", [ "risky", "risk" ] ]
#32 Mr. Spell. lione r = MOOList [ "", "", [ "lioness", "Lionel" ] ]
#32 Mr. Spell. Fonta r = MOOList [ "ine", "", [ "Fontainebleau", "Fontaine" ] ]
#32 Mr. Spell. exclu r = MOOList [ "", "s", [ "exclude" ] ]
#32 Mr. Spell. what r = MOOList [ "", "'", [ "whatsoever", "whatnot", "Whatley", "whatever", "what" ] ]
#32 Mr. Spell. Soren r = MOOList [ "s", "", [ "Sorenson", "Sorensen" ] ]
#32 Mr. Spell. gen r = MOOList [ "", "eiotu", [ "genre", "gender" ] ]
#32 Mr. Spell. geo r = MOOList [ "", "cdgmpr", [ "geology", "Geoffrey" ] ]
#32 Mr. Spell. get r = MOOList [ "", "t", [ "gets", "getaway", "get" ] ]
#32 Mr. Spell. slum r = MOOList [ "", "", [ "slump", "slumber", "slum" ] ]
#32 Mr. Spell. preempti r = MOOList [ "", "", [ "preemptive", "preemption" ] ]
#32 Mr. Spell. forget r = MOOList [ "", "t", [ "forgetful", "forget" ] ]
#32 Mr. Spell. Fitz r = MOOList [ "", "", [ "Fitzroy", "Fitzpatrick", "Fitzgerald" ] ]
#32 Mr. Spell. switchb r = MOOList [ "", "", [ "switchboard", "switchblade" ] ]
#32 Mr. Spell. slur r = MOOList [ "", "", [ "slurry", "slurp", "slur" ] ]
#32 Mr. Spell. slug r = MOOList [ "", "g", [ "slug" ] ]
#32 Mr. Spell. marro r = MOOList [ "w", "", [ "marrowbone", "marrow" ] ]
#32 Mr. Spell. gee r = MOOList [ "", "", [ "geese", "gee" ] ]
#32 Mr. Spell. marri r = MOOList [ "", "a", [ "Marriott", "Marrietta" ] ]
#32 Mr. Spell. gel r = MOOList [ "", "a", [ "geld", "gel" ] ]
#32 Mr. Spell. gem r = MOOList [ "", "i", [ "gemstone", "Gemma", "gem" ] ]
#32 Mr. Spell. annou r = MOOList [ "nc", "e", [ "announcing" ] ]
#32 Mr. Spell. Lenin r = MOOList [ "", "", [ "Leningrad", "Lenin" ] ]
#32 Mr. Spell. condemna r = MOOList [ "t", "", [ "condemnatory", "condemnate" ] ]
#32 Mr. Spell. magnan r = MOOList [ "im", "", [ "magnanimous", "magnanimity" ] ]
#32 Mr. Spell. gird r = MOOList [ "", "", [ "girdle", "gird" ] ]
#32 Mr. Spell. stonew r = MOOList [ "", "a", [ "stonewort" ] ]
#32 Mr. Spell. ecli r = MOOList [ "p", "", [ "ecliptic", "eclipse" ] ]
#32 Mr. Spell. town r = MOOList [ "", "s", [ "townhouse", "town" ] ]
#32 Mr. Spell. annoy r = MOOList [ "", "", [ "annoyance", "annoy" ] ]
#32 Mr. Spell. girl r = MOOList [ "", "i", [ "girl" ] ]
#32 Mr. Spell. towe r = MOOList [ "", "", [ "tower", "towel" ] ]
#32 Mr. Spell. Vel r = MOOList [ "", "alov", [ "veldt" ] ]
#32 Mr. Spell. citro r = MOOList [ "", "", [ "citron", "Citroen" ] ]
#32 Mr. Spell. towh r = MOOList [ "e", "", [ "towhee", "towhead" ] ]
#32 Mr. Spell. Fitc r = MOOList [ "h", "", [ "Fitchburg", "Fitch" ] ]
#32 Mr. Spell. covar r = MOOList [ "", "i", [ "covary" ] ]
#32 Mr. Spell. towa r = MOOList [ "rd", "", [ "towards", "toward" ] ]
#32 Mr. Spell. callig r = MOOList [ "raph", "", [ "calligraphy", "calligraph" ] ]
#32 Mr. Spell. Edm r = MOOList [ "", "o", [ "Edmund" ] ]
#32 Mr. Spell. Ver r = MOOList [ "", "abdimnost", [ "verve", "Verlag", "verge", "very" ] ]
#32 Mr. Spell. pestil r = MOOList [ "ent", "", [ "pestilential", "pestilent" ] ]
#32 Mr. Spell. ripe r = MOOList [ "", "", [ "ripen", "ripe" ] ]
#32 Mr. Spell. Edw r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. excis r = MOOList [ "", "", [ "excision", "excise", "excisable" ] ]
#32 Mr. Spell. excit r = MOOList [ "", "a", [ "exciton", "excite" ] ]
#32 Mr. Spell. tuber r = MOOList [ "cul", "", [ "tuberculosis", "tuberculin" ] ]
#32 Mr. Spell. Fisk r = MOOList [ "", "", [ "Fiske", "Fisk" ] ]
#32 Mr. Spell. tour r = MOOList [ "", "", [ "tournament", "tour" ] ]
#32 Mr. Spell. riot r = MOOList [ "", "", [ "riotous", "riot" ] ]
#32 Mr. Spell. ether r = MOOList [ "", "", [ "ethereal", "ether" ] ]
#32 Mr. Spell. quarrym r = MOOList [ "", "", [ "quarrymen", "quarryman" ] ]
#32 Mr. Spell. Mouth r = MOOList [ "", "", [ "mouthpiece", "mouthful", "mouth" ] ]
#32 Mr. Spell. gia r = MOOList [ "", "n", [ "Giacomo" ] ]
#32 Mr. Spell. touc r = MOOList [ "h", "", [ "touchy", "touchstone", "touchdown", "touch" ] ]
#32 Mr. Spell. extra r = MOOList [ "", "cdv", [ "extraterrestrial", "extrapolate", "extraordinary", "extraneous", "extramarital", "extralegal", "extra" ] ]
#32 Mr. Spell. ghe r = MOOList [ "", "", [ "ghetto", "gherkin", "Ghent" ] ]
#32 Mr. Spell. toug r = MOOList [ "h", "", [ "toughened", "tough" ] ]
#32 Mr. Spell. extre r = MOOList [ "m", "ae", [ "extremum" ] ]
#32 Mr. Spell. debar r = MOOList [ "", "", [ "debarring", "debar" ] ]
#32 Mr. Spell. extri r = MOOList [ "", "c", [ "extrinsic" ] ]
#32 Mr. Spell. desca r = MOOList [ "", "", [ "Descartes", "descant" ] ]
#32 Mr. Spell. stenc r = MOOList [ "", "", [ "stencil", "stench" ] ]
#32 Mr. Spell. extro r = MOOList [ "ver", "", [ "extrovert", "extroversion" ] ]
#32 Mr. Spell. gho r = MOOList [ "", "u", [ "ghost" ] ]
#32 Mr. Spell. debau r = MOOList [ "ch", "", [ "debauchery", "debauch" ] ]
#32 Mr. Spell. desce r = MOOList [ "n", "d", [ "descent" ] ]
#32 Mr. Spell. debat r = MOOList [ "e", "", [ "debater", "debate" ] ]
#32 Mr. Spell. gir r = MOOList [ "", "dl", [ "girth", "giraffe" ] ]
#32 Mr. Spell. giv r = MOOList [ "", "e", [ "giving" ] ]
#32 Mr. Spell. metallu r = MOOList [ "rg", "i", [ "metallurgy" ] ]
#32 Mr. Spell. reple r = MOOList [ "", "", [ "replete", "replenish" ] ]
#32 Mr. Spell. ring r = MOOList [ "", "", [ "ringside", "ringlet", "ring" ] ]
#32 Mr. Spell. inope r = MOOList [ "ra", "", [ "inoperative", "inoperable" ] ]
#32 Mr. Spell. saluta r = MOOList [ "", "", [ "salutation", "salutary" ] ]
#32 Mr. Spell. descr r = MOOList [ "i", "pb", [ ] ]
#32 Mr. Spell. repli r = MOOList [ "ca", "", [ "replicate", "replica" ] ]
#32 Mr. Spell. Howe r = MOOList [ "", "", [ "however", "Howell", "Howe" ] ]
#32 Mr. Spell. gib r = MOOList [ "", "b", [ "Gibson", "Gibraltar", "giblet", "gibe" ] ]
#32 Mr. Spell. tota r = MOOList [ "l", "", [ "totalitarian", "total" ] ]
#32 Mr. Spell. basem r = MOOList [ "", "", [ "basemen", "baseman" ] ]
#32 Mr. Spell. metalli r = MOOList [ "", "", [ "metalliferous", "metallic" ] ]
#32 Mr. Spell. gid r = MOOList [ "", "d", [ "Gideon" ] ]
#32 Mr. Spell. chasti r = MOOList [ "", "", [ "chastity", "chastise" ] ]
#32 Mr. Spell. basep r = MOOList [ "", "", [ "basepoint", "baseplate" ] ]
#32 Mr. Spell. gif r = MOOList [ "", "", [ "gift", "Gifford" ] ]
#32 Mr. Spell. tote r = MOOList [ "", "m", [ "tote" ] ]
#32 Mr. Spell. gig r = MOOList [ "", "ag", [ "gig" ] ]
#32 Mr. Spell. basel r = MOOList [ "", "", [ "baseline", "Basel" ] ]
#32 Mr. Spell. magnif r = MOOList [ "", "", [ "magnify", "magnificent" ] ]
#32 Mr. Spell. echo r = MOOList [ "", "", [ "echoes", "echo" ] ]
#32 Mr. Spell. gil r = MOOList [ "", "bel", [ "gilt", "Gilmore", "gild", "Gilchrist", "gila", "Gil" ] ]
#32 Mr. Spell. metallo r = MOOList [ "", "", [ "metalloid", "metallography" ] ]
#32 Mr. Spell. baseb r = MOOList [ "", "a", [ "baseboard" ] ]
#32 Mr. Spell. magnet r = MOOList [ "", "i", [ "magnetron", "magneto", "magnet" ] ]
#32 Mr. Spell. magnes r = MOOList [ "i", "", [ "magnesium", "magnesite", "magnesia" ] ]
#32 Mr. Spell. intran r = MOOList [ "si", "", [ "intransitive", "intransigent" ] ]
#32 Mr. Spell. ging r = MOOList [ "", "", [ "gingko", "gingham", "ginger" ] ]
#32 Mr. Spell. FIF r = MOOList [ "", "t", [ "FIFO", "fife" ] ]
#32 Mr. Spell. echi r = MOOList [ "", "", [ "echinoderm", "echidna" ] ]
#32 Mr. Spell. marke r = MOOList [ "t", "e", [ "markets", "marketing", "marketwise", "marketplace", "market" ] ]
#32 Mr. Spell. coven r = MOOList [ "", "", [ "Coventry", "covenant", "coven" ] ]
#32 Mr. Spell. ethy r = MOOList [ "l", "", [ "ethylene", "ethyl" ] ]
#32 Mr. Spell. apprehens r = MOOList [ "i", "", [ "apprehensive", "apprehension" ] ]
#32 Mr. Spell. cover r = MOOList [ "", "a", [ "covering", "covered", "covert", "coverlet", "cover" ] ]
#32 Mr. Spell. slov r = MOOList [ "", "e", [ "Slovakia" ] ]
#32 Mr. Spell. Egy r = MOOList [ "pt", "", [ "Egyptian", "Egypt" ] ]
#32 Mr. Spell. steph r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. slow r = MOOList [ "", "", [ "slowdown", "slow" ] ]
#32 Mr. Spell. covet r = MOOList [ "", "", [ "covetous", "covet" ] ]
#32 Mr. Spell. edito r = MOOList [ "r", "", [ "editors", "editorial", "editor" ] ]
#32 Mr. Spell. torp r = MOOList [ "", "", [ "torpor", "torpid", "torpedo" ] ]
#32 Mr. Spell. steno r = MOOList [ "", "g", [ "stenotype" ] ]
#32 Mr. Spell. toro r = MOOList [ "", "i", [ "Toronto" ] ]
#32 Mr. Spell. slop r = MOOList [ "", "", [ "sloppy", "slope", "slop" ] ]
#32 Mr. Spell. tort r = MOOList [ "", "ou", [ "tort" ] ]
#32 Mr. Spell. gimb r = MOOList [ "", "", [ "Gimbel", "gimbal" ] ]
#32 Mr. Spell. etho r = MOOList [ "", "", [ "ethos", "ethology" ] ]
#32 Mr. Spell. tors r = MOOList [ "", "", [ "torso", "torsion" ] ]
#32 Mr. Spell. Finl r = MOOList [ "", "", [ "Finley", "Finland" ] ]
#32 Mr. Spell. slot r = MOOList [ "", "h", [ "slot" ] ]
#32 Mr. Spell. slou r = MOOList [ "", "", [ "slough", "slouch" ] ]
#32 Mr. Spell. Finn r = MOOList [ "", "", [ "finny", "Finnish", "Finnegan", "Finn" ] ]
#32 Mr. Spell. ethn r = MOOList [ "", "o", [ "ethnic" ] ]
#32 Mr. Spell. granula r = MOOList [ "", "", [ "granulate", "granular" ] ]
#32 Mr. Spell. slog r = MOOList [ "", "a", [ "slogging", "slog" ] ]
#32 Mr. Spell. gla r = MOOList [ "", "cdmnsu", [ "glaze", "glare" ] ]
#32 Mr. Spell. torn r = MOOList [ "", "", [ "tornado", "torn" ] ]
#32 Mr. Spell. marks r = MOOList [ "m", "", [ "marksmen", "marksman" ] ]
#32 Mr. Spell. rill r = MOOList [ "", "", [ "rilly", "rill" ] ]
#32 Mr. Spell. Malon r = MOOList [ "e", "", [ "Maloney", "Malone" ] ]
#32 Mr. Spell. sloa r = MOOList [ "n", "", [ "Sloane", "Sloan" ] ]
#32 Mr. Spell. palladia r = MOOList [ "", "", [ "Palladian", "palladia" ] ]
#32 Mr. Spell. sportswrite r = MOOList [ "", "", [ "sportswriter", "sportswrite" ] ]
#32 Mr. Spell. grands r = MOOList [ "", "", [ "grandstand", "grandson" ] ]
#32 Mr. Spell. grandp r = MOOList [ "a", "", [ "grandparent", "grandpa" ] ]
#32 Mr. Spell. Houg r = MOOList [ "h", "", [ "Houghton", "hough" ] ]
#32 Mr. Spell. grandn r = MOOList [ "", "", [ "grandniece", "grandnephew" ] ]
#32 Mr. Spell. extol r = MOOList [ "", "l", [ "extol" ] ]
#32 Mr. Spell. ethe r = MOOList [ "", "r", [ "Ethel" ] ]
#32 Mr. Spell. grandm r = MOOList [ "", "", [ "grandmother", "grandma" ] ]
#32 Mr. Spell. glu r = MOOList [ "", "et", [ "glum", "glucose" ] ]
#32 Mr. Spell. Eis r = MOOList [ "", "", [ "Eisner", "Eisenhower" ] ]
#32 Mr. Spell. coch r = MOOList [ "", "r", [ "cochlea", "cochineal" ] ]
#32 Mr. Spell. vexa r = MOOList [ "tio", "", [ "vexatious", "vexation" ] ]
#32 Mr. Spell. chore r = MOOList [ "", "o", [ "chore" ] ]
#32 Mr. Spell. volcani r = MOOList [ "", "", [ "volcanism", "volcanic" ] ]
#32 Mr. Spell. chord r = MOOList [ "", "a", [ "chord" ] ]
#32 Mr. Spell. gly r = MOOList [ "", "c", [ "glyph" ] ]
#32 Mr. Spell. Ein r = MOOList [ "stein", "i", [ "Einstein" ] ]
#32 Mr. Spell. cock r = MOOList [ "", "l", [ "cocky", "cocktail", "cocksure", "cockroach", "cockpit", "cockeye", "cockcrow", "cockatoo", "cock" ] ]
#32 Mr. Spell. chora r = MOOList [ "l", "", [ "chorale", "choral" ] ]
#32 Mr. Spell. coco r = MOOList [ "", "", [ "cocoon", "coconut", "cocoa", "coco" ] ]
#32 Mr. Spell. Albe r = MOOList [ "", "r", [ "albeit" ] ]
#32 Mr. Spell. suppressi r = MOOList [ "", "", [ "suppression", "suppressible" ] ]
#32 Mr. Spell. gle r = MOOList [ "", "aen", [ ] ]
#32 Mr. Spell. nobe r = MOOList [ "l", "", [ "nobelium", "Nobel" ] ]
#32 Mr. Spell. Gustav r = MOOList [ "", "", [ "Gustavus", "Gustave", "Gustav" ] ]
#32 Mr. Spell. experim r = MOOList [ "ent", "", [ "experimentation", "experiment" ] ]
#32 Mr. Spell. nobo r = MOOList [ "dy", "", [ "nobody'd", "nobody" ] ]
#32 Mr. Spell. Albr r = MOOList [ "", "", [ "Albright", "Albrecht" ] ]
#32 Mr. Spell. glo r = MOOList [ "", "bmorst", [ "glow", "glove", "Gloucester", "gloat" ] ]
#32 Mr. Spell. coca r = MOOList [ "", "", [ "cocaine", "coca" ] ]
#32 Mr. Spell. experie r = MOOList [ "n", "c", [ "experiential" ] ]
#32 Mr. Spell. nobl r = MOOList [ "e", "m", [ "noblesse", "noble" ] ]
#32 Mr. Spell. Palla r = MOOList [ "di", "a", [ "palladium" ] ]
#32 Mr. Spell. usur r = MOOList [ "", "p", [ "usury", "usurious", "usurer" ] ]
#32 Mr. Spell. smoo r = MOOList [ "", "t", [ "smooch" ] ]
#32 Mr. Spell. escap r = MOOList [ "", "e", [ "escapade" ] ]
#32 Mr. Spell. brass r = MOOList [ "", "", [ "brassy", "brassiere", "brass" ] ]
#32 Mr. Spell. belon r = MOOList [ "g", "", [ "belonging", "belong" ] ]
#32 Mr. Spell. gna r = MOOList [ "", "", [ "gnaw", "gnat", "gnash", "gnarl" ] ]
#32 Mr. Spell. smok r = MOOList [ "", "e", [ "smoky" ] ]
#32 Mr. Spell. dres r = MOOList [ "s", "", [ "dressy", "dressmake", "dress" ] ]
#32 Mr. Spell. Alab r = MOOList [ "a", "m", [ "alabaster" ] ]
#32 Mr. Spell. coax r = MOOList [ "", "", [ "coaxial", "coax" ] ]
#32 Mr. Spell. usua r = MOOList [ "l", "", [ "usually", "usual" ] ]
#32 Mr. Spell. orde r = MOOList [ "", "r", [ "ordeal" ] ]
#32 Mr. Spell. Alam r = MOOList [ "", "", [ "Alamo", "Alameda" ] ]
#32 Mr. Spell. drea r = MOOList [ "", "dm", [ "dreary" ] ]
#32 Mr. Spell. ascend r = MOOList [ "", "", [ "ascendant", "ascend" ] ]
#32 Mr. Spell. crystall r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. cobb r = MOOList [ "", "l", [ "Cobb" ] ]
#32 Mr. Spell. ordi r = MOOList [ "na", "", [ "ordinate", "ordinary", "ordinance", "ordinal" ] ]
#32 Mr. Spell. dact r = MOOList [ "yl", "", [ "dactylic", "dactyl" ] ]
#32 Mr. Spell. incorr r = MOOList [ "", "", [ "incorruptible", "incorrigible", "incorrect" ] ]
#32 Mr. Spell. Cushi r = MOOList [ "", "", [ "cushion", "Cushing" ] ]
#32 Mr. Spell. obliga r = MOOList [ "t", "", [ "obligatory", "obligate" ] ]
#32 Mr. Spell. coag r = MOOList [ "ula", "", [ "coagulate", "coagulable" ] ]
#32 Mr. Spell. coal r = MOOList [ "", "e", [ "coalition", "coal" ] ]
#32 Mr. Spell. psycho r = MOOList [ "", "apst", [ "psychometry", "psychology", "psychobiology", "psycho" ] ]
#32 Mr. Spell. number r = MOOList [ "", "", [ "numbers", "number" ] ]
#32 Mr. Spell. goa r = MOOList [ "", "", [ "goat", "goal", "goad", "Goa" ] ]
#32 Mr. Spell. gob r = MOOList [ "", "b", [ "goblet", "gob" ] ]
#32 Mr. Spell. brigad r = MOOList [ "", "", [ "brigadier", "brigade" ] ]
#32 Mr. Spell. coar r = MOOList [ "se", "", [ "coarsen", "coarse" ] ]
#32 Mr. Spell. gog r = MOOList [ "", "", [ "gogo", "Gogh", "goggle", "gog" ] ]
#32 Mr. Spell. coas r = MOOList [ "t", "", [ "coastline", "coastal", "coast" ] ]
#32 Mr. Spell. Ele r = MOOList [ "", "acgmpv", [ "Elena" ] ]
#32 Mr. Spell. theore r = MOOList [ "", "t", [ "theorem" ] ]
#32 Mr. Spell. Ela r = MOOList [ "", "s", [ "elate", "elapse", "elan", "Elaine", "elaborate" ] ]
#32 Mr. Spell. brave r = MOOList [ "", "", [ "bravery", "brave" ] ]
#32 Mr. Spell. oppos r = MOOList [ "", "i", [ "oppose", "opposable" ] ]
#32 Mr. Spell. gno r = MOOList [ "", "m", [ "gnostic" ] ]
#32 Mr. Spell. troubles r = MOOList [ "", "", [ "troublesome", "troubleshoot" ] ]
#32 Mr. Spell. stimula r = MOOList [ "", "t", [ "stimulant" ] ]
#32 Mr. Spell. psychi r = MOOList [ "", "a", [ "psychic" ] ]
#32 Mr. Spell. incorp r = MOOList [ "ora", "", [ "incorporate", "incorporable" ] ]
#32 Mr. Spell. comman r = MOOList [ "d", "", [ "commando", "commandeer", "commandant", "command" ] ]
#32 Mr. Spell. coac r = MOOList [ "h", "m", [ "coachwork", "coach" ] ]
#32 Mr. Spell. visit r = MOOList [ "", "", [ "visitor", "visitation", "visit" ] ]
#32 Mr. Spell. Els r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. radioch r = MOOList [ "emi", "", [ "radiochemistry", "radiochemical" ] ]
#32 Mr. Spell. involve r = MOOList [ "", "", [ "involved", "involve" ] ]
#32 Mr. Spell. Martini r = MOOList [ "", "", [ "Martinique", "martini" ] ]
#32 Mr. Spell. estab r = MOOList [ "lish", "", [ "establishing", "established", "establish" ] ]
#32 Mr. Spell. exami r = MOOList [ "n", "", [ "examine", "examination" ] ]
#32 Mr. Spell. Elm r = MOOList [ "", "", [ "Elmsford", "Elmira", "Elmhurst", "Elmer", "elm" ] ]
#32 Mr. Spell. Ell r = MOOList [ "", "i", [ "Ellwood", "Ellsworth", "Ellen", "Ella", "ell" ] ]
#32 Mr. Spell. Elk r = MOOList [ "", "", [ "Elkhart", "elk" ] ]
#32 Mr. Spell. visio r = MOOList [ "n", "", [ "visionary", "vision" ] ]
#32 Mr. Spell. forme r = MOOList [ "", "", [ "former", "formed" ] ]
#32 Mr. Spell. Jewe r = MOOList [ "", "l", [ "Jewett" ] ]
#32 Mr. Spell. Spro r = MOOList [ "", "u", [ "sprocket" ] ]
#32 Mr. Spell. stubb r = MOOList [ "", "", [ "stubby", "stubborn", "stubble" ] ]
#32 Mr. Spell. examp r = MOOList [ "le", "", [ "examples", "example" ] ]
#32 Mr. Spell. psychoanalys r = MOOList [ "", "", [ "psychoanalyst", "psychoanalysis" ] ]
#32 Mr. Spell. quarter r = MOOList [ "", "", [ "quartermaster", "quarterback" ] ]
#32 Mr. Spell. kalei r = MOOList [ "d", "", [ "kaleidoscope", "kaleidescope" ] ]
#32 Mr. Spell. involut r = MOOList [ "", "", [ "involutorial", "involution", "involute" ] ]
#32 Mr. Spell. gon r = MOOList [ "", "z", [ "gong", "gone", "gondola" ] ]
#32 Mr. Spell. goo r = MOOList [ "", "dfs", [ "goober" ] ]
#32 Mr. Spell. gop r = MOOList [ "", "", [ "gopher", "GOP" ] ]
#32 Mr. Spell. estat r = MOOList [ "e", "", [ "estates", "estate" ] ]
#32 Mr. Spell. vete r = MOOList [ "r", "i", [ "veteran" ] ]
#32 Mr. Spell. Creo r = MOOList [ "", "", [ "creosote", "Creon", "Creole" ] ]
#32 Mr. Spell. axiom r = MOOList [ "", "", [ "axiomatic", "axiom" ] ]
#32 Mr. Spell. gos r = MOOList [ "", "hs", [ "gospel", "gosling" ] ]
#32 Mr. Spell. orbi r = MOOList [ "t", "", [ "orbital", "orbit" ] ]
#32 Mr. Spell. formu r = MOOList [ "la", "", [ "formulate", "formulaic", "formulae", "formula" ] ]
#32 Mr. Spell. Ely r = MOOList [ "", "s", [ "Ely" ] ]
#32 Mr. Spell. Cret r = MOOList [ "", "ai", [ "Crete" ] ]
#32 Mr. Spell. gov r = MOOList [ "ern", "", [ "government", "governor", "governess", "governance", "govern" ] ]
#32 Mr. Spell. keto r = MOOList [ "", "", [ "ketosis", "ketone" ] ]
#32 Mr. Spell. faile r = MOOList [ "", "", [ "failer", "failed" ] ]
#32 Mr. Spell. orat r = MOOList [ "", "o", [ "orate" ] ]
#32 Mr. Spell. fortu r = MOOList [ "", "n", [ "fortuitous" ] ]
#32 Mr. Spell. oran r = MOOList [ "g", "e", [ "orangutan" ] ]
#32 Mr. Spell. Emo r = MOOList [ "", "", [ "emotion", "Emory", "emolument" ] ]
#32 Mr. Spell. vest r = MOOList [ "", "i", [ "vestry", "vestal", "vest" ] ]
#32 Mr. Spell. Emm r = MOOList [ "", "a", [ "Emmett" ] ]
#32 Mr. Spell. conservato r = MOOList [ "r", "", [ "conservatory", "conservator" ] ]
#32 Mr. Spell. fortr r = MOOList [ "", "", [ "fortress", "fortran" ] ]
#32 Mr. Spell. Lacer r = MOOList [ "", "", [ "Lacerta", "lacerate" ] ]
#32 Mr. Spell. faili r = MOOList [ "ng", "", [ "failings", "failing" ] ]
#32 Mr. Spell. kett r = MOOList [ "", "", [ "kettle", "Kettering" ] ]
#32 Mr. Spell. fails r = MOOList [ "", "", [ "failsoft", "failsafe", "fails" ] ]
#32 Mr. Spell. islam r = MOOList [ "", "", [ "Islamic", "Islamabad", "Islam" ] ]
#32 Mr. Spell. draw r = MOOList [ "", "b", [ "drawn", "drawl", "draw" ] ]
#32 Mr. Spell. ketc r = MOOList [ "h", "", [ "ketchup", "ketch" ] ]
#32 Mr. Spell. geoph r = MOOList [ "ysic", "", [ "geophysics", "geophysical" ] ]
#32 Mr. Spell. draf r = MOOList [ "t", "s", [ "drafty", "draftee", "draft" ] ]
#32 Mr. Spell. drai r = MOOList [ "n", "", [ "drainage", "drain" ] ]
#32 Mr. Spell. gra r = MOOList [ "", "cdfimnpstvyz", [ "graham", "grab" ] ]
#32 Mr. Spell. drag r = MOOList [ "", "o", [ "dragnet", "dragging", "drag" ] ]
#32 Mr. Spell. dram r = MOOList [ "", "a", [ "dram" ] ]
#32 Mr. Spell. gre r = MOOList [ "", "aegnty", [ "grew", "Gresham", "gremlin", "Grecian", "grebe" ] ]
#32 Mr. Spell. vert r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. gri r = MOOList [ "", "deflmnpstz", [ ] ]
#32 Mr. Spell. drap r = MOOList [ "e", "", [ "drapery", "drape" ] ]
#32 Mr. Spell. verm r = MOOList [ "", "io", [ "vermeil" ] ]
#32 Mr. Spell. conservati r = MOOList [ "", "", [ "conservative", "conservatism", "conservation" ] ]
#32 Mr. Spell. vern r = MOOList [ "", "a", [ "Vernon", "vernier", "Verne" ] ]
#32 Mr. Spell. forth r = MOOList [ "", "", [ "forthwith", "forthright", "forthcome", "forth" ] ]
#32 Mr. Spell. forti r = MOOList [ "", "", [ "fortitude", "fortiori", "fortin", "fortify", "fortieth" ] ]
#32 Mr. Spell. stude r = MOOList [ "", "", [ "student", "Studebaker" ] ]
#32 Mr. Spell. puck r = MOOList [ "", "", [ "puckish", "puck" ] ]
#32 Mr. Spell. intuiti r = MOOList [ "", "", [ "intuitive", "intuition" ] ]
#32 Mr. Spell. cockl r = MOOList [ "e", "", [ "cockleshell", "cocklebur", "cockle" ] ]
#32 Mr. Spell. Hornbl r = MOOList [ "", "", [ "Hornblower", "hornblende" ] ]
#32 Mr. Spell. veri r = MOOList [ "", "t", [ "verisimilitude", "verify", "veridic" ] ]
#32 Mr. Spell. Stapl r = MOOList [ "e", "", [ "Stapleton", "staple" ] ]
#32 Mr. Spell. studi r = MOOList [ "o", "", [ "studious", "studio" ] ]
#32 Mr. Spell. epiphy r = MOOList [ "s", "", [ "epiphysis", "epiphyseal" ] ]
#32 Mr. Spell. sidew r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. testa r = MOOList [ "", "m", [ "testate" ] ]
#32 Mr. Spell. kern r = MOOList [ "", "", [ "Kernighan", "kernel", "kern" ] ]
#32 Mr. Spell. vera r = MOOList [ "", "cn", [ "Vera" ] ]
#32 Mr. Spell. verb r = MOOList [ "", "ao", [ "verbiage", "verbena", "verb" ] ]
#32 Mr. Spell. Craw r = MOOList [ "", "l", [ "Crawford", "craw" ] ]
#32 Mr. Spell. competi r = MOOList [ "t", "i", [ "competitor" ] ]
#32 Mr. Spell. turbo r = MOOList [ "", "", [ "turbojet", "turbofan" ] ]
#32 Mr. Spell. leads r = MOOList [ "", "m", [ "leads" ] ]
#32 Mr. Spell. compete r = MOOList [ "", "", [ "competent", "compete" ] ]
#32 Mr. Spell. turbi r = MOOList [ "", "dn", [ ] ]
#32 Mr. Spell. kerr r = MOOList [ "", "", [ "kerry", "Kerr" ] ]
#32 Mr. Spell. Ephes r = MOOList [ "", "", [ "Ephesus", "Ephesian" ] ]
#32 Mr. Spell. germin r = MOOList [ "a", "", [ "germinate", "germinal" ] ]
#32 Mr. Spell. commen r = MOOList [ "", "dst", [ ] ]
#32 Mr. Spell. gro r = MOOList [ "", "acostuvw", [ "grope", "grommet", "groin", "groggy" ] ]
#32 Mr. Spell. leade r = MOOList [ "", "r", [ "leadeth", "leaden" ] ]
#32 Mr. Spell. publ r = MOOList [ "i", "c", [ "publish" ] ]
#32 Mr. Spell. testi r = MOOList [ "", "cm", [ "testify" ] ]
#32 Mr. Spell. gru r = MOOList [ "", "bm", [ "grunt", "gruff", "gruesome", "grudge" ] ]
#32 Mr. Spell. rebell r = MOOList [ "", "i", [ "rebelled" ] ]
#32 Mr. Spell. forsa r = MOOList [ "ke", "", [ "forsaken", "forsake" ] ]
#32 Mr. Spell. germic r = MOOList [ "id", "", [ "germicide", "germicidal" ] ]
#32 Mr. Spell. Spoi r = MOOList [ "l", "", [ "spoilage", "spoil" ] ]
#32 Mr. Spell. smit r = MOOList [ "", "h", [ "smitten" ] ]
#32 Mr. Spell. Ephem r = MOOList [ "er", "i", [ "ephemeral" ] ]
#32 Mr. Spell. pube r = MOOList [ "", "", [ "pubescent", "puberty" ] ]
#32 Mr. Spell. commer r = MOOList [ "c", "", [ "commercial", "commerce" ] ]
#32 Mr. Spell. regressi r = MOOList [ "", "", [ "regressive", "regression" ] ]
#32 Mr. Spell. topol r = MOOList [ "og", "", [ "topology", "topologize" ] ]
#32 Mr. Spell. capita r = MOOList [ "", "", [ "capital", "capita" ] ]
#32 Mr. Spell. Eps r = MOOList [ "", "", [ "Epstein", "Epsom", "epsilon" ] ]
#32 Mr. Spell. sideb r = MOOList [ "", "", [ "sideboard", "sideband" ] ]
#32 Mr. Spell. Strom r = MOOList [ "", "", [ "Stromberg", "Strom" ] ]
#32 Mr. Spell. andesi r = MOOList [ "", "", [ "andesite", "andesine" ] ]
#32 Mr. Spell. Leona r = MOOList [ "", "r", [ "Leona" ] ]
#32 Mr. Spell. sidel r = MOOList [ "", "i", [ "sidelong" ] ]
#32 Mr. Spell. sidem r = MOOList [ "", "", [ "sidemen", "sideman" ] ]
#32 Mr. Spell. Cram r = MOOList [ "", "", [ "cramp", "Cramer", "cram" ] ]
#32 Mr. Spell. Bantu r = MOOList [ "", "", [ "Bantus", "Bantu" ] ]
#32 Mr. Spell. sider r = MOOList [ "", "", [ "siderite", "sidereal" ] ]
#32 Mr. Spell. Jesu r = MOOList [ "", "", [ "Jesus", "Jesuit" ] ]
#32 Mr. Spell. sides r = MOOList [ "", "t", [ "sideshow", "sidesaddle" ] ]
#32 Mr. Spell. Cran r = MOOList [ "", "ik", [ "Cranston", "cranny", "Cranford", "crane", "Crandall", "cranberry" ] ]
#32 Mr. Spell. gua r = MOOList [ "", "nr", [ "Guatemala", "Guam" ] ]
#32 Mr. Spell. Jere r = MOOList [ "", "m", [ "Jeres" ] ]
#32 Mr. Spell. gui r = MOOList [ "", "dl", [ "guitar", "guise", "guinea", "guignol", "Guiana" ] ]
#32 Mr. Spell. dilut r = MOOList [ "", "", [ "dilution", "dilute" ] ]
#32 Mr. Spell. economic r = MOOList [ "", "", [ "economics", "economic" ] ]
#32 Mr. Spell. geodes r = MOOList [ "", "", [ "geodesy", "geodesic" ] ]
#32 Mr. Spell. inflamm r = MOOList [ "a", "t", [ "inflammable" ] ]
#32 Mr. Spell. gul r = MOOList [ "", "l", [ "gulp", "gulf", "gules" ] ]
#32 Mr. Spell. gum r = MOOList [ "", "", [ "gumshoe", "gumption", "gummy", "gumdrop", "gumbo", "gum" ] ]
#32 Mr. Spell. aggressi r = MOOList [ "", "", [ "aggressive", "aggression" ] ]
#32 Mr. Spell. Eri r = MOOList [ "", "c", [ "Erik", "Erie" ] ]
#32 Mr. Spell. Jero r = MOOList [ "", "", [ "Jerome", "Jeroboam" ] ]
#32 Mr. Spell. Isol r = MOOList [ "", "", [ "Isolde", "isolate" ] ]
#32 Mr. Spell. flint r = MOOList [ "", "", [ "flinty", "flintlock", "flint" ] ]
#32 Mr. Spell. wavel r = MOOList [ "e", "", [ "wavelet", "wavelength" ] ]
#32 Mr. Spell. visco r = MOOList [ "", "u", [ "viscosity", "viscometer", "viscoelastic" ] ]
#32 Mr. Spell. millen r = MOOList [ "", "n", [ "millenia", "millenarian" ] ]
#32 Mr. Spell. visce r = MOOList [ "ra", "", [ "visceral", "viscera" ] ]
#32 Mr. Spell. Ers r = MOOList [ "", "", [ "Erskine", "ersatz" ] ]
#32 Mr. Spell. veno r = MOOList [ "", "m", [ "venous" ] ]
#32 Mr. Spell. humidi r = MOOList [ "", "", [ "humidistat", "humidify" ] ]
#32 Mr. Spell. Ern r = MOOList [ "", "e", [ "Ernst", "Ernie" ] ]
#32 Mr. Spell. vent r = MOOList [ "", "u", [ "ventricle", "ventilate", "vent" ] ]
#32 Mr. Spell. canter r = MOOList [ "", "", [ "canterelle", "Canterbury" ] ]
#32 Mr. Spell. handb r = MOOList [ "", "", [ "handbook", "handbag" ] ]
#32 Mr. Spell. veng r = MOOList [ "e", "", [ "vengeful", "vengeance" ] ]
#32 Mr. Spell. psychoth r = MOOList [ "erap", "", [ "psychotherapy", "psychotherapist", "psychotherapeutic" ] ]
#32 Mr. Spell. gus r = MOOList [ "", "t", [ "gusset", "gush", "Gus" ] ]
#32 Mr. Spell. handc r = MOOList [ "", "", [ "handcuff", "handclasp" ] ]
#32 Mr. Spell. wavef r = MOOList [ "", "", [ "wavefront", "waveform" ] ]
#32 Mr. Spell. handi r = MOOList [ "", "c", [ "handiwork" ] ]
#32 Mr. Spell. Esc r = MOOList [ "", "ahr", [ "escutcheon", "escort" ] ]
#32 Mr. Spell. vene r = MOOList [ "", "rt", [ "Venezuela", "veneer" ] ]
#32 Mr. Spell. handm r = MOOList [ "a", "", [ "handmaiden", "handmade" ] ]
#32 Mr. Spell. vend r = MOOList [ "", "", [ "vendor", "vendible", "vendetta", "vend" ] ]
#32 Mr. Spell. handl r = MOOList [ "", "e", [ "handline" ] ]
#32 Mr. Spell. upstat r = MOOList [ "e", "", [ "upstater", "upstate" ] ]
#32 Mr. Spell. hands r = MOOList [ "", "", [ "handstand", "handspike", "handsome", "handshake", "handset", "hands" ] ]
#32 Mr. Spell. handy r = MOOList [ "", "m", [ "handy" ] ]
#32 Mr. Spell. lyse r = MOOList [ "", "", [ "lysergic", "Lysenko" ] ]
#32 Mr. Spell. handw r = MOOList [ "", "r", [ "handwaving" ] ]
#32 Mr. Spell. Ess r = MOOList [ "", "e", [ "essay" ] ]
#32 Mr. Spell. triple r = MOOList [ "", "t", [ "triplex", "triple" ] ]
#32 Mr. Spell. commis r = MOOList [ "", "s", [ "commiserate" ] ]
#32 Mr. Spell. white r = MOOList [ "", "h", [ "whitewash", "whitetail", "whiten", "whiteface", "white" ] ]
#32 Mr. Spell. commit r = MOOList [ "", "t", [ "commit" ] ]
#32 Mr. Spell. illegit r = MOOList [ "ima", "", [ "illegitimate", "illegitimacy" ] ]
#32 Mr. Spell. smel r = MOOList [ "", "l", [ "smelt" ] ]
#32 Mr. Spell. bright r = MOOList [ "", "", [ "Brighton", "brighten", "bright" ] ]
#32 Mr. Spell. velv r = MOOList [ "et", "", [ "velvety", "velvet" ] ]
#32 Mr. Spell. exponenti r = MOOList [ "a", "", [ "exponentiate", "exponential" ] ]
#32 Mr. Spell. velo r = MOOList [ "", "", [ "velours", "velocity" ] ]
#32 Mr. Spell. whoo r = MOOList [ "", "", [ "whoosh", "whoop" ] ]
#32 Mr. Spell. whos r = MOOList [ "", "", [ "whosoever", "whose" ] ]
#32 Mr. Spell. Eul r = MOOList [ "", "e", [ "eulogy" ] ]
#32 Mr. Spell. whol r = MOOList [ "", "e", [ "wholly" ] ]
#32 Mr. Spell. whom r = MOOList [ "", "", [ "whomsoever", "whomever", "whom" ] ]
#32 Mr. Spell. vell r = MOOList [ "", "", [ "vellum", "Vella" ] ]
#32 Mr. Spell. Paleo r = MOOList [ "", "", [ "Paleozoic", "Paleolithic" ] ]
#32 Mr. Spell. Eug r = MOOList [ "en", "i", [ "Eugene" ] ]
#32 Mr. Spell. deposito r = MOOList [ "r", "", [ "depository", "depositor" ] ]
#32 Mr. Spell. Apple r = MOOList [ "", "", [ "Appleton", "applejack", "Appleby", "apple" ] ]
#32 Mr. Spell. Euc r = MOOList [ "", "l", [ "eucre", "Eucharist", "eucalyptus" ] ]
#32 Mr. Spell. vela r = MOOList [ "", "", [ "Velasquez", "velar" ] ]
#32 Mr. Spell. Nichols r = MOOList [ "", "", [ "Nicholson", "Nichols" ] ]
#32 Mr. Spell. gym r = MOOList [ "", "n", [ "gym" ] ]
#32 Mr. Spell. Eut r = MOOList [ "", "e", [ "euthanasia" ] ]
#32 Mr. Spell. contenti r = MOOList [ "o", "", [ "contentious", "contention" ] ]
#32 Mr. Spell. gyp r = MOOList [ "", "s", [ "gyp" ] ]
#32 Mr. Spell. kell r = MOOList [ "", "e", [ "kelly", "Kellogg" ] ]
#32 Mr. Spell. Polyhe r = MOOList [ "dr", "a", [ "polyhedron" ] ]
#32 Mr. Spell. cotta r = MOOList [ "", "", [ "cottage", "cotta" ] ]
#32 Mr. Spell. Eve r = MOOList [ "", "nr", [ "Evelyn", "eve" ] ]
#32 Mr. Spell. Jenn r = MOOList [ "", "i", [ "jenny" ] ]
#32 Mr. Spell. gunfi r = MOOList [ "", "", [ "gunfire", "gunfight" ] ]
#32 Mr. Spell. episcopal r = MOOList [ "", "", [ "Episcopalian", "episcopal" ] ]
#32 Mr. Spell. cotto r = MOOList [ "n", "", [ "cottony", "cottonwood", "cottonseed", "cottonmouth", "cotton" ] ]
#32 Mr. Spell. Atroph r = MOOList [ "", "", [ "atrophy", "atrophic" ] ]
#32 Mr. Spell. deterr r = MOOList [ "", "e", [ "deterring" ] ]
#32 Mr. Spell. estop r = MOOList [ "", "", [ "estoppal", "estop" ] ]
#32 Mr. Spell. Stric r = MOOList [ "", "kt", [ ] ]
#32 Mr. Spell. psychoph r = MOOList [ "ysi", "", [ "psychophysiology", "psychophysic" ] ]
#32 Mr. Spell. gyr r = MOOList [ "", "o", [ "gyrfalcon", "gyrate" ] ]
#32 Mr. Spell. who' r = MOOList [ "", "", [ "who'll", "who'd", "who've" ] ]
#32 Mr. Spell. psychopa r = MOOList [ "th", "", [ "psychopathic", "psychopath" ] ]
#32 Mr. Spell. determ r = MOOList [ "in", "a", [ "determine" ] ]
#32 Mr. Spell. fucke r = MOOList [ "", "", [ "fucker", "fucked" ] ]
#32 Mr. Spell. illegi r = MOOList [ "", "t", [ "illegible" ] ]
#32 Mr. Spell. heaven r = MOOList [ "", "", [ "heavenward", "heaven" ] ]
#32 Mr. Spell. budget r = MOOList [ "", "", [ "budgetary", "budget" ] ]
#32 Mr. Spell. honora r = MOOList [ "r", "i", [ "honorary" ] ]
#32 Mr. Spell. cancel r = MOOList [ "", "l", [ "cancel" ] ]
#32 Mr. Spell. plagia r = MOOList [ "ris", "", [ "plagiarist", "plagiarism" ] ]
#32 Mr. Spell. Midwe r = MOOList [ "", "s", [ "midweek" ] ]
#32 Mr. Spell. cancer r = MOOList [ "", "", [ "cancerous", "cancer" ] ]
#32 Mr. Spell. remedi r = MOOList [ "a", "", [ "remedial", "remediable" ] ]
#32 Mr. Spell. lymp r = MOOList [ "h", "o", [ "lymph" ] ]
#32 Mr. Spell. Columbi r = MOOList [ "", "", [ "columbine", "Columbia" ] ]
#32 Mr. Spell. oppre r = MOOList [ "ss", "i", [ "oppressor", "oppress" ] ]
#32 Mr. Spell. vehi r = MOOList [ "c", "", [ "vehicular", "vehicle" ] ]
#32 Mr. Spell. Isin r = MOOList [ "g", "", [ "isinglass", "Ising" ] ]
#32 Mr. Spell. Spen r = MOOList [ "", "cd", [ "spent" ] ]
#32 Mr. Spell. inflati r = MOOList [ "on", "", [ "inflation", "inflationary" ] ]
#32 Mr. Spell. inflate r = MOOList [ "", "", [ "inflater", "inflate" ] ]
#32 Mr. Spell. trick r = MOOList [ "", "", [ "tricky", "trickster", "trickle", "trickery", "trick" ] ]
#32 Mr. Spell. lime r = MOOList [ "", "", [ "limestone", "Limerick", "limelight", "lime" ] ]
#32 Mr. Spell. trich r = MOOList [ "", "l", [ "trichrome", "Trichinella" ] ]
#32 Mr. Spell. shame r = MOOList [ "", "f", [ "shame" ] ]
#32 Mr. Spell. nose r = MOOList [ "", "b", [ "nose" ] ]
#32 Mr. Spell. limb r = MOOList [ "", "", [ "limbo", "limbic", "limb" ] ]
#32 Mr. Spell. commod r = MOOList [ "", "i", [ "commodore" ] ]
#32 Mr. Spell. daup r = MOOList [ "hin", "", [ "dauphine", "dauphin" ] ]
#32 Mr. Spell. limi r = MOOList [ "t", "", [ "limits", "limiting", "limited", "limitate", "limit" ] ]
#32 Mr. Spell. attrib r = MOOList [ "ut", "i", [ "attribute" ] ]
#32 Mr. Spell. common r = MOOList [ "", "w", [ "commonplace", "commonality", "common" ] ]
#32 Mr. Spell. please r = MOOList [ "", "", [ "pleased", "please" ] ]
#32 Mr. Spell. woody r = MOOList [ "", "", [ "woodyard", "woody" ] ]
#32 Mr. Spell. wild r = MOOList [ "", "c", [ "wildlife", "wildfire", "wilderness", "wild" ] ]
#32 Mr. Spell. snap r = MOOList [ "", "p", [ "snapshot", "snapdragon", "snapback", "snap" ] ]
#32 Mr. Spell. snar r = MOOList [ "", "", [ "snarl", "snark", "snare" ] ]
#32 Mr. Spell. woodw r = MOOList [ "", "", [ "woodwork", "woodwind", "Woodward" ] ]
#32 Mr. Spell. wilf r = MOOList [ "", "", [ "wilful", "Wilfred" ] ]
#32 Mr. Spell. great r = MOOList [ "", "", [ "greater", "greatcoat", "great" ] ]
#32 Mr. Spell. embar r = MOOList [ "", "g", [ "embarrass", "embark", "embarcadero" ] ]
#32 Mr. Spell. greas r = MOOList [ "", "", [ "greasy", "grease" ] ]
#32 Mr. Spell. cosm r = MOOList [ "", "o", [ "cosmic", "cosmetic" ] ]
#32 Mr. Spell. woodr r = MOOList [ "", "", [ "woodruff", "Woodrow" ] ]
#32 Mr. Spell. snag r = MOOList [ "", "", [ "snagging", "snag" ] ]
#32 Mr. Spell. woods r = MOOList [ "", "", [ "woodside", "woodshed", "Woods" ] ]
#32 Mr. Spell. snak r = MOOList [ "e", "", [ "snakeroot", "snakebird", "snake" ] ]
#32 Mr. Spell. daug r = MOOList [ "h", "", [ "daughter", "Daugherty" ] ]
#32 Mr. Spell. corv r = MOOList [ "", "", [ "Corvus", "corvette", "Corvallis" ] ]
#32 Mr. Spell. blow r = MOOList [ "", "", [ "blowup", "blown", "blowfish", "blow" ] ]
#32 Mr. Spell. wrongd r = MOOList [ "o", "", [ "wrongdoing", "wrongdoer", "wrongdo" ] ]
#32 Mr. Spell. valed r = MOOList [ "ict", "o", [ "valediction" ] ]
#32 Mr. Spell. fronta r = MOOList [ "", "", [ "frontal", "frontage" ] ]
#32 Mr. Spell. yac r = MOOList [ "ht", "s", [ "yacht" ] ]
#32 Mr. Spell. shall r = MOOList [ "", "o", [ "shall" ] ]
#32 Mr. Spell. lawma r = MOOList [ "", "", [ "lawman", "lawmake" ] ]
#32 Mr. Spell. valen r = MOOList [ "t", "", [ "valentine", "valent" ] ]
#32 Mr. Spell. tribu r = MOOList [ "", "nt", [ "tribulate" ] ]
#32 Mr. Spell. stupe r = MOOList [ "", "f", [ "stupendous" ] ]
#32 Mr. Spell. cose r = MOOList [ "", "", [ "coset", "cosec" ] ]
#32 Mr. Spell. aile r = MOOList [ "", "", [ "aileron", "aile" ] ]
#32 Mr. Spell. drug r = MOOList [ "", "", [ "drugstore", "drugging", "drug" ] ]
#32 Mr. Spell. drum r = MOOList [ "", "", [ "Drummond", "drumlin", "drumhead", "drum" ] ]
#32 Mr. Spell. cork r = MOOList [ "", "", [ "corkscrew", "cork" ] ]
#32 Mr. Spell. drun r = MOOList [ "k", "", [ "drunken", "drunkard", "drunk" ] ]
#32 Mr. Spell. coro r = MOOList [ "", "n", [ "coroutine", "corollary" ] ]
#32 Mr. Spell. blon r = MOOList [ "d", "", [ "blonde", "blond" ] ]
#32 Mr. Spell. corn r = MOOList [ "", "ef", [ "corny", "Cornwall", "cornucopia", "cornstarch", "cornmeal", "cornish", "cornbread", "corn" ] ]
#32 Mr. Spell. data r = MOOList [ "", "", [ "database", "data" ] ]
#32 Mr. Spell. corp r = MOOList [ "", "osu", [ "Corp" ] ]
#32 Mr. Spell. bloo r = MOOList [ "", "dm", [ "bloop" ] ]
#32 Mr. Spell. tribe r = MOOList [ "", "s", [ "tribe" ] ]
#32 Mr. Spell. corr r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. coru r = MOOList [ "", "", [ "coruscate", "corundum" ] ]
#32 Mr. Spell. blot r = MOOList [ "", "", [ "blotch", "blot" ] ]
#32 Mr. Spell. date r = MOOList [ "", "", [ "dates", "dater", "dateline", "date" ] ]
#32 Mr. Spell. cort r = MOOList [ "", "e", [ "Cortland", "cortical" ] ]
#32 Mr. Spell. orth r = MOOList [ "", "o", [ "orthicon", "orthant" ] ]
#32 Mr. Spell. Nath r = MOOList [ "an", "", [ "Nathaniel", "Nathan" ] ]
#32 Mr. Spell. Alpe r = MOOList [ "", "", [ "Alpert", "alpenstock" ] ]
#32 Mr. Spell. melod r = MOOList [ "", "ir", [ "melody" ] ]
#32 Mr. Spell. eyebr r = MOOList [ "", "", [ "eyebrow", "eyebright" ] ]
#32 Mr. Spell. dash r = MOOList [ "", "", [ "dashboard", "dash" ] ]
#32 Mr. Spell. turno r = MOOList [ "", "", [ "turnover", "turnout", "turnoff" ] ]
#32 Mr. Spell. script r = MOOList [ "", "u", [ "scription", "script" ] ]
#32 Mr. Spell. Nata r = MOOList [ "l", "", [ "Natalie", "natal" ] ]
#32 Mr. Spell. cora r = MOOList [ "l", "", [ "coralline", "coralberry", "coral" ] ]
#32 Mr. Spell. Princi r = MOOList [ "p", "", [ "principle", "Principia", "principal" ] ]
#32 Mr. Spell. drud r = MOOList [ "ge", "", [ "drudgery", "drudge" ] ]
#32 Mr. Spell. cord r = MOOList [ "", "i", [ "corduroy", "cordon", "cordage", "cord" ] ]
#32 Mr. Spell. turna r = MOOList [ "", "", [ "turnaround", "turnabout" ] ]
#32 Mr. Spell. traine r = MOOList [ "", "", [ "trainee", "trained" ] ]
#32 Mr. Spell. Mose r = MOOList [ "", "", [ "Moses", "Moser" ] ]
#32 Mr. Spell. uter r = MOOList [ "", "", [ "uterus", "uterine" ] ]
#32 Mr. Spell. Kimb r = MOOList [ "", "", [ "Kimberly", "Kimball" ] ]
#32 Mr. Spell. yan r = MOOList [ "", "k", [ "yang" ] ]
#32 Mr. Spell. destin r = MOOList [ "", "", [ "destiny", "destine", "destinate" ] ]
#32 Mr. Spell. yap r = MOOList [ "", "", [ "yapping", "yap" ] ]
#32 Mr. Spell. yar r = MOOList [ "", "dm", [ "yarrow", "yarn" ] ]
#32 Mr. Spell. turne r = MOOList [ "", "", [ "turnery", "turned" ] ]
#32 Mr. Spell. yaw r = MOOList [ "", "", [ "yawn", "yawl", "yaw" ] ]
#32 Mr. Spell. hai r = MOOList [ "", "lrt", [ "Haines", "haiku", "Haifa" ] ]
#32 Mr. Spell. Bore r = MOOList [ "", "a", [ "boredom", "bore" ] ]
#32 Mr. Spell. hal r = MOOList [ "", "efilosv", [ "halt", "Halpern", "halma", "halcyon", "Hal" ] ]
#32 Mr. Spell. Icel r = MOOList [ "and", "", [ "Icelandic", "iceland" ] ]
#32 Mr. Spell. copy r = MOOList [ "", "", [ "copywriter", "copyright", "copybook", "copy" ] ]
#32 Mr. Spell. darl r = MOOList [ "", "", [ "darling", "Darlene" ] ]
#32 Mr. Spell. Bori r = MOOList [ "", "", [ "Boris", "boric" ] ]
#32 Mr. Spell. linem r = MOOList [ "", "", [ "linemen", "lineman" ] ]
#32 Mr. Spell. hap r = MOOList [ "", "lp", [ "Hapsburg", "haphazard", "hap" ] ]
#32 Mr. Spell. dark r = MOOList [ "", "", [ "darkle", "darken", "dark" ] ]
#32 Mr. Spell. keybi r = MOOList [ "nding", "", [ "keybindings", "keybinding" ] ]
#32 Mr. Spell. har r = MOOList [ "", "abdelmprstv", [ "Harold", "harness", "hark", "Harcourt" ] ]
#32 Mr. Spell. Cata r = MOOList [ "", "lst", [ "catawba", "cataract", "catapult", "cataclysmic" ] ]
#32 Mr. Spell. woodc r = MOOList [ "", "", [ "woodcut", "woodcock", "woodcarver" ] ]
#32 Mr. Spell. has r = MOOList [ "", "ht", [ "hassle", "hasp", "hasn't", "has" ] ]
#32 Mr. Spell. programm r = MOOList [ "", "e", [ "programming", "programmable" ] ]
#32 Mr. Spell. hat r = MOOList [ "", "ceht", [ "hatred", "Hatfield", "hat" ] ]
#32 Mr. Spell. hau r = MOOList [ "", "gln", [ "Hausdorff" ] ]
#32 Mr. Spell. hav r = MOOList [ "", "ei", [ "havoc", "Havana" ] ]
#32 Mr. Spell. accusa r = MOOList [ "t", "i", [ "accusatory" ] ]
#32 Mr. Spell. Nash r = MOOList [ "", "", [ "Nashville", "Nashua", "Nash" ] ]
#32 Mr. Spell. shant r = MOOList [ "", "", [ "shanty", "Shantung" ] ]
#32 Mr. Spell. linea r = MOOList [ "", "", [ "linear", "lineal", "lineage" ] ]
#32 Mr. Spell. noon r = MOOList [ "", "", [ "noontime", "noon" ] ]
#32 Mr. Spell. Moro r = MOOList [ "", "c", [ "morose", "moron" ] ]
#32 Mr. Spell. hab r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. hac r = MOOList [ "", "k", [ "hacienda" ] ]
#32 Mr. Spell. educ r = MOOList [ "a", "t", [ "educable" ] ]
#32 Mr. Spell. copr r = MOOList [ "", "", [ "coproduct", "coprinus", "copra" ] ]
#32 Mr. Spell. trigo r = MOOList [ "n", "", [ "trigonometry", "trigonal" ] ]
#32 Mr. Spell. thread r = MOOList [ "", "", [ "threadbare", "thread" ] ]
#32 Mr. Spell. attach r = MOOList [ "", "", [ "attache", "attach" ] ]
#32 Mr. Spell. Brown r = MOOList [ "", "ei", [ "brown" ] ]
#32 Mr. Spell. algae r = MOOList [ "", "", [ "algaecide", "algae" ] ]
#32 Mr. Spell. lease r = MOOList [ "", "", [ "leasehold", "lease" ] ]
#32 Mr. Spell. hanga r = MOOList [ "", "", [ "hangar", "hangable" ] ]
#32 Mr. Spell. hereto r = MOOList [ "", "", [ "heretofore", "hereto" ] ]
#32 Mr. Spell. Wah r = MOOList [ "", "", [ "Wahl", "wah" ] ]
#32 Mr. Spell. haz r = MOOList [ "", "ae", [ "hazy" ] ]
#32 Mr. Spell. threat r = MOOList [ "", "", [ "threaten", "threat" ] ]
#32 Mr. Spell. putt r = MOOList [ "", "", [ "putty", "putt" ] ]
#32 Mr. Spell. Yard r = MOOList [ "", "", [ "yardstick", "yardage", "yard" ] ]
#32 Mr. Spell. cool r = MOOList [ "", "", [ "Coolidge", "coolheaded", "Cooley", "coolant", "cool" ] ]
#32 Mr. Spell. hangm r = MOOList [ "", "", [ "hangmen", "hangman" ] ]
#32 Mr. Spell. cook r = MOOList [ "", "e", [ "cooky", "cookie", "cookbook", "cook" ] ]
#32 Mr. Spell. valid r = MOOList [ "", "", [ "validate", "valid" ] ]
#32 Mr. Spell. diffic r = MOOList [ "ult", "", [ "difficulty", "difficult" ] ]
#32 Mr. Spell. coop r = MOOList [ "", "", [ "cooperate", "coop" ] ]
#32 Mr. Spell. Bora r = MOOList [ "", "", [ "borax", "borate" ] ]
#32 Mr. Spell. share r = MOOList [ "", "", [ "shares", "shareholder", "sharecrop", "share" ] ]
#32 Mr. Spell. hango r = MOOList [ "", "", [ "hangover", "hangout" ] ]
#32 Mr. Spell. decisio r = MOOList [ "n", "", [ "decisions", "decision" ] ]
#32 Mr. Spell. nonc r = MOOList [ "", "", [ "nonchalant", "nonce" ] ]
#32 Mr. Spell. millio r = MOOList [ "n", "", [ "millions", "millionth", "millionaire", "million" ] ]
#32 Mr. Spell. cons r = MOOList [ "", "aceioptu", [ ] ]
#32 Mr. Spell. Moor r = MOOList [ "", "", [ "Moorish", "Moore", "moor" ] ]
#32 Mr. Spell. greed r = MOOList [ "", "", [ "greedy", "greed" ] ]
#32 Mr. Spell. cont r = MOOList [ "", "aeioru", [ ] ]
#32 Mr. Spell. Wat r = MOOList [ "", "cet", [ "Watson", "Watkins", "Watanabe" ] ]
#32 Mr. Spell. yea r = MOOList [ "", "rs", [ "Yeats", "yeah", "Yeager", "yea" ] ]
#32 Mr. Spell. conv r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. Moon r = MOOList [ "", "l", [ "Mooney", "moon" ] ]
#32 Mr. Spell. lubrica r = MOOList [ "", "", [ "lubricate", "lubricant" ] ]
#32 Mr. Spell. trainm r = MOOList [ "", "", [ "trainmen", "trainman" ] ]
#32 Mr. Spell. wealt r = MOOList [ "h", "", [ "wealthy", "wealth" ] ]
#32 Mr. Spell. dapp r = MOOList [ "", "", [ "dapple", "dapper" ] ]
#32 Mr. Spell. businessm r = MOOList [ "", "", [ "businessmen", "businessman" ] ]
#32 Mr. Spell. Wal r = MOOList [ "", "dklt", [ "Walsh", "walrus", "Walpole", "walnut", "Walgreen", "wale", "Walcott" ] ]
#32 Mr. Spell. Wak r = MOOList [ "e", "f", [ "wakeup", "wakerobin", "waken", "wake" ] ]
#32 Mr. Spell. none r = MOOList [ "", "", [ "nonetheless", "none" ] ]
#32 Mr. Spell. Cara r = MOOList [ "", "", [ "caraway", "caravan", "caramel", "Caracas", "carabao" ] ]
#32 Mr. Spell. conc r = MOOList [ "", "aeiloru", [ "conch" ] ]
#32 Mr. Spell. streng r = MOOList [ "th", "", [ "strengthen", "strength" ] ]
#32 Mr. Spell. lign r = MOOList [ "", "", [ "lignum", "lignite" ] ]
#32 Mr. Spell. illumi r = MOOList [ "n", "", [ "illumine", "illuminate" ] ]
#32 Mr. Spell. puss r = MOOList [ "y", "", [ "pussycat", "pussy" ] ]
#32 Mr. Spell. cone r = MOOList [ "", "", [ "coney", "Conestoga", "coneflower", "cone" ] ]
#32 Mr. Spell. eute r = MOOList [ "", "", [ "Euterpe", "eutectic" ] ]
#32 Mr. Spell. cond r = MOOList [ "", "eiou", [ ] ]
#32 Mr. Spell. cong r = MOOList [ "", "eor", [ "conglomerate" ] ]
#32 Mr. Spell. nomo r = MOOList [ "gra", "", [ "nomograph", "nomogram" ] ]
#32 Mr. Spell. conf r = MOOList [ "", "eiloru", [ "confabulate" ] ]
#32 Mr. Spell. coni r = MOOList [ "", "f", [ "conic" ] ]
#32 Mr. Spell. Cari r = MOOList [ "", "b", [ "caricature" ] ]
#32 Mr. Spell. discriminat r = MOOList [ "", "", [ "discriminatory", "discriminate" ] ]
#32 Mr. Spell. conj r = MOOList [ "", "eou", [ ] ]
#32 Mr. Spell. he' r = MOOList [ "", "", [ "he'll", "he'd" ] ]
#32 Mr. Spell. Carl r = MOOList [ "", "io", [ "Carlyle", "Carlton", "Carlson", "Carleton", "Carla", "Carl" ] ]
#32 Mr. Spell. Carm r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. prolif r = MOOList [ "", "", [ "prolific", "proliferate" ] ]
#32 Mr. Spell. lubrici r = MOOList [ "", "", [ "lubricity", "lubricious" ] ]
#32 Mr. Spell. conq r = MOOList [ "u", "e", [ "conquistador" ] ]
#32 Mr. Spell. Carp r = MOOList [ "", "e", [ "carport", "Carpathia", "carp" ] ]
#32 Mr. Spell. Monr r = MOOList [ "o", "", [ "Monrovia", "Monroe" ] ]
#32 Mr. Spell. spike r = MOOList [ "", "", [ "spikenard", "spike" ] ]
#32 Mr. Spell. Sperm r = MOOList [ "", "", [ "spermatophyte", "sperm" ] ]
#32 Mr. Spell. Fah r = MOOList [ "", "", [ "Fahrenheit", "Fahey" ] ]
#32 Mr. Spell. Alla r = MOOList [ "", "", [ "allay", "Allan", "Allah" ] ]
#32 Mr. Spell. noma r = MOOList [ "d", "", [ "nomadic", "nomad" ] ]
#32 Mr. Spell. commun r = MOOList [ "", "i", [ "commune", "communal" ] ]
#32 Mr. Spell. Fab r = MOOList [ "", "r", [ "fabulous", "fable", "Fabian", "Faber" ] ]
#32 Mr. Spell. shrub r = MOOList [ "", "", [ "shrubbery", "shrub" ] ]
#32 Mr. Spell. nomi r = MOOList [ "n", "a", [ "nominee" ] ]
#32 Mr. Spell. ligh r = MOOList [ "t", "h", [ "lightweight", "lightproof", "lightning", "lightface", "lighten", "light" ] ]
#32 Mr. Spell. constitut r = MOOList [ "", "i", [ "constitute" ] ]
#32 Mr. Spell. monome r = MOOList [ "r", "", [ "monomeric", "monomer" ] ]
#32 Mr. Spell. push r = MOOList [ "", "", [ "pushpin", "pushout", "pushbutton", "push" ] ]
#32 Mr. Spell. commut r = MOOList [ "", "", [ "commute", "commutate" ] ]
#32 Mr. Spell. Boon r = MOOList [ "", "", [ "Boone", "boon" ] ]
#32 Mr. Spell. springt r = MOOList [ "", "", [ "springtime", "springtail" ] ]
#32 Mr. Spell. shrug r = MOOList [ "", "", [ "shrugging", "shrug" ] ]
#32 Mr. Spell. yel r = MOOList [ "", "l", [ "yelp" ] ]
#32 Mr. Spell. fronti r = MOOList [ "er", "s", [ "frontier" ] ]
#32 Mr. Spell. comb r = MOOList [ "", "aiu", [ "comb" ] ]
#32 Mr. Spell. Boot r = MOOList [ "", "ls", [ "booty", "booth", "Bootes", "boot" ] ]
#32 Mr. Spell. Alls r = MOOList [ "", "", [ "Allstate", "allspice" ] ]
#32 Mr. Spell. purs r = MOOList [ "", "u", [ "purslane", "purse" ] ]
#32 Mr. Spell. monolo r = MOOList [ "g", "", [ "monologue", "monologist" ] ]
#32 Mr. Spell. Fay r = MOOList [ "", "e", [ "fay" ] ]
#32 Mr. Spell. coma r = MOOList [ "", "", [ "comatose", "Comanche", "coma" ] ]
#32 Mr. Spell. yeo r = MOOList [ "man", "", [ "yeomanry", "yeoman" ] ]
#32 Mr. Spell. purp r = MOOList [ "", "o", [ "purple" ] ]
#32 Mr. Spell. Napo r = MOOList [ "leon", "", [ "Napoleonic", "Napoleon" ] ]
#32 Mr. Spell. Fau r = MOOList [ "", "lns", [ "faucet" ] ]
#32 Mr. Spell. Ellis r = MOOList [ "", "", [ "Ellison", "Ellis" ] ]
#32 Mr. Spell. come r = MOOList [ "", "dt", [ "comeback", "come" ] ]
#32 Mr. Spell. shrun r = MOOList [ "k", "", [ "shrunken", "shrunk" ] ]
#32 Mr. Spell. yes r = MOOList [ "", "t", [ "yeshiva", "yes" ] ]
#32 Mr. Spell. comm r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. purv r = MOOList [ "", "e", [ "purview" ] ]
#32 Mr. Spell. comp r = MOOList [ "", "aeilortu", [ ] ]
#32 Mr. Spell. hem r = MOOList [ "", "iop", [ "hemlock", "hematite", "hem" ] ]
#32 Mr. Spell. dros r = MOOList [ "", "", [ "dross", "drosophila" ] ]
#32 Mr. Spell. hen r = MOOList [ "", "cdr", [ "henpeck", "Henley", "henequen", "henbane", "hen" ] ]
#32 Mr. Spell. dand r = MOOList [ "", "", [ "dandy", "dandelion" ] ]
#32 Mr. Spell. hep r = MOOList [ "", "a", [ "heptane", "Hepburn" ] ]
#32 Mr. Spell. ratio r = MOOList [ "", "", [ "rationale", "ratiocinate", "ratio" ] ]
#32 Mr. Spell. embed r = MOOList [ "", "d", [ "embed" ] ]
#32 Mr. Spell. drow r = MOOList [ "", "s", [ "drown" ] ]
#32 Mr. Spell. colu r = MOOList [ "m", "bn", [ ] ]
#32 Mr. Spell. blit r = MOOList [ "", "", [ "blitz", "blithe" ] ]
#32 Mr. Spell. colt r = MOOList [ "", "", [ "coltsfoot", "coltish", "colt" ] ]
#32 Mr. Spell. blis r = MOOList [ "", "s", [ "blister" ] ]
#32 Mr. Spell. hes r = MOOList [ "", "is", [ "Hester", "Hesperus" ] ]
#32 Mr. Spell. het r = MOOList [ "", "et", [ "Hetman" ] ]
#32 Mr. Spell. dang r = MOOList [ "", "e", [ "dangle", "dang" ] ]
#32 Mr. Spell. purl r = MOOList [ "", "", [ "purloin", "purl" ] ]
#32 Mr. Spell. incompl r = MOOList [ "et", "", [ "incompletion", "incomplete" ] ]
#32 Mr. Spell. heu r = MOOList [ "", "s", [ "heuristic", "Heublein" ] ]
#32 Mr. Spell. Yank r = MOOList [ "", "", [ "Yankton", "Yankee", "yank" ] ]
#32 Mr. Spell. hex r = MOOList [ "", "a", [ "hex" ] ]
#32 Mr. Spell. hey r = MOOList [ "", "", [ "heyday", "hey" ] ]
#32 Mr. Spell. diffeo r = MOOList [ "morphi", "", [ "diffeomorphism", "diffeomorphic" ] ]
#32 Mr. Spell. purg r = MOOList [ "", "a", [ "purge" ] ]
#32 Mr. Spell. sanat r = MOOList [ "ori", "", [ "sanatorium", "sanatoria" ] ]
#32 Mr. Spell. northe r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. incompr r = MOOList [ "e", "h", [ "incompressible" ] ]
#32 Mr. Spell. cola r = MOOList [ "", "", [ "colatitude", "colander", "cola" ] ]
#32 Mr. Spell. differ r = MOOList [ "", "e", [ "differ" ] ]
#32 Mr. Spell. damp r = MOOList [ "", "", [ "dampen", "damp" ] ]
#32 Mr. Spell. Mona r = MOOList [ "", "drs", [ "monaural", "Monaco", "Mona" ] ]
#32 Mr. Spell. hea r = MOOList [ "", "dlrtv", [ "heap" ] ]
#32 Mr. Spell. heb r = MOOList [ "", "er", [ ] ]
#32 Mr. Spell. Capi r = MOOList [ "", "t", [ "Capistrano", "capillary" ] ]
#32 Mr. Spell. hec r = MOOList [ "", "akt", [ "Hecuba" ] ]
#32 Mr. Spell. hed r = MOOList [ "", "go", [ ] ]
#32 Mr. Spell. widt r = MOOList [ "h", "", [ "widthwise", "width" ] ]
#32 Mr. Spell. lieu r = MOOList [ "", "", [ "lieutenant", "lieu" ] ]
#32 Mr. Spell. hee r = MOOList [ "", "", [ "heel", "heed" ] ]
#32 Mr. Spell. coli r = MOOList [ "", "", [ "coliseum", "coliform", "colicky" ] ]
#32 Mr. Spell. hef r = MOOList [ "t", "", [ "hefty", "heft" ] ]
#32 Mr. Spell. Moni r = MOOList [ "", "ct", [ "monies" ] ]
#32 Mr. Spell. heg r = MOOList [ "e", "", [ "hegemony", "Hegelian" ] ]
#32 Mr. Spell. northw r = MOOList [ "", "e", [ "northward" ] ]
#32 Mr. Spell. hei r = MOOList [ "", "gnr", [ "Heisenberg", "Heidelberg" ] ]
#32 Mr. Spell. droo r = MOOList [ "", "p", [ "drool" ] ]
#32 Mr. Spell. incompa r = MOOList [ "", "", [ "incompatible", "incomparable" ] ]
#32 Mr. Spell. drop r = MOOList [ "", "", [ "dropout", "droplet", "drophead", "drop" ] ]
#32 Mr. Spell. coll r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. Palat r = MOOList [ "", "", [ "Palatine", "palate" ] ]
#32 Mr. Spell. blin r = MOOList [ "", "d", [ "Blinn", "blink" ] ]
#32 Mr. Spell. newel r = MOOList [ "", "", [ "Newell", "newel" ] ]
#32 Mr. Spell. orna r = MOOList [ "", "m", [ "ornate" ] ]
#32 Mr. Spell. newsm r = MOOList [ "", "", [ "newsmen", "newsman" ] ]
#32 Mr. Spell. newsp r = MOOList [ "aper", "m", [ "newspaper" ] ]
#32 Mr. Spell. Moll r = MOOList [ "", "iy", [ "mollusk", "Moll" ] ]
#32 Mr. Spell. Cant r = MOOList [ "", "aeio", [ "cantle", "cant" ] ]
#32 Mr. Spell. wido r = MOOList [ "w", "", [ "widowhood", "widow" ] ]
#32 Mr. Spell. wide r = MOOList [ "", "", [ "widespread", "widen", "wide" ] ]
#32 Mr. Spell. Viet r = MOOList [ "", "n", [ "Viet" ] ]
#32 Mr. Spell. notor r = MOOList [ "i", "", [ "notorious", "notoriety" ] ]
#32 Mr. Spell. widg r = MOOList [ "e", "", [ "widget", "widgeon" ] ]
#32 Mr. Spell. damn r = MOOList [ "", "", [ "damnation", "damn" ] ]
#32 Mr. Spell. Wel r = MOOList [ "", "cdl", [ "welt", "welsh", "welfare" ] ]
#32 Mr. Spell. Patric r = MOOList [ "", "i", [ "Patrick", "Patrice" ] ]
#32 Mr. Spell. pupp r = MOOList [ "", "ey", [ ] ]
#32 Mr. Spell. Wei r = MOOList [ "", "gnr", [ "Weiss", "Weierstrass", "Wei" ] ]
#32 Mr. Spell. kitte r = MOOList [ "n", "", [ "kittenish", "kitten" ] ]
#32 Mr. Spell. Web r = MOOList [ "", "", [ "Webster", "weber", "Webb", "web" ] ]
#32 Mr. Spell. Patria r = MOOList [ "rch", "", [ "patriarchy", "patriarchal", "patriarch" ] ]
#32 Mr. Spell. wick r = MOOList [ "", "", [ "wicket", "wick" ] ]
#32 Mr. Spell. pupa r = MOOList [ "", "", [ "pupate", "pupal" ] ]
#32 Mr. Spell. inhabita r = MOOList [ "", "", [ "inhabitation", "inhabitant" ] ]
#32 Mr. Spell. Dura r = MOOList [ "", "n", [ "duration", "durable" ] ]
#32 Mr. Spell. Alic r = MOOList [ "", "", [ "Alicia", "Alice" ] ]
#32 Mr. Spell. Boli r = MOOList [ "v", "", [ "Bolivia", "bolivar" ] ]
#32 Mr. Spell. Durk r = MOOList [ "", "", [ "Durkin", "Durkee" ] ]
#32 Mr. Spell. arterio r = MOOList [ "", "l", [ "arteriosclerosis" ] ]
#32 Mr. Spell. dall r = MOOList [ "", "", [ "dally", "Dallas" ] ]
#32 Mr. Spell. Crom r = MOOList [ "well", "", [ "Cromwellian", "Cromwell" ] ]
#32 Mr. Spell. Wen r = MOOList [ "", "d", [ "went" ] ]
#32 Mr. Spell. shrew r = MOOList [ "", "", [ "shrewish", "shrewd", "shrew" ] ]
#32 Mr. Spell. Chinam r = MOOList [ "", "", [ "Chinamen", "Chinaman" ] ]
#32 Mr. Spell. Bolo r = MOOList [ "", "", [ "bolometer", "Bologna", "bolo" ] ]
#32 Mr. Spell. Cana r = MOOList [ "", "d", [ "Canaveral", "canary", "canal", "Canaan" ] ]
#32 Mr. Spell. incommu r = MOOList [ "", "", [ "incommutable", "incommunicable" ] ]
#32 Mr. Spell. credit r = MOOList [ "", "", [ "creditor", "credit" ] ]
#32 Mr. Spell. headwa r = MOOList [ "", "", [ "headway", "headwater", "headwall" ] ]
#32 Mr. Spell. Bols r = MOOList [ "", "h", [ "bolster" ] ]
#32 Mr. Spell. Vien r = MOOList [ "", "n", [ "Vientiane" ] ]
#32 Mr. Spell. telepr r = MOOList [ "", "o", [ "teleprinter" ] ]
#32 Mr. Spell. shado r = MOOList [ "w", "", [ "shadowy", "shadow" ] ]
#32 Mr. Spell. Bolt r = MOOList [ "", "", [ "Boltzmann", "Bolton", "bolt" ] ]
#32 Mr. Spell. Alis r = MOOList [ "", "", [ "Alistair", "Alison" ] ]
#32 Mr. Spell. Moli r = MOOList [ "", "", [ "Moline", "Moliere" ] ]
#32 Mr. Spell. teleph r = MOOList [ "o", "n", [ "telephotography" ] ]
#32 Mr. Spell. Cani r = MOOList [ "", "s", [ "canine" ] ]
#32 Mr. Spell. Mold r = MOOList [ "", "", [ "moldboard", "Moldavia", "mold" ] ]
#32 Mr. Spell. Cano r = MOOList [ "", "n", [ "canopy", "Canoga", "canoe" ] ]
#32 Mr. Spell. telepa r = MOOList [ "th", "", [ "telepathy", "telepathic" ] ]
#32 Mr. Spell. coin r = MOOList [ "", "c", [ "coinage", "coin" ] ]
#32 Mr. Spell. incomme r = MOOList [ "nsura", "", [ "incommensurate", "incommensurable" ] ]
#32 Mr. Spell. moist r = MOOList [ "", "", [ "moisture", "moisten", "moist" ] ]
#32 Mr. Spell. lice r = MOOList [ "", "n", [ "lice" ] ]
#32 Mr. Spell. shagg r = MOOList [ "", "", [ "shaggy", "shagging" ] ]
#32 Mr. Spell. yip r = MOOList [ "", "", [ "yipping", "yip" ] ]
#32 Mr. Spell. libi r = MOOList [ "d", "", [ "libido", "libidinous" ] ]
#32 Mr. Spell. Camb r = MOOList [ "", "r", [ "Cambodia", "camber" ] ]
#32 Mr. Spell. punk r = MOOList [ "", "", [ "punky", "punk" ] ]
#32 Mr. Spell. libe r = MOOList [ "", "lr", [ ] ]
#32 Mr. Spell. puni r = MOOList [ "", "", [ "punitive", "punish", "Punic" ] ]
#32 Mr. Spell. barbi r = MOOList [ "t", "", [ "barbiturate", "barbital" ] ]
#32 Mr. Spell. libr r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. Cami r = MOOList [ "", "l", [ "Camino" ] ]
#32 Mr. Spell. barbe r = MOOList [ "", "r", [ "barbell", "barbecue" ] ]
#32 Mr. Spell. Fer r = MOOList [ "", "mnor", [ "fervent", "fertile", "Ferguson", "Ferdinand", "Ferber" ] ]
#32 Mr. Spell. smut r = MOOList [ "", "", [ "smutty", "smut" ] ]
#32 Mr. Spell. hir r = MOOList [ "", "eos", [ "Hiram" ] ]
#32 Mr. Spell. coho r = MOOList [ "", "", [ "cohosh", "cohort", "cohomology" ] ]
#32 Mr. Spell. include r = MOOList [ "", "", [ "included", "include" ] ]
#32 Mr. Spell. bles r = MOOList [ "", "s", [ "blest" ] ]
#32 Mr. Spell. pund r = MOOList [ "it", "", [ "punditry", "pundit" ] ]
#32 Mr. Spell. punc r = MOOList [ "", "t", [ "punch" ] ]
#32 Mr. Spell. concerti r = MOOList [ "", "", [ "concertina", "concerti" ] ]
#32 Mr. Spell. Vick r = MOOList [ "", "", [ "Vicky", "Vicksburg" ] ]
#32 Mr. Spell. hia r = MOOList [ "", "t", [ "Hiawatha" ] ]
#32 Mr. Spell. smud r = MOOList [ "g", "", [ "smudgy", "smudge" ] ]
#32 Mr. Spell. Algo r = MOOList [ "", "r", [ "Algonquin", "Algol" ] ]
#32 Mr. Spell. hid r = MOOList [ "", "e", [ "hidden", "hidalgo", "hid" ] ]
#32 Mr. Spell. smug r = MOOList [ "", "", [ "smuggle", "smug" ] ]
#32 Mr. Spell. illust r = MOOList [ "r", "", [ "illustrious", "illustrate" ] ]
#32 Mr. Spell. hie r = MOOList [ "r", "ao", [ ] ]
#32 Mr. Spell. hig r = MOOList [ "", "h", [ "Higgins" ] ]
#32 Mr. Spell. dais r = MOOList [ "", "", [ "daisy", "dais" ] ]
#32 Mr. Spell. blea r = MOOList [ "", "", [ "bleat", "bleary", "bleak", "bleach" ] ]
#32 Mr. Spell. illusi r = MOOList [ "", "o", [ "illusive" ] ]
#32 Mr. Spell. hil r = MOOList [ "", "alt", [ "hilum", "Hildebrand", "Hilbert" ] ]
#32 Mr. Spell. hin r = MOOList [ "", "dt", [ "Hinman", "hinge", "Hines" ] ]
#32 Mr. Spell. pump r = MOOList [ "", "k", [ "pump" ] ]
#32 Mr. Spell. hip r = MOOList [ "", "p", [ "hipster", "hip" ] ]
#32 Mr. Spell. cogn r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. statut r = MOOList [ "", "", [ "statutory", "statute" ] ]
#32 Mr. Spell. momenta r = MOOList [ "", "", [ "momentary", "momenta" ] ]
#32 Mr. Spell. operan r = MOOList [ "", "", [ "operant", "operand" ] ]
#32 Mr. Spell. stump r = MOOList [ "", "", [ "stumpy", "stumpage", "stump" ] ]
#32 Mr. Spell. statue r = MOOList [ "", "", [ "statuette", "statue" ] ]
#32 Mr. Spell. pull r = MOOList [ "", "", [ "pullover", "Pullman", "pulley", "pullback", "pull" ] ]
#32 Mr. Spell. Wil r = MOOList [ "", "defhklms", [ "wily", "wilt", "Wilcox", "Wilbur" ] ]
#32 Mr. Spell. Bois r = MOOList [ "", "", [ "boisterous", "Boise", "Bois" ] ]
#32 Mr. Spell. Alfr r = MOOList [ "e", "d", [ "alfresco" ] ]
#32 Mr. Spell. orig r = MOOList [ "in", "a", [ "origin" ] ]
#32 Mr. Spell. Middl r = MOOList [ "e", "mt", [ "middleweight", "Middlesex", "Middlebury", "middle" ] ]
#32 Mr. Spell. puls r = MOOList [ "", "a", [ "pulse" ] ]
#32 Mr. Spell. headst r = MOOList [ "", "", [ "headstrong", "headstone", "headstand" ] ]
#32 Mr. Spell. pulp r = MOOList [ "", "", [ "pulpit", "pulp" ] ]
#32 Mr. Spell. shril r = MOOList [ "l", "", [ "shrilly", "shrill" ] ]
#32 Mr. Spell. lingu r = MOOList [ "", "a", [ "linguist" ] ]
#32 Mr. Spell. Cain r = MOOList [ "", "", [ "Caine", "Cain" ] ]
#32 Mr. Spell. shrin r = MOOList [ "", "k", [ "shrine" ] ]
#32 Mr. Spell. Cair r = MOOList [ "", "", [ "Cairo", "cairn" ] ]
#32 Mr. Spell. headsm r = MOOList [ "", "", [ "headsmen", "headsman" ] ]
#32 Mr. Spell. drip r = MOOList [ "", "", [ "drippy", "drip" ] ]
#32 Mr. Spell. orie r = MOOList [ "nt", "", [ "oriented", "oriental", "orient" ] ]
#32 Mr. Spell. driv r = MOOList [ "", "e", [ "driving" ] ]
#32 Mr. Spell. descripti r = MOOList [ "", "", [ "descriptive", "description" ] ]
#32 Mr. Spell. shriv r = MOOList [ "e", "", [ "shrivel", "shrive" ] ]
#32 Mr. Spell. operat r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. Dune r = MOOList [ "", "", [ "Dunedin", "dune" ] ]
#32 Mr. Spell. Alec r = MOOList [ "", "", [ "Aleck", "Alec" ] ]
#32 Mr. Spell. energ r = MOOList [ "", "", [ "energy", "energetic" ] ]
#32 Mr. Spell. Dunl r = MOOList [ "", "", [ "Dunlop", "Dunlap" ] ]
#32 Mr. Spell. Dunk r = MOOList [ "", "", [ "Dunkirk", "dunk" ] ]
#32 Mr. Spell. driz r = MOOList [ "zl", "", [ "drizzly", "drizzle" ] ]
#32 Mr. Spell. linge r = MOOList [ "r", "", [ "lingerie", "linger" ] ]
#32 Mr. Spell. embod r = MOOList [ "", "", [ "embody", "embodiment" ] ]
#32 Mr. Spell. telety r = MOOList [ "pe", "", [ "teletypewrite", "teletypesetting", "teletype" ] ]
#32 Mr. Spell. drib r = MOOList [ "", "", [ "dribble", "drib" ] ]
#32 Mr. Spell. Nair r = MOOList [ "", "", [ "Nairobi", "Nair" ] ]
#32 Mr. Spell. eule r = MOOList [ "r", "", [ "Eulerian", "Euler" ] ]
#32 Mr. Spell. Moha r = MOOList [ "", "", [ "Mohawk", "Mohammedan" ] ]
#32 Mr. Spell. Alex r = MOOList [ "", "a", [ "Alexis", "Alexei", "Alex" ] ]
#32 Mr. Spell. coff r = MOOList [ "", "e", [ "Coffman", "coffin" ] ]
#32 Mr. Spell. langui r = MOOList [ "", "", [ "languish", "languid" ] ]
#32 Mr. Spell. toothp r = MOOList [ "", "", [ "toothpick", "toothpaste" ] ]
#32 Mr. Spell. nodu r = MOOList [ "l", "", [ "nodule", "nodular" ] ]
#32 Mr. Spell. bladd r = MOOList [ "er", "", [ "bladderwort", "bladdernut", "bladder" ] ]
#32 Mr. Spell. shake r = MOOList [ "", "s", [ "shaken", "shakedown", "shakeable", "shake" ] ]
#32 Mr. Spell. incont r = MOOList [ "", "r", [ "incontestable" ] ]
#32 Mr. Spell. incons r = MOOList [ "", "i", [ "inconstant", "inconspicuous", "inconsolable", "inconsequential" ] ]
#32 Mr. Spell. inconv r = MOOList [ "e", "", [ "inconvertible", "inconvenient" ] ]
#32 Mr. Spell. coer r = MOOList [ "c", "i", [ "coerce" ] ]
#32 Mr. Spell. spice r = MOOList [ "", "", [ "spicebush", "spice" ] ]
#32 Mr. Spell. trian r = MOOList [ "", "g", [ "Trianon" ] ]
#32 Mr. Spell. innoc r = MOOList [ "", "", [ "innocuous", "innocent" ] ]
#32 Mr. Spell. notif r = MOOList [ "", "", [ "notifies", "notify" ] ]
#32 Mr. Spell. refrac r = MOOList [ "t", "o", [ "refract" ] ]
#32 Mr. Spell. jenni r = MOOList [ "", "", [ "Jennings", "Jennifer", "Jennie" ] ]
#32 Mr. Spell. coex r = MOOList [ "", "i", [ "coextensive" ] ]
#32 Mr. Spell. Alde r = MOOList [ "", "r", [ "Alden", "aldehyde", "Aldebaran" ] ]
#32 Mr. Spell. dupli r = MOOList [ "c", "a", [ "duplicity" ] ]
#32 Mr. Spell. notic r = MOOList [ "e", "", [ "noticeable", "notice" ] ]
#32 Mr. Spell. positi r = MOOList [ "", "", [ "positive", "position" ] ]
#32 Mr. Spell. blaz r = MOOList [ "", "", [ "blazon", "blaze" ] ]
#32 Mr. Spell. conversa r = MOOList [ "", "", [ "conversation", "conversant" ] ]
#32 Mr. Spell. inconc r = MOOList [ "", "", [ "inconclusive", "inconceivable" ] ]
#32 Mr. Spell. Dump r = MOOList [ "", "", [ "dumped", "dumpy", "Dumpty", "dump" ] ]
#32 Mr. Spell. coed r = MOOList [ "", "", [ "coeducation", "coeditor", "coed" ] ]
#32 Mr. Spell. incong r = MOOList [ "ru", "", [ "incongruous", "incongruity" ] ]
#32 Mr. Spell. Fit r = MOOList [ "", "cz", [ "fitful", "fit" ] ]
#32 Mr. Spell. Fis r = MOOList [ "", "chkst", [ ] ]
#32 Mr. Spell. incomm r = MOOList [ "", "eu", [ ] ]
#32 Mr. Spell. codi r = MOOList [ "", "", [ "codify", "codicil" ] ]
#32 Mr. Spell. yog r = MOOList [ "", "", [ "yogurt", "yogi", "yoghurt", "yoga" ] ]
#32 Mr. Spell. keys r = MOOList [ "", "", [ "keys", "keystone" ] ]
#32 Mr. Spell. yok r = MOOList [ "", "e", [ "Yokuts", "Yokohama" ] ]
#32 Mr. Spell. incomp r = MOOList [ "", "alr", [ "incomputable", "incompetent" ] ]
#32 Mr. Spell. codo r = MOOList [ "", "", [ "codon", "codomain" ] ]
#32 Mr. Spell. blan r = MOOList [ "", "cdk", [ ] ]
#32 Mr. Spell. blam r = MOOList [ "e", "", [ "blameworthy", "blame" ] ]
#32 Mr. Spell. adverb r = MOOList [ "", "", [ "adverbial", "adverb" ] ]
#32 Mr. Spell. yon r = MOOList [ "", "", [ "Yonkers", "yond", "yon" ] ]
#32 Mr. Spell. orga r = MOOList [ "", "n", [ "orgasm" ] ]
#32 Mr. Spell. libert r = MOOList [ "", "", [ "liberty", "libertine", "libertarian" ] ]
#32 Mr. Spell. yor r = MOOList [ "", "k", [ "yore" ] ]
#32 Mr. Spell. blat r = MOOList [ "", "", [ "Blatz", "blather", "blatant", "blat" ] ]
#32 Mr. Spell. keyw r = MOOList [ "ord", "", [ "keywords", "keyword" ] ]
#32 Mr. Spell. blas r = MOOList [ "", "pt", [ ] ]
#32 Mr. Spell. edif r = MOOList [ "", "", [ "edify", "edifice" ] ]
#32 Mr. Spell. you r = MOOList [ "", "'rnt", [ "you" ] ]
#32 Mr. Spell. Crim r = MOOList [ "", "e", [ "crimson", "crimp", "criminal" ] ]
#32 Mr. Spell. advert r = MOOList [ "", "", [ "advertise", "advert" ] ]
#32 Mr. Spell. pentago r = MOOList [ "n", "", [ "pentagonal", "pentagon" ] ]
#32 Mr. Spell. keyb r = MOOList [ "", "i", [ "keyboard" ] ]
#32 Mr. Spell. advers r = MOOList [ "", "", [ "adverse", "adversary" ] ]
#32 Mr. Spell. Crisp r = MOOList [ "", "", [ "Crispin", "crisp" ] ]
#32 Mr. Spell. baref r = MOOList [ "", "", [ "barefoot", "barefaced" ] ]
#32 Mr. Spell. code r = MOOList [ "", "", [ "codeword", "codetermine", "codeposit", "codebreak", "code" ] ]
#32 Mr. Spell. blad r = MOOList [ "", "d", [ "blade" ] ]
#32 Mr. Spell. psychoan r = MOOList [ "aly", "s", [ "psychoanalytic" ] ]
#32 Mr. Spell. codd r = MOOList [ "", "", [ "coddle", "Coddington" ] ]
#32 Mr. Spell. blac r = MOOList [ "k", "bms", [ "blackness", "Blackwell", "blackout", "blackjack", "Blackfeet", "blacken", "black" ] ]
#32 Mr. Spell. prolon r = MOOList [ "g", "", [ "prolongate", "prolong" ] ]
#32 Mr. Spell. further r = MOOList [ "", "m", [ "further" ] ]
#32 Mr. Spell. imperc r = MOOList [ "e", "", [ "imperceptible", "imperceivable" ] ]
#32 Mr. Spell. Conne r = MOOList [ "", "c", [ "Conner" ] ]
#32 Mr. Spell. promp r = MOOList [ "t", "", [ "promptitude", "prompt" ] ]
#32 Mr. Spell. hoc r = MOOList [ "", "k", [ "hoc" ] ]
#32 Mr. Spell. hod r = MOOList [ "g", "e", [ "Hodgkin" ] ]
#32 Mr. Spell. impers r = MOOList [ "ona", "", [ "impersonate", "impersonal" ] ]
#32 Mr. Spell. promi r = MOOList [ "", "s", [ "prominent" ] ]
#32 Mr. Spell. impert r = MOOList [ "", "", [ "imperturbable", "impertinent" ] ]
#32 Mr. Spell. promo r = MOOList [ "t", "", [ "promotion", "promote" ] ]
#32 Mr. Spell. Dela r = MOOList [ "", "n", [ "delay", "Delaware" ] ]
#32 Mr. Spell. imperi r = MOOList [ "", "", [ "imperishable", "imperious", "imperil", "imperial" ] ]
#32 Mr. Spell. constru r = MOOList [ "", "c", [ "construe" ] ]
#32 Mr. Spell. power r = MOOList [ "", "", [ "powerhouse", "powerful", "power" ] ]
#32 Mr. Spell. imperm r = MOOList [ "", "", [ "impermissible", "impermeable" ] ]
#32 Mr. Spell. appare r = MOOList [ "", "", [ "apparent", "apparel" ] ]
#32 Mr. Spell. confor r = MOOList [ "m", "a", [ "conform" ] ]
#32 Mr. Spell. hoy r = MOOList [ "", "d", [ "Hoyt", "hoy" ] ]
#32 Mr. Spell. prolo r = MOOList [ "", "n", [ "prologue" ] ]
#32 Mr. Spell. additio r = MOOList [ "n", "", [ "additions", "additional", "addition" ] ]
#32 Mr. Spell. genit r = MOOList [ "", "", [ "genitive", "genital" ] ]
#32 Mr. Spell. proli r = MOOList [ "", "f", [ "prolix", "proline" ] ]
#32 Mr. Spell. hog r = MOOList [ "", "", [ "hogging", "hogan", "hog" ] ]
#32 Mr. Spell. require r = MOOList [ "", "", [ "requirements", "requires", "required", "require" ] ]
#32 Mr. Spell. hom r = MOOList [ "", "eio", [ "homunculus", "homage", "Hom" ] ]
#32 Mr. Spell. hon r = MOOList [ "", "deo", [ "Honshu", "honk", "hong" ] ]
#32 Mr. Spell. telephone r = MOOList [ "", "", [ "telephones", "telephone" ] ]
#32 Mr. Spell. scala r = MOOList [ "", "", [ "scalar", "Scala" ] ]
#32 Mr. Spell. hoo r = MOOList [ "", "dfkpsv", [ "hoot", "hooligan", "hooch" ] ]
#32 Mr. Spell. hop r = MOOList [ "", "ek", [ "hopscotch", "hopple", "hop" ] ]
#32 Mr. Spell. hos r = MOOList [ "", "pt", [ "hosiery", "hose" ] ]
#32 Mr. Spell. hot r = MOOList [ "", "beh", [ "hotrod", "hot" ] ]
#32 Mr. Spell. hov r = MOOList [ "e", "", [ "hover", "hovel", "hove" ] ]
#32 Mr. Spell. scrol r = MOOList [ "l", "", [ "scrolling", "scroll" ] ]
#32 Mr. Spell. Mathew r = MOOList [ "s", "", [ "Mathewson", "Mathews" ] ]
#32 Mr. Spell. dissem r = MOOList [ "", "", [ "disseminate", "dissemble" ] ]
#32 Mr. Spell. encom r = MOOList [ "i", "", [ "encomium", "encomia" ] ]
#32 Mr. Spell. evil r = MOOList [ "", "", [ "evildoer", "evil" ] ]
#32 Mr. Spell. Amaz r = MOOList [ "", "", [ "Amazon", "amaze" ] ]
#32 Mr. Spell. sourc r = MOOList [ "e", "", [ "sources", "source" ] ]
#32 Mr. Spell. Mathem r = MOOList [ "ati", "c", [ "Mathematik" ] ]
#32 Mr. Spell. transmitt r = MOOList [ "", "ae", [ "transmitting" ] ]
#32 Mr. Spell. sextu r = MOOList [ "ple", "", [ "sextuplet", "sextuple" ] ]
#32 Mr. Spell. cellulo r = MOOList [ "", "", [ "cellulose", "celluloid" ] ]
#32 Mr. Spell. snow r = MOOList [ "", "f", [ "snowy", "snowstorm", "snowball", "snow" ] ]
#32 Mr. Spell. evid r = MOOList [ "ent", "", [ "evidential", "evident" ] ]
#32 Mr. Spell. veteri r = MOOList [ "nar", "", [ "veterinary", "veterinarian" ] ]
#32 Mr. Spell. cuttl r = MOOList [ "e", "", [ "cuttlefish", "cuttlebone" ] ]
#32 Mr. Spell. entre r = MOOList [ "preneur", "", [ "entrepreneurial", "entrepreneur" ] ]
#32 Mr. Spell. Connec r = MOOList [ "t", "i", [ "connector", "connect" ] ]
#32 Mr. Spell. cobbl r = MOOList [ "e", "", [ "cobblestone", "cobble" ] ]
#32 Mr. Spell. antipa r = MOOList [ "", "", [ "antipathy", "antipasto" ] ]
#32 Mr. Spell. snoo r = MOOList [ "", "p", [ "snook" ] ]
#32 Mr. Spell. entra r = MOOList [ "n", "", [ "entrant", "entranceway" ] ]
#32 Mr. Spell. snor r = MOOList [ "", "", [ "snort", "snorkel", "snore" ] ]
#32 Mr. Spell. constri r = MOOList [ "ct", "", [ "constrictor", "constrict" ] ]
#32 Mr. Spell. scant r = MOOList [ "", "", [ "scanty", "scant" ] ]
#32 Mr. Spell. tangen r = MOOList [ "t", "", [ "tangential", "tangent" ] ]
#32 Mr. Spell. smoke r = MOOList [ "", "s", [ "smokehouse", "smoke" ] ]
#32 Mr. Spell. constra r = MOOList [ "in", "", [ "constraint", "constrain" ] ]
#32 Mr. Spell. termi r = MOOList [ "", "n", [ "termite" ] ]
#32 Mr. Spell. Fog r = MOOList [ "", "g", [ "fogy", "Fogarty", "fog" ] ]
#32 Mr. Spell. furtherm r = MOOList [ "o", "", [ "furthermost", "furthermore" ] ]
#32 Mr. Spell. snob r = MOOList [ "", "b", [ "snob" ] ]
#32 Mr. Spell. saliv r = MOOList [ "a", "", [ "salivate", "salivary", "saliva" ] ]
#32 Mr. Spell. peep r = MOOList [ "", "", [ "peepy", "peephole", "peep" ] ]
#32 Mr. Spell. scand r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. salin r = MOOList [ "", "", [ "saline", "Salina" ] ]
#32 Mr. Spell. catalys r = MOOList [ "", "", [ "catalyst", "catalysis" ] ]
#32 Mr. Spell. Amar r = MOOList [ "", "", [ "Amarillo", "amaranth" ] ]
#32 Mr. Spell. confro r = MOOList [ "nt", "", [ "confrontation", "confront" ] ]
#32 Mr. Spell. bronch r = MOOList [ "", "i", [ "bronchus" ] ]
#32 Mr. Spell. approv r = MOOList [ "", "", [ "approve", "approval" ] ]
#32 Mr. Spell. quart r = MOOList [ "", "eiz", [ "quart" ] ]
#32 Mr. Spell. approx r = MOOList [ "ima", "", [ "approximate", "approximant", "approximable" ] ]
#32 Mr. Spell. quarr r = MOOList [ "", "ey", [ ] ]
#32 Mr. Spell. termina r = MOOList [ "", "", [ "terminate", "terminal", "terminable" ] ]
#32 Mr. Spell. osci r = MOOList [ "ll", "a", [ "oscilloscope" ] ]
#32 Mr. Spell. approp r = MOOList [ "ria", "", [ "appropriate", "appropriable" ] ]
#32 Mr. Spell. pede r = MOOList [ "st", "", [ "pedestrian", "pedestal" ] ]
#32 Mr. Spell. neutr r = MOOList [ "", "", [ "neutron", "neutrino", "neutral" ] ]
#32 Mr. Spell. peda r = MOOList [ "", "gn", [ "pedal" ] ]
#32 Mr. Spell. scapu r = MOOList [ "la", "", [ "scapular", "scapula" ] ]
#32 Mr. Spell. pedi r = MOOList [ "", "a", [ "pediment", "pedigree" ] ]
#32 Mr. Spell. pecu r = MOOList [ "", "l", [ "pecuniary" ] ]
#32 Mr. Spell. pect r = MOOList [ "oral", "", [ "pectoralis", "pectoral" ] ]
#32 Mr. Spell. Phil r = MOOList [ "", "aio", [ "Phillip", "philharmonic", "Phil" ] ]
#32 Mr. Spell. usurp r = MOOList [ "", "", [ "usurpation", "usurp" ] ]
#32 Mr. Spell. quasi r = MOOList [ "", "", [ "quasiparticle", "quasi" ] ]
#32 Mr. Spell. teams r = MOOList [ "", "", [ "teams", "teamster" ] ]
#32 Mr. Spell. Gross r = MOOList [ "", "", [ "Grossman", "Grosset", "gross" ] ]
#32 Mr. Spell. suffi r = MOOList [ "", "c", [ "suffix" ] ]
#32 Mr. Spell. progr r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. hub r = MOOList [ "", "be", [ "hubris", "hub" ] ]
#32 Mr. Spell. rhombi r = MOOList [ "", "", [ "rhombic", "rhombi" ] ]
#32 Mr. Spell. huc r = MOOList [ "k", "", [ "huckster", "huckleberry", "huck" ] ]
#32 Mr. Spell. even r = MOOList [ "", "t", [ "evensong", "evenhanded", "even" ] ]
#32 Mr. Spell. hug r = MOOList [ "", "gh", [ "Hugo", "huge", "hug" ] ]
#32 Mr. Spell. Deer r = MOOList [ "", "s", [ "Deere", "deer" ] ]
#32 Mr. Spell. progn r = MOOList [ "os", "", [ "prognosticate", "prognosis" ] ]
#32 Mr. Spell. Mathematic r = MOOList [ "", "", [ "mathematician", "mathematic" ] ]
#32 Mr. Spell. hul r = MOOList [ "", "", [ "hull", "hulk" ] ]
#32 Mr. Spell. proge r = MOOList [ "n", "", [ "progeny", "progenitor" ] ]
#32 Mr. Spell. activa r = MOOList [ "t", "", [ "activating", "activate" ] ]
#32 Mr. Spell. confuc r = MOOList [ "i", "", [ "Confucius", "Confucian" ] ]
#32 Mr. Spell. terri r = MOOList [ "", "ft", [ "terrier", "terrible" ] ]
#32 Mr. Spell. suffr r = MOOList [ "age", "", [ "suffragette", "suffrage" ] ]
#32 Mr. Spell. norma r = MOOList [ "", "ln", [ "normative", "Norma" ] ]
#32 Mr. Spell. terre r = MOOList [ "", "", [ "terrestrial", "Terre" ] ]
#32 Mr. Spell. wildc r = MOOList [ "at", "", [ "wildcatter", "wildcat" ] ]
#32 Mr. Spell. Portu r = MOOList [ "", "g", [ "portulaca" ] ]
#32 Mr. Spell. Fry r = MOOList [ "", "", [ "Frye", "fry" ] ]
#32 Mr. Spell. neuro r = MOOList [ "", "anps", [ "neurotic", "neuromuscular", "neurology" ] ]
#32 Mr. Spell. confus r = MOOList [ "", "", [ "confusion", "confuse" ] ]
#32 Mr. Spell. snapp r = MOOList [ "", "", [ "snappy", "snappish" ] ]
#32 Mr. Spell. profu r = MOOList [ "", "s", [ "profundity" ] ]
#32 Mr. Spell. Fru r = MOOList [ "", "is", [ "frugal", "Fruehauf", "fructose" ] ]
#32 Mr. Spell. delete r = MOOList [ "", "", [ "deleted", "deleterious", "delete" ] ]
#32 Mr. Spell. profi r = MOOList [ "", "t", [ "profile", "proficient" ] ]
#32 Mr. Spell. hum r = MOOList [ "", "abimp", [ "humus", "humorous", "humerus", "hum" ] ]
#32 Mr. Spell. hun r = MOOList [ "", "dgt", [ "hunk", "hunch", "Hun" ] ]
#32 Mr. Spell. scarl r = MOOList [ "", "", [ "scarlet", "Scarlatti" ] ]
#32 Mr. Spell. neura r = MOOList [ "", "l", [ "neurasthenic" ] ]
#32 Mr. Spell. hur r = MOOList [ "", "dlrt", [ "Hurwitz", "Hurst", "Huron" ] ]
#32 Mr. Spell. profe r = MOOList [ "ss", "o", [ "profession", "profess" ] ]
#32 Mr. Spell. hus r = MOOList [ "", "bt", [ "husky", "hush" ] ]
#32 Mr. Spell. hut r = MOOList [ "", "c", [ "hut" ] ]
#32 Mr. Spell. Britan r = MOOList [ "nic", "", [ "Britannica", "Britannic" ] ]
#32 Mr. Spell. smoot r = MOOList [ "h", "", [ "smoothbore", "smooth" ] ]
#32 Mr. Spell. live r = MOOList [ "", "r", [ "liveth", "livestock", "liven", "live" ] ]
#32 Mr. Spell. scare r = MOOList [ "", "", [ "scarecrow", "scare" ] ]
#32 Mr. Spell. scarf r = MOOList [ "", "", [ "scarface", "scarf" ] ]
#32 Mr. Spell. Conno r = MOOList [ "", "t", [ "Connors", "connoisseur" ] ]
#32 Mr. Spell. peac r = MOOList [ "", "eh", [ "peacock" ] ]
#32 Mr. Spell. domes r = MOOList [ "", "", [ "domestic", "Domesday" ] ]
#32 Mr. Spell. prove r = MOOList [ "", "nr", [ "prove" ] ]
#32 Mr. Spell. witt r = MOOList [ "", "", [ "witty", "Witt" ] ]
#32 Mr. Spell. peak r = MOOList [ "", "", [ "peaky", "peak" ] ]
#32 Mr. Spell. respons r = MOOList [ "", "i", [ "response" ] ]
#32 Mr. Spell. nucle r = MOOList [ "", "aio", [ "nucleus" ] ]
#32 Mr. Spell. cosmo r = MOOList [ "", "", [ "cosmos", "cosmopolitan", "cosmology" ] ]
#32 Mr. Spell. counterpr r = MOOList [ "o", "", [ "counterproposal", "counterproductive" ] ]
#32 Mr. Spell. proposi r = MOOList [ "", "", [ "proposing", "proposition" ] ]
#32 Mr. Spell. snip r = MOOList [ "", "p", [ "snipe", "snip" ] ]
#32 Mr. Spell. witc r = MOOList [ "h", "", [ "witchcraft", "witch" ] ]
#32 Mr. Spell. with r = MOOList [ "", "dehs", [ "withy", "withal", "without", "within", "with" ] ]
#32 Mr. Spell. counterpo r = MOOList [ "i", "", [ "counterpoise", "counterpoint" ] ]
#32 Mr. Spell. snif r = MOOList [ "", "f", [ "snifter" ] ]
#32 Mr. Spell. Debb r = MOOList [ "", "", [ "Debby", "Debbie" ] ]
#32 Mr. Spell. Deba r = MOOList [ "", "rtu", [ "debase", "debacle" ] ]
#32 Mr. Spell. Ridge r = MOOList [ "", "", [ "ridgepole", "ridge" ] ]
#32 Mr. Spell. lith r = MOOList [ "", "io", [ "Lithuania", "lithe" ] ]
#32 Mr. Spell. propose r = MOOList [ "", "", [ "proposes", "proposed", "propose" ] ]
#32 Mr. Spell. liti r = MOOList [ "g", "a", [ "litigious" ] ]
#32 Mr. Spell. litt r = MOOList [ "", "lo", [ "litterbug" ] ]
#32 Mr. Spell. screw r = MOOList [ "", "b", [ "screwworm", "screwdriver", "screw" ] ]
#32 Mr. Spell. cyclot r = MOOList [ "", "", [ "cyclotron", "cyclotomic" ] ]
#32 Mr. Spell. litu r = MOOList [ "rg", "", [ "liturgy", "liturgic" ] ]
#32 Mr. Spell. cameram r = MOOList [ "", "", [ "cameramen", "cameraman" ] ]
#32 Mr. Spell. Debo r = MOOList [ "", "", [ "Deborah", "debonair" ] ]
#32 Mr. Spell. mammal r = MOOList [ "", "", [ "mammalian", "mammal" ] ]
#32 Mr. Spell. parish r = MOOList [ "", "", [ "parishioner", "parish" ] ]
#32 Mr. Spell. protr r = MOOList [ "", "u", [ "protract" ] ]
#32 Mr. Spell. evas r = MOOList [ "i", "", [ "evasive", "evasion" ] ]
#32 Mr. Spell. proto r = MOOList [ "", "ptz", [ "proton", "protocol" ] ]
#32 Mr. Spell. Fuj r = MOOList [ "i", "", [ "Fujitsu", "Fuji" ] ]
#32 Mr. Spell. wisp r = MOOList [ "", "", [ "wispy", "wisp" ] ]
#32 Mr. Spell. Viva r = MOOList [ "", "c", [ "Vivaldi", "viva" ] ]
#32 Mr. Spell. lite r = MOOList [ "ra", "t", [ "literary", "literal", "literacy" ] ]
#32 Mr. Spell. scree r = MOOList [ "", "cn", [ "screed" ] ]
#32 Mr. Spell. wish r = MOOList [ "", "", [ "wishy", "wishful", "wishbone", "wish" ] ]
#32 Mr. Spell. wise r = MOOList [ "", "", [ "wisenheimer", "wisecrack", "wiseacre", "wise" ] ]
#32 Mr. Spell. prota r = MOOList [ "", "", [ "protagonist", "protactinium" ] ]
#32 Mr. Spell. hya r = MOOList [ "", "", [ "Hyannis", "hyaline", "Hyades", "hyacinth" ] ]
#32 Mr. Spell. hyd r = MOOList [ "", "r", [ "Hyde" ] ]
#32 Mr. Spell. prote r = MOOList [ "", "acos", [ "protein", "protege" ] ]
#32 Mr. Spell. hyg r = MOOList [ "", "r", [ "hygiene" ] ]
#32 Mr. Spell. tetrah r = MOOList [ "edr", "a", [ "tetrahedron" ] ]
#32 Mr. Spell. panda r = MOOList [ "", "", [ "Pandanus", "panda" ] ]
#32 Mr. Spell. tetraf r = MOOList [ "luo", "", [ "tetrafluouride", "tetrafluoride" ] ]
#32 Mr. Spell. list r = MOOList [ "", "e", [ "lists", "list" ] ]
#32 Mr. Spell. hym r = MOOList [ "", "n", [ "hymen", "Hyman" ] ]
#32 Mr. Spell. evan r = MOOList [ "", "gs", [ "evanescent" ] ]
#32 Mr. Spell. pande r = MOOList [ "", "m", [ "pander" ] ]
#32 Mr. Spell. gallon r = MOOList [ "", "", [ "gallonage", "gallon" ] ]
#32 Mr. Spell. Dean r = MOOList [ "", "", [ "Deanna", "Deane", "dean" ] ]
#32 Mr. Spell. eval r = MOOList [ "ua", "t", [ "evaluable" ] ]
#32 Mr. Spell. hyp r = MOOList [ "", "ehno", [ ] ]
#32 Mr. Spell. prosp r = MOOList [ "e", "cr", [ ] ]
#32 Mr. Spell. Dear r = MOOList [ "", "", [ "dearth", "dearie", "Dearborn", "dear" ] ]
#32 Mr. Spell. participa r = MOOList [ "", "", [ "participate", "participant" ] ]
#32 Mr. Spell. proso r = MOOList [ "", "d", [ "prosopopoeia" ] ]
#32 Mr. Spell. prost r = MOOList [ "", "i", [ "prostrate", "prosthetic", "prostate" ] ]
#32 Mr. Spell. procedure r = MOOList [ "", "", [ "procedures", "procedure" ] ]
#32 Mr. Spell. pytha r = MOOList [ "gor", "", [ "Pythagorean", "Pythagoras" ] ]
#32 Mr. Spell. Const r = MOOList [ "", "aeir", [ ] ]
#32 Mr. Spell. fantasi r = MOOList [ "", "", [ "fantasist", "fantasia" ] ]
#32 Mr. Spell. wire r = MOOList [ "", "mt", [ "wire" ] ]
#32 Mr. Spell. pancr r = MOOList [ "ea", "", [ "pancreatic", "pancreas" ] ]
#32 Mr. Spell. Visi r = MOOList [ "", "ot", [ "Visigoth", "visible" ] ]
#32 Mr. Spell. prose r = MOOList [ "", "c", [ "Proserpine", "prose" ] ]
#32 Mr. Spell. umbra r = MOOList [ "", "", [ "umbrage", "umbra" ] ]
#32 Mr. Spell. prosc r = MOOList [ "", "r", [ "proscenium" ] ]
#32 Mr. Spell. Wya r = MOOList [ "", "", [ "Wyatt", "Wyandotte" ] ]
#32 Mr. Spell. journeym r = MOOList [ "", "", [ "journeymen", "journeyman" ] ]
#32 Mr. Spell. hys r = MOOList [ "ter", "ei", [ "hysteron" ] ]
#32 Mr. Spell. blun r = MOOList [ "", "", [ "blunt", "blunder" ] ]
#32 Mr. Spell. airl r = MOOList [ "", "i", [ "airlock" ] ]
#32 Mr. Spell. airm r = MOOList [ "", "a", [ "airmen" ] ]
#32 Mr. Spell. strict r = MOOList [ "", "", [ "stricture", "stricter", "strict" ] ]
#32 Mr. Spell. gallow r = MOOList [ "", "", [ "gallows", "Galloway" ] ]
#32 Mr. Spell. blur r = MOOList [ "", "", [ "blurt", "blurry", "blur" ] ]
#32 Mr. Spell. airp r = MOOList [ "", "", [ "airport", "airplane", "airpark" ] ]
#32 Mr. Spell. salam r = MOOList [ "", "", [ "salami", "salamander" ] ]
#32 Mr. Spell. teach r = MOOList [ "", "", [ "teaches", "teach" ] ]
#32 Mr. Spell. compassi r = MOOList [ "on", "", [ "compassionate", "compassion" ] ]
#32 Mr. Spell. blus r = MOOList [ "", "t", [ "blush" ] ]
#32 Mr. Spell. airs r = MOOList [ "", "", [ "airstrip", "airspeed" ] ]
#32 Mr. Spell. strick r = MOOList [ "", "", [ "Strickland", "stricken" ] ]
#32 Mr. Spell. Boyl r = MOOList [ "", "", [ "Boylston", "Boyle" ] ]
#32 Mr. Spell. scrib r = MOOList [ "", "", [ "Scribners", "scribe", "scribble" ] ]
#32 Mr. Spell. Nazi r = MOOList [ "", "", [ "Nazism", "Nazi" ] ]
#32 Mr. Spell. longe r = MOOList [ "", "", [ "longer", "longevity" ] ]
#32 Mr. Spell. blue r = MOOList [ "", "bg", [ "bluet", "bluestocking", "blueprint", "bluejacket", "bluefish", "blue" ] ]
#32 Mr. Spell. nitroge r = MOOList [ "n", "", [ "nitrogenous", "nitrogen" ] ]
#32 Mr. Spell. longi r = MOOList [ "", "t", [ "longish" ] ]
#32 Mr. Spell. explan r = MOOList [ "at", "", [ "explanatory", "explanation" ] ]
#32 Mr. Spell. airf r = MOOList [ "", "", [ "airframe", "airflow", "airfield", "airfare" ] ]
#32 Mr. Spell. longh r = MOOList [ "", "", [ "longhorn", "longhand" ] ]
#32 Mr. Spell. cowl r = MOOList [ "", "", [ "cowlick", "cowl" ] ]
#32 Mr. Spell. Kings r = MOOList [ "", "", [ "Kingston", "Kingsley", "Kingsbury" ] ]
#32 Mr. Spell. cowm r = MOOList [ "", "", [ "cowmen", "cowman" ] ]
#32 Mr. Spell. cowp r = MOOList [ "", "o", [ "cowpunch", "cowpea" ] ]
#32 Mr. Spell. domin r = MOOList [ "", "ai", [ "domino", "Domingo", "domineer" ] ]
#32 Mr. Spell. dayb r = MOOList [ "", "", [ "daybreak", "daybed" ] ]
#32 Mr. Spell. markete r = MOOList [ "", "", [ "marketed", "marketeer" ] ]
#32 Mr. Spell. novi r = MOOList [ "", "", [ "novitiate", "novice" ] ]
#32 Mr. Spell. snee r = MOOList [ "", "", [ "sneeze", "sneer" ] ]
#32 Mr. Spell. nove r = MOOList [ "", "l", [ "November" ] ]
#32 Mr. Spell. cowb r = MOOList [ "", "", [ "cowboy", "cowbird", "cowbell" ] ]
#32 Mr. Spell. cowa r = MOOList [ "", "r", [ "Cowan" ] ]
#32 Mr. Spell. your r = MOOList [ "", "s", [ "your" ] ]
#32 Mr. Spell. Kirc r = MOOList [ "h", "", [ "Kirchoff", "Kirchner" ] ]
#32 Mr. Spell. propy r = MOOList [ "l", "", [ "propylene", "propyl" ] ]
#32 Mr. Spell. cowh r = MOOList [ "", "", [ "cowhide", "cowherd", "cowhand" ] ]
#32 Mr. Spell. yout r = MOOList [ "h", "", [ "youthful", "youth" ] ]
#32 Mr. Spell. snea r = MOOList [ "k", "", [ "sneaky", "sneak" ] ]
#32 Mr. Spell. Frede r = MOOList [ "ric", "k", [ "Fredericton", "Frederic" ] ]
#32 Mr. Spell. Kirk r = MOOList [ "", "", [ "Kirkpatrick", "Kirkland", "kirk" ] ]
#32 Mr. Spell. Fredd r = MOOList [ "", "", [ "Freddy", "Freddie" ] ]
#32 Mr. Spell. youn r = MOOList [ "g", "s", [ "youngish", "young" ] ]
#32 Mr. Spell. propr r = MOOList [ "i", "eo", [ ] ]
#32 Mr. Spell. propo r = MOOList [ "", "rs", [ "proponent" ] ]
#32 Mr. Spell. scrip r = MOOList [ "", "t", [ "Scripps" ] ]
#32 Mr. Spell. scrim r = MOOList [ "", "", [ "scrimmage", "scrim" ] ]
#32 Mr. Spell. prope r = MOOList [ "", "lr", [ "propensity" ] ]
#32 Mr. Spell. propi r = MOOList [ "", "t", [ "propionate" ] ]
#32 Mr. Spell. Naza r = MOOList [ "re", "", [ "Nazareth", "Nazarene" ] ]
#32 Mr. Spell. proph r = MOOList [ "e", "t", [ "prophesy", "prophecy" ] ]
#32 Mr. Spell. oratori r = MOOList [ "", "", [ "oratorio", "oratoric" ] ]
#32 Mr. Spell. propa r = MOOList [ "", "g", [ "propane" ] ]
#32 Mr. Spell. actini r = MOOList [ "", "", [ "actinium", "actinide", "actinic" ] ]
#32 Mr. Spell. cova r = MOOList [ "", "r", [ "covalent" ] ]
#32 Mr. Spell. cove r = MOOList [ "", "nrt", [ "cove" ] ]
#32 Mr. Spell. wins r = MOOList [ "", "", [ "Winston", "winsome", "Winslow" ] ]
#32 Mr. Spell. actino r = MOOList [ "", "", [ "actinometer", "actinolite" ] ]
#32 Mr. Spell. quali r = MOOList [ "", "t", [ "qualify" ] ]
#32 Mr. Spell. wing r = MOOList [ "", "m", [ "wingtip", "wingspan", "wingback", "wing" ] ]
#32 Mr. Spell. wind r = MOOList [ "", "bos", [ "windy", "windward", "windup", "windmill", "windfall", "wind" ] ]
#32 Mr. Spell. coul r = MOOList [ "", "d", [ "Coulter", "coulomb" ] ]
#32 Mr. Spell. wine r = MOOList [ "", "m", [ "wineskin", "winery", "wine" ] ]
#32 Mr. Spell. genti r = MOOList [ "", "l", [ "gentian" ] ]
#32 Mr. Spell. coun r = MOOList [ "", "cst", [ ] ]
#32 Mr. Spell. wink r = MOOList [ "", "", [ "winkle", "wink" ] ]
#32 Mr. Spell. coup r = MOOList [ "", "", [ "coupon", "couple", "coupe", "coup" ] ]
#32 Mr. Spell. cour r = MOOList [ "", "at", [ "course", "courier" ] ]
#32 Mr. Spell. util r = MOOList [ "", "i", [ "utile" ] ]
#32 Mr. Spell. cous r = MOOList [ "", "", [ "cousin", "couscous" ] ]
#32 Mr. Spell. winc r = MOOList [ "", "h", [ "wince" ] ]
#32 Mr. Spell. Sagit r = MOOList [ "ta", "", [ "Sagittarius", "sagittal" ] ]
#32 Mr. Spell. gentl r = MOOList [ "e", "m", [ "gentle" ] ]
#32 Mr. Spell. noti r = MOOList [ "", "cf", [ "notion" ] ]
#32 Mr. Spell. line r = MOOList [ "", "am", [ "lines", "lineup", "lineprinter", "linen", "linebacker", "line" ] ]
#32 Mr. Spell. Freet r = MOOList [ "", "", [ "Freetown", "freethink" ] ]
#32 Mr. Spell. ling r = MOOList [ "", "eu", [ "lingo" ] ]
#32 Mr. Spell. deple r = MOOList [ "t", "", [ "depletion", "deplete" ] ]
#32 Mr. Spell. cancell r = MOOList [ "", "", [ "cancelling", "cancelled", "cancellate" ] ]
#32 Mr. Spell. note r = MOOList [ "", "", [ "notepad", "notes", "noted", "noteworthy", "notebook", "note" ] ]
#32 Mr. Spell. Also r = MOOList [ "", "", [ "Alsop", "also" ] ]
#32 Mr. Spell. noto r = MOOList [ "", "r", [ "notocord" ] ]
#32 Mr. Spell. chairw r = MOOList [ "om", "", [ "chairwomen", "chairwoman" ] ]
#32 Mr. Spell. link r = MOOList [ "", "", [ "linkage", "link" ] ]
#32 Mr. Spell. coug r = MOOList [ "", "", [ "cough", "cougar" ] ]
#32 Mr. Spell. you' r = MOOList [ "", "", [ "you've", "you're", "you'll", "you'd" ] ]
#32 Mr. Spell. prono r = MOOList [ "un", "c", [ "pronoun" ] ]
#32 Mr. Spell. nost r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. limp r = MOOList [ "", "", [ "limpkin", "limpid", "limpet", "limp" ] ]
#32 Mr. Spell. chairm r = MOOList [ "", "", [ "chairmen", "chairman" ] ]
#32 Mr. Spell. nota r = MOOList [ "", "", [ "notate", "notary" ] ]
#32 Mr. Spell. Bowd r = MOOList [ "", "", [ "Bowdoin", "Bowditch" ] ]
#32 Mr. Spell. syrin r = MOOList [ "", "g", [ "syrinx" ] ]
#32 Mr. Spell. deplo r = MOOList [ "", "", [ "deploy", "deplore" ] ]
#32 Mr. Spell. Bowe r = MOOList [ "", "", [ "Bowen", "bowel" ] ]
#32 Mr. Spell. respond r = MOOList [ "", "", [ "respondent", "respond" ] ]
#32 Mr. Spell. official r = MOOList [ "", "", [ "officials", "officialdom", "official" ] ]
#32 Mr. Spell. cott r = MOOList [ "", "ao", [ "cotty", "Cottrell" ] ]
#32 Mr. Spell. glan r = MOOList [ "", "d", [ "glans", "glance" ] ]
#32 Mr. Spell. glam r = MOOList [ "o", "r", [ "glamour" ] ]
#32 Mr. Spell. glas r = MOOList [ "", "s", [ "glasnost", "Glaswegian", "Glasgow" ] ]
#32 Mr. Spell. agglu r = MOOList [ "tin", "", [ "agglutinin", "agglutinate" ] ]
#32 Mr. Spell. glau r = MOOList [ "co", "", [ "glaucous", "glaucoma" ] ]
#32 Mr. Spell. zag r = MOOList [ "", "", [ "Zagreb", "zagging", "zag" ] ]
#32 Mr. Spell. repres r = MOOList [ "", "se", [ ] ]
#32 Mr. Spell. obvi r = MOOList [ "", "o", [ "obviate" ] ]
#32 Mr. Spell. noseb r = MOOList [ "", "", [ "nosebleed", "nosebag" ] ]
#32 Mr. Spell. glac r = MOOList [ "i", "a", [ "glacis", "glacier" ] ]
#32 Mr. Spell. soci r = MOOList [ "", "aeo", [ ] ]
#32 Mr. Spell. glad r = MOOList [ "", "di", [ "Gladys", "Gladstone", "glade", "glad" ] ]
#32 Mr. Spell. feuda r = MOOList [ "", "", [ "feudatory", "feudal" ] ]
#32 Mr. Spell. sock r = MOOList [ "", "e", [ "sock" ] ]
#32 Mr. Spell. circu r = MOOList [ "", "ilm", [ "circus" ] ]
#32 Mr. Spell. perspi r = MOOList [ "", "cr", [ ] ]
#32 Mr. Spell. brace r = MOOList [ "", "", [ "bracelet", "brace" ] ]
#32 Mr. Spell. depre r = MOOList [ "", "cs", [ ] ]
#32 Mr. Spell. circl r = MOOList [ "e", "", [ "circlet", "circle" ] ]
#32 Mr. Spell. wonde r = MOOList [ "r", "", [ "wonderland", "wonderful", "wonder" ] ]
#32 Mr. Spell. brack r = MOOList [ "", "e", [ "brackish" ] ]
#32 Mr. Spell. depri r = MOOList [ "v", "", [ "deprive", "deprivation" ] ]
#32 Mr. Spell. directo r = MOOList [ "r", "", [ "directory", "directorate", "director" ] ]
#32 Mr. Spell. requir r = MOOList [ "", "e", [ "requiring" ] ]
#32 Mr. Spell. sobr r = MOOList [ "i", "", [ "sobriquet", "sobriety" ] ]
#32 Mr. Spell. tres r = MOOList [ "", "", [ "trestle", "tress", "trespass" ] ]
#32 Mr. Spell. Sophi r = MOOList [ "", "s", [ "Sophie", "Sophia" ] ]
#32 Mr. Spell. requis r = MOOList [ "it", "", [ "requisition", "requisite" ] ]
#32 Mr. Spell. frankfu r = MOOList [ "rt", "", [ "frankfurter", "Frankfurt" ] ]
#32 Mr. Spell. Sopho r = MOOList [ "", "cm", [ ] ]
#32 Mr. Spell. hock r = MOOList [ "", "", [ "hockey", "hock" ] ]
#32 Mr. Spell. tren r = MOOList [ "", "cd", [ "Trenton" ] ]
#32 Mr. Spell. directr r = MOOList [ "i", "", [ "directrix", "directrices" ] ]
#32 Mr. Spell. trem r = MOOList [ "", "", [ "tremulous", "tremor", "tremendous", "tremble" ] ]
#32 Mr. Spell. ibi r = MOOList [ "", "", [ "ibis", "ibid" ] ]
#32 Mr. Spell. trea r = MOOList [ "", "cdst", [ ] ]
#32 Mr. Spell. declin r = MOOList [ "", "", [ "decline", "declination" ] ]
#32 Mr. Spell. tree r = MOOList [ "", "", [ "treetop", "tree" ] ]
#32 Mr. Spell. tact r = MOOList [ "", "i", [ "tactual", "tactful", "tact" ] ]
#32 Mr. Spell. obtr r = MOOList [ "u", "", [ "obtrusive", "obtrude" ] ]
#32 Mr. Spell. tach r = MOOList [ "", "i", [ "tachometer" ] ]
#32 Mr. Spell. tack r = MOOList [ "", "", [ "tacky", "tackle", "tack" ] ]
#32 Mr. Spell. Godf r = MOOList [ "", "", [ "Godfrey", "godfather" ] ]
#32 Mr. Spell. soap r = MOOList [ "", "s", [ "soapy", "soap" ] ]
#32 Mr. Spell. concert r = MOOList [ "", "i", [ "concerto", "concertmaster", "concert" ] ]
#32 Mr. Spell. hobb r = MOOList [ "", "y", [ "Hobbs", "hobble", "Hobbes" ] ]
#32 Mr. Spell. Flan r = MOOList [ "", "", [ "flannel", "flank", "flange", "Flanders", "Flanagan" ] ]
#32 Mr. Spell. depos r = MOOList [ "", "i", [ "depose" ] ]
#32 Mr. Spell. tabu r = MOOList [ "", "l", [ "tabu" ] ]
#32 Mr. Spell. depor r = MOOList [ "t", "", [ "deportee", "deportation", "deport" ] ]
#32 Mr. Spell. Pasteu r = MOOList [ "", "", [ "Pasteur", "pasteup" ] ]
#32 Mr. Spell. cartog r = MOOList [ "raph", "", [ "cartography", "cartographer" ] ]
#32 Mr. Spell. ibe r = MOOList [ "", "", [ "ibex", "Iberia" ] ]
#32 Mr. Spell. anchor r = MOOList [ "", "", [ "anchorite", "anchorage", "anchor" ] ]
#32 Mr. Spell. obst r = MOOList [ "", "ir", [ "obstetric", "obstacle" ] ]
#32 Mr. Spell. northern r = MOOList [ "", "", [ "northernmost", "northern" ] ]
#32 Mr. Spell. ico r = MOOList [ "", "ns", [ ] ]
#32 Mr. Spell. zea r = MOOList [ "l", "o", [ "Zealand", "zeal" ] ]
#32 Mr. Spell. whims r = MOOList [ "", "", [ "whimsic", "whimsey" ] ]
#32 Mr. Spell. Robe r = MOOList [ "", "r", [ "robe" ] ]
#32 Mr. Spell. hoar r = MOOList [ "", "", [ "hoarse", "hoarfrost", "hoard", "hoar" ] ]
#32 Mr. Spell. repris r = MOOList [ "", "", [ "reprise", "reprisal" ] ]
#32 Mr. Spell. Robi r = MOOList [ "n", "", [ "Robinson", "robin" ] ]
#32 Mr. Spell. tabl r = MOOList [ "", "e", [ "tabloid" ] ]
#32 Mr. Spell. obse r = MOOList [ "", "qrs", [ ] ]
#32 Mr. Spell. rabbi r = MOOList [ "", "", [ "rabbit", "rabbi" ] ]
#32 Mr. Spell. ostr r = MOOList [ "", "a", [ "ostrich" ] ]
#32 Mr. Spell. obsc r = MOOList [ "", "", [ "obscure", "obscene" ] ]
#32 Mr. Spell. obso r = MOOList [ "le", "", [ "obsolete", "obsolescent" ] ]
#32 Mr. Spell. margina r = MOOList [ "l", "", [ "marginalia", "marginal" ] ]
#32 Mr. Spell. ice r = MOOList [ "", "bl", [ "ice" ] ]
#32 Mr. Spell. hoag r = MOOList [ "", "", [ "hoagy", "Hoagland", "hoagie" ] ]
#32 Mr. Spell. jugg r = MOOList [ "", "", [ "juggle", "jugging" ] ]
#32 Mr. Spell. Gai r = MOOList [ "", "lnt", [ "gaiety" ] ]
#32 Mr. Spell. Chime r = MOOList [ "", "r", [ "chime" ] ]
#32 Mr. Spell. oste r = MOOList [ "", "no", [ ] ]
#32 Mr. Spell. gastr r = MOOList [ "o", "n", [ "gastrointestinal" ] ]
#32 Mr. Spell. ido r = MOOList [ "l", "", [ "idolatry", "idol" ] ]
#32 Mr. Spell. whirl r = MOOList [ "", "", [ "whirlwind", "whirlpool", "whirligig", "whirl" ] ]
#32 Mr. Spell. hyperb r = MOOList [ "ol", "o", [ "hyperbolic", "hyperbola" ] ]
#32 Mr. Spell. Charle r = MOOList [ "", "s", [ "Charley", "Charlemagne" ] ]
#32 Mr. Spell. idy r = MOOList [ "ll", "", [ "idyllic", "idyll" ] ]
#32 Mr. Spell. Gay r = MOOList [ "", "", [ "Gaylord", "gay" ] ]
#32 Mr. Spell. zen r = MOOList [ "", "", [ "zenith", "Zen" ] ]
#32 Mr. Spell. Gat r = MOOList [ "", "e", [ "gator", "Gatlinburg", "gather" ] ]
#32 Mr. Spell. Gas r = MOOList [ "", "pt", [ "gassy", "gasoline", "gaslight", "gasket", "gasify", "gash", "gaseous", "Gascony", "gas" ] ]
#32 Mr. Spell. zer r = MOOList [ "o", "", [ "zeroth", "zeroes", "zero" ] ]
#32 Mr. Spell. dilat r = MOOList [ "", "", [ "dilatory", "dilate", "dilatation" ] ]
#32 Mr. Spell. zes r = MOOList [ "t", "", [ "zesty", "zest" ] ]
#32 Mr. Spell. Sach r = MOOList [ "", "", [ "Sachs", "sachem" ] ]
#32 Mr. Spell. ide r = MOOList [ "", "ano", [ "idempotent" ] ]
#32 Mr. Spell. Charlo r = MOOList [ "tte", "", [ "Charlottesville", "Charlotte" ] ]
#32 Mr. Spell. Gam r = MOOList [ "", "be", [ "gamut", "gamma", "gamin", "gam" ] ]
#32 Mr. Spell. idi r = MOOList [ "o", "mst", [ "idiocy" ] ]
#32 Mr. Spell. electrolyt r = MOOList [ "", "", [ "electrolytic", "electrolyte" ] ]
#32 Mr. Spell. whist r = MOOList [ "le", "", [ "whistleable", "whistle" ] ]
#32 Mr. Spell. petu r = MOOList [ "", "", [ "petunia", "petulant" ] ]
#32 Mr. Spell. pett r = MOOList [ "", "", [ "petty", "petticoat" ] ]
#32 Mr. Spell. Phyl r = MOOList [ "", "", [ "phylogeny", "Phyllis", "phyla" ] ]
#32 Mr. Spell. Sabb r = MOOList [ "at", "", [ "sabbatical", "sabbath" ] ]
#32 Mr. Spell. petr r = MOOList [ "", "io", [ "petrel" ] ]
#32 Mr. Spell. bragg r = MOOList [ "", "", [ "bragging", "Bragg" ] ]
#32 Mr. Spell. force r = MOOList [ "", "", [ "forces", "forceful", "force" ] ]
#32 Mr. Spell. congen r = MOOList [ "", "i", [ "congener" ] ]
#32 Mr. Spell. tras r = MOOList [ "", "h", [ "Trastevere" ] ]
#32 Mr. Spell. trav r = MOOList [ "", "e", [ "Travis", "travail" ] ]
#32 Mr. Spell. trau r = MOOList [ "ma", "", [ "traumatic", "trauma" ] ]
#32 Mr. Spell. Theod r = MOOList [ "o", "", [ "Theodosian", "Theodore" ] ]
#32 Mr. Spell. needl r = MOOList [ "e", "", [ "needlepoint", "needle" ] ]
#32 Mr. Spell. prepon r = MOOList [ "dera", "", [ "preponderate", "preponderant" ] ]
#32 Mr. Spell. tran r = MOOList [ "", "qs", [ "trance" ] ]
#32 Mr. Spell. tram r = MOOList [ "", "p", [ "tramway", "trammel", "tram" ] ]
#32 Mr. Spell. trap r = MOOList [ "", "e", [ "trap" ] ]
#32 Mr. Spell. never r = MOOList [ "", "", [ "never", "nevertheless" ] ]
#32 Mr. Spell. conges r = MOOList [ "t", "i", [ "congest" ] ]
#32 Mr. Spell. connecti r = MOOList [ "", "", [ "connection", "Connecticut" ] ]
#32 Mr. Spell. trad r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. trac r = MOOList [ "", "ekt", [ "Tracy", "trachea" ] ]
#32 Mr. Spell. traf r = MOOList [ "fic", "k", [ "traffic" ] ]
#32 Mr. Spell. trag r = MOOList [ "", "ei", [ "trag" ] ]
#32 Mr. Spell. peti r = MOOList [ "t", "", [ "petition", "petite", "petit" ] ]
#32 Mr. Spell. trai r = MOOList [ "", "nlt", [ "traipse" ] ]
#32 Mr. Spell. Sabi r = MOOList [ "n", "", [ "Sabine", "Sabina" ] ]
#32 Mr. Spell. whipp r = MOOList [ "", "", [ "Whipple", "whippet", "Whippany" ] ]
#32 Mr. Spell. forbe r = MOOList [ "", "a", [ "Forbes" ] ]
#32 Mr. Spell. pest r = MOOList [ "", "i", [ "pestle", "peste", "pest" ] ]
#32 Mr. Spell. pess r = MOOList [ "im", "i", [ "pessimum", "pessimal" ] ]
#32 Mr. Spell. proxi r = MOOList [ "m", "a", [ "proximity" ] ]
#32 Mr. Spell. judi r = MOOList [ "", "c", [ "Judith" ] ]
#32 Mr. Spell. promis r = MOOList [ "", "c", [ "promise" ] ]
#32 Mr. Spell. Habe r = MOOList [ "", "r", [ "habeas" ] ]
#32 Mr. Spell. forbo r = MOOList [ "r", "", [ "forborne", "forbore" ] ]
#32 Mr. Spell. forbi r = MOOList [ "d", "d", [ "forbid" ] ]
#32 Mr. Spell. necrom r = MOOList [ "an", "c", [ "necromantic" ] ]
#32 Mr. Spell. pert r = MOOList [ "", "iu", [ "Perth", "pertain", "pert" ] ]
#32 Mr. Spell. ign r = MOOList [ "", "io", [ "igneous" ] ]
#32 Mr. Spell. pers r = MOOList [ "", "eiopu", [ "Pershing" ] ]
#32 Mr. Spell. perp r = MOOList [ "", "e", [ "perplex" ] ]
#32 Mr. Spell. perm r = MOOList [ "", "aeiu", [ ] ]
#32 Mr. Spell. zig r = MOOList [ "", "z", [ "zigging", "zig" ] ]
#32 Mr. Spell. Xer r = MOOList [ "", "o", [ "Xerxes" ] ]
#32 Mr. Spell. situa r = MOOList [ "t", "", [ "situation", "situate" ] ]
#32 Mr. Spell. construc r = MOOList [ "t", "i", [ "constructor", "construct" ] ]
#32 Mr. Spell. perv r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. zin r = MOOList [ "", "", [ "zing", "zinc" ] ]
#32 Mr. Spell. peru r = MOOList [ "", "s", [ "Peruvian", "Peru" ] ]
#32 Mr. Spell. perc r = MOOList [ "", "ehu", [ "Percy", "percolate", "Percival" ] ]
#32 Mr. Spell. aggre r = MOOList [ "", "s", [ "aggregate" ] ]
#32 Mr. Spell. financi r = MOOList [ "", "", [ "financier", "financial" ] ]
#32 Mr. Spell. provi r = MOOList [ "", "dns", [ ] ]
#32 Mr. Spell. perj r = MOOList [ "ur", "", [ "perjury", "perjure" ] ]
#32 Mr. Spell. provo r = MOOList [ "", "c", [ "provost", "provoke" ] ]
#32 Mr. Spell. perf r = MOOList [ "", "eiou", [ ] ]
#32 Mr. Spell. pere r = MOOList [ "", "", [ "perestroika", "Perez", "perennial", "peremptory" ] ]
#32 Mr. Spell. consume r = MOOList [ "", "r", [ "consumed", "consume" ] ]
#32 Mr. Spell. Tuck r = MOOList [ "", "", [ "Tucker", "tuck" ] ]
#32 Mr. Spell. scrup r = MOOList [ "", "u", [ "scruple" ] ]
#32 Mr. Spell. saloo r = MOOList [ "n", "", [ "saloonkeep", "saloon" ] ]
#32 Mr. Spell. geode r = MOOList [ "", "s", [ "geodetic" ] ]
#32 Mr. Spell. Gei r = MOOList [ "", "g", [ "geisha" ] ]
#32 Mr. Spell. vocab r = MOOList [ "", "u", [ "vocable" ] ]
#32 Mr. Spell. choir r = MOOList [ "", "", [ "choirmaster", "choir" ] ]
#32 Mr. Spell. consult r = MOOList [ "", "a", [ "consult" ] ]
#32 Mr. Spell. zip r = MOOList [ "", "", [ "zippy", "zip" ] ]
#32 Mr. Spell. zir r = MOOList [ "con", "", [ "zirconium", "zircon" ] ]
#32 Mr. Spell. vocal r = MOOList [ "", "", [ "vocalic", "vocal" ] ]
#32 Mr. Spell. Ges r = MOOList [ "t", "a", [ "gesture", "gesticulate" ] ]
#32 Mr. Spell. Ger r = MOOList [ "", "abhmu", [ "Gertrude", "Gershwin", "Gerry", "geriatric" ] ]
#32 Mr. Spell. geoch r = MOOList [ "", "e", [ "geochronology" ] ]
#32 Mr. Spell. aerob r = MOOList [ "", "", [ "aerobic", "Aerobacter" ] ]
#32 Mr. Spell. pepp r = MOOList [ "", "e", [ "peppy" ] ]
#32 Mr. Spell. forgi r = MOOList [ "ve", "", [ "forgiven", "forgive" ] ]
#32 Mr. Spell. forge r = MOOList [ "", "t", [ "forgery", "forge" ] ]
#32 Mr. Spell. rende r = MOOList [ "", "", [ "rendezvous", "render" ] ]
#32 Mr. Spell. scatt r = MOOList [ "er", "", [ "scattergun", "scatterbrain" ] ]
#32 Mr. Spell. vigila r = MOOList [ "nt", "", [ "vigilantism", "vigilante", "vigilant" ] ]
#32 Mr. Spell. Desc r = MOOList [ "", "aer", [ ] ]
#32 Mr. Spell. aeros r = MOOList [ "", "", [ "aerospace", "aerosol" ] ]
#32 Mr. Spell. psychot r = MOOList [ "", "h", [ "psychotic" ] ]
#32 Mr. Spell. consump r = MOOList [ "ti", "", [ "consumptive", "consumption" ] ]
#32 Mr. Spell. forgo r = MOOList [ "t", "", [ "forgotten", "forgot" ] ]
#32 Mr. Spell. Lauren r = MOOList [ "", "t", [ "Lauren" ] ]
#32 Mr. Spell. scrut r = MOOList [ "", "", [ "scrutiny", "scrutable" ] ]
#32 Mr. Spell. panth r = MOOList [ "e", "i", [ "panther", "pantheon" ] ]
#32 Mr. Spell. obli r = MOOList [ "", "gv", [ "obliterate", "oblique" ] ]
#32 Mr. Spell. volume r = MOOList [ "", "", [ "volumetric", "volume" ] ]
#32 Mr. Spell. psychop r = MOOList [ "", "ah", [ "psychopomp" ] ]
#32 Mr. Spell. psychos r = MOOList [ "", "", [ "psychosomatic", "psychosis", "psychoses" ] ]
#32 Mr. Spell. panto r = MOOList [ "mim", "", [ "pantomimic", "pantomime" ] ]
#32 Mr. Spell. bloodsh r = MOOList [ "", "", [ "bloodshot", "bloodshed" ] ]
#32 Mr. Spell. handicapp r = MOOList [ "", "e", [ "handicapping" ] ]
#32 Mr. Spell. altern r = MOOList [ "", "a", [ "altern" ] ]
#32 Mr. Spell. Orpha r = MOOList [ "n", "", [ "orphanage", "orphan" ] ]
#32 Mr. Spell. osmo r = MOOList [ "", "", [ "osmotic", "osmosis" ] ]
#32 Mr. Spell. impell r = MOOList [ "", "e", [ "impelling" ] ]
#32 Mr. Spell. Derb r = MOOList [ "y", "", [ "Derbyshire", "derby" ] ]
#32 Mr. Spell. declar r = MOOList [ "", "a", [ "declare" ] ]
#32 Mr. Spell. branc r = MOOList [ "h", "", [ "branches", "branch" ] ]
#32 Mr. Spell. bloodst r = MOOList [ "", "", [ "bloodstream", "bloodstone", "bloodstain" ] ]
#32 Mr. Spell. psychoa r = MOOList [ "", "n", [ "psychoacoustic" ] ]
#32 Mr. Spell. hypothes r = MOOList [ "", "", [ "hypothesis", "hypotheses" ] ]
#32 Mr. Spell. excell r = MOOList [ "", "e", [ "excelling" ] ]
#32 Mr. Spell. declam r = MOOList [ "at", "", [ "declamatory", "declamation" ] ]
#32 Mr. Spell. teasp r = MOOList [ "oon", "", [ "teaspoonful", "teaspoon" ] ]
#32 Mr. Spell. penn r = MOOList [ "", "ay", [ "Pennsylvania", "Penn" ] ]
#32 Mr. Spell. penm r = MOOList [ "", "", [ "penmen", "penman" ] ]
#32 Mr. Spell. consula r = MOOList [ "", "", [ "consulate", "consular" ] ]
#32 Mr. Spell. peni r = MOOList [ "", "t", [ "penis", "peninsula", "penicillin" ] ]
#32 Mr. Spell. Chine r = MOOList [ "", "", [ "Chinese", "chine" ] ]
#32 Mr. Spell. argum r = MOOList [ "ent", "a", [ "argument" ] ]
#32 Mr. Spell. individual r = MOOList [ "", "", [ "individuals", "individual" ] ]
#32 Mr. Spell. belie r = MOOList [ "", "v", [ "belief", "belie" ] ]
#32 Mr. Spell. persis r = MOOList [ "t", "", [ "persistent", "persist" ] ]
#32 Mr. Spell. penu r = MOOList [ "", "r", [ "penumbra", "penultimate" ] ]
#32 Mr. Spell. China r = MOOList [ "", "m", [ "Chinatown", "china" ] ]
#32 Mr. Spell. pent r = MOOList [ "", "ae", [ "penthouse", "pent" ] ]
#32 Mr. Spell. pens r = MOOList [ "", "i", [ "Pensacola" ] ]
#32 Mr. Spell. deprec r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. tease r = MOOList [ "", "", [ "teasel", "tease" ] ]
#32 Mr. Spell. Gha r = MOOList [ "", "", [ "ghastly", "Ghana" ] ]
#32 Mr. Spell. anasto r = MOOList [ "mo", "", [ "anastomotic", "anastomosis" ] ]
#32 Mr. Spell. planetari r = MOOList [ "", "", [ "planetarium", "planetaria" ] ]
#32 Mr. Spell. skimp r = MOOList [ "", "", [ "skimpy", "skimp" ] ]
#32 Mr. Spell. pene r = MOOList [ "", "t", [ "Penelope" ] ]
#32 Mr. Spell. fores r = MOOList [ "t", "", [ "forestry", "forest" ] ]
#32 Mr. Spell. pend r = MOOList [ "", "", [ "pendulum", "pendant", "pend" ] ]
#32 Mr. Spell. dogmat r = MOOList [ "i", "", [ "dogmatism", "dogmatic" ] ]
#32 Mr. Spell. penc r = MOOList [ "", "", [ "pencil", "penchant", "pence" ] ]
#32 Mr. Spell. anasti r = MOOList [ "gmat", "", [ "anastigmatic", "anastigmat" ] ]
#32 Mr. Spell. depres r = MOOList [ "s", "i", [ "depressor", "depressant", "depress" ] ]
#32 Mr. Spell. pena r = MOOList [ "", "l", [ "penates", "penance" ] ]
#32 Mr. Spell. matrim r = MOOList [ "on", "", [ "matrimony", "matrimonial" ] ]
#32 Mr. Spell. Gin r = MOOList [ "", "gs", [ "Gino", "Ginn", "ginmill", "ginkgo", "Gina", "gin" ] ]
#32 Mr. Spell. candida r = MOOList [ "", "", [ "candidate", "candidacy" ] ]
#32 Mr. Spell. Gim r = MOOList [ "", "b", [ "gimpy" ] ]
#32 Mr. Spell. bellm r = MOOList [ "", "", [ "bellmen", "bellman" ] ]
#32 Mr. Spell. belli r = MOOList [ "", "n", [ "belligerent", "bellicose" ] ]
#32 Mr. Spell. ima r = MOOList [ "g", "ei", [ ] ]
#32 Mr. Spell. imb r = MOOList [ "", "r", [ "imbue", "imbibe", "imbecile", "imbalance" ] ]
#32 Mr. Spell. endog r = MOOList [ "", "a", [ "endogenous" ] ]
#32 Mr. Spell. forma r = MOOList [ "", "lt", [ "formant" ] ]
#32 Mr. Spell. trivia r = MOOList [ "", "", [ "trivial", "trivia" ] ]
#32 Mr. Spell. evoc r = MOOList [ "a", "", [ "evocate", "evocable" ] ]
#32 Mr. Spell. matric r = MOOList [ "", "", [ "matriculate", "matrices" ] ]
#32 Mr. Spell. tooth r = MOOList [ "", "p", [ "toothbrush", "tooth" ] ]
#32 Mr. Spell. ill r = MOOList [ "", "eiu", [ "illogic", "ill" ] ]
#32 Mr. Spell. belly r = MOOList [ "", "", [ "bellyfull", "bellyache", "belly" ] ]
#32 Mr. Spell. Procru r = MOOList [ "ste", "", [ "Procrustes", "procrustean" ] ]
#32 Mr. Spell. goldf r = MOOList [ "i", "", [ "goldfish", "goldfinch" ] ]
#32 Mr. Spell. Giu r = MOOList [ "", "", [ "Giuseppe", "Giuliano" ] ]
#32 Mr. Spell. evol r = MOOList [ "", "u", [ "evolve" ] ]
#32 Mr. Spell. matria r = MOOList [ "rch", "", [ "matriarchal", "matriarch" ] ]
#32 Mr. Spell. quanti r = MOOList [ "", "t", [ "quantile", "quantify", "Quantico" ] ]
#32 Mr. Spell. golde r = MOOList [ "n", "", [ "goldenseal", "goldenrod", "goldeneye", "golden" ] ]
#32 Mr. Spell. pell r = MOOList [ "", "", [ "pellet", "pellagra" ] ]
#32 Mr. Spell. Denn r = MOOList [ "", "", [ "Denny", "Dennis" ] ]
#32 Mr. Spell. zom r = MOOList [ "b", "", [ "zombie", "Zomba" ] ]
#32 Mr. Spell. pelv r = MOOList [ "i", "", [ "pelvis", "pelvic" ] ]
#32 Mr. Spell. zoo r = MOOList [ "", "l", [ "zoom", "zoo" ] ]
#32 Mr. Spell. pelt r = MOOList [ "", "", [ "peltry", "pelt" ] ]
#32 Mr. Spell. ina r = MOOList [ "", "cdlnptu", [ "inasmuch", "inarticulate", "inability" ] ]
#32 Mr. Spell. inb r = MOOList [ "", "or", [ ] ]
#32 Mr. Spell. ind r = MOOList [ "", "eiou", [ "indy", "indwell" ] ]
#32 Mr. Spell. bella r = MOOList [ "", "", [ "Bellatrix", "Bellamy", "belladonna", "Bella" ] ]
#32 Mr. Spell. gallan r = MOOList [ "t", "", [ "gallantry", "gallant" ] ]
#32 Mr. Spell. snuf r = MOOList [ "f", "", [ "snuffle", "snuff" ] ]
#32 Mr. Spell. snug r = MOOList [ "", "g", [ "snug" ] ]
#32 Mr. Spell. imi r = MOOList [ "ta", "", [ "imitate", "imitable" ] ]
#32 Mr. Spell. imm r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. imp r = MOOList [ "", "aeiloru", [ "imp" ] ]
#32 Mr. Spell. chole r = MOOList [ "", "", [ "cholesterol", "cholera" ] ]
#32 Mr. Spell. endot r = MOOList [ "he", "", [ "endothermic", "endothelial" ] ]
#32 Mr. Spell. salut r = MOOList [ "", "a", [ "salute" ] ]
#32 Mr. Spell. inu r = MOOList [ "", "", [ "inure", "inundate" ] ]
#32 Mr. Spell. apath r = MOOList [ "", "", [ "apathy", "apathetic" ] ]
#32 Mr. Spell. Winnip r = MOOList [ "e", "", [ "Winnipesaukee", "Winnipeg" ] ]
#32 Mr. Spell. purgati r = MOOList [ "", "", [ "purgative", "purgation" ] ]
#32 Mr. Spell. inv r = MOOList [ "", "aeio", [ "invulnerable" ] ]
#32 Mr. Spell. transv r = MOOList [ "e", "r", [ "transvestite" ] ]
#32 Mr. Spell. transp r = MOOList [ "", "ailo", [ ] ]
#32 Mr. Spell. transs r = MOOList [ "hip", "p", [ "transship" ] ]
#32 Mr. Spell. transm r = MOOList [ "", "iu", [ "transmogrify" ] ]
#32 Mr. Spell. hideo r = MOOList [ "u", "", [ "hideout", "hideous" ] ]
#32 Mr. Spell. transl r = MOOList [ "", "", [ "translucent", "transliterate", "translate" ] ]
#32 Mr. Spell. figure r = MOOList [ "", "", [ "figures", "figure" ] ]
#32 Mr. Spell. transo r = MOOList [ "", "", [ "transom", "transoceanic" ] ]
#32 Mr. Spell. compreh r = MOOList [ "en", "s", [ "comprehend" ] ]
#32 Mr. Spell. transi r = MOOList [ "", "t", [ "transistor", "transient" ] ]
#32 Mr. Spell. licens r = MOOList [ "", "", [ "licensor", "licensee", "licensable" ] ]
#32 Mr. Spell. figura r = MOOList [ "", "", [ "figurate", "figural" ] ]
#32 Mr. Spell. iod r = MOOList [ "", "i", [ "iodate" ] ]
#32 Mr. Spell. ine r = MOOList [ "", "flqrsx", [ "inevitable", "inept", "ineducable" ] ]
#32 Mr. Spell. inf r = MOOList [ "", "aeiloru", [ ] ]
#32 Mr. Spell. ing r = MOOList [ "", "er", [ "ingot", "inglorious", "ingather" ] ]
#32 Mr. Spell. panor r = MOOList [ "am", "", [ "panoramic", "panorama" ] ]
#32 Mr. Spell. inh r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. ini r = MOOList [ "", "mqt", [ ] ]
#32 Mr. Spell. Pyre r = MOOList [ "", "", [ "Pyrex", "pyre" ] ]
#32 Mr. Spell. inj r = MOOList [ "", "u", [ "inject" ] ]
#32 Mr. Spell. Congo r = MOOList [ "", "", [ "Congolese", "Congo" ] ]
#32 Mr. Spell. ink r = MOOList [ "", "", [ "inkling", "ink" ] ]
#32 Mr. Spell. inl r = MOOList [ "", "a", [ "inlet" ] ]
#32 Mr. Spell. inm r = MOOList [ "a", "", [ "inmate", "Inman" ] ]
#32 Mr. Spell. ingenu r = MOOList [ "", "", [ "ingenuous", "ingenuity" ] ]
#32 Mr. Spell. inn r = MOOList [ "", "aou", [ "innkeeper", "innermost", "inn" ] ]
#32 Mr. Spell. coinciden r = MOOList [ "t", "", [ "coincidental", "coincident" ] ]
#32 Mr. Spell. ino r = MOOList [ "", "pr", [ "inoculate" ] ]
#32 Mr. Spell. inp r = MOOList [ "ut", "", [ "inputting", "input" ] ]
#32 Mr. Spell. Dene r = MOOList [ "b", "", [ "Denebola", "Deneb" ] ]
#32 Mr. Spell. Athen r = MOOList [ "", "", [ "Athens", "Athenian", "Athena" ] ]
#32 Mr. Spell. inq r = MOOList [ "u", "i", [ "inquest" ] ]
#32 Mr. Spell. compres r = MOOList [ "s", "i", [ "compressor", "compress" ] ]
#32 Mr. Spell. Athei r = MOOList [ "s", "", [ "atheist", "atheism" ] ]
#32 Mr. Spell. ins r = MOOList [ "", "aceioptu", [ "inshore" ] ]
#32 Mr. Spell. int r = MOOList [ "", "aeioru", [ ] ]
#32 Mr. Spell. Dell r = MOOList [ "", "", [ "Della", "dell" ] ]
#32 Mr. Spell. willo r = MOOList [ "", "w", [ "Willoughby" ] ]
#32 Mr. Spell. Phoe r = MOOList [ "", "n", [ "phoebe" ] ]
#32 Mr. Spell. Delp r = MOOList [ "hi", "n", [ "Delphic", "Delphi" ] ]
#32 Mr. Spell. Butterf r = MOOList [ "", "", [ "butterfly", "Butterfield", "butterfat" ] ]
#32 Mr. Spell. Churchi r = MOOList [ "ll", "", [ "Churchillian", "Churchill" ] ]
#32 Mr. Spell. Gli r = MOOList [ "", "dmst", [ "glint", "glib" ] ]
#32 Mr. Spell. persev r = MOOList [ "er", "", [ "persevere", "perseverant" ] ]
#32 Mr. Spell. congres r = MOOList [ "s", "mw", [ "congressional", "congress" ] ]
#32 Mr. Spell. sickl r = MOOList [ "e", "", [ "sicklewort", "sickle" ] ]
#32 Mr. Spell. Confu r = MOOList [ "", "cs", [ "confute" ] ]
#32 Mr. Spell. transe r = MOOList [ "", "", [ "transept", "transect" ] ]
#32 Mr. Spell. transd r = MOOList [ "uc", "", [ "transduction", "transducer" ] ]
#32 Mr. Spell. transg r = MOOList [ "ress", "", [ "transgressor", "transgression", "transgress" ] ]
#32 Mr. Spell. transf r = MOOList [ "", "eiou", [ ] ]
#32 Mr. Spell. transa r = MOOList [ "", "", [ "transatlantic", "transalpine", "transact" ] ]
#32 Mr. Spell. salva r = MOOList [ "", "gt", [ "Salvador" ] ]
#32 Mr. Spell. transc r = MOOList [ "", "eor", [ ] ]
#32 Mr. Spell. ion r = MOOList [ "", "o", [ "ionic", "ion" ] ]
#32 Mr. Spell. Amer r = MOOList [ "", "i", [ "Amerada" ] ]
#32 Mr. Spell. Saturn r = MOOList [ "", "", [ "saturnine", "Saturnalia", "Saturn" ] ]
#32 Mr. Spell. quickl r = MOOList [ "", "", [ "quickly", "quicklime" ] ]
#32 Mr. Spell. parenth r = MOOList [ "e", "s", [ "parenthetic" ] ]
#32 Mr. Spell. journe r = MOOList [ "y", "m", [ "journey" ] ]
#32 Mr. Spell. houd r = MOOList [ "", "", [ "Houdini", "Houdaille" ] ]
#32 Mr. Spell. Satura r = MOOList [ "", "t", [ "saturable" ] ]
#32 Mr. Spell. journa r = MOOList [ "l", "", [ "journalese", "journal" ] ]
#32 Mr. Spell. parenta r = MOOList [ "", "", [ "parental", "parentage" ] ]
#32 Mr. Spell. taut r = MOOList [ "", "", [ "tautology", "taut" ] ]
#32 Mr. Spell. custo r = MOOList [ "", "dm", [ ] ]
#32 Mr. Spell. Artic r = MOOList [ "", "u", [ "article", "artichoke" ] ]
#32 Mr. Spell. ips r = MOOList [ "", "", [ "ipso", "ipsilateral" ] ]
#32 Mr. Spell. socke r = MOOList [ "", "", [ "sockeye", "socket" ] ]
#32 Mr. Spell. explo r = MOOList [ "", "irs", [ "explode" ] ]
#32 Mr. Spell. fina r = MOOList [ "", "ln", [ ] ]
#32 Mr. Spell. hotb r = MOOList [ "", "", [ "hotbox", "hotbed" ] ]
#32 Mr. Spell. Hawa r = MOOList [ "ii", "", [ "Hawaiian", "Hawaii" ] ]
#32 Mr. Spell. hoth r = MOOList [ "", "", [ "hothouse", "hothead" ] ]
#32 Mr. Spell. Hawk r = MOOList [ "", "", [ "Hawkins", "hawk" ] ]
#32 Mr. Spell. fine r = MOOList [ "", "s", [ "finery", "fine" ] ]
#32 Mr. Spell. cordi r = MOOList [ "", "", [ "cordite", "cordial" ] ]
#32 Mr. Spell. find r = MOOList [ "", "", [ "finds", "find" ] ]
#32 Mr. Spell. hote r = MOOList [ "l", "", [ "hotelman", "hotel" ] ]
#32 Mr. Spell. it' r = MOOList [ "", "", [ "it's", "it'll", "it'd" ] ]
#32 Mr. Spell. fini r = MOOList [ "", "s", [ "finite", "finicky", "finial" ] ]
#32 Mr. Spell. fing r = MOOList [ "er", "", [ "fingertip", "fingerprint", "fingernail", "finger" ] ]
#32 Mr. Spell. Pion r = MOOList [ "", "", [ "pioneer", "pion" ] ]
#32 Mr. Spell. Rous r = MOOList [ "", "", [ "roustabout", "Rousseau", "rouse" ] ]
#32 Mr. Spell. Goe r = MOOList [ "", "", [ "Goethe", "goes" ] ]
#32 Mr. Spell. Hawt r = MOOList [ "horn", "", [ "Hawthorne", "hawthorn" ] ]
#32 Mr. Spell. God r = MOOList [ "", "dfsw", [ "godparent", "godmother", "godkin", "godhead", "god" ] ]
#32 Mr. Spell. tatt r = MOOList [ "", "l", [ "tatty", "tattoo" ] ]
#32 Mr. Spell. convol r = MOOList [ "", "u", [ "convolve" ] ]
#32 Mr. Spell. hosp r = MOOList [ "i", "t", [ "hospice" ] ]
#32 Mr. Spell. host r = MOOList [ "", "e", [ "hostler", "hostile", "hostage", "host" ] ]
#32 Mr. Spell. lacun r = MOOList [ "a", "", [ "lacunae", "lacuna" ] ]
#32 Mr. Spell. Gou r = MOOList [ "", "r", [ "gout", "Gould", "gouge", "Gouda", "Goucher" ] ]
#32 Mr. Spell. Got r = MOOList [ "", "ht", [ "got" ] ]
#32 Mr. Spell. trut r = MOOList [ "h", "", [ "truthful", "truth" ] ]
#32 Mr. Spell. sorr r = MOOList [ "", "o", [ "sorry", "sorrel" ] ]
#32 Mr. Spell. trus r = MOOList [ "", "t", [ "truss" ] ]
#32 Mr. Spell. Gor r = MOOList [ "", "deg", [ "gorbachev", "gory", "Gorton", "gorse", "Gorky", "gorilla", "Gorham" ] ]
#32 Mr. Spell. sort r = MOOList [ "", "", [ "sorted", "sortie", "sort" ] ]
#32 Mr. Spell. tate r = MOOList [ "", "", [ "tater", "tate" ] ]
#32 Mr. Spell. Gol r = MOOList [ "", "d", [ "golly", "Goliath", "golf", "Goleta" ] ]
#32 Mr. Spell. Gott r = MOOList [ "", "", [ "Gottfried", "gotten" ] ]
#32 Mr. Spell. Ande r = MOOList [ "", "rs", [ "Andean" ] ]
#32 Mr. Spell. trun r = MOOList [ "", "c", [ "trunk", "trundle" ] ]
#32 Mr. Spell. atlan r = MOOList [ "t", "i", [ "atlantes", "Atlanta" ] ]
#32 Mr. Spell. Saul r = MOOList [ "", "", [ "Sault", "Saul" ] ]
#32 Mr. Spell. isi r = MOOList [ "", "n", [ "Isis" ] ]
#32 Mr. Spell. iri r = MOOList [ "", "s", [ "iridium" ] ]
#32 Mr. Spell. horn r = MOOList [ "", "b", [ "horny", "hornwort", "horntail", "hornmouth", "hornet", "horn" ] ]
#32 Mr. Spell. glom r = MOOList [ "", "", [ "glomerular", "glom" ] ]
#32 Mr. Spell. expla r = MOOList [ "", "n", [ "explain" ] ]
#32 Mr. Spell. fill r = MOOList [ "", "e", [ "filly", "fillip", "fill" ] ]
#32 Mr. Spell. irk r = MOOList [ "", "", [ "irksome", "irk" ] ]
#32 Mr. Spell. fili r = MOOList [ "", "", [ "Filipino", "filigree", "filibuster", "filial" ] ]
#32 Mr. Spell. trua r = MOOList [ "n", "", [ "truant", "truancy" ] ]
#32 Mr. Spell. tass r = MOOList [ "", "", [ "tassel", "Tass" ] ]
#32 Mr. Spell. horr r = MOOList [ "", "i", [ "horror", "horrendous" ] ]
#32 Mr. Spell. truc r = MOOList [ "", "", [ "truculent", "truck", "truce" ] ]
#32 Mr. Spell. Malay r = MOOList [ "", "", [ "Malaysia", "Malay" ] ]
#32 Mr. Spell. Pins r = MOOList [ "", "", [ "Pinsky", "pinscher" ] ]
#32 Mr. Spell. iro r = MOOList [ "", "n", [ "Iroquois" ] ]
#32 Mr. Spell. gloo r = MOOList [ "m", "", [ "gloomy", "gloom" ] ]
#32 Mr. Spell. film r = MOOList [ "", "", [ "filmy", "filmstrip", "filmmake", "filmdom", "film" ] ]
#32 Mr. Spell. tast r = MOOList [ "", "e", [ "tasty", "tasting" ] ]
#32 Mr. Spell. horo r = MOOList [ "", "", [ "Horowitz", "horoscope", "horology" ] ]
#32 Mr. Spell. thist r = MOOList [ "le", "", [ "thistledown", "thistle" ] ]
#32 Mr. Spell. Roth r = MOOList [ "", "", [ "Rothschild", "Roth" ] ]
#32 Mr. Spell. expli r = MOOList [ "c", "a", [ "explicit" ] ]
#32 Mr. Spell. irr r = MOOList [ "", "aei", [ "irruption" ] ]
#32 Mr. Spell. glot r = MOOList [ "t", "", [ "glottis", "glottal" ] ]
#32 Mr. Spell. filt r = MOOList [ "", "h", [ "filtrate", "filter" ] ]
#32 Mr. Spell. Andr r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. glos r = MOOList [ "s", "", [ "glossy", "glossolalia", "glossary", "gloss" ] ]
#32 Mr. Spell. Ando r = MOOList [ "", "", [ "Andover", "Andorra" ] ]
#32 Mr. Spell. hors r = MOOList [ "e", "fmpw", [ "horsetail", "horseshoe", "horsehair", "horsedom", "horseback", "horse" ] ]
#32 Mr. Spell. block r = MOOList [ "", "a", [ "blocky", "blockhouse", "block" ] ]
#32 Mr. Spell. hora r = MOOList [ "", "", [ "Horatio", "Horace" ] ]
#32 Mr. Spell. ocea r = MOOList [ "n", "i", [ "oceanside", "oceanography", "ocean" ] ]
#32 Mr. Spell. ita r = MOOList [ "l", "i", [ "Italy" ] ]
#32 Mr. Spell. Balla r = MOOList [ "", "", [ "ballast", "Ballard", "ballad" ] ]
#32 Mr. Spell. sights r = MOOList [ "ee", "", [ "sightseer", "sightseeing", "sightsee" ] ]
#32 Mr. Spell. ite r = MOOList [ "", "", [ "iterate", "item" ] ]
#32 Mr. Spell. fila r = MOOList [ "ment", "", [ "filamentary", "filament" ] ]
#32 Mr. Spell. glob r = MOOList [ "", "u", [ "globe", "global", "glob" ] ]
#32 Mr. Spell. hori r = MOOList [ "zon", "t", [ "horizon" ] ]
#32 Mr. Spell. iti r = MOOList [ "nera", "", [ "itinerary", "itinerant" ] ]
#32 Mr. Spell. file r = MOOList [ "", "", [ "filet", "file" ] ]
#32 Mr. Spell. tarp r = MOOList [ "", "a", [ "tarpon" ] ]
#32 Mr. Spell. iso r = MOOList [ "", "clmt", [ "isopleth" ] ]
#32 Mr. Spell. tart r = MOOList [ "", "a", [ "tart" ] ]
#32 Mr. Spell. Sauc r = MOOList [ "", "e", [ "saucy" ] ]
#32 Mr. Spell. emplo r = MOOList [ "y", "e", [ "employ" ] ]
#32 Mr. Spell. Saud r = MOOList [ "", "", [ "Saudi", "Saud" ] ]
#32 Mr. Spell. thirs r = MOOList [ "t", "", [ "thirsty", "thirst" ] ]
#32 Mr. Spell. Goth r = MOOList [ "", "", [ "Gothic", "Gotham" ] ]
#32 Mr. Spell. thirt r = MOOList [ "", "e", [ "thirty", "thirtieth" ] ]
#32 Mr. Spell. iss r = MOOList [ "u", "e", [ "issuant" ] ]
#32 Mr. Spell. quicks r = MOOList [ "", "", [ "quickstep", "quicksilver", "quicksand" ] ]
#32 Mr. Spell. festi r = MOOList [ "v", "", [ "festive", "festival" ] ]
#32 Mr. Spell. Anat r = MOOList [ "", "o", [ "anathema" ] ]
#32 Mr. Spell. alumi r = MOOList [ "na", "", [ "aluminate", "alumina" ] ]
#32 Mr. Spell. carefu r = MOOList [ "l", "", [ "carefully", "careful" ] ]
#32 Mr. Spell. tara r = MOOList [ "", "n", [ "tara" ] ]
#32 Mr. Spell. Rosenb r = MOOList [ "", "", [ "Rosenblum", "Rosenberg" ] ]
#32 Mr. Spell. content r = MOOList [ "", "i", [ "contents", "content" ] ]
#32 Mr. Spell. Francisc r = MOOList [ "", "", [ "Francisco", "Franciscan" ] ]
#32 Mr. Spell. Hath r = MOOList [ "", "", [ "Hathaway", "hath" ] ]
#32 Mr. Spell. Sash r = MOOList [ "", "", [ "sashay", "sash" ] ]
#32 Mr. Spell. Sask r = MOOList [ "at", "", [ "Saskatoon", "Saskatchewan" ] ]
#32 Mr. Spell. alumn r = MOOList [ "", "a", [ "alumnus", "alumni" ] ]
#32 Mr. Spell. occu r = MOOList [ "", "lpr", [ ] ]
#32 Mr. Spell. expre r = MOOList [ "ss", "i", [ "expressway", "express" ] ]
#32 Mr. Spell. associat r = MOOList [ "", "i", [ "associate" ] ]
#32 Mr. Spell. its r = MOOList [ "", "", [ "its", "itself" ] ]
#32 Mr. Spell. Maldi r = MOOList [ "", "", [ "Maldive", "maldistribute" ] ]
#32 Mr. Spell. personal r = MOOList [ "", "", [ "personality", "personal" ] ]
#32 Mr. Spell. soot r = MOOList [ "", "h", [ "soot" ] ]
#32 Mr. Spell. Hatt r = MOOList [ "", "i", [ "Hatteras" ] ]
#32 Mr. Spell. milita r = MOOList [ "", "r", [ "militate", "militant" ] ]
#32 Mr. Spell. represe r = MOOList [ "nt", "", [ "represents", "representative" ] ]
#32 Mr. Spell. occl r = MOOList [ "u", "s", [ "occlude" ] ]
#32 Mr. Spell. occi r = MOOList [ "", "d", [ "occipital" ] ]
#32 Mr. Spell. Anab r = MOOList [ "", "", [ "Anabel", "Anabaptist" ] ]
#32 Mr. Spell. militi r = MOOList [ "a", "", [ "militiamen", "militia" ] ]
#32 Mr. Spell. hope r = MOOList [ "", "", [ "hopeful", "hope" ] ]
#32 Mr. Spell. hook r = MOOList [ "", "", [ "hookworm", "hookup", "hook" ] ]
#32 Mr. Spell. effe r = MOOList [ "", "c", [ "effete", "efferent", "effeminate" ] ]
#32 Mr. Spell. tapp r = MOOList [ "", "", [ "tappet", "tappa" ] ]
#32 Mr. Spell. irri r = MOOList [ "", "t", [ "irrigate" ] ]
#32 Mr. Spell. repress r = MOOList [ "i", "", [ "repressive", "repression" ] ]
#32 Mr. Spell. effl r = MOOList [ "", "ou", [ ] ]
#32 Mr. Spell. effi r = MOOList [ "", "c", [ "Effie" ] ]
#32 Mr. Spell. effo r = MOOList [ "rt", "", [ "efforts", "effort" ] ]
#32 Mr. Spell. manne r = MOOList [ "", "", [ "manner", "mannequin" ] ]
#32 Mr. Spell. tape r = MOOList [ "", "", [ "tapeworm", "tapestry", "taper", "tape" ] ]
#32 Mr. Spell. hoop r = MOOList [ "", "", [ "hoopla", "hoop" ] ]
#32 Mr. Spell. hoov r = MOOList [ "e", "", [ "hooves", "Hoover" ] ]
#32 Mr. Spell. tapi r = MOOList [ "", "", [ "tapis", "tapir" ] ]
#32 Mr. Spell. Gore r = MOOList [ "", "", [ "Goren", "gore" ] ]
#32 Mr. Spell. expor r = MOOList [ "t", "", [ "exportation", "export" ] ]
#32 Mr. Spell. expos r = MOOList [ "", "i", [ "exposure", "expose" ] ]
#32 Mr. Spell. sonn r = MOOList [ "", "", [ "sonny", "sonnet" ] ]
#32 Mr. Spell. Roos r = MOOList [ "", "e", [ "roost" ] ]
#32 Mr. Spell. irre r = MOOList [ "", "cdmpsv", [ "irretrievable", "irrelevant", "irregular", "irrefutable" ] ]
#32 Mr. Spell. arteriol r = MOOList [ "", "", [ "arteriolosclerosis", "arteriole" ] ]
#32 Mr. Spell. seminar r = MOOList [ "", "", [ "seminary", "seminarian", "seminar" ] ]
#32 Mr. Spell. irra r = MOOList [ "", "", [ "Irrawaddy", "irrational", "irradiate" ] ]
#32 Mr. Spell. song r = MOOList [ "", "b", [ "songful", "song" ] ]
#32 Mr. Spell. hoof r = MOOList [ "", "", [ "hoofmark", "hoof" ] ]
#32 Mr. Spell. Hara r = MOOList [ "", "", [ "harass", "harangue" ] ]
#32 Mr. Spell. effa r = MOOList [ "ce", "", [ "effaceable", "efface" ] ]
#32 Mr. Spell. hood r = MOOList [ "", "", [ "hoodlum", "hood" ] ]
#32 Mr. Spell. Harl r = MOOList [ "", "e", [ "Harlan" ] ]
#32 Mr. Spell. sona r = MOOList [ "", "", [ "sonata", "sonar", "sonant" ] ]
#32 Mr. Spell. hono r = MOOList [ "", "r", [ "Honolulu" ] ]
#32 Mr. Spell. Harr r = MOOList [ "", "i", [ "harry", "harrow" ] ]
#32 Mr. Spell. Hart r = MOOList [ "", "", [ "Hartman", "Hartley", "Hartford", "hart" ] ]
#32 Mr. Spell. particular r = MOOList [ "", "", [ "particularly", "particular" ] ]
#32 Mr. Spell. figu r = MOOList [ "r", "ae", [ "figurine" ] ]
#32 Mr. Spell. hexag r = MOOList [ "on", "", [ "hexagonal", "hexagon" ] ]
#32 Mr. Spell. soma r = MOOList [ "", "l", [ "somatic", "soma" ] ]
#32 Mr. Spell. somb r = MOOList [ "", "", [ "sombre", "somber" ] ]
#32 Mr. Spell. synops r = MOOList [ "", "", [ "synopsis", "synopses" ] ]
#32 Mr. Spell. some r = MOOList [ "", "bortw", [ "someplace", "somehow", "someday", "some" ] ]
#32 Mr. Spell. oscilla r = MOOList [ "t", "", [ "oscillatory", "oscillate" ] ]
#32 Mr. Spell. hone r = MOOList [ "", "sy", [ "hone" ] ]
#32 Mr. Spell. hond r = MOOList [ "", "", [ "Honduras", "hondo", "Honda" ] ]
#32 Mr. Spell. homi r = MOOList [ "", "c", [ "homily" ] ]
#32 Mr. Spell. inaccu r = MOOList [ "ra", "", [ "inaccurate", "inaccuracy" ] ]
#32 Mr. Spell. Archi r = MOOList [ "", "tv", [ "archipelago", "Archimedes", "Archibald" ] ]
#32 Mr. Spell. Gue r = MOOList [ "", "rs", [ "Guenther", "Guelph" ] ]
#32 Mr. Spell. homo r = MOOList [ "", "glm", [ "homozygous", "homotopy", "homosexual", "homophobia", "homonym", "homo" ] ]
#32 Mr. Spell. hydran r = MOOList [ "", "", [ "hydrant", "hydrangea" ] ]
#32 Mr. Spell. trou r = MOOList [ "", "bt", [ "trouser", "troupe", "trounce", "trough" ] ]
#32 Mr. Spell. solu r = MOOList [ "", "t", [ "soluble" ] ]
#32 Mr. Spell. solv r = MOOList [ "", "e", [ "solvate" ] ]
#32 Mr. Spell. expon r = MOOList [ "ent", "i", [ "exponent" ] ]
#32 Mr. Spell. tang r = MOOList [ "", "e", [ "tangy", "tango", "tangle", "tangible", "tang" ] ]
#32 Mr. Spell. soli r = MOOList [ "", "cdt", [ "solipsism", "soliloquy" ] ]
#32 Mr. Spell. trol r = MOOList [ "l", "", [ "trollop", "trolley", "troll" ] ]
#32 Mr. Spell. glit r = MOOList [ "", "", [ "glitter", "glitch" ] ]
#32 Mr. Spell. fift r = MOOList [ "", "e", [ "fifty", "fiftieth", "fifth" ] ]
#32 Mr. Spell. Guy r = MOOList [ "", "", [ "Guyana", "guy" ] ]
#32 Mr. Spell. trom r = MOOList [ "", "", [ "trompe", "trombone" ] ]
#32 Mr. Spell. gladd r = MOOList [ "", "", [ "gladdy", "gladden" ] ]
#32 Mr. Spell. trop r = MOOList [ "", "ho", [ "tropic" ] ]
#32 Mr. Spell. holy r = MOOList [ "", "", [ "holystone", "Holyoke" ] ]
#32 Mr. Spell. sola r = MOOList [ "", "", [ "solar", "solace" ] ]
#32 Mr. Spell. Gut r = MOOList [ "", "", [ "guttural", "gutsy", "Guthrie", "Gutenberg", "gut" ] ]
#32 Mr. Spell. trod r = MOOList [ "", "", [ "trodden", "trod" ] ]
#32 Mr. Spell. Gur r = MOOList [ "", "", [ "guru", "Gurkha", "gurgle" ] ]
#32 Mr. Spell. sold r = MOOList [ "", "i", [ "solder", "sold" ] ]
#32 Mr. Spell. home r = MOOList [ "", "bmosw", [ "Homeric", "homeland", "homecoming", "home" ] ]
#32 Mr. Spell. sole r = MOOList [ "", "", [ "solenoid", "solemn", "solecism", "sole" ] ]
#32 Mr. Spell. Gun r = MOOList [ "", "fkmnps", [ "Gunther", "Gunderson", "gun" ] ]
#32 Mr. Spell. Gonz r = MOOList [ "ale", "", [ "Gonzalez", "Gonzales" ] ]
#32 Mr. Spell. hole r = MOOList [ "", "", [ "holeable", "hole" ] ]
#32 Mr. Spell. glid r = MOOList [ "", "", [ "glide", "Glidden" ] ]
#32 Mr. Spell. starc r = MOOList [ "h", "", [ "starchy", "starch" ] ]
#32 Mr. Spell. juri r = MOOList [ "", "s", [ "juridic" ] ]
#32 Mr. Spell. tama r = MOOList [ "", "r", [ "tamale" ] ]
#32 Mr. Spell. glim r = MOOList [ "", "", [ "glimpse", "glimmer" ] ]
#32 Mr. Spell. breaka r = MOOList [ "", "", [ "breakaway", "breakage" ] ]
#32 Mr. Spell. glis r = MOOList [ "", "", [ "glisten", "glissade" ] ]
#32 Mr. Spell. starl r = MOOList [ "", "i", [ "starlet" ] ]
#32 Mr. Spell. fier r = MOOList [ "", "", [ "fiery", "fierce" ] ]
#32 Mr. Spell. Sanc r = MOOList [ "", "ht", [ ] ]
#32 Mr. Spell. hold r = MOOList [ "", "", [ "holds", "holding", "holdup", "holdover", "holden", "hold" ] ]
#32 Mr. Spell. jura r = MOOList [ "", "", [ "Jurassic", "Jura" ] ]
#32 Mr. Spell. Tusk r = MOOList [ "", "", [ "Tuskegee", "tusk" ] ]
#32 Mr. Spell. tali r = MOOList [ "sman", "", [ "talismanic", "talisman" ] ]
#32 Mr. Spell. talk r = MOOList [ "", "", [ "talky", "talkie", "talkative", "talk" ] ]
#32 Mr. Spell. fief r = MOOList [ "", "", [ "fiefdom", "fief" ] ]
#32 Mr. Spell. Roma r = MOOList [ "n", "", [ "romantic", "Romano", "Romania", "romance", "Roman" ] ]
#32 Mr. Spell. fiel r = MOOList [ "d", "s", [ "fieldwork", "field" ] ]
#32 Mr. Spell. school r = MOOList [ "", "bgm", [ "schoolwork", "schoolteacher", "schoolroom", "schoolhouse", "school" ] ]
#32 Mr. Spell. Rome r = MOOList [ "", "", [ "Romeo", "Rome" ] ]
#32 Mr. Spell. talc r = MOOList [ "", "", [ "talcum", "talc" ] ]
#32 Mr. Spell. Sant r = MOOList [ "", "a", [ "Santo", "Santiago" ] ]
#32 Mr. Spell. fien r = MOOList [ "d", "", [ "fiendish", "fiend" ] ]
#32 Mr. Spell. tale r = MOOList [ "", "", [ "talent", "tale" ] ]
#32 Mr. Spell. Gold r = MOOList [ "", "efs", [ "Goldwater", "Goldman", "Goldberg", "gold" ] ]
#32 Mr. Spell. precipit r = MOOList [ "", "a", [ "precipitous" ] ]
#32 Mr. Spell. lauda r = MOOList [ "", "", [ "laudatory", "laudanum" ] ]
#32 Mr. Spell. whereo r = MOOList [ "", "", [ "whereon", "whereof" ] ]
#32 Mr. Spell. Cinem r = MOOList [ "a", "", [ "cinematic", "cinema" ] ]
#32 Mr. Spell. stati r = MOOList [ "", "o", [ "statistician", "static" ] ]
#32 Mr. Spell. wherew r = MOOList [ "ith", "", [ "wherewithal", "wherewith" ] ]
#32 Mr. Spell. fidd r = MOOList [ "l", "e", [ "fiddling" ] ]
#32 Mr. Spell. Turi r = MOOList [ "n", "", [ "Turing", "Turin" ] ]
#32 Mr. Spell. Hanl r = MOOList [ "", "", [ "Hanlon", "Hanley" ] ]
#32 Mr. Spell. Hank r = MOOList [ "", "", [ "Hankel", "hank" ] ]
#32 Mr. Spell. state r = MOOList [ "", "rs", [ "stated", "statewide", "Staten", "state" ] ]
#32 Mr. Spell. fide r = MOOList [ "", "", [ "fidelity", "fide" ] ]
#32 Mr. Spell. securi r = MOOList [ "", "", [ "securing", "security" ] ]
#32 Mr. Spell. Samp r = MOOList [ "", "", [ "Sampson", "sample" ] ]
#32 Mr. Spell. Hans r = MOOList [ "", "eo", [ "Hans" ] ]
#32 Mr. Spell. Samu r = MOOList [ "el", "", [ "Samuelson", "Samuel" ] ]
#32 Mr. Spell. Hann r = MOOList [ "", "a", [ "Hannibal" ] ]
#32 Mr. Spell. take r = MOOList [ "", "o", [ "taker", "takes", "taketh", "taken", "take" ] ]
#32 Mr. Spell. Hano r = MOOList [ "", "v", [ "Hanoi" ] ]
#32 Mr. Spell. starv r = MOOList [ "", "", [ "starve", "starvation" ] ]
#32 Mr. Spell. Sali r = MOOList [ "", "nsv", [ "salient" ] ]
#32 Mr. Spell. correc r = MOOList [ "t", "", [ "corrector", "correct" ] ]
#32 Mr. Spell. penitenti r = MOOList [ "a", "", [ "penitentiary", "penitential" ] ]
#32 Mr. Spell. lithos r = MOOList [ "pher", "", [ "lithospheric", "lithosphere" ] ]
#32 Mr. Spell. Hals r = MOOList [ "", "", [ "Halstead", "Halsey" ] ]
#32 Mr. Spell. vestig r = MOOList [ "", "", [ "vestigial", "vestige" ] ]
#32 Mr. Spell. fict r = MOOList [ "i", "", [ "fictive", "fictitious", "fiction" ] ]
#32 Mr. Spell. start r = MOOList [ "", "", [ "starts", "starting", "started", "startup", "startle", "start" ] ]
#32 Mr. Spell. shore r = MOOList [ "", "", [ "shoreline", "shore" ] ]
#32 Mr. Spell. Sale r = MOOList [ "", "s", [ "Salerno", "Salem", "sale" ] ]
#32 Mr. Spell. subtle r = MOOList [ "", "", [ "subtlety", "subtle" ] ]
#32 Mr. Spell. prestig r = MOOList [ "", "", [ "prestigious", "prestige" ] ]
#32 Mr. Spell. corres r = MOOList [ "pond", "", [ "correspondent", "correspond" ] ]
#32 Mr. Spell. Cinde r = MOOList [ "r", "", [ "Cinderella", "cinder" ] ]
#32 Mr. Spell. struc r = MOOList [ "", "t", [ "struck" ] ]
#32 Mr. Spell. lithog r = MOOList [ "raph", "", [ "lithography", "lithograph" ] ]
#32 Mr. Spell. Hamp r = MOOList [ "", "", [ "Hampton", "Hampshire", "hamper" ] ]
#32 Mr. Spell. short r = MOOList [ "", "cse", [ "shortish", "shorthand", "shortfall", "shortage", "short" ] ]
#32 Mr. Spell. Haml r = MOOList [ "", "", [ "Hamlin", "hamlet" ] ]
#32 Mr. Spell. buildi r = MOOList [ "ng", "", [ "buildings", "building" ] ]
#32 Mr. Spell. where' r = MOOList [ "", "", [ "where're", "where'd" ] ]
#32 Mr. Spell. fibr r = MOOList [ "", "o", [ "fibrin", "fibration" ] ]
#32 Mr. Spell. concurre r = MOOList [ "", "", [ "concurrent", "concurred" ] ]
#32 Mr. Spell. tail r = MOOList [ "", "", [ "tailwind", "tailspin", "tailor", "tailgate", "tail" ] ]
#32 Mr. Spell. shoul r = MOOList [ "d", "", [ "shouldn't", "shoulder", "should" ] ]
#32 Mr. Spell. juni r = MOOList [ "", "", [ "juniper", "junior" ] ]
#32 Mr. Spell. glea r = MOOList [ "", "", [ "Gleason", "glean", "gleam" ] ]
#32 Mr. Spell. glee r = MOOList [ "", "", [ "gleeful", "glee" ] ]
#32 Mr. Spell. Hale r = MOOList [ "", "", [ "Haley", "hale" ] ]
#32 Mr. Spell. chordat r = MOOList [ "", "", [ "chordate", "chordata" ] ]
#32 Mr. Spell. manum r = MOOList [ "i", "t", [ "manumission" ] ]
#32 Mr. Spell. socia r = MOOList [ "", "", [ "social", "sociable" ] ]
#32 Mr. Spell. junk r = MOOList [ "", "e", [ "junky", "junk" ] ]
#32 Mr. Spell. pictu r = MOOList [ "re", "", [ "picturesque", "picture" ] ]
#32 Mr. Spell. vorti r = MOOList [ "c", "", [ "vorticity", "vortices" ] ]
#32 Mr. Spell. origina r = MOOList [ "", "", [ "originate", "original" ] ]
#32 Mr. Spell. fian r = MOOList [ "ce", "", [ "fiancee", "fiance" ] ]
#32 Mr. Spell. exposito r = MOOList [ "r", "", [ "expository", "expositor" ] ]
#32 Mr. Spell. statu r = MOOList [ "", "et", [ "status", "stature", "statuary" ] ]
#32 Mr. Spell. Alban r = MOOList [ "", "i", [ "Albany" ] ]
#32 Mr. Spell. corpo r = MOOList [ "r", "a", [ "corporeal" ] ]
#32 Mr. Spell. corpu r = MOOList [ "", "s", [ "corpulent" ] ]
#32 Mr. Spell. epicy r = MOOList [ "cl", "", [ "epicyclic", "epicycle" ] ]
#32 Mr. Spell. corps r = MOOList [ "", "m", [ "corpse", "corps" ] ]
#32 Mr. Spell. obvio r = MOOList [ "us", "", [ "obviously", "obvious" ] ]
#32 Mr. Spell. proofr r = MOOList [ "ead", "", [ "proofreading", "proofread" ] ]
#32 Mr. Spell. trit r = MOOList [ "", "", [ "triton", "tritium", "trite" ] ]
#32 Mr. Spell.entries r = MOONumber 25132
#32 Mr. Spell. triv r = MOOList [ "", "i", [ "trivalent" ] ]
#32 Mr. Spell. soft r = MOOList [ "", "w", [ "soften", "softball", "soft" ] ]
#32 Mr. Spell. triu r = MOOList [ "", "m", [ "triune" ] ]
#32 Mr. Spell. jumb r = MOOList [ "", "", [ "jumbo", "jumble" ] ]
#32 Mr. Spell. tril r = MOOList [ "", "lo", [ ] ]
#32 Mr. Spell. trin r = MOOList [ "", "i", [ "trinket" ] ]
#32 Mr. Spell. Misso r = MOOList [ "u", "", [ "Missouri", "Missoula" ] ]
#32 Mr. Spell. jump r = MOOList [ "", "", [ "jumpy", "jump" ] ]
#32 Mr. Spell. wherea r = MOOList [ "", "", [ "whereas", "whereabout" ] ]
#32 Mr. Spell. trim r = MOOList [ "", "e", [ "trim" ] ]
#32 Mr. Spell. trip r = MOOList [ "", "lo", [ "triptych", "triphenylphosphine", "tripe", "tripartite", "trip" ] ]
#32 Mr. Spell. trio r = MOOList [ "", "", [ "trioxide", "triode", "trio" ] ]
#32 Mr. Spell. Pica r = MOOList [ "", "", [ "picayune", "Picasso", "pica" ] ]
#32 Mr. Spell. trid r = MOOList [ "", "", [ "tridiagonal", "trident" ] ]
#32 Mr. Spell. Hait r = MOOList [ "i", "", [ "Haitian", "Haiti" ] ]
#32 Mr. Spell. trif r = MOOList [ "l", "u", [ "trifle" ] ]
#32 Mr. Spell. trie r = MOOList [ "", "", [ "tries", "triennial", "tried" ] ]
#32 Mr. Spell. trig r = MOOList [ "", "o", [ "trigram", "trig" ] ]
#32 Mr. Spell. classi r = MOOList [ "", "f", [ "classic" ] ]
#32 Mr. Spell. coale r = MOOList [ "sce", "", [ "coalescent", "coalesce" ] ]
#32 Mr. Spell. trib r = MOOList [ "", "eu", [ "tribal" ] ]
#32 Mr. Spell. tria r = MOOList [ "", "n", [ "triatomic", "Triassic", "trial", "triad", "triac", "triable" ] ]
#32 Mr. Spell. showm r = MOOList [ "", "", [ "showmen", "showman" ] ]
#32 Mr. Spell. Flet r = MOOList [ "ch", "", [ "Fletcher", "fletch" ] ]
#32 Mr. Spell. showp r = MOOList [ "", "", [ "showplace", "showpiece" ] ]
#32 Mr. Spell. Tuni r = MOOList [ "", "s", [ "tunic" ] ]
#32 Mr. Spell. complain r = MOOList [ "", "", [ "complaint", "complainant", "complain" ] ]
#32 Mr. Spell. cornf r = MOOList [ "", "", [ "cornflower", "cornfield" ] ]
#32 Mr. Spell. thing r = MOOList [ "", "", [ "things", "thing" ] ]
#32 Mr. Spell. jag r = MOOList [ "", "", [ "jaguar", "jagging", "jag" ] ]
#32 Mr. Spell. corrig r = MOOList [ "", "e", [ "corrigible" ] ]
#32 Mr. Spell. jak r = MOOList [ "", "", [ "jake", "Jakarta" ] ]
#32 Mr. Spell. manti r = MOOList [ "", "s", [ "mantic" ] ]
#32 Mr. Spell. blood r = MOOList [ "", "s", [ "bloody", "bloodroot", "bloodline", "bloodhound", "bloodbath", "blood" ] ]
#32 Mr. Spell. jar r = MOOList [ "", "", [ "Jarvin", "jargon", "jar" ] ]
#32 Mr. Spell. histo r = MOOList [ "", "cr", [ "histology", "histogram" ] ]
#32 Mr. Spell. jas r = MOOList [ "", "", [ "jasper", "Jason" ] ]
#32 Mr. Spell. socio r = MOOList [ "", "", [ "sociometry", "sociology", "socioeconomic" ] ]
#32 Mr. Spell. jau r = MOOList [ "n", "", [ "jaunty", "jaundice" ] ]
#32 Mr. Spell. jav r = MOOList [ "", "", [ "javelin", "Java" ] ]
#32 Mr. Spell. irritat r = MOOList [ "e", "", [ "irritated", "irritate" ] ]
#32 Mr. Spell. gladi r = MOOList [ "", "", [ "gladiolus", "gladiator" ] ]
#32 Mr. Spell. mantl r = MOOList [ "e", "", [ "mantlepiece", "mantle" ] ]
#32 Mr. Spell. jab r = MOOList [ "", "", [ "Jablonsky", "jab" ] ]
#32 Mr. Spell. Modes r = MOOList [ "t", "", [ "modesty", "Modesto", "modest" ] ]
#32 Mr. Spell. jac r = MOOList [ "", "koq", [ "JACM" ] ]
#32 Mr. Spell. dolla r = MOOList [ "r", "", [ "dollars", "dollar" ] ]
#32 Mr. Spell. times r = MOOList [ "", "", [ "times", "timeshare" ] ]
#32 Mr. Spell. frien r = MOOList [ "d", "", [ "friendly", "friends", "friend" ] ]
#32 Mr. Spell. compulsi r = MOOList [ "", "", [ "compulsive", "compulsion" ] ]
#32 Mr. Spell. remin r = MOOList [ "", "i", [ "Remington" ] ]
#32 Mr. Spell. jaw r = MOOList [ "", "", [ "jawbone", "jaw" ] ]
#32 Mr. Spell. sper r = MOOList [ "", "m", [ "Sperry" ] ]
#32 Mr. Spell. jaz r = MOOList [ "z", "", [ "jazzy", "jazz" ] ]
#32 Mr. Spell. corte r = MOOList [ "", "", [ "cortex", "cortege" ] ]
#32 Mr. Spell. spel r = MOOList [ "l", "", [ "spellcheck", "spellbound", "spell" ] ]
#32 Mr. Spell. spea r = MOOList [ "", "kr", [ ] ]
#32 Mr. Spell. spec r = MOOList [ "", "iktu", [ "spec" ] ]
#32 Mr. Spell. Florid r = MOOList [ "", "", [ "Floridian", "Florida", "florid" ] ]
#32 Mr. Spell. spee r = MOOList [ "", "d", [ "speech" ] ]
#32 Mr. Spell. transmis r = MOOList [ "si", "", [ "transmission", "transmissible" ] ]
#32 Mr. Spell. Yam r = MOOList [ "", "", [ "Yamaha", "yam" ] ]
#32 Mr. Spell. Yal r = MOOList [ "", "", [ "Yalta", "Yale" ] ]
#32 Mr. Spell. Yak r = MOOList [ "", "", [ "Yakima", "yak" ] ]
#32 Mr. Spell. Ranki r = MOOList [ "n", "", [ "Rankine", "Rankin" ] ]
#32 Mr. Spell. furni r = MOOList [ "", "", [ "furniture", "furnish" ] ]
#32 Mr. Spell. fried r = MOOList [ "", "", [ "Friedrich", "Friedman" ] ]
#32 Mr. Spell. communic r = MOOList [ "a", "t", [ "communicant", "communicable" ] ]
#32 Mr. Spell. remit r = MOOList [ "", "t", [ "remit" ] ]
#32 Mr. Spell. triflu r = MOOList [ "o", "", [ "trifluouride", "trifluoride" ] ]
#32 Mr. Spell. remis r = MOOList [ "s", "", [ "remission", "remiss" ] ]
#32 Mr. Spell. transmit r = MOOList [ "", "t", [ "transmit" ] ]
#32 Mr. Spell. epigr r = MOOList [ "a", "m", [ "epigraph" ] ]
#32 Mr. Spell. Hag r = MOOList [ "", "eg", [ "Hague", "Hagstrom" ] ]
#32 Mr. Spell. concurr r = MOOList [ "", "e", [ "concurring" ] ]
#32 Mr. Spell. Had r = MOOList [ "", "dr", [ "hadn't", "Hadley", "Hades", "Hadamard", "had" ] ]
#32 Mr. Spell. Haa r = MOOList [ "", "", [ "Haas", "Haag" ] ]
#32 Mr. Spell. habita r = MOOList [ "", "t", [ "habitant" ] ]
#32 Mr. Spell. furlo r = MOOList [ "", "", [ "furlough", "furlong" ] ]
#32 Mr. Spell. informat r = MOOList [ "i", "", [ "informative", "information", "Informatica" ] ]
#32 Mr. Spell. Anto r = MOOList [ "", "in", [ ] ]
#32 Mr. Spell. Haw r = MOOList [ "", "akt", [ "Hawley", "haw" ] ]
#32 Mr. Spell. corra r = MOOList [ "l", "", [ "corralled", "corral" ] ]
#32 Mr. Spell. Han r = MOOList [ "", "dgklnos", [ "Hanukkah", "Hanford", "Haney", "Hancock", "Han" ] ]
#32 Mr. Spell. Ham r = MOOList [ "", "blmp", [ "hamster", "Hamilton", "Hamal", "ham" ] ]
#32 Mr. Spell. corre r = MOOList [ "", "cs", [ "correlate" ] ]
#32 Mr. Spell. Fresn r = MOOList [ "", "", [ "Fresno", "Fresnel" ] ]
#32 Mr. Spell. corri r = MOOList [ "", "g", [ "corridor" ] ]
#32 Mr. Spell. jel r = MOOList [ "ly", "", [ "jellyfish", "jelly" ] ]
#32 Mr. Spell. corro r = MOOList [ "", "bds", [ ] ]
#32 Mr. Spell. jeo r = MOOList [ "pard", "", [ "jeopardy", "jeopard" ] ]
#32 Mr. Spell. habitu r = MOOList [ "a", "", [ "habituate", "habitual" ] ]
#32 Mr. Spell. built r = MOOList [ "", "", [ "built-in", "builtin", "built" ] ]
#32 Mr. Spell. jet r = MOOList [ "", "", [ "jettison", "jetliner", "jet" ] ]
#32 Mr. Spell. corru r = MOOList [ "", "p", [ "corrugate" ] ]
#32 Mr. Spell. jew r = MOOList [ "", "e", [ "Jewish", "Jew" ] ]
#32 Mr. Spell. Hay r = MOOList [ "", "d", [ "hayward", "haystack", "Haynes", "hayfield", "Hayes", "hay" ] ]
#32 Mr. Spell. capacit r = MOOList [ "", "a", [ "capacity", "capacitor", "capacitive" ] ]
#32 Mr. Spell. build r = MOOList [ "", "i", [ "buildup", "build" ] ]
#32 Mr. Spell. Anta r = MOOList [ "", "gr", [ "Antaeus", "antacid" ] ]
#32 Mr. Spell. fisherm r = MOOList [ "", "", [ "fishermen", "fisherman" ] ]
#32 Mr. Spell. allott r = MOOList [ "", "", [ "allotting", "allotted" ] ]
#32 Mr. Spell. jej r = MOOList [ "un", "", [ "jejunum", "jejune" ] ]
#32 Mr. Spell. hydrog r = MOOList [ "en", "", [ "hydrogenate", "hydrogen" ] ]
#32 Mr. Spell. Welle r = MOOList [ "", "s", [ "Weller" ] ]
#32 Mr. Spell. hydroc r = MOOList [ "", "h", [ "hydrocarbon" ] ]
#32 Mr. Spell. spat r = MOOList [ "", "", [ "spatula", "spatterdock", "spatlum", "spatial", "spate", "spat" ] ]
#32 Mr. Spell. hydrol r = MOOList [ "", "", [ "hydrolysis", "hydrology" ] ]
#32 Mr. Spell. spay r = MOOList [ "", "", [ "spayed", "spay" ] ]
#32 Mr. Spell. accessi r = MOOList [ "", "", [ "accession", "accessible" ] ]
#32 Mr. Spell. span r = MOOList [ "", "i", [ "spangle", "spandrel", "span" ] ]
#32 Mr. Spell. octe r = MOOList [ "", "", [ "octet", "octennial" ] ]
#32 Mr. Spell. Marria r = MOOList [ "ge", "", [ "marriageable", "marriage" ] ]
#32 Mr. Spell. spar r = MOOList [ "", "kt", [ "sparse", "sparrow", "sparling", "sparge", "spare", "spar" ] ]
#32 Mr. Spell. spas r = MOOList [ "", "", [ "spastic", "spasm" ] ]
#32 Mr. Spell. octa r = MOOList [ "", "ghnv", [ "octal" ] ]
#32 Mr. Spell. corrob r = MOOList [ "or", "", [ "corroboree", "corroborate" ] ]
#32 Mr. Spell. octo r = MOOList [ "", "", [ "octoroon", "octopus", "octogenarian", "October" ] ]
#32 Mr. Spell. irresolu r = MOOList [ "t", "", [ "irresolution", "irresolute" ] ]
#32 Mr. Spell. octi r = MOOList [ "l", "", [ "octillion", "octile" ] ]
#32 Mr. Spell. scraw r = MOOList [ "", "", [ "scrawny", "scrawl" ] ]
#32 Mr. Spell. spac r = MOOList [ "", "e", [ "spacious" ] ]
#32 Mr. Spell. corrod r = MOOList [ "", "", [ "corrodible", "corrode" ] ]
#32 Mr. Spell. scrat r = MOOList [ "ch", "", [ "scratchy", "scratch" ] ]
#32 Mr. Spell. curricula r = MOOList [ "", "", [ "curricular", "curricula" ] ]
#32 Mr. Spell. scrap r = MOOList [ "", "", [ "scrape", "scrapbook", "scrap" ] ]
#32 Mr. Spell. corrige r = MOOList [ "nd", "", [ "corrigendum", "corrigenda" ] ]
#32 Mr. Spell. scram r = MOOList [ "", "", [ "scramble", "scram" ] ]
#32 Mr. Spell. clipb r = MOOList [ "oard", "", [ "clipboards", "clipboard" ] ]
#32 Mr. Spell. stealt r = MOOList [ "h", "", [ "stealthy", "stealth" ] ]
#32 Mr. Spell. rigoro r = MOOList [ "us", "", [ "rigorously", "rigorous" ] ]
#32 Mr. Spell. hydros r = MOOList [ "", "", [ "hydrostatic", "hydrosphere" ] ]
#32 Mr. Spell. hydrop r = MOOList [ "h", "o", [ "hydrophilic" ] ]
#32 Mr. Spell. corros r = MOOList [ "i", "", [ "corrosive", "corrosion" ] ]
#32 Mr. Spell. Antarc r = MOOList [ "tic", "", [ "Antarctica", "antarctic" ] ]
#32 Mr. Spell. hydrox r = MOOList [ "", "y", [ "hydroxide" ] ]
#32 Mr. Spell. Hel r = MOOList [ "", "eilmp", [ "Helvetica", "Helsinki", "Helga", "held" ] ]
#32 Mr. Spell. exempla r = MOOList [ "r", "", [ "exemplary", "exemplar" ] ]
#32 Mr. Spell. gland r = MOOList [ "", "", [ "glandular", "gland" ] ]
#32 Mr. Spell. remor r = MOOList [ "se", "", [ "remorseful", "remorse" ] ]
#32 Mr. Spell. eighte r = MOOList [ "en", "", [ "eighteenth", "eighteen" ] ]
#32 Mr. Spell. termin r = MOOList [ "", "a", [ "terminus", "terminology", "termini" ] ]
#32 Mr. Spell. extrema r = MOOList [ "", "", [ "extremal", "extrema" ] ]
#32 Mr. Spell. clima r = MOOList [ "", "t", [ "climax", "climactic" ] ]
#32 Mr. Spell. extreme r = MOOList [ "", "", [ "extremely", "extreme" ] ]
#32 Mr. Spell. Hew r = MOOList [ "", "", [ "hewn", "Hewlett", "Hewitt", "Hewett", "hew" ] ]
#32 Mr. Spell. Her r = MOOList [ "", "abcdeimoprst", [ "Hernandez", "Herkimer", "her" ] ]
#32 Mr. Spell. quadr r = MOOList [ "", "aiu", [ "quadrennial" ] ]
#32 Mr. Spell. appointe r = MOOList [ "", "", [ "appointee", "appointe" ] ]
#32 Mr. Spell. confec r = MOOList [ "t", "", [ "confectionery", "confect" ] ]
#32 Mr. Spell. jit r = MOOList [ "ter", "", [ "jittery", "jitterbug", "jitter" ] ]
#32 Mr. Spell. confed r = MOOList [ "era", "", [ "confederate", "confederacy" ] ]
#32 Mr. Spell. enter r = MOOList [ "", "", [ "entertain", "enterprise", "enter" ] ]
#32 Mr. Spell. expediti r = MOOList [ "o", "", [ "expeditious", "expedition" ] ]
#32 Mr. Spell. remov r = MOOList [ "", "e", [ "removal" ] ]
#32 Mr. Spell. Angle r = MOOList [ "", "", [ "Angles", "angle" ] ]
#32 Mr. Spell. frigh r = MOOList [ "t", "", [ "frightful", "frighten", "fright" ] ]
#32 Mr. Spell. confes r = MOOList [ "s", "", [ "confessor", "confession", "confess" ] ]
#32 Mr. Spell. confer r = MOOList [ "", "er", [ "confer" ] ]
#32 Mr. Spell. jig r = MOOList [ "", "g", [ "jigsaw", "jig" ] ]
#32 Mr. Spell. squatt r = MOOList [ "", "e", [ "squatting" ] ]
#32 Mr. Spell. cling r = MOOList [ "", "", [ "clinging", "cling" ] ]
#32 Mr. Spell. clini r = MOOList [ "c", "", [ "clinician", "clinic" ] ]
#32 Mr. Spell. jil r = MOOList [ "", "", [ "jilt", "Jill" ] ]
#32 Mr. Spell. jin r = MOOList [ "", "", [ "jinx", "jingle" ] ]
#32 Mr. Spell. Anglo r = MOOList [ "", "", [ "Anglophobia", "Anglo" ] ]
#32 Mr. Spell. escape r = MOOList [ "", "", [ "escapee", "escape" ] ]
#32 Mr. Spell. conscio r = MOOList [ "", "", [ "conscious", "conscionable" ] ]
#32 Mr. Spell. laure r = MOOList [ "", "n", [ "laurel", "laureate" ] ]
#32 Mr. Spell. multit r = MOOList [ "ud", "", [ "multitudinous", "multitude" ] ]
#32 Mr. Spell. conscie r = MOOList [ "n", "", [ "conscientious", "conscience" ] ]
#32 Mr. Spell. cardio r = MOOList [ "", "", [ "cardiovascular", "cardiology", "cardiod" ] ]
#32 Mr. Spell. skyli r = MOOList [ "", "", [ "skyline", "skylight" ] ]
#32 Mr. Spell. multip r = MOOList [ "l", "ei", [ ] ]
#32 Mr. Spell. patrici r = MOOList [ "a", "", [ "patrician", "Patricia" ] ]
#32 Mr. Spell. wreat r = MOOList [ "h", "", [ "wreathe", "wreath" ] ]
#32 Mr. Spell. melani r = MOOList [ "", "", [ "melanin", "Melanie" ] ]
#32 Mr. Spell. produ r = MOOList [ "c", "eit", [ ] ]
#32 Mr. Spell. glass r = MOOList [ "", "w", [ "glassy", "glassine", "glass" ] ]
#32 Mr. Spell. prodi r = MOOList [ "g", "", [ "prodigy", "prodigious", "prodigal" ] ]
#32 Mr. Spell. shamef r = MOOList [ "", "", [ "shameful", "shameface" ] ]
#32 Mr. Spell. residu r = MOOList [ "", "a", [ "residuum", "residue" ] ]
#32 Mr. Spell. aristocrat r = MOOList [ "", "", [ "aristocratic", "aristocrat" ] ]
#32 Mr. Spell. Montag r = MOOList [ "", "", [ "Montague", "montage" ] ]
#32 Mr. Spell. jeal r = MOOList [ "ous", "", [ "jealousy", "jealous" ] ]
#32 Mr. Spell. remai r = MOOList [ "n", "", [ "remains", "remain", "remainder" ] ]
#32 Mr. Spell. reman r = MOOList [ "", "", [ "remand", "reman" ] ]
#32 Mr. Spell. glyc r = MOOList [ "", "eo", [ "glycine" ] ]
#32 Mr. Spell. reside r = MOOList [ "", "n", [ "reside" ] ]
#32 Mr. Spell. Him r = MOOList [ "", "", [ "himself", "Himalaya", "him" ] ]
#32 Mr. Spell. proct r = MOOList [ "", "", [ "proctor", "Procter" ] ]
#32 Mr. Spell. procr r = MOOList [ "", "u", [ "procreate", "procrastinate" ] ]
#32 Mr. Spell. enthu r = MOOList [ "sias", "t", [ "enthusiasm" ] ]
#32 Mr. Spell. erosi r = MOOList [ "", "", [ "erosive", "erosion", "erosible" ] ]
#32 Mr. Spell. procl r = MOOList [ "", "a", [ "proclivity" ] ]
#32 Mr. Spell. Hic r = MOOList [ "k", "", [ "hickory", "Hickman", "Hickey", "hick" ] ]
#32 Mr. Spell. Hib r = MOOList [ "", "e", [ "Hibbard", "hibachi" ] ]
#32 Mr. Spell. proce r = MOOList [ "", "ds", [ "proceed" ] ]
#32 Mr. Spell. cheese r = MOOList [ "", "c", [ "cheese" ] ]
#32 Mr. Spell. confid r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. Hit r = MOOList [ "", "ch", [ "Hitler", "Hitachi", "hit" ] ]
#32 Mr. Spell. His r = MOOList [ "", "t", [ "hiss", "Hispanic", "his" ] ]
#32 Mr. Spell. cutle r = MOOList [ "", "", [ "cutlet", "cutler" ] ]
#32 Mr. Spell. config r = MOOList [ "ur", "", [ "configure", "configuration" ] ]
#32 Mr. Spell. confis r = MOOList [ "ca", "t", [ "confiscable" ] ]
#32 Mr. Spell. entir r = MOOList [ "e", "", [ "entirety", "entire" ] ]
#32 Mr. Spell. Specta r = MOOList [ "", "c", [ "spectator" ] ]
#32 Mr. Spell. confir r = MOOList [ "m", "a", [ "confirm" ] ]
#32 Mr. Spell. probl r = MOOList [ "em", "", [ "problems", "problematic", "problem" ] ]
#32 Mr. Spell. corrup r = MOOList [ "t", "i", [ "corrupt" ] ]
#32 Mr. Spell. fiss r = MOOList [ "", "i", [ "fissure" ] ]
#32 Mr. Spell. tweed r = MOOList [ "", "", [ "tweedy", "tweed" ] ]
#32 Mr. Spell. proba r = MOOList [ "", "b", [ "probate" ] ]
#32 Mr. Spell. fist r = MOOList [ "", "", [ "fisticuff", "fist" ] ]
#32 Mr. Spell. furth r = MOOList [ "e", "r", [ "furthest" ] ]
#32 Mr. Spell. firewo r = MOOList [ "", "", [ "firework", "firewood" ] ]
#32 Mr. Spell. hoyd r = MOOList [ "en", "", [ "hoydenish", "hoyden" ] ]
#32 Mr. Spell. fisc r = MOOList [ "", "h", [ "fiscal" ] ]
#32 Mr. Spell. epist r = MOOList [ "", "", [ "epistolatory", "epistle", "epistemology" ] ]
#32 Mr. Spell. riflem r = MOOList [ "", "", [ "riflemen", "rifleman" ] ]
#32 Mr. Spell. episo r = MOOList [ "d", "", [ "episodic", "episode" ] ]
#32 Mr. Spell. percen r = MOOList [ "t", "", [ "percentile", "percentage", "percent" ] ]
#32 Mr. Spell. remed r = MOOList [ "", "i", [ "remedy" ] ]
#32 Mr. Spell. fish r = MOOList [ "", "e", [ "fishy", "fishpond", "fishmonger", "fish" ] ]
#32 Mr. Spell. dread r = MOOList [ "", "", [ "dreadnought", "dreadful", "dread" ] ]
#32 Mr. Spell. laund r = MOOList [ "", "", [ "laundry", "launder" ] ]
#32 Mr. Spell. impress r = MOOList [ "", "i", [ "impressed", "impress" ] ]
#32 Mr. Spell. job r = MOOList [ "", "", [ "jobs", "jobholder", "job" ] ]
#32 Mr. Spell. joc r = MOOList [ "", "ku", [ "jocose" ] ]
#32 Mr. Spell. salesm r = MOOList [ "", "", [ "salesmen", "salesman" ] ]
#32 Mr. Spell. episc r = MOOList [ "opa", "l", [ "episcopate" ] ]
#32 Mr. Spell. Victori r = MOOList [ "", "a", [ "victorious" ] ]
#32 Mr. Spell. Pitt r = MOOList [ "", "s", [ "Pitt" ] ]
#32 Mr. Spell. timbe r = MOOList [ "r", "", [ "timberland", "timber" ] ]
#32 Mr. Spell. firs r = MOOList [ "t", "", [ "firsthand", "first" ] ]
#32 Mr. Spell. glut r = MOOList [ "", "a", [ "glutton", "glutinous", "glut" ] ]
#32 Mr. Spell. anatom r = MOOList [ "", "", [ "anatomy", "anatomic" ] ]
#32 Mr. Spell. percep r = MOOList [ "t", "i", [ "perceptual", "percept" ] ]
#32 Mr. Spell. polarograp r = MOOList [ "h", "", [ "polarography", "polarograph" ] ]
#32 Mr. Spell. jou r = MOOList [ "", "r", [ "joust", "jounce", "joule" ] ]
#32 Mr. Spell. jow r = MOOList [ "l", "", [ "jowly", "jowl" ] ]
#32 Mr. Spell. substa r = MOOList [ "nti", "a", [ "substantive" ] ]
#32 Mr. Spell. fire r = MOOList [ "", "bmpsw", [ "firelight", "firehouse", "firefly", "firecracker", "firearm", "fire" ] ]
#32 Mr. Spell. Montev r = MOOList [ "", "", [ "Montevideo", "Monteverdi" ] ]
#32 Mr. Spell. glue r = MOOList [ "", "", [ "gluey", "glue" ] ]
#32 Mr. Spell. genes r = MOOList [ "", "", [ "genesis", "Genesco" ] ]
#32 Mr. Spell. substi r = MOOList [ "tu", "t", [ "substituent" ] ]
#32 Mr. Spell. gener r = MOOList [ "", "ao", [ "generic" ] ]
#32 Mr. Spell. firm r = MOOList [ "", "", [ "firms", "firmware", "firm" ] ]
#32 Mr. Spell. epith r = MOOList [ "e", "l", [ "epithet" ] ]
#32 Mr. Spell. sculptu r = MOOList [ "r", "", [ "sculpture", "sculptural" ] ]
#32 Mr. Spell. Byron r = MOOList [ "", "", [ "Byronic", "Byron" ] ]
#32 Mr. Spell. hows r = MOOList [ "o", "", [ "howsomever", "howsoever" ] ]
#32 Mr. Spell. Delan r = MOOList [ "", "", [ "Delano", "Delaney" ] ]
#32 Mr. Spell. jog r = MOOList [ "", "g", [ "jog" ] ]
#32 Mr. Spell. dream r = MOOList [ "", "", [ "dreamy", "dreamt", "dreamboat", "dream" ] ]
#32 Mr. Spell. remem r = MOOList [ "b", "", [ "remembrance", "remember" ] ]
#32 Mr. Spell. joi r = MOOList [ "n", "", [ "joint", "join" ] ]
#32 Mr. Spell. epita r = MOOList [ "", "x", [ "epitaph" ] ]
#32 Mr. Spell. taxp r = MOOList [ "ay", "", [ "taxpaying", "taxpayer" ] ]
#32 Mr. Spell. taxo r = MOOList [ "nom", "", [ "taxonomy", "taxonomic" ] ]
#32 Mr. Spell. Yod r = MOOList [ "e", "", [ "Yoder", "yodel" ] ]
#32 Mr. Spell. order r = MOOList [ "", "", [ "ordered", "orders", "order" ] ]
#32 Mr. Spell. taxi r = MOOList [ "", "", [ "taxiway", "taxied", "taxicab", "taxi" ] ]
#32 Mr. Spell. Verna r = MOOList [ "", "", [ "vernal", "vernacular", "Verna" ] ]
#32 Mr. Spell. Yos r = MOOList [ "", "", [ "Yost", "Yosemite" ] ]
#32 Mr. Spell. sove r = MOOList [ "reign", "", [ "sovereignty", "sovereign" ] ]
#32 Mr. Spell. sovi r = MOOList [ "et", "", [ "soviets", "soviet" ] ]
#32 Mr. Spell. sour r = MOOList [ "", "c", [ "sourwood", "sourdough", "sourberry", "sour" ] ]
#32 Mr. Spell. Hayd r = MOOList [ "", "", [ "Haydn", "Hayden" ] ]
#32 Mr. Spell. Rowe r = MOOList [ "", "", [ "Rowena", "Rowe" ] ]
#32 Mr. Spell. sout r = MOOList [ "", "h", [ "soutane" ] ]
#32 Mr. Spell. aspara r = MOOList [ "g", "", [ "asparagus", "asparagine" ] ]
#32 Mr. Spell. locatio r = MOOList [ "n", "", [ "locations", "location" ] ]
#32 Mr. Spell. Ange r = MOOList [ "", "l", [ "anger" ] ]
#32 Mr. Spell. soul r = MOOList [ "", "", [ "soulful", "soul" ] ]
#32 Mr. Spell. dictat r = MOOList [ "", "", [ "dictatorial", "dictate" ] ]
#32 Mr. Spell. soun r = MOOList [ "d", "", [ "sounds", "soundproof", "sound" ] ]
#32 Mr. Spell. Saxo r = MOOList [ "", "n", [ "saxophone" ] ]
#32 Mr. Spell. Hof r = MOOList [ "f", "", [ "Hoffman", "Hoff" ] ]
#32 Mr. Spell. Angl r = MOOList [ "", "eio", [ ] ]
#32 Mr. Spell. Hob r = MOOList [ "", "bo", [ "Hobart", "hob" ] ]
#32 Mr. Spell. Hoa r = MOOList [ "", "gr", [ ] ]
#32 Mr. Spell. soug r = MOOList [ "h", "", [ "sought", "sough" ] ]
#32 Mr. Spell. hous r = MOOList [ "", "e", [ "Houston" ] ]
#32 Mr. Spell. hour r = MOOList [ "", "", [ "hours", "hourglass", "hour" ] ]
#32 Mr. Spell. Ango r = MOOList [ "", "", [ "Angora", "Angola" ] ]
#32 Mr. Spell. Tarta r = MOOList [ "r", "", [ "Tartary", "tartar" ] ]
#32 Mr. Spell. Rowl r = MOOList [ "", "", [ "Rowley", "Rowland" ] ]
#32 Mr. Spell. Hou r = MOOList [ "", "dgrs", [ "hound" ] ]
#32 Mr. Spell. Christens r = MOOList [ "", "", [ "Christenson", "Christensen" ] ]
#32 Mr. Spell. dull r = MOOList [ "", "", [ "dully", "dull" ] ]
#32 Mr. Spell. Hor r = MOOList [ "", "ainorst", [ "Horus", "hormone", "horehound", "horde" ] ]
#32 Mr. Spell. exor r = MOOList [ "", "c", [ "exorbitant" ] ]
#32 Mr. Spell. crin r = MOOList [ "", "", [ "crinkle", "cringe" ] ]
#32 Mr. Spell. alco r = MOOList [ "", "h", [ "alcove", "Alcott", "Alcoa" ] ]
#32 Mr. Spell. Maid r = MOOList [ "", "e", [ "maidservant", "maid" ] ]
#32 Mr. Spell. cris r = MOOList [ "", "ps", [ "crisis", "crises" ] ]
#32 Mr. Spell. Hol r = MOOList [ "", "delmosy", [ "holt", "holiday", "Holcomb", "Holbrook" ] ]
#32 Mr. Spell. exot r = MOOList [ "", "i", [ "exothermic" ] ]
#32 Mr. Spell. curra r = MOOList [ "n", "", [ "currant", "Curran" ] ]
#32 Mr. Spell. myste r = MOOList [ "r", "", [ "mystery", "mysterious" ] ]
#32 Mr. Spell. crit r = MOOList [ "", "ei", [ "critter" ] ]
#32 Mr. Spell. mysti r = MOOList [ "", "", [ "mystique", "mystify", "mystic" ] ]
#32 Mr. Spell. seemi r = MOOList [ "ng", "", [ "seemingly", "seeming" ] ]
#32 Mr. Spell. Cunn r = MOOList [ "ing", "", [ "Cunningham", "cunning" ] ]
#32 Mr. Spell. curri r = MOOList [ "cul", "a", [ "curriculum" ] ]
#32 Mr. Spell. doorke r = MOOList [ "ep", "", [ "doorkeeper", "doorkeep" ] ]
#32 Mr. Spell. curre r = MOOList [ "nt", "", [ "currently", "current" ] ]
#32 Mr. Spell. infusi r = MOOList [ "", "", [ "infusion", "infusible" ] ]
#32 Mr. Spell. spenc r = MOOList [ "er", "", [ "Spencerian", "Spencer" ] ]
#32 Mr. Spell. exog r = MOOList [ "", "a", [ "exogenous" ] ]
#32 Mr. Spell. digesti r = MOOList [ "", "", [ "digestive", "digestion", "digestible" ] ]
#32 Mr. Spell. spend r = MOOList [ "", "", [ "spending", "spend" ] ]
#32 Mr. Spell. Main r = MOOList [ "", "lst", [ "Maine", "main" ] ]
#32 Mr. Spell. How r = MOOList [ "", "es", [ "howl", "howdy", "Howard", "how" ] ]
#32 Mr. Spell. grain r = MOOList [ "", "", [ "grainy", "grain" ] ]
#32 Mr. Spell. tribun r = MOOList [ "", "", [ "tribune", "tribunal" ] ]
#32 Mr. Spell. brood r = MOOList [ "", "", [ "broody", "brood" ] ]
#32 Mr. Spell. spur r = MOOList [ "", "", [ "spurt", "spurn", "spurious", "spurge", "spur" ] ]
#32 Mr. Spell. ferme r = MOOList [ "nt", "", [ "fermentation", "ferment" ] ]
#32 Mr. Spell. sput r = MOOList [ "", "", [ "sputter", "sputnik" ] ]
#32 Mr. Spell. modu r = MOOList [ "l", "a", [ "modulus", "modulo", "moduli", "module" ] ]
#32 Mr. Spell. tribut r = MOOList [ "", "", [ "tribute", "tributary" ] ]
#32 Mr. Spell. fermi r = MOOList [ "", "", [ "fermium", "fermion", "Fermi" ] ]
#32 Mr. Spell. broom r = MOOList [ "", "", [ "broomcorn", "broom" ] ]
#32 Mr. Spell. spum r = MOOList [ "", "", [ "spumoni", "spume" ] ]
#32 Mr. Spell. spun r = MOOList [ "", "", [ "spunk", "spun" ] ]
#32 Mr. Spell. albu r = MOOList [ "", "m", [ "Albuquerque" ] ]
#32 Mr. Spell. econome r = MOOList [ "tric", "", [ "Econometrica", "econometric" ] ]
#32 Mr. Spell. modi r = MOOList [ "", "f", [ "modish", "modicum" ] ]
#32 Mr. Spell. ellip r = MOOList [ "", "s", [ "elliptic" ] ]
#32 Mr. Spell. Cumm r = MOOList [ "in", "", [ "Cummins", "Cummings" ] ]
#32 Mr. Spell. embarg r = MOOList [ "o", "", [ "embargoes", "embargo" ] ]
#32 Mr. Spell. body r = MOOList [ "", "b", [ "bodyguard", "body" ] ]
#32 Mr. Spell. economi r = MOOList [ "", "c", [ "economist" ] ]
#32 Mr. Spell. mode r = MOOList [ "", "rs", [ "modem", "model", "mode" ] ]
#32 Mr. Spell. ellio r = MOOList [ "t", "", [ "Elliott", "Elliot" ] ]
#32 Mr. Spell. curso r = MOOList [ "r", "", [ "cursory", "cursor" ] ]
#32 Mr. Spell. crucifi r = MOOList [ "x", "", [ "crucifixion", "crucifix" ] ]
#32 Mr. Spell. alba r = MOOList [ "", "n", [ "albatross", "albacore", "alba" ] ]
#32 Mr. Spell. Maho r = MOOList [ "", "", [ "Mahoney", "mahogany" ] ]
#32 Mr. Spell. bronz r = MOOList [ "", "", [ "bronzy", "bronze" ] ]
#32 Mr. Spell. mamma r = MOOList [ "", "l", [ "mamma" ] ]
#32 Mr. Spell. jua r = MOOList [ "n", "", [ "Juanita", "Juan" ] ]
#32 Mr. Spell. jub r = MOOList [ "ila", "", [ "jubilate", "jubilant" ] ]
#32 Mr. Spell. adsorb r = MOOList [ "", "", [ "adsorbate", "adsorb" ] ]
#32 Mr. Spell. thyro r = MOOList [ "", "i", [ "thyroxine", "thyrotoxic", "thyronine", "thyroglobulin" ] ]
#32 Mr. Spell. jug r = MOOList [ "", "g", [ "Jugoslavia", "jugate", "jug" ] ]
#32 Mr. Spell. trend r = MOOList [ "", "", [ "trendy", "trend" ] ]
#32 Mr. Spell. jui r = MOOList [ "c", "", [ "juicy", "juice" ] ]
#32 Mr. Spell. trenc r = MOOList [ "h", "e", [ "trenchant", "trench" ] ]
#32 Mr. Spell. juj r = MOOList [ "u", "", [ "jujube", "juju" ] ]
#32 Mr. Spell. Bril r = MOOList [ "l", "", [ "Brillouin", "brilliant" ] ]
#32 Mr. Spell. repetitio r = MOOList [ "", "", [ "repetitious", "repetition" ] ]
#32 Mr. Spell. pronounc r = MOOList [ "e", "", [ "pronounceable", "pronounce" ] ]
#32 Mr. Spell. Brit r = MOOList [ "", "at", [ "Briton", "British", "britches" ] ]
#32 Mr. Spell. adsorp r = MOOList [ "ti", "", [ "adsorptive", "adsorption" ] ]
#32 Mr. Spell. mock r = MOOList [ "", "e", [ "mockup", "mockingbird", "mock" ] ]
#32 Mr. Spell. Andre r = MOOList [ "", "", [ "Andrew", "Andrei", "Andrea", "Andre" ] ]
#32 Mr. Spell. antiquar r = MOOList [ "", "", [ "antiquary", "antiquarian" ] ]
#32 Mr. Spell. crew r = MOOList [ "", "m", [ "crewel", "crewcut", "crew" ] ]
#32 Mr. Spell. jum r = MOOList [ "", "bp", [ ] ]
#32 Mr. Spell. jun r = MOOList [ "", "ceik", [ "junta", "Juno", "jungle" ] ]
#32 Mr. Spell. anima r = MOOList [ "", "d", [ "animate", "animal" ] ]
#32 Mr. Spell. Andro r = MOOList [ "m", "", [ "Andromeda", "Andromache" ] ]
#32 Mr. Spell. spru r = MOOList [ "", "", [ "sprung", "sprue", "spruce" ] ]
#32 Mr. Spell. jus r = MOOList [ "t", "i", [ "just" ] ]
#32 Mr. Spell. jut r = MOOList [ "", "", [ "Jutish", "jute", "jut" ] ]
#32 Mr. Spell. Morel r = MOOList [ "", "", [ "Moreland", "morel" ] ]
#32 Mr. Spell. jux r = MOOList [ "tapos", "", [ "juxtaposition", "juxtapose" ] ]
#32 Mr. Spell. mobi r = MOOList [ "l", "", [ "mobility", "mobile", "Mobil" ] ]
#32 Mr. Spell. Yuk r = MOOList [ "", "", [ "Yukon", "Yuki" ] ]
#32 Mr. Spell. ferri r = MOOList [ "", "", [ "ferrite", "ferris", "ferric" ] ]
#32 Mr. Spell. Yug r = MOOList [ "oslav", "", [ "Yugoslavia", "Yugoslav" ] ]
#32 Mr. Spell. Madr r = MOOList [ "", "i", [ "Madras" ] ]
#32 Mr. Spell. granu r = MOOList [ "l", "a", [ "granule" ] ]
#32 Mr. Spell. crem r = MOOList [ "at", "", [ "crematory", "cremate" ] ]
#32 Mr. Spell. grant r = MOOList [ "", "", [ "grantor", "grantee", "grant" ] ]
#32 Mr. Spell. Yuc r = MOOList [ "", "", [ "yuck", "yucca", "Yucatan" ] ]
#32 Mr. Spell. spre r = MOOList [ "", "", [ "spree", "spread" ] ]
#32 Mr. Spell. propag r = MOOList [ "a", "n", [ "propagate" ] ]
#32 Mr. Spell. grani r = MOOList [ "t", "", [ "granitic", "granite" ] ]
#32 Mr. Spell. cada r = MOOList [ "ver", "", [ "cadaverous", "cadaver" ] ]
#32 Mr. Spell. crep r = MOOList [ "", "", [ "crept", "crepe" ] ]
#32 Mr. Spell. spri r = MOOList [ "", "gn", [ "sprite" ] ]
#32 Mr. Spell. Lock r = MOOList [ "", "h", [ "Lockwood", "lockup", "locksmith", "lockout", "locknut", "Lockian", "Locke", "lock" ] ]
#32 Mr. Spell. cres r = MOOList [ "", "ct", [ "cress" ] ]
#32 Mr. Spell. ferre r = MOOList [ "", "", [ "ferret", "Ferrer", "Ferreira" ] ]
#32 Mr. Spell. curva r = MOOList [ "", "", [ "curvature", "curvaceous" ] ]
#32 Mr. Spell. cade r = MOOList [ "", "n", [ "cadet" ] ]
#32 Mr. Spell. cadd r = MOOList [ "", "", [ "caddy", "caddis" ] ]
#32 Mr. Spell. crime r = MOOList [ "", "", [ "Crimea", "crime" ] ]
#32 Mr. Spell. boat r = MOOList [ "", "m", [ "boatyard", "boatswain", "boatload", "boathouse", "boat" ] ]
#32 Mr. Spell. cach r = MOOList [ "", "", [ "cache", "cachalot" ] ]
#32 Mr. Spell. bands r = MOOList [ "t", "", [ "bandstop", "bandstand" ] ]
#32 Mr. Spell. spra r = MOOList [ "", "", [ "spray", "sprawl", "sprang", "sprain", "Sprague" ] ]
#32 Mr. Spell. librar r = MOOList [ "", "", [ "library", "librarian" ] ]
#32 Mr. Spell. inerti r = MOOList [ "a", "", [ "inertial", "inertia" ] ]
#32 Mr. Spell. grand r = MOOList [ "", "cimnps", [ "grandfather", "grandeur", "granddaughter", "grand" ] ]
#32 Mr. Spell. ferro r = MOOList [ "", "m", [ "ferrous", "ferroelectric" ] ]
#32 Mr. Spell. crea r = MOOList [ "", "kmt", [ "crease" ] ]
#32 Mr. Spell. caco r = MOOList [ "phon", "", [ "cacophony", "cacophonist" ] ]
#32 Mr. Spell. bobb r = MOOList [ "", "i", [ "bobby", "bobble" ] ]
#32 Mr. Spell. ferru r = MOOList [ "", "", [ "ferrule", "ferruginous" ] ]
#32 Mr. Spell. cree r = MOOList [ "", "dkp", [ ] ]
#32 Mr. Spell. cact r = MOOList [ "", "", [ "cactus", "cacti" ] ]
#32 Mr. Spell. cred r = MOOList [ "", "eiu", [ "credo" ] ]
#32 Mr. Spell. Bade r = MOOList [ "", "", [ "Baden", "bade" ] ]
#32 Mr. Spell. presen r = MOOList [ "", "t", [ "presence" ] ]
#32 Mr. Spell. sphero r = MOOList [ "id", "", [ "spheroidal", "spheroid" ] ]
#32 Mr. Spell. labor r = MOOList [ "", "", [ "laborious", "laboratory", "labor" ] ]
#32 Mr. Spell. boas r = MOOList [ "t", "", [ "boasts", "boastful", "boast" ] ]
#32 Mr. Spell. boar r = MOOList [ "", "d", [ "boar" ] ]
#32 Mr. Spell. Medit r = MOOList [ "", "", [ "Mediterranean", "meditate" ] ]
#32 Mr. Spell. polyme r = MOOList [ "r", "", [ "polymeric", "polymerase", "polymer" ] ]
#32 Mr. Spell. Made r = MOOList [ "", "l", [ "Madeira", "made" ] ]
#32 Mr. Spell. Madd r = MOOList [ "", "", [ "Maddox", "madden" ] ]
#32 Mr. Spell. cabi r = MOOList [ "n", "e", [ "cabin" ] ]
#32 Mr. Spell. Huf r = MOOList [ "f", "", [ "Huffman", "huff" ] ]
#32 Mr. Spell. Hud r = MOOList [ "", "", [ "Hudson", "huddle" ] ]
#32 Mr. Spell. lumberm r = MOOList [ "", "", [ "lumbermen", "lumberman" ] ]
#32 Mr. Spell. polymo r = MOOList [ "rph", "", [ "polymorphic", "polymorph" ] ]
#32 Mr. Spell. extens r = MOOList [ "", "i", [ "extensor" ] ]
#32 Mr. Spell. patrim r = MOOList [ "on", "", [ "patrimony", "patrimonial" ] ]
#32 Mr. Spell. Hux r = MOOList [ "", "", [ "Huxtable", "Huxley" ] ]
#32 Mr. Spell. patrio r = MOOList [ "t", "", [ "patriotic", "patriot" ] ]
#32 Mr. Spell. Savoy r = MOOList [ "", "", [ "Savoyard", "savoy" ] ]
#32 Mr. Spell. extend r = MOOList [ "", "", [ "extendible", "extend" ] ]
#32 Mr. Spell. curta r = MOOList [ "i", "", [ "curtain", "curtail" ] ]
#32 Mr. Spell. caba r = MOOList [ "", "", [ "cabaret", "cabana", "cabal" ] ]
#32 Mr. Spell. progressi r = MOOList [ "", "", [ "progressive", "progression" ] ]
#32 Mr. Spell. exis r = MOOList [ "t", "e", [ "exist" ] ]
#32 Mr. Spell. survey r = MOOList [ "", "", [ "surveys", "surveyor", "survey" ] ]
#32 Mr. Spell. polyph r = MOOList [ "", "", [ "polyphony", "Polyphemus" ] ]
#32 Mr. Spell. Mace r = MOOList [ "", "d", [ "mace" ] ]
#32 Mr. Spell. exhu r = MOOList [ "m", "", [ "exhume", "exhumation" ] ]
#32 Mr. Spell. strab r = MOOList [ "ism", "", [ "strabismus", "strabismic" ] ]
#32 Mr. Spell. washb r = MOOList [ "", "o", [ "Washburn", "washbasin" ] ]
#32 Mr. Spell. stran r = MOOList [ "", "g", [ "strand" ] ]
#32 Mr. Spell. spor r = MOOList [ "", "t", [ "spore", "sporadic" ] ]
#32 Mr. Spell. spot r = MOOList [ "", "", [ "spotty", "spotlight", "spot" ] ]
#32 Mr. Spell. spou r = MOOList [ "", "", [ "spout", "spouse" ] ]
#32 Mr. Spell. Bren r = MOOList [ "", "dn", [ "Brent" ] ]
#32 Mr. Spell. serpent r = MOOList [ "", "", [ "serpentine", "serpent" ] ]
#32 Mr. Spell. Bret r = MOOList [ "", "", [ "Brett", "Breton", "brethren" ] ]
#32 Mr. Spell. Mach r = MOOList [ "", "i", [ "macho", "Mach" ] ]
#32 Mr. Spell. strai r = MOOList [ "", "g", [ "strait", "strain" ] ]
#32 Mr. Spell. Babe r = MOOList [ "", "", [ "Babel", "babe" ] ]
#32 Mr. Spell. spok r = MOOList [ "", "e", [ "Spokane" ] ]
#32 Mr. Spell. mortgage r = MOOList [ "", "", [ "mortgagee", "mortgage" ] ]
#32 Mr. Spell. prescr r = MOOList [ "ipti", "", [ "prescriptive", "prescription" ] ]
#32 Mr. Spell. spon r = MOOList [ "", "gt", [ "sponsor" ] ]
#32 Mr. Spell. spoo r = MOOList [ "", "kn", [ "spool", "spoof" ] ]
#32 Mr. Spell. exhi r = MOOList [ "", "b", [ "exhilarate" ] ]
#32 Mr. Spell. exho r = MOOList [ "rt", "", [ "exhortation", "exhort" ] ]
#32 Mr. Spell. dairym r = MOOList [ "", "", [ "dairymen", "dairyman" ] ]
#32 Mr. Spell. bandw r = MOOList [ "", "", [ "bandwidth", "bandwagon" ] ]
#32 Mr. Spell. cras r = MOOList [ "", "", [ "crass", "crash" ] ]
#32 Mr. Spell. superfl r = MOOList [ "u", "", [ "superfluous", "superfluity" ] ]
#32 Mr. Spell. MacD r = MOOList [ "o", "", [ "MacDougall", "MacDonald" ] ]
#32 Mr. Spell. crat r = MOOList [ "e", "", [ "crater", "crate" ] ]
#32 Mr. Spell. Philip r = MOOList [ "", "", [ "Philippine", "Philip" ] ]
#32 Mr. Spell. Galat r = MOOList [ "", "", [ "Galatia", "Galatea" ] ]
#32 Mr. Spell. Baby r = MOOList [ "", "s", [ "Babylon", "baby" ] ]
#32 Mr. Spell. crav r = MOOList [ "", "e", [ "cravat" ] ]
#32 Mr. Spell. cray r = MOOList [ "", "", [ "crayon", "crayfish" ] ]
#32 Mr. Spell. craz r = MOOList [ "", "", [ "crazy", "craze" ] ]
#32 Mr. Spell. MacK r = MOOList [ "", "ei", [ "mack" ] ]
#32 Mr. Spell. Bacc r = MOOList [ "", "a", [ "Bacchus" ] ]
#32 Mr. Spell. exha r = MOOList [ "", "u", [ "exhale" ] ]
#32 Mr. Spell. crac r = MOOList [ "k", "", [ "crackpot", "crackle", "crack" ] ]
#32 Mr. Spell. crab r = MOOList [ "", "", [ "crabapple", "crab" ] ]
#32 Mr. Spell. speed r = MOOList [ "", "", [ "speedy", "speedwell", "speedup", "speedometer", "speedboat", "speed" ] ]
#32 Mr. Spell. crag r = MOOList [ "", "", [ "craggy", "crag" ] ]
#32 Mr. Spell. craf r = MOOList [ "t", "s", [ "crafty", "craft" ] ]
#32 Mr. Spell. palaz r = MOOList [ "z", "", [ "palazzo", "palazzi" ] ]
#32 Mr. Spell. refere r = MOOList [ "", "en", [ ] ]
#32 Mr. Spell. propel r = MOOList [ "", "l", [ "propel" ] ]
#32 Mr. Spell. coloni r = MOOList [ "", "", [ "colonist", "colonial" ] ]
#32 Mr. Spell. dispersi r = MOOList [ "", "", [ "dispersive", "dispersion", "dispersible" ] ]
#32 Mr. Spell. jess r = MOOList [ "", "i", [ "Jesse", "jess" ] ]
#32 Mr. Spell. crap r = MOOList [ "", "", [ "crappie", "crap" ] ]
#32 Mr. Spell. proper r = MOOList [ "", "t", [ "proper" ] ]
#32 Mr. Spell. duct r = MOOList [ "", "", [ "ductwork", "ductile", "duct" ] ]
#32 Mr. Spell. exoti r = MOOList [ "c", "", [ "exotica", "exotic" ] ]
#32 Mr. Spell. tattl r = MOOList [ "e", "", [ "tattletale", "tattler", "tattle" ] ]
#32 Mr. Spell. conspirat r = MOOList [ "or", "", [ "conspiratorial", "conspirator" ] ]
#32 Mr. Spell. referr r = MOOList [ "", "", [ "referring", "referred", "referral" ] ]
#32 Mr. Spell. Babb r = MOOList [ "", "", [ "babble", "babbitt" ] ]
#32 Mr. Spell. Williams r = MOOList [ "", "", [ "Williamson", "Williamsburg", "Williams" ] ]
#32 Mr. Spell. jerk r = MOOList [ "", "", [ "jerky", "jerk" ] ]
#32 Mr. Spell. functi r = MOOList [ "on", "a", [ "functions", "function" ] ]
#32 Mr. Spell. Bras r = MOOList [ "", "s", [ "Brasilia", "brash" ] ]
#32 Mr. Spell. functo r = MOOList [ "r", "", [ "functorial", "functor" ] ]
#32 Mr. Spell. Hersh r = MOOList [ "e", "", [ "Hershey", "Hershel" ] ]
#32 Mr. Spell. duck r = MOOList [ "", "", [ "duckling", "duck" ] ]
#32 Mr. Spell. anise r = MOOList [ "", "", [ "aniseikonic", "anise" ] ]
#32 Mr. Spell. epider r = MOOList [ "mi", "", [ "epidermis", "epidermic" ] ]
#32 Mr. Spell. finan r = MOOList [ "c", "i", [ "finance" ] ]
#32 Mr. Spell. feath r = MOOList [ "er", "b", [ "feathery", "featherweight", "feathertop", "feather" ] ]
#32 Mr. Spell. exer r = MOOList [ "", "c", [ "exert" ] ]
#32 Mr. Spell. epidem r = MOOList [ "i", "", [ "epidemiology", "epidemic" ] ]
#32 Mr. Spell. splo r = MOOList [ "tch", "", [ "splotchy", "splotch" ] ]
#32 Mr. Spell. bangl r = MOOList [ "", "", [ "bangle", "Bangladesh" ] ]
#32 Mr. Spell. aniso r = MOOList [ "trop", "", [ "anisotropy", "anisotropic" ] ]
#32 Mr. Spell. splu r = MOOList [ "", "", [ "splutter", "splurge" ] ]
#32 Mr. Spell. final r = MOOList [ "", "", [ "finally", "finale", "final" ] ]
#32 Mr. Spell. tacti r = MOOList [ "", "c", [ "tactile" ] ]
#32 Mr. Spell. spli r = MOOList [ "", "n", [ "split", "splice" ] ]
#32 Mr. Spell. exec r = MOOList [ "", "ru", [ ] ]
#32 Mr. Spell. scandi r = MOOList [ "", "", [ "scandium", "Scandinavia" ] ]
#32 Mr. Spell. exeg r = MOOList [ "e", "", [ "exegete", "exegesis" ] ]
#32 Mr. Spell. exem r = MOOList [ "p", "lt", [ ] ]
#32 Mr. Spell. spla r = MOOList [ "", "sy", [ "splat" ] ]
#32 Mr. Spell. particu r = MOOList [ "la", "r", [ "particulate" ] ]
#32 Mr. Spell. dubi r = MOOList [ "", "", [ "dubitable", "dubious" ] ]
#32 Mr. Spell. squeak r = MOOList [ "", "", [ "squeaky", "squeak" ] ]
#32 Mr. Spell. includ r = MOOList [ "", "e", [ "including" ] ]
#32 Mr. Spell. areaw r = MOOList [ "", "", [ "areawide", "areaway" ] ]
#32 Mr. Spell. sple r = MOOList [ "", "en", [ ] ]
#32 Mr. Spell. exorc r = MOOList [ "is", "", [ "exorcist", "exorcism", "exorcise" ] ]
#32 Mr. Spell. grape r = MOOList [ "", "", [ "grapevine", "grapefruit", "grape" ] ]
#32 Mr. Spell. Brad r = MOOList [ "", "", [ "Brady", "Bradshaw", "Bradley", "Bradford", "Bradbury", "brad" ] ]
#32 Mr. Spell. phospho r = MOOList [ "r", "e", [ "phosphorylate", "phosphorus", "phosphoric", "phosphor" ] ]
#32 Mr. Spell. Brag r = MOOList [ "", "g", [ "brag" ] ]
#32 Mr. Spell. graph r = MOOList [ "", "i", [ "grapheme", "graph" ] ]
#32 Mr. Spell. Brah r = MOOList [ "m", "s", [ "Brahmaputra" ] ]
#32 Mr. Spell. conduc r = MOOList [ "", "t", [ "conducive", "conduce" ] ]
#32 Mr. Spell. Bucha r = MOOList [ "", "", [ "Bucharest", "Buchanan" ] ]
#32 Mr. Spell. Brai r = MOOList [ "", "n", [ "Braille", "braid" ] ]
#32 Mr. Spell. isot r = MOOList [ "", "", [ "isotropy", "isotope", "isotherm" ] ]
#32 Mr. Spell. Colos r = MOOList [ "s", "", [ "colossus", "colossi", "Colosseum", "colossal" ] ]
#32 Mr. Spell. phosphi r = MOOList [ "", "", [ "phosphine", "phosphide" ] ]
#32 Mr. Spell. isom r = MOOList [ "", "o", [ "isomer" ] ]
#32 Mr. Spell. Colom r = MOOList [ "b", "", [ "Colombo", "Colombia" ] ]
#32 Mr. Spell. Ostrac r = MOOList [ "", "", [ "ostracod", "ostracism" ] ]
#32 Mr. Spell. quadrang r = MOOList [ "", "", [ "quadrangular", "quadrangle" ] ]
#32 Mr. Spell. carcinog r = MOOList [ "en", "", [ "carcinogenic", "carcinogen" ] ]
#32 Mr. Spell. isoc r = MOOList [ "", "h", [ "isocline" ] ]
#32 Mr. Spell. Cathe r = MOOList [ "", "r", [ "catheter", "cathedral" ] ]
#32 Mr. Spell. excr r = MOOList [ "", "e", [ "excruciate" ] ]
#32 Mr. Spell. alcoh r = MOOList [ "ol", "", [ "alcoholic", "alcohol" ] ]
#32 Mr. Spell. excu r = MOOList [ "", "lrs", [ ] ]
#32 Mr. Spell. colora r = MOOList [ "", "t", [ "Colorado" ] ]
#32 Mr. Spell. troubl r = MOOList [ "e", "s", [ "trouble" ] ]
#32 Mr. Spell. partici r = MOOList [ "p", "a", [ "participle" ] ]
#32 Mr. Spell. pisto r = MOOList [ "", "l", [ "piston" ] ]
#32 Mr. Spell. stimulat r = MOOList [ "", "", [ "stimulatory", "stimulate" ] ]
#32 Mr. Spell. sevente r = MOOList [ "en", "", [ "seventeenth", "seventeen" ] ]
#32 Mr. Spell. exce r = MOOList [ "", "lps", [ "excerpt", "exceed" ] ]
#32 Mr. Spell. injun r = MOOList [ "", "", [ "injunct", "Injun" ] ]
#32 Mr. Spell. exch r = MOOList [ "", "a", [ "exchequer" ] ]
#32 Mr. Spell. exci r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. centrif r = MOOList [ "ug", "a", [ "centrifuge" ] ]
#32 Mr. Spell. marina r = MOOList [ "", "", [ "marinate", "marinade", "marina" ] ]
#32 Mr. Spell. exco r = MOOList [ "", "", [ "excoriate", "excommunicate" ] ]
#32 Mr. Spell. propit r = MOOList [ "i", "", [ "propitious", "propitiate" ] ]
#32 Mr. Spell. excl r = MOOList [ "", "au", [ ] ]
#32 Mr. Spell. denia r = MOOList [ "", "", [ "denial", "deniable" ] ]
#32 Mr. Spell. spit r = MOOList [ "", "e", [ "spitz", "spittle", "spitfire", "spit" ] ]
#32 Mr. Spell. merrim r = MOOList [ "", "", [ "merriment", "Merrimack" ] ]
#32 Mr. Spell. gravi r = MOOList [ "", "", [ "gravitate", "gravid" ] ]
#32 Mr. Spell. spil r = MOOList [ "", "", [ "spilt", "spill" ] ]
#32 Mr. Spell. deposi r = MOOList [ "t", "o", [ "deposition", "depositary", "deposit" ] ]
#32 Mr. Spell. spin r = MOOList [ "", "ano", [ "spiny", "spinster", "spine", "spindle", "spin" ] ]
#32 Mr. Spell. synaps r = MOOList [ "e", "", [ "synapses", "synapse" ] ]
#32 Mr. Spell. spir r = MOOList [ "", "i", [ "Spiro", "spire", "spiral" ] ]
#32 Mr. Spell. grave r = MOOList [ "", "s", [ "graveyard", "graven", "gravel", "grave" ] ]
#32 Mr. Spell. spid r = MOOList [ "er", "", [ "spidery", "spiderwort", "spider" ] ]
#32 Mr. Spell. kal r = MOOList [ "", "em", [ "Kalamazoo" ] ]
#32 Mr. Spell. spik r = MOOList [ "", "e", [ "spiky" ] ]
#32 Mr. Spell. kam r = MOOList [ "", "", [ "Kampala", "kamikaze", "Kamchatka" ] ]
#32 Mr. Spell. kan r = MOOList [ "", "", [ "Kant", "Kansas", "Kankakee", "kangaroo", "Kane" ] ]
#32 Mr. Spell. kao r = MOOList [ "lin", "", [ "kaolinite", "kaolin" ] ]
#32 Mr. Spell. kap r = MOOList [ "", "", [ "kappa", "kapok", "Kaplan" ] ]
#32 Mr. Spell. pyram r = MOOList [ "id", "", [ "pyramidal", "pyramid" ] ]
#32 Mr. Spell. spic r = MOOList [ "", "e", [ "spicy", "Spica" ] ]
#32 Mr. Spell. fines r = MOOList [ "s", "", [ "finessing", "finesse" ] ]
#32 Mr. Spell. multipli r = MOOList [ "c", "a", [ "multiplicity" ] ]
#32 Mr. Spell. injur r = MOOList [ "", "", [ "injury", "injurious", "injure" ] ]
#32 Mr. Spell. multiple r = MOOList [ "", "x", [ "multiplet", "multiple" ] ]
#32 Mr. Spell. exas r = MOOList [ "perate", "", [ "exasperater", "exasperate" ] ]
#32 Mr. Spell. bankr r = MOOList [ "upt", "", [ "bankruptcy", "bankrupt" ] ]
#32 Mr. Spell. inclus r = MOOList [ "i", "", [ "inclusive", "inclusion" ] ]
#32 Mr. Spell. Astor r = MOOList [ "", "", [ "Astoria", "Astor" ] ]
#32 Mr. Spell. sphe r = MOOList [ "r", "o", [ "spherule", "spheric", "sphere" ] ]
#32 Mr. Spell. footw r = MOOList [ "", "", [ "footwork", "footwear" ] ]
#32 Mr. Spell. exac r = MOOList [ "", "", [ "exact", "exacerbate" ] ]
#32 Mr. Spell. foots r = MOOList [ "t", "", [ "footstool", "footstep" ] ]
#32 Mr. Spell. appal r = MOOList [ "", "", [ "appall", "Appalachia" ] ]
#32 Mr. Spell. isla r = MOOList [ "", "m", [ "island" ] ]
#32 Mr. Spell. Bridget r = MOOList [ "", "", [ "Bridgetown", "Bridget" ] ]
#32 Mr. Spell. gratu r = MOOList [ "it", "", [ "gratuity", "gratuitous" ] ]
#32 Mr. Spell. exal r = MOOList [ "t", "", [ "exaltation", "exalt" ] ]
#32 Mr. Spell. exam r = MOOList [ "", "ip", [ "exam" ] ]
#32 Mr. Spell. spha r = MOOList [ "", "", [ "sphalerite", "sphagnum" ] ]
#32 Mr. Spell. footp r = MOOList [ "", "a", [ "footprint" ] ]
#32 Mr. Spell. Browne r = MOOList [ "", "", [ "Brownell", "Browne" ] ]
#32 Mr. Spell. grati r = MOOList [ "", "", [ "gratitude", "gratis", "gratify" ] ]
#32 Mr. Spell. kay r = MOOList [ "", "", [ "kayo", "Kay" ] ]
#32 Mr. Spell. appar r = MOOList [ "", "e", [ "apparition", "apparatus" ] ]
#32 Mr. Spell. criss r = MOOList [ "", "", [ "crisscross", "criss" ] ]
#32 Mr. Spell. Tenn r = MOOList [ "", "e", [ "Tennyson", "tennis" ] ]
#32 Mr. Spell. obsessi r = MOOList [ "", "", [ "obsessive", "obsession" ] ]
#32 Mr. Spell. grate r = MOOList [ "", "", [ "grater", "grateful", "grate" ] ]
#32 Mr. Spell. medica r = MOOList [ "", "", [ "medical", "medicate" ] ]
#32 Mr. Spell. Buckl r = MOOList [ "e", "", [ "Buckley", "buckle" ] ]
#32 Mr. Spell. Swede r = MOOList [ "", "", [ "Sweden", "Swede" ] ]
#32 Mr. Spell. medici r = MOOList [ "", "n", [ "Medici" ] ]
#32 Mr. Spell. Zan r = MOOList [ "", "", [ "Zanzibar", "Zan" ] ]
#32 Mr. Spell. Effic r = MOOList [ "", "a", [ "efficient" ] ]
#32 Mr. Spell. crite r = MOOList [ "ri", "", [ "criterion", "criteria" ] ]
#32 Mr. Spell. Herme r = MOOList [ "", "", [ "hermetic", "Hermes", "hermeneutic" ] ]
#32 Mr. Spell. criti r = MOOList [ "", "c", [ "critique" ] ]
#32 Mr. Spell. grass r = MOOList [ "", "", [ "grassy", "grassland", "grass" ] ]
#32 Mr. Spell. footm r = MOOList [ "", "", [ "footmen", "footman" ] ]
#32 Mr. Spell. Judic r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. footb r = MOOList [ "", "", [ "footbridge", "football" ] ]
#32 Mr. Spell. paperw r = MOOList [ "", "", [ "paperwork", "paperweight" ] ]
#32 Mr. Spell. foote r = MOOList [ "", "", [ "footer", "Foote" ] ]
#32 Mr. Spell. stairw r = MOOList [ "", "", [ "stairwell", "stairway" ] ]
#32 Mr. Spell. underc r = MOOList [ "lassm", "", [ "underclassmen", "underclassman" ] ]
#32 Mr. Spell. Greenbe r = MOOList [ "", "", [ "Greenberg", "Greenbelt" ] ]
#32 Mr. Spell. movi r = MOOList [ "", "", [ "moving", "movie" ] ]
#32 Mr. Spell. octahedra r = MOOList [ "", "", [ "octahedral", "octahedra" ] ]
#32 Mr. Spell. Mayf r = MOOList [ "", "", [ "Mayflower", "Mayfair" ] ]
#32 Mr. Spell. move r = MOOList [ "", "", [ "moves", "movement", "moved", "move" ] ]
#32 Mr. Spell. alta r = MOOList [ "", "", [ "altar", "Altair" ] ]
#32 Mr. Spell. stair r = MOOList [ "", "w", [ "staircase", "stair" ] ]
#32 Mr. Spell. alte r = MOOList [ "r", "n", [ "alterman", "altercate", "alterate", "alter" ] ]
#32 Mr. Spell. trichl r = MOOList [ "oro", "", [ "trichloroethane", "trichloroacetic" ] ]
#32 Mr. Spell. plaint r = MOOList [ "i", "", [ "plaintive", "plaintiff" ] ]
#32 Mr. Spell. alth r = MOOList [ "", "", [ "although", "althea" ] ]
#32 Mr. Spell. populat r = MOOList [ "", "", [ "population", "populate" ] ]
#32 Mr. Spell. palin r = MOOList [ "drom", "", [ "palindromic", "palindrome" ] ]
#32 Mr. Spell. cryo r = MOOList [ "", "", [ "cryostat", "cryogenic" ] ]
#32 Mr. Spell. lunar r = MOOList [ "", "", [ "lunary", "lunar" ] ]
#32 Mr. Spell. mous r = MOOList [ "", "", [ "mousy", "moustache", "mouse" ] ]
#32 Mr. Spell. mout r = MOOList [ "", "h", [ "Mouton" ] ]
#32 Mr. Spell. cryp r = MOOList [ "t", "ao", [ "cryptic", "crypt" ] ]
#32 Mr. Spell. crys r = MOOList [ "tal", "l", [ "crystal" ] ]
#32 Mr. Spell. lunat r = MOOList [ "", "", [ "lunatic", "lunate" ] ]
#32 Mr. Spell. vint r = MOOList [ "", "", [ "vintner", "vintage" ] ]
#32 Mr. Spell. Brande r = MOOList [ "", "", [ "Brandenburg", "Brandeis" ] ]
#32 Mr. Spell. kep r = MOOList [ "", "", [ "kept", "Kepler" ] ]
#32 Mr. Spell. manag r = MOOList [ "", "e", [ "managing", "Managua" ] ]
#32 Mr. Spell. mour r = MOOList [ "n", "", [ "mournful", "mourn" ] ]
#32 Mr. Spell. kes r = MOOList [ "", "", [ "kestrel", "Kessler" ] ]
#32 Mr. Spell. transpos r = MOOList [ "", "", [ "transposition", "transpose", "transposable" ] ]
#32 Mr. Spell. ket r = MOOList [ "", "cot", [ ] ]
#32 Mr. Spell. transpor r = MOOList [ "t", "", [ "transporter", "transportation", "transport" ] ]
#32 Mr. Spell. Shipl r = MOOList [ "", "", [ "Shipley", "shiplap" ] ]
#32 Mr. Spell. moun r = MOOList [ "", "t", [ "mound" ] ]
#32 Mr. Spell. moul r = MOOList [ "", "", [ "Moulton", "mould" ] ]
#32 Mr. Spell. key r = MOOList [ "", "nswb", [ "keypunch", "keyhole", "Keyes", "key" ] ]
#32 Mr. Spell. vine r = MOOList [ "", "", [ "vineyard", "vinegar", "vine" ] ]
#32 Mr. Spell. navi r = MOOList [ "ga", "", [ "navigate", "navigable" ] ]
#32 Mr. Spell. Morris r = MOOList [ "", "", [ "Morristown", "Morrissey", "Morrison", "morris" ] ]
#32 Mr. Spell. vind r = MOOList [ "ic", "", [ "vindictive", "vindicate" ] ]
#32 Mr. Spell. nave r = MOOList [ "", "", [ "navel", "nave" ] ]
#32 Mr. Spell. mott r = MOOList [ "", "", [ "motto", "mottle" ] ]
#32 Mr. Spell. Maxw r = MOOList [ "ell", "", [ "Maxwellian", "maxwell" ] ]
#32 Mr. Spell. boul r = MOOList [ "", "", [ "boulevard", "boulder" ] ]
#32 Mr. Spell. midwi r = MOOList [ "", "", [ "midwives", "midwinter", "midwife" ] ]
#32 Mr. Spell. Lowe r = MOOList [ "", "", [ "lower", "Lowell", "Lowe" ] ]
#32 Mr. Spell. kea r = MOOList [ "t", "", [ "Keats", "Keaton" ] ]
#32 Mr. Spell. boun r = MOOList [ "", "cd", [ "bounty" ] ]
#32 Mr. Spell. Bayo r = MOOList [ "", "n", [ "bayou" ] ]
#32 Mr. Spell. Musco r = MOOList [ "v", "", [ "Muscovy", "Muscovite" ] ]
#32 Mr. Spell. kee r = MOOList [ "", "lnp", [ "keeshond" ] ]
#32 Mr. Spell. bour r = MOOList [ "", "bg", [ "bourn" ] ]
#32 Mr. Spell. smokes r = MOOList [ "", "", [ "smokestack", "smokescreen" ] ]
#32 Mr. Spell. finis r = MOOList [ "h", "e", [ "finish" ] ]
#32 Mr. Spell. Liver r = MOOList [ "", "p", [ "livery", "liverwort", "Livermore" ] ]
#32 Mr. Spell. bout r = MOOList [ "", "", [ "boutique", "bout" ] ]
#32 Mr. Spell. moth r = MOOList [ "", "e", [ "moth" ] ]
#32 Mr. Spell. kine r = MOOList [ "", "s", [ "kinetic", "kinematic" ] ]
#32 Mr. Spell. cavi r = MOOList [ "", "l", [ "Caviness", "caviar" ] ]
#32 Mr. Spell. Abram r = MOOList [ "", "", [ "Abramson", "Abram" ] ]
#32 Mr. Spell. traffick r = MOOList [ "", "", [ "trafficking", "trafficked" ] ]
#32 Mr. Spell. moti r = MOOList [ "", "v", [ "motion", "motif" ] ]
#32 Mr. Spell. kind r = MOOList [ "", "", [ "kindred", "kindle", "kindergarten", "kind" ] ]
#32 Mr. Spell. ingesti r = MOOList [ "", "", [ "ingestion", "ingestible" ] ]
#32 Mr. Spell. relic r = MOOList [ "", "", [ "relict", "relic" ] ]
#32 Mr. Spell. king r = MOOList [ "", "s", [ "kingpin", "kinglet", "kingfisher", "kingdom", "kingbird", "king" ] ]
#32 Mr. Spell. chartre r = MOOList [ "", "", [ "chartreuse", "Chartres" ] ]
#32 Mr. Spell. Louv r = MOOList [ "", "", [ "Louvre", "louver" ] ]
#32 Mr. Spell. relie r = MOOList [ "", "", [ "relieve", "relief" ] ]
#32 Mr. Spell. naut r = MOOList [ "i", "", [ "nautilus", "nautical" ] ]
#32 Mr. Spell. mote r = MOOList [ "", "", [ "motet", "motel" ] ]
#32 Mr. Spell. midst r = MOOList [ "", "", [ "midstream", "midst" ] ]
#32 Mr. Spell. relig r = MOOList [ "io", "", [ "religious", "religiosity", "religion" ] ]
#32 Mr. Spell. naus r = MOOList [ "e", "a", [ "nauseum" ] ]
#32 Mr. Spell. nava r = MOOList [ "", "", [ "naval", "Navajo" ] ]
#32 Mr. Spell. moto r = MOOList [ "r", "", [ "Motorola", "motorcycle", "motor" ] ]
#32 Mr. Spell. appen r = MOOList [ "d", "i", [ "appendage", "append" ] ]
#32 Mr. Spell. kink r = MOOList [ "", "", [ "kinky", "kink" ] ]
#32 Mr. Spell. boug r = MOOList [ "h", "", [ "bought", "bough" ] ]
#32 Mr. Spell. appel r = MOOList [ "la", "", [ "appellate", "appellant" ] ]
#32 Mr. Spell. latit r = MOOList [ "ud", "i", [ "latitude" ] ]
#32 Mr. Spell. both r = MOOList [ "", "", [ "bothersome", "both" ] ]
#32 Mr. Spell. administr r = MOOList [ "a", "t", [ "administrable" ] ]
#32 Mr. Spell. moss r = MOOList [ "", "", [ "mossy", "moss" ] ]
#32 Mr. Spell. mosq r = MOOList [ "u", "", [ "mosquito", "mosque" ] ]
#32 Mr. Spell. officia r = MOOList [ "", "l", [ "officiate" ] ]
#32 Mr. Spell. cava r = MOOList [ "l", "", [ "cavalry", "cavalier", "cavalcade" ] ]
#32 Mr. Spell. benefi r = MOOList [ "", "ct", [ ] ]
#32 Mr. Spell. officio r = MOOList [ "", "", [ "officious", "officio" ] ]
#32 Mr. Spell. marion r = MOOList [ "", "", [ "marionette", "Marion" ] ]
#32 Mr. Spell. Josep r = MOOList [ "h", "", [ "Josephus", "Josephson", "Josephine", "Joseph" ] ]
#32 Mr. Spell. stale r = MOOList [ "", "", [ "Staley", "stalemate", "stale" ] ]
#32 Mr. Spell. cave r = MOOList [ "", "mr", [ "Cavendish", "caveat", "cave" ] ]
#32 Mr. Spell. bott r = MOOList [ "", "lo", [ ] ]
#32 Mr. Spell. latin r = MOOList [ "", "", [ "Latinate", "Latin" ] ]
#32 Mr. Spell. botu r = MOOList [ "li", "", [ "botulism", "botulin" ] ]
#32 Mr. Spell. Stir r = MOOList [ "", "", [ "stirrup", "Stirling", "stir" ] ]
#32 Mr. Spell. natu r = MOOList [ "r", "", [ "naturopath", "nature", "natural" ] ]
#32 Mr. Spell. asymp r = MOOList [ "tot", "", [ "asymptotic", "asymptote" ] ]
#32 Mr. Spell. caul r = MOOList [ "", "", [ "caulk", "cauliflower" ] ]
#32 Mr. Spell. vill r = MOOList [ "", "a", [ "villein" ] ]
#32 Mr. Spell. Ida r = MOOList [ "", "", [ "Idaho", "Ida" ] ]
#32 Mr. Spell. bota r = MOOList [ "n", "i", [ "botany" ] ]
#32 Mr. Spell. caut r = MOOList [ "io", "n", [ "cautious" ] ]
#32 Mr. Spell. caus r = MOOList [ "", "ae", [ "causing", "caustic" ] ]
#32 Mr. Spell. continuo r = MOOList [ "", "", [ "continuous", "continuo" ] ]
#32 Mr. Spell. Schr r = MOOList [ "oed", "", [ "Schroedinger", "Schroeder" ] ]
#32 Mr. Spell. Loui r = MOOList [ "s", "", [ "Louisville", "Louisiana", "Louise", "Louisa", "Louis" ] ]
#32 Mr. Spell. mort r = MOOList [ "", "agi", [ "Morton", "mortem", "mort" ] ]
#32 Mr. Spell. alph r = MOOList [ "", "a", [ "Alphonse", "Alpheratz" ] ]
#32 Mr. Spell. continui r = MOOList [ "", "", [ "continuing", "continuity" ] ]
#32 Mr. Spell. morr r = MOOList [ "", "i", [ "morrow" ] ]
#32 Mr. Spell. hystere r = MOOList [ "", "", [ "hysteresis", "hysterectomy" ] ]
#32 Mr. Spell. Schw r = MOOList [ "", "a", [ "Schweitzer" ] ]
#32 Mr. Spell. mors r = MOOList [ "e", "", [ "morsel", "Morse" ] ]
#32 Mr. Spell. morp r = MOOList [ "h", "eio", [ ] ]
#32 Mr. Spell. Schu r = MOOList [ "", "lmy", [ "Schuster", "Schubert" ] ]
#32 Mr. Spell. continue r = MOOList [ "", "", [ "continues", "continued", "continue" ] ]
#32 Mr. Spell. hysteri r = MOOList [ "", "", [ "hysteric", "hysteria" ] ]
#32 Mr. Spell. conval r = MOOList [ "esce", "", [ "convalescent", "convalesce" ] ]
#32 Mr. Spell. boso r = MOOList [ "", "n", [ "bosom" ] ]
#32 Mr. Spell. Brya r = MOOList [ "n", "", [ "Bryant", "Bryan" ] ]
#32 Mr. Spell. Loun r = MOOList [ "", "", [ "Lounsbury", "lounge" ] ]
#32 Mr. Spell. appea r = MOOList [ "", "rs", [ "appeal" ] ]
#32 Mr. Spell. continua r = MOOList [ "", "", [ "continuation", "continuant", "continual", "continua" ] ]
#32 Mr. Spell. Scho r = MOOList [ "", "lo", [ "Schottky", "Schofield", "Schoenberg" ] ]
#32 Mr. Spell. cauc r = MOOList [ "", "a", [ "caucus", "Cauchy" ] ]
#32 Mr. Spell. nati r = MOOList [ "", "o", [ "native" ] ]
#32 Mr. Spell. knott r = MOOList [ "", "", [ "knotty", "Knott" ] ]
#32 Mr. Spell. Schm r = MOOList [ "i", "", [ "Schmitt", "Schmidt" ] ]
#32 Mr. Spell. morg r = MOOList [ "", "", [ "morgue", "morgen", "Morgan" ] ]
#32 Mr. Spell. strob r = MOOList [ "", "", [ "stroboscopic", "strobe" ] ]
#32 Mr. Spell. nast r = MOOList [ "", "", [ "nasty", "nasturtium" ] ]
#32 Mr. Spell. cati r = MOOList [ "on", "", [ "cationic", "cation" ] ]
#32 Mr. Spell. more r = MOOList [ "", "l", [ "Moresby", "moreover", "more" ] ]
#32 Mr. Spell. cath r = MOOList [ "", "eo", [ "Cathy", "catharsis" ] ]
#32 Mr. Spell. stamp r = MOOList [ "", "", [ "stampede", "stamp" ] ]
#32 Mr. Spell. mora r = MOOList [ "", "l", [ "Moravia", "moratorium", "morass", "Moran", "moraine" ] ]
#32 Mr. Spell. expan r = MOOList [ "", "s", [ "expand" ] ]
#32 Mr. Spell. autocr r = MOOList [ "a", "t", [ "autocracy" ] ]
#32 Mr. Spell. kill r = MOOList [ "", "", [ "killjoy", "killdeer", "kill" ] ]
#32 Mr. Spell. cats r = MOOList [ "", "", [ "catsup", "Catskill" ] ]
#32 Mr. Spell. leoni r = MOOList [ "", "", [ "leonine", "Leonid" ] ]
#32 Mr. Spell. mori r = MOOList [ "", "", [ "moribund", "Moriarty" ] ]
#32 Mr. Spell. Hutchin r = MOOList [ "s", "", [ "Hutchinson", "Hutchins" ] ]
#32 Mr. Spell. catt r = MOOList [ "", "l", [ "cattail" ] ]
#32 Mr. Spell. autoco r = MOOList [ "", "", [ "autocorrelate", "autocollimate" ] ]
#32 Mr. Spell. stanc r = MOOList [ "", "h", [ "stance" ] ]
#32 Mr. Spell. Borea r = MOOList [ "", "", [ "Boreas", "Borealis" ] ]
#32 Mr. Spell. casu r = MOOList [ "al", "", [ "casualty", "casual" ] ]
#32 Mr. Spell. crui r = MOOList [ "", "", [ "cruise", "Cruickshank" ] ]
#32 Mr. Spell. stand r = MOOList [ "", "a", [ "standstill", "standpoint", "standoff", "Standish", "standeth", "standby", "stand" ] ]
#32 Mr. Spell. strop r = MOOList [ "", "", [ "strophe", "strop" ] ]
#32 Mr. Spell. Savag r = MOOList [ "e", "", [ "savagery", "savage" ] ]
#32 Mr. Spell. stron r = MOOList [ "", "g", [ "strontium" ] ]
#32 Mr. Spell. Maur r = MOOList [ "", "i", [ "Maureen" ] ]
#32 Mr. Spell. crum r = MOOList [ "", "bp", [ "crummy" ] ]
#32 Mr. Spell. alphab r = MOOList [ "et", "", [ "alphabetic", "alphabet" ] ]
#32 Mr. Spell. yarm r = MOOList [ "", "", [ "yarmulke", "Yarmouth" ] ]
#32 Mr. Spell. born r = MOOList [ "", "e", [ "born" ] ]
#32 Mr. Spell. regist r = MOOList [ "r", "a", [ "registry" ] ]
#32 Mr. Spell. alon r = MOOList [ "", "g", [ "alone" ] ]
#32 Mr. Spell. boro r = MOOList [ "", "", [ "borough", "borosilicate", "boron" ] ]
#32 Mr. Spell. crus r = MOOList [ "", "", [ "crust", "Crusoe", "crush", "crusade" ] ]
#32 Mr. Spell. catc r = MOOList [ "h", "", [ "catchy", "catchword", "catchup", "catch" ] ]
#32 Mr. Spell. borr r = MOOList [ "o", "", [ "borrow", "Borroughs" ] ]
#32 Mr. Spell. cate r = MOOList [ "", "gr", [ "catenate", "catechism" ] ]
#32 Mr. Spell. ANSe r = MOOList [ "lm", "", [ "Anselmo", "Anselm" ] ]
#32 Mr. Spell. kin r = MOOList [ "", "degk", [ "Kinshasha", "Kinney", "kin" ] ]
#32 Mr. Spell. case r = MOOList [ "", "", [ "Casey", "casework", "casein", "casebook", "case" ] ]
#32 Mr. Spell. Mate r = MOOList [ "", "r", [ "Mateo", "mate" ] ]
#32 Mr. Spell. cash r = MOOList [ "", "", [ "cashmere", "cashier", "cashew", "cash" ] ]
#32 Mr. Spell. iceb r = MOOList [ "", "", [ "icebox", "iceberg" ] ]
#32 Mr. Spell. stall r = MOOList [ "", "", [ "stallion", "stall" ] ]
#32 Mr. Spell. narr r = MOOList [ "", "a", [ "narrow" ] ]
#32 Mr. Spell. cask r = MOOList [ "", "", [ "casket", "cask" ] ]
#32 Mr. Spell. kiv r = MOOList [ "", "", [ "kivu", "kiva" ] ]
#32 Mr. Spell. kiw r = MOOList [ "", "", [ "kiwi", "Kiwanis" ] ]
#32 Mr. Spell. einsteini r = MOOList [ "", "", [ "einsteinium", "Einsteinian" ] ]
#32 Mr. Spell. cruc r = MOOList [ "i", "f", [ "crucible", "crucial" ] ]
#32 Mr. Spell. Baud r = MOOList [ "", "", [ "Baudelaire", "baud" ] ]
#32 Mr. Spell. crue r = MOOList [ "l", "", [ "cruelty", "cruel" ] ]
#32 Mr. Spell. cast r = MOOList [ "", "ei", [ "Castro", "castor", "castle", "castanet", "cast" ] ]
#32 Mr. Spell. bord r = MOOList [ "e", "r", [ "Borden", "bordello", "Bordeaux" ] ]
#32 Mr. Spell. crud r = MOOList [ "", "", [ "crude", "cruddy", "crud" ] ]
#32 Mr. Spell. cass r = MOOList [ "", "ei", [ "cassock", "Cassandra" ] ]
#32 Mr. Spell. midsh r = MOOList [ "ipm", "", [ "midshipmen", "midshipman" ] ]
#32 Mr. Spell. cart r = MOOList [ "", "eio", [ "cartwheel", "cartridge", "Carthage", "cart" ] ]
#32 Mr. Spell. narc r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. Matt r = MOOList [ "", "e", [ "Mattson", "mattress", "mattock", "Matthew" ] ]
#32 Mr. Spell. Casti r = MOOList [ "", "", [ "Castillo", "castigate" ] ]
#32 Mr. Spell. carv r = MOOList [ "e", "", [ "carven", "carve" ] ]
#32 Mr. Spell. Mats r = MOOList [ "", "", [ "Matsumoto", "Matson" ] ]
#32 Mr. Spell. kib r = MOOList [ "", "", [ "kibitz", "kibbutzim" ] ]
#32 Mr. Spell. kic r = MOOList [ "k", "", [ "kickoff", "kickback", "kick" ] ]
#32 Mr. Spell. Wort r = MOOList [ "h", "l", [ "worthy", "worthwhile", "Worthington", "worth" ] ]
#32 Mr. Spell. nasA r = MOOList [ "", "", [ "nasal", "NASA" ] ]
#32 Mr. Spell. height r = MOOList [ "", "", [ "heighten", "height" ] ]
#32 Mr. Spell. stami r = MOOList [ "na", "", [ "staminate", "stamina" ] ]
#32 Mr. Spell. convolu r = MOOList [ "t", "", [ "convolution", "convolute" ] ]
#32 Mr. Spell. servicem r = MOOList [ "", "", [ "servicemen", "serviceman" ] ]
#32 Mr. Spell. kil r = MOOList [ "", "l", [ "kilohm", "Kilgore" ] ]
#32 Mr. Spell. casc r = MOOList [ "a", "", [ "cascara", "cascade" ] ]
#32 Mr. Spell. care r = MOOList [ "", "eft", [ "Carey", "careworn", "caress", "care" ] ]
#32 Mr. Spell. arena r = MOOList [ "", "", [ "arenaceous", "arena" ] ]
#32 Mr. Spell. Mase r = MOOList [ "r", "", [ "Maseru", "maser" ] ]
#32 Mr. Spell. card r = MOOList [ "", "i", [ "cardboard", "cardamom", "card" ] ]
#32 Mr. Spell. carg r = MOOList [ "", "o", [ "Cargill" ] ]
#32 Mr. Spell. caro r = MOOList [ "", "l", [ "carouse", "carob" ] ]
#32 Mr. Spell. carn r = MOOList [ "", "ae", [ "carnival" ] ]
#32 Mr. Spell. Batc r = MOOList [ "h", "", [ "Batchelder", "batch" ] ]
#32 Mr. Spell. carr r = MOOList [ "", "aioy", [ "Carruthers", "carrel", "Carr" ] ]
#32 Mr. Spell. Lore r = MOOList [ "", "n", [ "Lorelei", "lore" ] ]
#32 Mr. Spell. Cassi r = MOOList [ "", "", [ "Cassius", "Cassiopeia" ] ]
#32 Mr. Spell. Mass r = MOOList [ "", "aei", [ "mass" ] ]
#32 Mr. Spell. pluton r = MOOList [ "", "", [ "plutonium", "pluton" ] ]
#32 Mr. Spell. later r = MOOList [ "", "a", [ "laterite", "later" ] ]
#32 Mr. Spell. denou r = MOOList [ "", "", [ "denounce", "denouement" ] ]
#32 Mr. Spell. Bato r = MOOList [ "", "", [ "Bator", "baton" ] ]
#32 Mr. Spell. denot r = MOOList [ "", "a", [ "denote" ] ]
#32 Mr. Spell. ancestr r = MOOList [ "", "", [ "ancestry", "ancestral" ] ]
#32 Mr. Spell. staph r = MOOList [ "", "", [ "staphylococcus", "staph" ] ]
#32 Mr. Spell. almo r = MOOList [ "", "", [ "almost", "almond" ] ]
#32 Mr. Spell. carc r = MOOList [ "", "i", [ "carcass" ] ]
#32 Mr. Spell. carb r = MOOList [ "", "iou", [ ] ]
#32 Mr. Spell. mood r = MOOList [ "", "", [ "moody", "mood" ] ]
#32 Mr. Spell. boor r = MOOList [ "", "", [ "boorish", "boor" ] ]
#32 Mr. Spell. Marc r = MOOList [ "", "e", [ "Marcy", "Marcus", "Marco", "Marcia", "march", "Marc" ] ]
#32 Mr. Spell. greene r = MOOList [ "", "", [ "greenery", "Greene" ] ]
#32 Mr. Spell. allu r = MOOList [ "", "sv", [ "allure", "allude" ] ]
#32 Mr. Spell. stann r = MOOList [ "", "", [ "stannous", "stannic" ] ]
#32 Mr. Spell. Justin r = MOOList [ "", "", [ "Justinian", "Justine" ] ]
#32 Mr. Spell. Ander r = MOOList [ "s", "", [ "Anderson", "Andersen" ] ]
#32 Mr. Spell. ancesto r = MOOList [ "r", "", [ "ancestors", "ancestor" ] ]
#32 Mr. Spell. thiev r = MOOList [ "", "", [ "thieving", "thieves" ] ]
#32 Mr. Spell. ally r = MOOList [ "", "", [ "Allyn", "allyl", "ally" ] ]
#32 Mr. Spell. Marl r = MOOList [ "", "b", [ "Marlowe", "marlin", "Marlene" ] ]
#32 Mr. Spell. Marj r = MOOList [ "or", "", [ "Marjory", "Marjorie", "marjoram" ] ]
#32 Mr. Spell. Mari r = MOOList [ "", "aenot", [ "marimba", "Marilyn", "marijuana", "marigold" ] ]
#32 Mr. Spell. Stei r = MOOList [ "n", "", [ "Steiner", "Steinberg", "stein" ] ]
#32 Mr. Spell. Zio r = MOOList [ "n", "", [ "Zionism", "Zion" ] ]
#32 Mr. Spell. alma r = MOOList [ "", "", [ "almanac", "almagest", "Almaden", "alma" ] ]
#32 Mr. Spell. greens r = MOOList [ "", "", [ "greensward", "Greensboro" ] ]
#32 Mr. Spell. caps r = MOOList [ "", "t", [ "capsule", "capsize" ] ]
#32 Mr. Spell. mons r = MOOList [ "", "t", [ "monsoon", "monsieur", "Monsanto" ] ]
#32 Mr. Spell. capr r = MOOList [ "ic", "", [ "Capricorn", "capricious", "caprice" ] ]
#32 Mr. Spell. competiti r = MOOList [ "", "", [ "competitive", "competition" ] ]
#32 Mr. Spell. capt r = MOOList [ "", "ai", [ "capture", "captor" ] ]
#32 Mr. Spell. alle r = MOOList [ "", "gnry", [ "alleviate", "allemand", "allele" ] ]
#32 Mr. Spell. mono r = MOOList [ "", "cglmt", [ "monoxide", "monopoly", "Monongahela" ] ]
#32 Mr. Spell. Wrong r = MOOList [ "", "d", [ "wrongful", "wrong" ] ]
#32 Mr. Spell. book r = MOOList [ "", "is", [ "booky", "bookplate", "booklet", "bookkeep", "bookend", "bookcase", "bookbind", "book" ] ]
#32 Mr. Spell. alli r = MOOList [ "", "s", [ "alliterate", "alligator", "alliance" ] ]
#32 Mr. Spell. Stet r = MOOList [ "", "", [ "Stetson", "stethoscope" ] ]
#32 Mr. Spell. conven r = MOOList [ "", "ti", [ "convene" ] ]
#32 Mr. Spell. boom r = MOOList [ "", "", [ "boomerang", "boom" ] ]
#32 Mr. Spell. Mary r = MOOList [ "", "", [ "Maryland", "Mary" ] ]
#32 Mr. Spell. expressi r = MOOList [ "", "", [ "expressive", "expression", "expressible" ] ]
#32 Mr. Spell. Bruc r = MOOList [ "", "e", [ "Bruckner" ] ]
#32 Mr. Spell. Bass r = MOOList [ "", "i", [ "basswood", "basso", "Bassett", "bass" ] ]
#32 Mr. Spell. mont r = MOOList [ "", "aerh", [ "Monty", "Montpelier", "Montmartre", "Monticello", "Montgomery", "Montclair", "Mont" ] ]
#32 Mr. Spell. allo r = MOOList [ "", "ctw", [ "alloy" ] ]
#32 Mr. Spell. Wood r = MOOList [ "", "clrswy", [ "woodpeck", "woodhen", "woodgrain", "wooden", "Woodbury", "Woodard", "wood" ] ]
#32 Mr. Spell. cape r = MOOList [ "", "", [ "Capetown", "caper", "capella", "cape" ] ]
#32 Mr. Spell. expen r = MOOList [ "", "ds", [ ] ]
#32 Mr. Spell. divisi r = MOOList [ "", "", [ "divisive", "division", "divisible" ] ]
#32 Mr. Spell. bonu r = MOOList [ "s", "", [ "bonuses", "bonus" ] ]
#32 Mr. Spell. Loom r = MOOList [ "", "", [ "Loomis", "loom" ] ]
#32 Mr. Spell. expel r = MOOList [ "", "l", [ "expel" ] ]
#32 Mr. Spell. conver r = MOOList [ "", "gst", [ ] ]
#32 Mr. Spell. exper r = MOOList [ "", "it", [ ] ]
#32 Mr. Spell. outl r = MOOList [ "a", "", [ "outlawry", "outlandish" ] ]
#32 Mr. Spell. monk r = MOOList [ "", "e", [ "monkish", "monk" ] ]
#32 Mr. Spell. mong r = MOOList [ "o", "", [ "mongoose", "Mongolia" ] ]
#32 Mr. Spell. Barb r = MOOList [ "", "aei", [ "barbudo", "Barbour", "barb" ] ]
#32 Mr. Spell. admin r = MOOList [ "ist", "r", [ "administer" ] ]
#32 Mr. Spell. vigi r = MOOList [ "l", "a", [ "vigil" ] ]
#32 Mr. Spell. mone r = MOOList [ "", "ty", [ "monel" ] ]
#32 Mr. Spell. convey r = MOOList [ "", "", [ "conveyor", "conveyance", "convey" ] ]
#32 Mr. Spell. kla r = MOOList [ "", "", [ "klaxon", "Klaus", "Klan" ] ]
#32 Mr. Spell. committee r = MOOList [ "", "mw", [ "committees", "committee" ] ]
#32 Mr. Spell. appla r = MOOList [ "u", "", [ "applause", "applaud" ] ]
#32 Mr. Spell. bona r = MOOList [ "", "", [ "Bonaventure", "Bonaparte", "bonanza", "bona" ] ]
#32 Mr. Spell. dutc r = MOOList [ "h", "m", [ "dutchess", "Dutch" ] ]
#32 Mr. Spell. bond r = MOOList [ "", "s", [ "bondage", "bond" ] ]
#32 Mr. Spell. Barc r = MOOList [ "", "", [ "Barclay", "Barcelona" ] ]
#32 Mr. Spell. admir r = MOOList [ "", "a", [ "admire" ] ]
#32 Mr. Spell. dignit r = MOOList [ "", "", [ "dignity", "dignitary" ] ]
#32 Mr. Spell. Bolshevis r = MOOList [ "", "", [ "Bolshevist", "Bolshevism" ] ]
#32 Mr. Spell. duti r = MOOList [ "", "", [ "dutiful", "dutiable" ] ]
#32 Mr. Spell. admit r = MOOList [ "", "t", [ "admit" ] ]
#32 Mr. Spell. neckl r = MOOList [ "", "", [ "neckline", "necklace" ] ]
#32 Mr. Spell. admis r = MOOList [ "si", "", [ "admission", "admissible" ] ]
#32 Mr. Spell. bong r = MOOList [ "", "", [ "bongo", "bong" ] ]
#32 Mr. Spell. appli r = MOOList [ "", "c", [ "applique", "appliance" ] ]
#32 Mr. Spell. admix r = MOOList [ "", "", [ "admixture", "admix" ] ]
#32 Mr. Spell. boni r = MOOList [ "", "", [ "bonito", "Boniface" ] ]
#32 Mr. Spell. Barn r = MOOList [ "", "ae", [ "barnyard", "barnstorm", "Barnhard", "barn" ] ]
#32 Mr. Spell. mania r = MOOList [ "", "c", [ "mania" ] ]
#32 Mr. Spell. Barl r = MOOList [ "", "", [ "Barlow", "barley" ] ]
#32 Mr. Spell. bonn r = MOOList [ "", "e", [ "Bonnie", "Bonn" ] ]
#32 Mr. Spell. patron r = MOOList [ "", "", [ "patroness", "patronage", "patron" ] ]
#32 Mr. Spell. capa r = MOOList [ "ci", "t", [ "capacious" ] ]
#32 Mr. Spell. patrol r = MOOList [ "", "lm", [ "patrol" ] ]
#32 Mr. Spell. manif r = MOOList [ "", "e", [ "manifold" ] ]
#32 Mr. Spell. Lope r = MOOList [ "", "", [ "Lopez", "lope" ] ]
#32 Mr. Spell. dust r = MOOList [ "", "", [ "dusty", "dustbin", "dust" ] ]
#32 Mr. Spell. straw r = MOOList [ "", "", [ "strawflower", "strawberry", "straw" ] ]
#32 Mr. Spell. strat r = MOOList [ "", "aeo", [ "stratum", "Stratton", "stratify", "Stratford" ] ]
#32 Mr. Spell. inquis r = MOOList [ "it", "i", [ "inquisitor" ] ]
#32 Mr. Spell. inquir r = MOOList [ "", "", [ "inquiry", "inquire" ] ]
#32 Mr. Spell. manip r = MOOList [ "ula", "", [ "manipulate", "manipulable" ] ]
#32 Mr. Spell. woodla r = MOOList [ "", "", [ "Woodlawn", "woodland" ] ]
#32 Mr. Spell. waterf r = MOOList [ "", "", [ "waterfront", "waterfall" ] ]
#32 Mr. Spell. Scar r = MOOList [ "", "efl", [ "scary", "scarves", "Scarsdale", "scarify", "scarce", "Scarborough", "scar" ] ]
#32 Mr. Spell. mome r = MOOList [ "nt", "a", [ "moments", "momentum", "momentous", "moment" ] ]
#32 Mr. Spell. orchi r = MOOList [ "", "", [ "orchis", "orchid" ] ]
#32 Mr. Spell. kna r = MOOList [ "", "p", [ "Knauer", "knack" ] ]
#32 Mr. Spell. bienn r = MOOList [ "i", "", [ "biennium", "biennial" ] ]
#32 Mr. Spell. ours r = MOOList [ "", "", [ "ours", "ourselves" ] ]
#32 Mr. Spell. duse r = MOOList [ "nb", "", [ "Dusenbury", "Dusenberg" ] ]
#32 Mr. Spell. waterm r = MOOList [ "", "", [ "watermelon", "Waterman" ] ]
#32 Mr. Spell. prince r = MOOList [ "", "", [ "Princeton", "princess", "prince" ] ]
#32 Mr. Spell. canv r = MOOList [ "as", "", [ "canvass", "canvasback", "canvas" ] ]
#32 Mr. Spell. propelle r = MOOList [ "", "", [ "propeller", "propelled" ] ]
#32 Mr. Spell. waters r = MOOList [ "", "", [ "waterside", "watershed", "Waters" ] ]
#32 Mr. Spell. moly r = MOOList [ "bd", "e", [ "molybdate" ] ]
#32 Mr. Spell. expec r = MOOList [ "t", "ao", [ "expecting", "expected", "expect" ] ]
#32 Mr. Spell. dusk r = MOOList [ "", "", [ "dusky", "dusk" ] ]
#32 Mr. Spell. molt r = MOOList [ "", "", [ "molten", "molt" ] ]
#32 Mr. Spell. glamor r = MOOList [ "", "", [ "glamorous", "glamor" ] ]
#32 Mr. Spell. exped r = MOOList [ "i", "t", [ "expedient" ] ]
#32 Mr. Spell. view r = MOOList [ "", "p", [ "views", "view" ] ]
#32 Mr. Spell. mola r = MOOList [ "", "", [ "molasses", "molar", "molal" ] ]
#32 Mr. Spell. knu r = MOOList [ "", "cdt", [ "knurl" ] ]
#32 Mr. Spell. cros r = MOOList [ "", "s", [ "Crosby" ] ]
#32 Mr. Spell. canc r = MOOList [ "e", "lr", [ ] ]
#32 Mr. Spell. otherw r = MOOList [ "", "", [ "otherworld", "otherwise" ] ]
#32 Mr. Spell. diplomat r = MOOList [ "", "", [ "diplomatic", "diplomat" ] ]
#32 Mr. Spell. crou r = MOOList [ "", "", [ "croupier", "crouch" ] ]
#32 Mr. Spell. crot r = MOOList [ "ch", "", [ "crotchety", "crotch" ] ]
#32 Mr. Spell. cand r = MOOList [ "", "eil", [ "candy" ] ]
#32 Mr. Spell. automo r = MOOList [ "", "", [ "automotive", "automorphism", "automobile" ] ]
#32 Mr. Spell. crow r = MOOList [ "", "b", [ "crown", "Crowley", "crowfoot", "crowd", "crow" ] ]
#32 Mr. Spell. virtuos r = MOOList [ "", "i", [ "virtuoso" ] ]
#32 Mr. Spell. cank r = MOOList [ "er", "", [ "cankerworm", "canker" ] ]
#32 Mr. Spell. strea r = MOOList [ "", "m", [ "streak" ] ]
#32 Mr. Spell. virgin r = MOOList [ "", "i", [ "virginal", "virgin" ] ]
#32 Mr. Spell. mole r = MOOList [ "", "c", [ "molest", "molehill", "mole" ] ]
#32 Mr. Spell. cann r = MOOList [ "", "aeio", [ "canny" ] ]
#32 Mr. Spell. mange r = MOOList [ "", "", [ "mangel", "mange" ] ]
#32 Mr. Spell. exud r = MOOList [ "", "", [ "exude", "exudate" ] ]
#32 Mr. Spell. croa r = MOOList [ "", "", [ "Croatia", "croak" ] ]
#32 Mr. Spell. camp r = MOOList [ "", "a", [ "campus", "campsite", "campion", "campground", "campfire", "Campbell", "camp" ] ]
#32 Mr. Spell. orche r = MOOList [ "stra", "", [ "orchestrate", "orchestral", "orchestra" ] ]
#32 Mr. Spell. kne r = MOOList [ "", "e", [ "knew", "knelt", "knead" ] ]
#32 Mr. Spell. croc r = MOOList [ "", "ko", [ "crocus", "crochet" ] ]
#32 Mr. Spell. alia r = MOOList [ "", "s", [ "alia" ] ]
#32 Mr. Spell. bold r = MOOList [ "", "", [ "boldface", "bold" ] ]
#32 Mr. Spell. dure r = MOOList [ "", "", [ "duress", "Durer" ] ]
#32 Mr. Spell. stree r = MOOList [ "t", "", [ "streets", "streetcar", "street" ] ]
#32 Mr. Spell. bole r = MOOList [ "", "", [ "boletus", "bole" ] ]
#32 Mr. Spell. automa r = MOOList [ "t", "i", [ "automaton", "automate", "automata", "automat" ] ]
#32 Mr. Spell. alie r = MOOList [ "n", "", [ "alienate", "alien" ] ]
#32 Mr. Spell. exul r = MOOList [ "t", "a", [ "exult" ] ]
#32 Mr. Spell. stres r = MOOList [ "s", "", [ "stressful", "stress" ] ]
#32 Mr. Spell. alig r = MOOList [ "", "", [ "align", "alight" ] ]
#32 Mr. Spell. strep r = MOOList [ "to", "", [ "streptomycin", "streptococcus" ] ]
#32 Mr. Spell. stren r = MOOList [ "", "g", [ "strenuous" ] ]
#32 Mr. Spell. kno r = MOOList [ "", "bctwx", [ "knoll" ] ]
#32 Mr. Spell. name r = MOOList [ "", "s", [ "named", "nameplate", "nameable", "name" ] ]
#32 Mr. Spell. croo r = MOOList [ "", "", [ "croon", "crook" ] ]
#32 Mr. Spell. cron r = MOOList [ "", "", [ "crony", "crone" ] ]
#32 Mr. Spell. finishe r = MOOList [ "", "", [ "finishes", "finished" ] ]
#32 Mr. Spell. reciproca r = MOOList [ "", "", [ "reciprocate", "reciprocal" ] ]
#32 Mr. Spell. extr r = MOOList [ "", "aeiou", [ ] ]
#32 Mr. Spell. Stam r = MOOList [ "", "ip", [ "stammer", "Stamford", "stamen" ] ]
#32 Mr. Spell. came r = MOOList [ "", "lr", [ "cameo", "came" ] ]
#32 Mr. Spell. Ili r = MOOList [ "a", "", [ "Iliad", "iliac" ] ]
#32 Mr. Spell. Staf r = MOOList [ "f", "", [ "Stafford", "staff" ] ]
#32 Mr. Spell. vide r = MOOList [ "", "o", [ "vide" ] ]
#32 Mr. Spell. superst r = MOOList [ "itio", "", [ "superstitious", "superstition" ] ]
#32 Mr. Spell. stabl r = MOOList [ "e", "m", [ "stable" ] ]
#32 Mr. Spell. kod r = MOOList [ "", "a", [ "Kodiak" ] ]
#32 Mr. Spell. calo r = MOOList [ "ri", "", [ "calorimeter", "calorie", "caloric" ] ]
#32 Mr. Spell. ortho r = MOOList [ "", "dgp", [ "orthorhombic", "orthonormal", "orthoclase" ] ]
#32 Mr. Spell. exte r = MOOList [ "", "mnr", [ ] ]
#32 Mr. Spell. calu r = MOOList [ "m", "n", [ "Calumet" ] ]
#32 Mr. Spell. denud r = MOOList [ "", "", [ "denude", "denudation" ] ]
#32 Mr. Spell. kol r = MOOList [ "", "", [ "kolkhoz", "kola" ] ]
#32 Mr. Spell. calv r = MOOList [ "", "e", [ "Calvin", "Calvary" ] ]
#32 Mr. Spell. exti r = MOOList [ "", "n", [ "extirpate" ] ]
#32 Mr. Spell. Manu r = MOOList [ "", "m", [ "manuscript", "manure", "manufacture", "Manuel", "manual" ] ]
#32 Mr. Spell. exto r = MOOList [ "", "l", [ "extort" ] ]
#32 Mr. Spell. relat r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. kidn r = MOOList [ "", "a", [ "kidney" ] ]
#32 Mr. Spell. Wolf r = MOOList [ "", "", [ "wolfish", "Wolfgang", "Wolff", "Wolfe", "wolf" ] ]
#32 Mr. Spell. vict r = MOOList [ "", "o", [ "victual", "victrola", "victim" ] ]
#32 Mr. Spell. Stat r = MOOList [ "", "eiu", [ "stator", "Statler" ] ]
#32 Mr. Spell. nostra r = MOOList [ "", "", [ "Nostrand", "Nostradamus" ] ]
#32 Mr. Spell. Lomb r = MOOList [ "", "a", [ "Lomb" ] ]
#32 Mr. Spell. Zod r = MOOList [ "iac", "", [ "zodiacal", "zodiac" ] ]
#32 Mr. Spell. mandr r = MOOList [ "", "", [ "mandrill", "mandrel", "mandrake" ] ]
#32 Mr. Spell. continu r = MOOList [ "", "aoei", [ "continuum" ] ]
#32 Mr. Spell. cala r = MOOList [ "", "m", [ "Calais" ] ]
#32 Mr. Spell. vici r = MOOList [ "", "n", [ "vicissitude", "vicious" ] ]
#32 Mr. Spell. appos r = MOOList [ "it", "", [ "apposition", "apposite" ] ]
#32 Mr. Spell. expir r = MOOList [ "", "", [ "expire", "expiration" ] ]
#32 Mr. Spell. calc r = MOOList [ "", "iu", [ "calcareous" ] ]
#32 Mr. Spell. Sacram r = MOOList [ "ent", "", [ "Sacramento", "sacrament" ] ]
#32 Mr. Spell. cale r = MOOList [ "", "n", [ "Caleb" ] ]
#32 Mr. Spell. cald r = MOOList [ "", "e", [ "Caldwell" ] ]
#32 Mr. Spell. calf r = MOOList [ "", "", [ "calfskin", "calf" ] ]
#32 Mr. Spell. cali r = MOOList [ "", "bfp", [ "calisthenic", "calico" ] ]
#32 Mr. Spell. vica r = MOOList [ "r", "", [ "vicarious", "vicar" ] ]
#32 Mr. Spell. kidd r = MOOList [ "", "", [ "kiddie", "Kidde" ] ]
#32 Mr. Spell. Borne r = MOOList [ "", "", [ "Borneo", "borne" ] ]
#32 Mr. Spell. vice r = MOOList [ "", "", [ "viceroy", "vice" ] ]
#32 Mr. Spell. call r = MOOList [ "", "ai", [ "calls", "called", "callus", "callous", "call" ] ]
#32 Mr. Spell. Inc r = MOOList [ "", "aeiloru", [ "inch", "Inc" ] ]
#32 Mr. Spell. Zor r = MOOList [ "", "o", [ "Zorn" ] ]
#32 Mr. Spell. contine r = MOOList [ "nt", "", [ "continental", "continent" ] ]
#32 Mr. Spell. knowl r = MOOList [ "", "e", [ "Knowlton" ] ]
#32 Mr. Spell. alga r = MOOList [ "", "e", [ "algal", "alga" ] ]
#32 Mr. Spell. vibr r = MOOList [ "a", "t", [ "vibrant" ] ]
#32 Mr. Spell. alge r = MOOList [ "", "br", [ "Algenib" ] ]
#32 Mr. Spell. mois r = MOOList [ "", "t", [ "Moiseyev" ] ]
#32 Mr. Spell. algi r = MOOList [ "", "", [ "alginate", "Algiers" ] ]
#32 Mr. Spell. dupl r = MOOList [ "", "i", [ "duplex" ] ]
#32 Mr. Spell. functiona r = MOOList [ "", "", [ "functional", "functionary" ] ]
#32 Mr. Spell. Balt r = MOOList [ "i", "m", [ "Baltic" ] ]
#32 Mr. Spell. George r = MOOList [ "", "", [ "Georgetown", "George" ] ]
#32 Mr. Spell. Mala r = MOOList [ "", "dry", [ "Malawi", "malaprop", "malaise", "Malagasy", "Malabar" ] ]
#32 Mr. Spell. waste r = MOOList [ "", "", [ "wastewater", "wasteland", "wasteful", "wastebasket", "waste" ] ]
#32 Mr. Spell. Malo r = MOOList [ "", "n", [ "malocclusion" ] ]
#32 Mr. Spell. naiv r = MOOList [ "e", "", [ "naivete", "naive" ] ]
#32 Mr. Spell. Bamb r = MOOList [ "", "", [ "bamboo", "Bambi", "Bamberger" ] ]
#32 Mr. Spell. expia r = MOOList [ "", "", [ "expiate", "expiable" ] ]
#32 Mr. Spell. tomog r = MOOList [ "raph", "", [ "tomography", "tomograph" ] ]
#32 Mr. Spell. Malt r = MOOList [ "", "o", [ "maltreat", "Maltese", "Malta", "malt" ] ]
#32 Mr. Spell. providen r = MOOList [ "t", "", [ "providential", "provident" ] ]
#32 Mr. Spell. appoi r = MOOList [ "nt", "e", [ "appoint" ] ]
#32 Mr. Spell. extolle r = MOOList [ "", "", [ "extoller", "extolled" ] ]
#32 Mr. Spell. stagn r = MOOList [ "a", "", [ "stagnate", "stagnant" ] ]
#32 Mr. Spell. alder r = MOOList [ "", "m", [ "alder" ] ]
#32 Mr. Spell. relea r = MOOList [ "s", "", [ "release", "releasable" ] ]
#32 Mr. Spell. forgett r = MOOList [ "", "", [ "forgetting", "forgettable" ] ]
#32 Mr. Spell. strid r = MOOList [ "e", "", [ "strident", "stride" ] ]
#32 Mr. Spell. palli r = MOOList [ "", "", [ "pallid", "palliate" ] ]
#32 Mr. Spell. ammonia r = MOOList [ "", "", [ "ammoniac", "ammonia" ] ]
#32 Mr. Spell. Loin r = MOOList [ "", "", [ "loincloth", "loin" ] ]
#32 Mr. Spell. strin r = MOOList [ "g", "", [ "strings", "stringy", "stringent", "string" ] ]
#32 Mr. Spell. appre r = MOOList [ "", "ch", [ "apprentice" ] ]
#32 Mr. Spell. dragon r = MOOList [ "", "", [ "dragonhead", "dragonfly", "dragon" ] ]
#32 Mr. Spell. methan r = MOOList [ "", "", [ "methanol", "methane" ] ]
#32 Mr. Spell. dunc r = MOOList [ "", "", [ "dunce", "Duncan" ] ]
#32 Mr. Spell. strik r = MOOList [ "e", "", [ "strikebreak", "strike" ] ]
#32 Mr. Spell. egot r = MOOList [ "is", "", [ "egotist", "egotism" ] ]
#32 Mr. Spell. appra r = MOOList [ "is", "", [ "appraise", "appraisal" ] ]
#32 Mr. Spell. striv r = MOOList [ "e", "", [ "striven", "strive" ] ]
#32 Mr. Spell. dung r = MOOList [ "", "", [ "dungeon", "dung" ] ]
#32 Mr. Spell. appro r = MOOList [ "", "pvx", [ "approbation", "approach" ] ]
#32 Mr. Spell. Balk r = MOOList [ "", "", [ "balky", "Balkan", "balk" ] ]
#32 Mr. Spell. strip r = MOOList [ "", "", [ "stripy", "striptease", "stripe", "strip" ] ]
#32 Mr. Spell. Bali r = MOOList [ "", "", [ "Balinese", "Bali" ] ]
#32 Mr. Spell. expo r = MOOList [ "", "nrs", [ "expound" ] ]
#32 Mr. Spell. polygo r = MOOList [ "n", "", [ "polygonal", "polygon" ] ]
#32 Mr. Spell. emphy r = MOOList [ "sema", "", [ "emphysematous", "emphysema" ] ]
#32 Mr. Spell. expr r = MOOList [ "", "e", [ "expropriate" ] ]
#32 Mr. Spell. aldr r = MOOList [ "i", "", [ "aldrin", "Aldrich" ] ]
#32 Mr. Spell. expu r = MOOList [ "", "", [ "expurgate", "expunge", "expulsion" ] ]
#32 Mr. Spell. bestir r = MOOList [ "", "", [ "bestirring", "bestir" ] ]
#32 Mr. Spell. pyrox r = MOOList [ "en", "", [ "pyroxenite", "pyroxene" ] ]
#32 Mr. Spell. bloods r = MOOList [ "", "ht", [ ] ]
#32 Mr. Spell. dumb r = MOOList [ "", "", [ "dumbbell", "dumb" ] ]
#32 Mr. Spell. expa r = MOOList [ "", "n", [ "expatiate" ] ]
#32 Mr. Spell. pyrol r = MOOList [ "ys", "", [ "pyrolysis", "pyrolyse" ] ]
#32 Mr. Spell. expe r = MOOList [ "", "cdlnr", [ ] ]
#32 Mr. Spell. boge r = MOOList [ "y", "", [ "bogeymen", "bogey" ] ]
#32 Mr. Spell. stage r = MOOList [ "", "", [ "stagestruck", "stagecoach", "stage" ] ]
#32 Mr. Spell. Bake r = MOOList [ "", "r", [ "Bakelite", "bake" ] ]
#32 Mr. Spell. empha r = MOOList [ "", "s", [ "emphatic" ] ]
#32 Mr. Spell. bogg r = MOOList [ "", "", [ "boggy", "boggle", "bogging" ] ]
#32 Mr. Spell. expl r = MOOList [ "", "aio", [ "expletive" ] ]
#32 Mr. Spell. expi r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. manda r = MOOList [ "", "t", [ "mandarin", "mandamus" ] ]
#32 Mr. Spell. phon r = MOOList [ "", "eo", [ "phony", "phonic", "phon" ] ]
#32 Mr. Spell. chorda r = MOOList [ "", "t", [ "chordal" ] ]
#32 Mr. Spell. wardr r = MOOList [ "o", "", [ "wardroom", "wardrobe" ] ]
#32 Mr. Spell. Creta r = MOOList [ "", "", [ "Cretan", "Cretaceous" ] ]
#32 Mr. Spell. amel r = MOOList [ "i", "", [ "ameliorate", "Amelia" ] ]
#32 Mr. Spell. dema r = MOOList [ "", "grn", [ ] ]
#32 Mr. Spell. amen r = MOOList [ "", "d", [ "amen" ] ]
#32 Mr. Spell. Buddh r = MOOList [ "", "i", [ "Buddha" ] ]
#32 Mr. Spell. psychia r = MOOList [ "tr", "i", [ "psychiatry" ] ]
#32 Mr. Spell. McLe r = MOOList [ "", "", [ "McLeod", "McLean" ] ]
#32 Mr. Spell. deme r = MOOList [ "", "n", [ "demerit", "demean" ] ]
#32 Mr. Spell. phot r = MOOList [ "o", "gl", [ "photon", "photometry", "photo" ] ]
#32 Mr. Spell. kud r = MOOList [ "", "", [ "kudzu", "kudo" ] ]
#32 Mr. Spell. phos r = MOOList [ "", "p", [ "phosgene" ] ]
#32 Mr. Spell. amet r = MOOList [ "hyst", "", [ "amethystine", "amethyst" ] ]
#32 Mr. Spell. demi r = MOOList [ "", "st", [ "demijohn", "demigod" ] ]
#32 Mr. Spell. Edmond r = MOOList [ "s", "", [ "Edmondson", "Edmonds" ] ]
#32 Mr. Spell. compara r = MOOList [ "t", "", [ "comparator", "comparative" ] ]
#32 Mr. Spell. calami r = MOOList [ "t", "", [ "calamity", "calamitous" ] ]
#32 Mr. Spell. extensi r = MOOList [ "", "", [ "extensive", "extension", "extensible" ] ]
#32 Mr. Spell. Ire r = MOOList [ "", "", [ "Irene", "Ireland", "ire" ] ]
#32 Mr. Spell. Ira r = MOOList [ "", "", [ "irate", "Iraq", "Iran", "Ira" ] ]
#32 Mr. Spell. delt r = MOOList [ "", "", [ "deltoid", "delta" ] ]
#32 Mr. Spell. delu r = MOOList [ "", "s", [ "deluxe", "deluge", "delude" ] ]
#32 Mr. Spell. Liverp r = MOOList [ "", "", [ "Liverpudlian", "Liverpool" ] ]
#32 Mr. Spell. Irv r = MOOList [ "in", "", [ "Irving", "Irvine", "Irvin" ] ]
#32 Mr. Spell. concil r = MOOList [ "iat", "", [ "conciliatory", "conciliate" ] ]
#32 Mr. Spell. Alexandr r = MOOList [ "", "", [ "Alexandria", "Alexandre", "Alexandra" ] ]
#32 Mr. Spell. controvers r = MOOList [ "", "", [ "controversy", "controversial" ] ]
#32 Mr. Spell. locati r = MOOList [ "", "o", [ "locating" ] ]
#32 Mr. Spell. dele r = MOOList [ "", "cgt", [ ] ]
#32 Mr. Spell. Singa r = MOOList [ "", "", [ "Singapore", "singable" ] ]
#32 Mr. Spell. concis r = MOOList [ "", "", [ "concision", "concise" ] ]
#32 Mr. Spell. locate r = MOOList [ "", "", [ "located", "locate" ] ]
#32 Mr. Spell. deli r = MOOList [ "", "cgmnqrvb", [ "Delilah", "Delia" ] ]
#32 Mr. Spell. bitte r = MOOList [ "", "r", [ "bitten" ] ]
#32 Mr. Spell. McKi r = MOOList [ "n", "", [ "McKinney", "McKinley" ] ]
#32 Mr. Spell. Arabi r = MOOList [ "", "", [ "Arabic", "Arabia" ] ]
#32 Mr. Spell. McKe r = MOOList [ "", "n", [ "McKesson", "McKeon", "McKee" ] ]
#32 Mr. Spell. remini r = MOOList [ "sce", "", [ "reminiscent", "reminisce" ] ]
#32 Mr. Spell. Isa r = MOOList [ "", "ab", [ "Isaiah", "Isadore" ] ]
#32 Mr. Spell. arcta r = MOOList [ "n", "", [ "arctangent", "arctan" ] ]
#32 Mr. Spell. wareh r = MOOList [ "ouse", "", [ "warehouseman", "warehouse" ] ]
#32 Mr. Spell. Scyt r = MOOList [ "h", "", [ "Scythia", "scythe" ] ]
#32 Mr. Spell. Ist r = MOOList [ "", "", [ "Istvan", "Istanbul" ] ]
#32 Mr. Spell. Isr r = MOOList [ "ael", "i", [ "Israel" ] ]
#32 Mr. Spell. trump r = MOOList [ "", "e", [ "trump" ] ]
#32 Mr. Spell. Cauca r = MOOList [ "s", "", [ "Caucasus", "Caucasian" ] ]
#32 Mr. Spell. Isl r = MOOList [ "", "a", [ "isle" ] ]
#32 Mr. Spell. councilw r = MOOList [ "om", "", [ "councilwomen", "councilwoman" ] ]
#32 Mr. Spell. Nell r = MOOList [ "", "", [ "Nellie", "Nell" ] ]
#32 Mr. Spell. councilm r = MOOList [ "", "", [ "councilmen", "councilman" ] ]
#32 Mr. Spell. Nels r = MOOList [ "", "", [ "Nelson", "Nelsen" ] ]
#32 Mr. Spell. Evere r = MOOList [ "", "", [ "Everett", "Eveready" ] ]
#32 Mr. Spell. Christia r = MOOList [ "n", "", [ "Christianson", "Christiana", "Christian" ] ]
#32 Mr. Spell. transce r = MOOList [ "", "n", [ "transceiver" ] ]
#32 Mr. Spell. ambi r = MOOList [ "", "gt", [ "ambivalent", "ambient", "ambidextrous", "ambiance" ] ]
#32 Mr. Spell. ambl r = MOOList [ "", "", [ "ambling", "amble" ] ]
#32 Mr. Spell. Christin r = MOOList [ "", "", [ "Christine", "Christina" ] ]
#32 Mr. Spell. Ricke r = MOOList [ "t", "", [ "rickety", "Rickettsia", "rickets" ] ]
#32 Mr. Spell. squi r = MOOList [ "", "r", [ "squishy", "squint", "squill", "squid", "Squibb" ] ]
#32 Mr. Spell. ambr r = MOOList [ "os", "i", [ "ambrose" ] ]
#32 Mr. Spell. ambu r = MOOList [ "", "ls", [ ] ]
#32 Mr. Spell. accordi r = MOOList [ "", "", [ "according", "accordion" ] ]
#32 Mr. Spell. squa r = MOOList [ "", "dlstw", [ "square", "squander", "squamous", "squabble" ] ]
#32 Mr. Spell. mallo r = MOOList [ "", "", [ "mallow", "Mallory" ] ]
#32 Mr. Spell. filth r = MOOList [ "", "", [ "filthy", "filth" ] ]
#32 Mr. Spell. Cela r = MOOList [ "n", "", [ "Celanese", "celandine" ] ]
#32 Mr. Spell. sque r = MOOList [ "", "ae", [ "squelch" ] ]
#32 Mr. Spell. choreo r = MOOList [ "graph", "", [ "choreography", "choreograph" ] ]
#32 Mr. Spell. malle r = MOOList [ "", "", [ "mallet", "malleable" ] ]
#32 Mr. Spell. transcr r = MOOList [ "i", "p", [ "transcribe" ] ]
#32 Mr. Spell. transco r = MOOList [ "n", "", [ "transcontinental", "transconductance" ] ]
#32 Mr. Spell. dispel r = MOOList [ "", "l", [ "dispel" ] ]
#32 Mr. Spell. compani r = MOOList [ "", "o", [ "companies" ] ]
#32 Mr. Spell. dispen r = MOOList [ "s", "a", [ "dispense" ] ]
#32 Mr. Spell. McGr r = MOOList [ "", "a", [ "McGregor" ] ]
#32 Mr. Spell. disper r = MOOList [ "s", "i", [ "disperse", "dispersal" ] ]
#32 Mr. Spell. amal r = MOOList [ "gam", "", [ "amalgamate", "amalgam" ] ]
#32 Mr. Spell. aman r = MOOList [ "", "", [ "amanuensis", "amanita" ] ]
#32 Mr. Spell. depressi r = MOOList [ "", "", [ "depressive", "depression", "depressible" ] ]
#32 Mr. Spell. conclu r = MOOList [ "", "s", [ "conclude" ] ]
#32 Mr. Spell. forbidd r = MOOList [ "", "", [ "forbidding", "forbidden" ] ]
#32 Mr. Spell. amat r = MOOList [ "", "e", [ "amatory" ] ]
#32 Mr. Spell. Styr r = MOOList [ "", "", [ "Styrofoam", "styrene" ] ]
#32 Mr. Spell. venture r = MOOList [ "", "", [ "venturesome", "venture" ] ]
#32 Mr. Spell. Buddhi r = MOOList [ "s", "", [ "Buddhist", "Buddhism" ] ]
#32 Mr. Spell. malic r = MOOList [ "", "", [ "malicious", "malice" ] ]
#32 Mr. Spell. Iva r = MOOList [ "n", "", [ "Ivanhoe", "Ivan" ] ]
#32 Mr. Spell. malig r = MOOList [ "n", "", [ "malignant", "malign" ] ]
#32 Mr. Spell. pervas r = MOOList [ "i", "", [ "pervasive", "pervasion" ] ]
#32 Mr. Spell. toler r = MOOList [ "a", "", [ "tolerate", "tolerant", "tolerable" ] ]
#32 Mr. Spell. phoen r = MOOList [ "i", "", [ "phoenix", "Phoenicia" ] ]
#32 Mr. Spell. McGo r = MOOList [ "", "", [ "McGowan", "McGovern" ] ]
#32 Mr. Spell. critic r = MOOList [ "", "", [ "criticism", "critic" ] ]
#32 Mr. Spell. degr r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. degu r = MOOList [ "m", "", [ "degumming", "degum" ] ]
#32 Mr. Spell. trunc r = MOOList [ "ate", "", [ "truncated", "truncate" ] ]
#32 Mr. Spell. McGi r = MOOList [ "", "", [ "McGinnis", "McGill" ] ]
#32 Mr. Spell. Negr r = MOOList [ "o", "", [ "Negroid", "Negroes", "Negro" ] ]
#32 Mr. Spell. malfo r = MOOList [ "rm", "", [ "malformed", "malformation" ] ]
#32 Mr. Spell. dega r = MOOList [ "s", "", [ "degassing", "degas" ] ]
#32 Mr. Spell. dege r = MOOList [ "nera", "", [ "degenerate", "degeneracy" ] ]
#32 Mr. Spell. defe r = MOOList [ "", "cnr", [ "defeat" ] ]
#32 Mr. Spell. Sylva r = MOOList [ "n", "", [ "Sylvania", "sylvan" ] ]
#32 Mr. Spell. defi r = MOOList [ "", "cn", [ "defiant" ] ]
#32 Mr. Spell. gnom r = MOOList [ "", "o", [ "gnome" ] ]
#32 Mr. Spell. defl r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. defo r = MOOList [ "", "r", [ "defocus" ] ]
#32 Mr. Spell. defr r = MOOList [ "", "a", [ "defrost" ] ]
#32 Mr. Spell. silico r = MOOList [ "n", "", [ "silicone", "silicon" ] ]
#32 Mr. Spell. concor r = MOOList [ "d", "", [ "concordant", "concord" ] ]
#32 Mr. Spell. silici r = MOOList [ "", "", [ "silicide", "silicic" ] ]
#32 Mr. Spell. McDo r = MOOList [ "", "n", [ "McDowell", "McDougall" ] ]
#32 Mr. Spell. confiscat r = MOOList [ "", "", [ "confiscatory", "confiscate" ] ]
#32 Mr. Spell. Stut r = MOOList [ "t", "", [ "Stuttgart", "stutter" ] ]
#32 Mr. Spell. defa r = MOOList [ "", "u", [ "deface" ] ]
#32 Mr. Spell. silica r = MOOList [ "", "", [ "silicate", "silica" ] ]
#32 Mr. Spell. remitt r = MOOList [ "", "", [ "remitting", "remitted", "remittance" ] ]
#32 Mr. Spell. deep r = MOOList [ "", "", [ "deepen", "deep" ] ]
#32 Mr. Spell. phosp r = MOOList [ "h", "io", [ "phosphate" ] ]
#32 Mr. Spell. over r = MOOList [ "", "t", [ "overview", "over" ] ]
#32 Mr. Spell. dedu r = MOOList [ "c", "t", [ "deducible", "deduce" ] ]
#32 Mr. Spell. McCo r = MOOList [ "", "n", [ "McCoy", "McCormick" ] ]
#32 Mr. Spell. contra r = MOOList [ "", "bcdlrv", [ "contrast", "contraption" ] ]
#32 Mr. Spell. oven r = MOOList [ "", "", [ "ovenbird", "oven" ] ]
#32 Mr. Spell. contro r = MOOList [ "", "lv", [ ] ]
#32 Mr. Spell. contri r = MOOList [ "", "btv", [ ] ]
#32 Mr. Spell. triangu r = MOOList [ "l", "a", [ "Triangulum" ] ]
#32 Mr. Spell. Christop r = MOOList [ "h", "", [ "Christopher", "Christoph" ] ]
#32 Mr. Spell. commiss r = MOOList [ "", "a", [ "commission" ] ]
#32 Mr. Spell. Ingen r = MOOList [ "", "u", [ "ingenious" ] ]
#32 Mr. Spell. Stud r = MOOList [ "", "ei", [ "study", "stud" ] ]
#32 Mr. Spell. errant r = MOOList [ "", "", [ "errantry", "errant" ] ]
#32 Mr. Spell. celebra r = MOOList [ "", "", [ "celebrate", "celebrant" ] ]
#32 Mr. Spell. decr r = MOOList [ "", "ey", [ ] ]
#32 Mr. Spell. embroid r = MOOList [ "er", "", [ "embroidery", "embroider" ] ]
#32 Mr. Spell. bridgew r = MOOList [ "", "", [ "bridgework", "Bridgewater" ] ]
#32 Mr. Spell. alderm r = MOOList [ "", "", [ "aldermen", "alderman" ] ]
#32 Mr. Spell. amend r = MOOList [ "", "", [ "amende", "amend" ] ]
#32 Mr. Spell. dece r = MOOList [ "", "inp", [ "decertify", "December", "decelerate", "decedent", "decease" ] ]
#32 Mr. Spell. McCa r = MOOList [ "", "lr", [ "McCauley", "McCann", "McCabe" ] ]
#32 Mr. Spell. inequi r = MOOList [ "", "t", [ "inequivalent" ] ]
#32 Mr. Spell. precis r = MOOList [ "", "", [ "precision", "precise" ] ]
#32 Mr. Spell. phen r = MOOList [ "", "oy", [ ] ]
#32 Mr. Spell. deci r = MOOList [ "", "dms", [ "decipher", "decile", "decibel" ] ]
#32 Mr. Spell. committ r = MOOList [ "", "ae", [ "committing" ] ]
#32 Mr. Spell. ninet r = MOOList [ "", "e", [ "ninety", "ninetieth" ] ]
#32 Mr. Spell. McCl r = MOOList [ "", "u", [ "McClellan", "McClain" ] ]
#32 Mr. Spell. hobby r = MOOList [ "", "", [ "hobbyhorse", "hobby" ] ]
#32 Mr. Spell. precip r = MOOList [ "i", "t", [ "precipice" ] ]
#32 Mr. Spell. decl r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. vivi r = MOOList [ "", "", [ "vivify", "vivid", "Vivian" ] ]
#32 Mr. Spell. deco r = MOOList [ "", "lmnr", [ "decouple", "decode" ] ]
#32 Mr. Spell. debr r = MOOList [ "", "i", [ "Debra" ] ]
#32 Mr. Spell. debt r = MOOList [ "", "", [ "debtor", "debt" ] ]
#32 Mr. Spell. Pollut r = MOOList [ "", "", [ "pollution", "pollute", "pollutant" ] ]
#32 Mr. Spell. debu r = MOOList [ "", "gt", [ "Debussy", "debunk" ] ]
#32 Mr. Spell. deca r = MOOList [ "", "dt", [ "decay", "decant", "decal" ] ]
#32 Mr. Spell. subsi r = MOOList [ "", "ds", [ ] ]
#32 Mr. Spell. deman r = MOOList [ "d", "", [ "demands", "demand" ] ]
#32 Mr. Spell. orato r = MOOList [ "r", "i", [ "oratory" ] ]
#32 Mr. Spell. demar r = MOOList [ "", "", [ "demark", "demarcate" ] ]
#32 Mr. Spell. impassi r = MOOList [ "", "", [ "impassive", "impassion" ] ]
#32 Mr. Spell. demag r = MOOList [ "", "", [ "demagogue", "demagnify" ] ]
#32 Mr. Spell. debi r = MOOList [ "", "l", [ "debit" ] ]
#32 Mr. Spell. taste r = MOOList [ "", "", [ "tasteful", "taste" ] ]
#32 Mr. Spell. lag r = MOOList [ "", "or", [ "Laguerre", "lagging", "lager", "lag" ] ]
#32 Mr. Spell. politi r = MOOList [ "c", "", [ "politics", "political", "politico", "politicking", "politician", "politic" ] ]
#32 Mr. Spell. deat r = MOOList [ "h", "", [ "deathward", "deathbed", "death" ] ]
#32 Mr. Spell. fledg r = MOOList [ "", "", [ "fledgling", "fledge" ] ]
#32 Mr. Spell. icos r = MOOList [ "ahedr", "a", [ "icosahedron" ] ]
#32 Mr. Spell. Ceci r = MOOList [ "l", "", [ "Cecilia", "Cecil" ] ]
#32 Mr. Spell. vitr r = MOOList [ "", "i", [ "vitro", "vitreous" ] ]
#32 Mr. Spell. lap r = MOOList [ "", "e", [ "lapse", "lappet", "Laplace", "lapidary", "lap" ] ]
#32 Mr. Spell. bureauc r = MOOList [ "ra", "t", [ "bureaucracy" ] ]
#32 Mr. Spell. lar r = MOOList [ "", "cegksvy", [ "Larry", "lariat", "lard", "Laramie" ] ]
#32 Mr. Spell. icon r = MOOList [ "", "o", [ "icon" ] ]
#32 Mr. Spell. las r = MOOList [ "", "cs", [ "Laszlo", "last", "lash", "lase" ] ]
#32 Mr. Spell. lat r = MOOList [ "", "ehit", [ "Latvia", "latus", "Latrobe", "latch" ] ]
#32 Mr. Spell. eyes r = MOOList [ "", "", [ "eyes", "eyesight" ] ]
#32 Mr. Spell. deac r = MOOList [ "", "o", [ "deactivate" ] ]
#32 Mr. Spell. dead r = MOOList [ "", "l", [ "deadwood", "deadhead", "deaden", "dead" ] ]
#32 Mr. Spell. deaf r = MOOList [ "", "", [ "deafen", "deaf" ] ]
#32 Mr. Spell. vita r = MOOList [ "", "", [ "vitamin", "vital", "vitae", "vita" ] ]
#32 Mr. Spell. malto r = MOOList [ "", "", [ "maltose", "Malton" ] ]
#32 Mr. Spell. deal r = MOOList [ "", "", [ "deals", "dealt", "deallocate", "deal" ] ]
#32 Mr. Spell. lac r = MOOList [ "", "ektu", [ "lacy", "lacrosse", "lacquer", "laconic", "Lachesis", "lac" ] ]
#32 Mr. Spell. architectu r = MOOList [ "r", "", [ "architecture", "architectural" ] ]
#32 Mr. Spell. lad r = MOOList [ "", "y", [ "ladle", "laden", "lad" ] ]
#32 Mr. Spell. townsm r = MOOList [ "", "", [ "townsmen", "townsman" ] ]
#32 Mr. Spell. eyeb r = MOOList [ "", "r", [ "eyeball" ] ]
#32 Mr. Spell. neate r = MOOList [ "", "", [ "neatest", "neater" ] ]
#32 Mr. Spell. vivaci r = MOOList [ "", "", [ "vivacity", "vivacious" ] ]
#32 Mr. Spell. borderl r = MOOList [ "", "", [ "borderline", "borderland" ] ]
#32 Mr. Spell. Trash r = MOOList [ "", "", [ "trashy", "trash" ] ]
#32 Mr. Spell. eyel r = MOOList [ "", "", [ "eyelid", "eyelet", "eyelash" ] ]
#32 Mr. Spell. Richa r = MOOList [ "rd", "", [ "Richardson", "Richard" ] ]
#32 Mr. Spell. kitt r = MOOList [ "", "e", [ "kitty", "kittle" ] ]
#32 Mr. Spell. lau r = MOOList [ "", "dgnr", [ "Lausanne", "Laue" ] ]
#32 Mr. Spell. lav r = MOOList [ "", "a", [ "Lavoisier", "lavish", "lavender" ] ]
#32 Mr. Spell. law r = MOOList [ "", "bgmrs", [ "lawyer", "lawn", "lawful", "law" ] ]
#32 Mr. Spell. lax r = MOOList [ "", "", [ "laxative", "lax" ] ]
#32 Mr. Spell. lay r = MOOList [ "", "mo", [ "layup", "Layton", "layette", "lay" ] ]
#32 Mr. Spell. laz r = MOOList [ "", "y", [ "laze", "Lazarus" ] ]
#32 Mr. Spell. kitc r = MOOList [ "hen", "", [ "kitchenette", "kitchen" ] ]
#32 Mr. Spell. concur r = MOOList [ "", "r", [ "concur" ] ]
#32 Mr. Spell. visc r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. visa r = MOOList [ "", "", [ "visage", "visa" ] ]
#32 Mr. Spell. subsu r = MOOList [ "m", "e", [ "subsuming" ] ]
#32 Mr. Spell. Since r = MOOList [ "", "r", [ "since" ] ]
#32 Mr. Spell. aberr r = MOOList [ "a", "", [ "aberrate", "aberrant" ] ]
#32 Mr. Spell. subst r = MOOList [ "", "ai", [ "substrate" ] ]
#32 Mr. Spell. Annale r = MOOList [ "", "", [ "Annalen", "Annale" ] ]
#32 Mr. Spell. viru r = MOOList [ "", "", [ "virus", "virulent" ] ]
#32 Mr. Spell. phono r = MOOList [ "", "", [ "phonon", "phonology", "phonograph" ] ]
#32 Mr. Spell. virt r = MOOList [ "u", "o", [ "virtue", "virtual" ] ]
#32 Mr. Spell. vesti r = MOOList [ "", "g", [ "vestibule" ] ]
#32 Mr. Spell. virg r = MOOList [ "", "i", [ "virgule", "Virgo" ] ]
#32 Mr. Spell. phan r = MOOList [ "t", "", [ "phantom", "phantasy" ] ]
#32 Mr. Spell. phal r = MOOList [ "a", "n", [ "phalarope" ] ]
#32 Mr. Spell. subte r = MOOList [ "r", "", [ "subterranean", "subterfuge" ] ]
#32 Mr. Spell. snobb r = MOOList [ "", "", [ "snobbish", "snobbery" ] ]
#32 Mr. Spell. subtr r = MOOList [ "a", "", [ "subtrahend", "subtracter" ] ]
#32 Mr. Spell. phone r = MOOList [ "", "m", [ "phonetic", "phone" ] ]
#32 Mr. Spell. circul r = MOOList [ "a", "t", [ "circular", "circulant" ] ]
#32 Mr. Spell. circum r = MOOList [ "", "cfsv", [ "circumpolar", "circumlocution" ] ]
#32 Mr. Spell. subtl r = MOOList [ "", "e", [ "subtly" ] ]
#32 Mr. Spell. phar r = MOOList [ "mac", "o", [ "pharmacy", "pharmacist", "pharmaceutic" ] ]
#32 Mr. Spell. Chica r = MOOList [ "", "gn", [ ] ]
#32 Mr. Spell. circui r = MOOList [ "t", "", [ "circuitry", "circuitous", "circuit" ] ]
#32 Mr. Spell. transfi r = MOOList [ "", "", [ "transfix", "transfinite" ] ]
#32 Mr. Spell. sedit r = MOOList [ "io", "", [ "seditious", "sedition" ] ]
#32 Mr. Spell. osteopa r = MOOList [ "th", "", [ "osteopathy", "osteopathic", "osteopath" ] ]
#32 Mr. Spell. boyc r = MOOList [ "", "", [ "boycott", "Boyce" ] ]
#32 Mr. Spell. alva r = MOOList [ "", "", [ "Alvarez", "Alva" ] ]
#32 Mr. Spell. Spart r = MOOList [ "a", "", [ "Spartan", "Sparta" ] ]
#32 Mr. Spell. sedim r = MOOList [ "ent", "a", [ "sediment" ] ]
#32 Mr. Spell. phag r = MOOList [ "", "", [ "phagocyte", "phage" ] ]
#32 Mr. Spell. alve r = MOOList [ "ol", "", [ "alveolus", "alveoli", "alveolar" ] ]
#32 Mr. Spell. transfe r = MOOList [ "r", "er", [ "transferor", "transferable", "transfer" ] ]
#32 Mr. Spell. potat r = MOOList [ "o", "", [ "potatoes", "potato" ] ]
#32 Mr. Spell. alum r = MOOList [ "", "in", [ "alum" ] ]
#32 Mr. Spell. piani r = MOOList [ "s", "", [ "pianist", "pianissimo" ] ]
#32 Mr. Spell. Jap r = MOOList [ "an", "", [ "Japanese", "Japan" ] ]
#32 Mr. Spell. Stok r = MOOList [ "e", "", [ "Stokes", "stoke" ] ]
#32 Mr. Spell. Jan r = MOOList [ "", "eiu", [ "Jansenist", "Janos", "jangle", "Jan" ] ]
#32 Mr. Spell. Jam r = MOOList [ "", "e", [ "jamboree", "Jamaica", "jam" ] ]
#32 Mr. Spell. transfo r = MOOList [ "rm", "", [ "transformation", "transform" ] ]
#32 Mr. Spell. transfu r = MOOList [ "s", "", [ "transfusion", "transfuse", "transfusable" ] ]
#32 Mr. Spell. Jai r = MOOList [ "", "", [ "Jaime", "jail" ] ]
#32 Mr. Spell. combina r = MOOList [ "t", "o", [ "combinate" ] ]
#32 Mr. Spell. potas r = MOOList [ "", "", [ "potassium", "potash" ] ]
#32 Mr. Spell. demen r = MOOList [ "t", "", [ "dementia", "demented" ] ]
#32 Mr. Spell. anthra r = MOOList [ "c", "", [ "anthracnose", "anthracite" ] ]
#32 Mr. Spell. fortun r = MOOList [ "", "", [ "fortune", "fortunate" ] ]
#32 Mr. Spell. lem r = MOOList [ "", "mo", [ "Lemuel" ] ]
#32 Mr. Spell. abett r = MOOList [ "", "", [ "abetting", "abetted" ] ]
#32 Mr. Spell. tabul r = MOOList [ "a", "", [ "tabulate", "tabular", "tabula" ] ]
#32 Mr. Spell. lep r = MOOList [ "", "", [ "leprosy", "lepidolite", "leper" ] ]
#32 Mr. Spell. les r = MOOList [ "", "st", [ "Lesotho", "Leslie", "lesion", "Lesbian" ] ]
#32 Mr. Spell. latera r = MOOList [ "", "", [ "Lateran", "lateral", "latera" ] ]
#32 Mr. Spell. let r = MOOList [ "", "ht", [ "lets", "Letitia", "let" ] ]
#32 Mr. Spell. leu r = MOOList [ "", "", [ "leukemia", "leucine" ] ]
#32 Mr. Spell. lev r = MOOList [ "", "ei", [ "levy", "levulose", "Lev" ] ]
#32 Mr. Spell. lew r = MOOList [ "", "", [ "lewis", "lewd", "lew" ] ]
#32 Mr. Spell. lex r = MOOList [ "i", "c", [ "Lexington" ] ]
#32 Mr. Spell. anthro r = MOOList [ "po", "", [ "anthropomorphic", "anthropology", "anthropogenic" ] ]
#32 Mr. Spell. alti r = MOOList [ "", "", [ "altitude", "altimeter" ] ]
#32 Mr. Spell. bowm r = MOOList [ "", "", [ "bowmen", "bowman" ] ]
#32 Mr. Spell. bowl r = MOOList [ "", "", [ "bowline", "bowl" ] ]
#32 Mr. Spell. occurr r = MOOList [ "", "e", [ "occurring" ] ]
#32 Mr. Spell. alto r = MOOList [ "", "", [ "Alton", "altogether", "alto" ] ]
#32 Mr. Spell. altr r = MOOList [ "uis", "", [ "altruist", "altruism" ] ]
#32 Mr. Spell. lec r = MOOList [ "", "ht", [ ] ]
#32 Mr. Spell. administrat r = MOOList [ "", "", [ "administration", "administratrix", "administrate" ] ]
#32 Mr. Spell. led r = MOOList [ "", "", [ "ledge", "led" ] ]
#32 Mr. Spell. lee r = MOOList [ "", "rw", [ "Leeuwenhoek", "leek", "Leeds", "leech", "lee" ] ]
#32 Mr. Spell. janit r = MOOList [ "or", "", [ "janitorial", "janitor" ] ]
#32 Mr. Spell. lef r = MOOList [ "t", "", [ "lefty", "leftward", "leftover", "leftmost", "left" ] ]
#32 Mr. Spell. leg r = MOOList [ "", "aegiu", [ "leghorn", "leg" ] ]
#32 Mr. Spell. snowf r = MOOList [ "", "", [ "snowflake", "snowfall" ] ]
#32 Mr. Spell. occupa r = MOOList [ "", "", [ "occupation", "occupant" ] ]
#32 Mr. Spell. conforma r = MOOList [ "", "", [ "conformation", "conformance", "conformal" ] ]
#32 Mr. Spell. Sunn r = MOOList [ "y", "", [ "Sunnyvale", "sunny" ] ]
#32 Mr. Spell. Plei r = MOOList [ "", "", [ "Pleistocene", "Pleiades" ] ]
#32 Mr. Spell. bedimm r = MOOList [ "", "", [ "bedimming", "bedimmed" ] ]
#32 Mr. Spell. transpi r = MOOList [ "r", "", [ "transpire", "transpiration" ] ]
#32 Mr. Spell. Buttr r = MOOList [ "", "", [ "Buttrick", "buttress" ] ]
#32 Mr. Spell. transpo r = MOOList [ "", "rs", [ "transpond" ] ]
#32 Mr. Spell. Galva r = MOOList [ "n", "i", [ "galvanometer" ] ]
#32 Mr. Spell. tumb r = MOOList [ "", "", [ "tumbrel", "tumble" ] ]
#32 Mr. Spell. transpl r = MOOList [ "ant", "", [ "transplantation", "transplant" ] ]
#32 Mr. Spell. hail r = MOOList [ "", "s", [ "hail" ] ]
#32 Mr. Spell. invali r = MOOList [ "d", "", [ "invalidate", "invalid" ] ]
#32 Mr. Spell. other r = MOOList [ "", "w", [ "others", "other" ] ]
#32 Mr. Spell. Gait r = MOOList [ "", "", [ "Gaithersburg", "gait" ] ]
#32 Mr. Spell. Hung r = MOOList [ "", "a", [ "hungry", "hung" ] ]
#32 Mr. Spell. sagi r = MOOList [ "", "t", [ "Saginaw" ] ]
#32 Mr. Spell. transferr r = MOOList [ "", "", [ "transferring", "transferred", "transferral" ] ]
#32 Mr. Spell. Bever r = MOOList [ "", "", [ "Beverly", "beverage" ] ]
#32 Mr. Spell. attent r = MOOList [ "i", "", [ "attentive", "attention" ] ]
#32 Mr. Spell. inappro r = MOOList [ "", "", [ "inappropriate", "inapproachable" ] ]
#32 Mr. Spell. tula r = MOOList [ "", "", [ "tularemia", "Tulane" ] ]
#32 Mr. Spell. biblio r = MOOList [ "", "", [ "bibliophile", "bibliography" ] ]
#32 Mr. Spell. saga r = MOOList [ "", "c", [ "saga" ] ]
#32 Mr. Spell. slipp r = MOOList [ "", "", [ "slippery", "slippage" ] ]
#32 Mr. Spell. protecto r = MOOList [ "r", "", [ "protectorate", "protector" ] ]
#32 Mr. Spell. sage r = MOOList [ "", "", [ "sagebrush", "sage" ] ]
#32 Mr. Spell. Octav r = MOOList [ "", "", [ "Octavia", "octave" ] ]
#32 Mr. Spell. Hunt r = MOOList [ "", "", [ "Huntsville", "Huntley", "Huntington", "hunt" ] ]
#32 Mr. Spell. apprec r = MOOList [ "ia", "", [ "appreciate", "appreciable" ] ]
#32 Mr. Spell. Jef r = MOOList [ "f", "", [ "Jeffrey", "Jefferson", "Jeff" ] ]
#32 Mr. Spell. insigh r = MOOList [ "t", "", [ "insightful", "insight" ] ]
#32 Mr. Spell. hage r = MOOList [ "", "", [ "Hager", "Hagen" ] ]
#32 Mr. Spell. Humb r = MOOList [ "", "", [ "Humboldt", "humble" ] ]
#32 Mr. Spell. Sull r = MOOList [ "", "", [ "sully", "Sullivan", "sullen" ] ]
#32 Mr. Spell. Jea r = MOOList [ "", "ln", [ ] ]
#32 Mr. Spell. apocr r = MOOList [ "ypha", "", [ "apocryphal", "Apocrypha" ] ]
#32 Mr. Spell. hagg r = MOOList [ "", "", [ "haggle", "haggard" ] ]
#32 Mr. Spell. Elde r = MOOList [ "", "", [ "eldest", "elder" ] ]
#32 Mr. Spell. double r = MOOList [ "", "t", [ "doubleheader", "Doubleday", "double" ] ]
#32 Mr. Spell. Sume r = MOOList [ "ria", "", [ "Sumerian", "Sumeria" ] ]
#32 Mr. Spell. Dian r = MOOList [ "", "", [ "Dianne", "Diane", "Diana" ] ]
#32 Mr. Spell. safe r = MOOList [ "", "", [ "safely", "safety", "safekeeping", "safeguard", "safe" ] ]
#32 Mr. Spell. transfere r = MOOList [ "", "", [ "transference", "transferee" ] ]
#32 Mr. Spell. Jes r = MOOList [ "", "su", [ "jest" ] ]
#32 Mr. Spell. broad r = MOOList [ "", "", [ "Broadway", "broadside", "broadloom", "broaden", "broadcast", "broad" ] ]
#32 Mr. Spell. Jer r = MOOList [ "", "eko", [ "Jerusalem", "jersey", "jerry", "Jericho" ] ]
#32 Mr. Spell. debugge r = MOOList [ "", "", [ "debugger", "debugged" ] ]
#32 Mr. Spell. appreh r = MOOList [ "en", "s", [ "apprehend" ] ]
#32 Mr. Spell. Gain r = MOOList [ "", "e", [ "gainful", "gain" ] ]
#32 Mr. Spell. Suma r = MOOList [ "", "", [ "Sumatra", "sumac" ] ]
#32 Mr. Spell. Jen r = MOOList [ "", "n", [ "Jensen", "Jenkins" ] ]
#32 Mr. Spell. demit r = MOOList [ "", "t", [ "demit" ] ]
#32 Mr. Spell. attend r = MOOList [ "", "", [ "attendee", "attendant", "attend" ] ]
#32 Mr. Spell. swish r = MOOList [ "", "", [ "swishy", "swish" ] ]
#32 Mr. Spell. demis r = MOOList [ "", "", [ "demise", "demiscible" ] ]
#32 Mr. Spell. flam r = MOOList [ "", "", [ "flammable", "flamingo", "flame", "flamboyant", "flam" ] ]
#32 Mr. Spell. flak r = MOOList [ "", "", [ "flaky", "flake", "flak" ] ]
#32 Mr. Spell. lip r = MOOList [ "", "s", [ "Lipton", "Lippincott", "lipid", "lip" ] ]
#32 Mr. Spell. liq r = MOOList [ "u", "ei", [ "liquor" ] ]
#32 Mr. Spell. gods r = MOOList [ "", "", [ "godson", "godsend" ] ]
#32 Mr. Spell. successi r = MOOList [ "", "", [ "successive", "succession" ] ]
#32 Mr. Spell. rode r = MOOList [ "", "", [ "rodeo", "rodent", "rode" ] ]
#32 Mr. Spell. lit r = MOOList [ "", "ehitu", [ "litmus", "litany", "lit" ] ]
#32 Mr. Spell. godw r = MOOList [ "i", "", [ "godwit", "Godwin" ] ]
#32 Mr. Spell. flau r = MOOList [ "", "", [ "flautist", "flaunt" ] ]
#32 Mr. Spell. liv r = MOOList [ "", "ei", [ "livre" ] ]
#32 Mr. Spell. flas r = MOOList [ "", "h", [ "flask" ] ]
#32 Mr. Spell. flat r = MOOList [ "", "tu", [ "flatworm", "flatland", "flatiron", "flathead", "flatbed", "flat" ] ]
#32 Mr. Spell. Grif r = MOOList [ "fi", "", [ "Griffith", "griffin" ] ]
#32 Mr. Spell. liz r = MOOList [ "", "", [ "Lizzie", "lizard", "Liz" ] ]
#32 Mr. Spell. flax r = MOOList [ "", "", [ "flaxseed", "flaxen", "flax" ] ]
#32 Mr. Spell. percepti r = MOOList [ "", "", [ "perceptive", "perception", "perceptible" ] ]
#32 Mr. Spell. lia r = MOOList [ "", "", [ "liar", "liaison", "liable" ] ]
#32 Mr. Spell. lib r = MOOList [ "", "eir", [ "Libya", "libation" ] ]
#32 Mr. Spell. lic r = MOOList [ "", "e", [ "licorice", "lick", "lichen" ] ]
#32 Mr. Spell. lif r = MOOList [ "", "e", [ "lift", "LIFO" ] ]
#32 Mr. Spell. lig r = MOOList [ "", "aghn", [ ] ]
#32 Mr. Spell. integra r = MOOList [ "", "", [ "integrate", "integrand", "integral", "integrable" ] ]
#32 Mr. Spell. godd r = MOOList [ "", "", [ "goddess", "Goddard" ] ]
#32 Mr. Spell. flai r = MOOList [ "", "", [ "flair", "flail" ] ]
#32 Mr. Spell. rock r = MOOList [ "", "ae", [ "rocky", "Rockwell", "Rockland", "Rockies", "Rockford", "rockbound", "rock" ] ]
#32 Mr. Spell. lik r = MOOList [ "e", "", [ "likely", "likewise", "liken", "like" ] ]
#32 Mr. Spell. flag r = MOOList [ "", "es", [ "flagrant", "flagpole", "Flagler", "flagging", "flag" ] ]
#32 Mr. Spell. lil r = MOOList [ "", "al", [ "lily", "lilt", "Lilian" ] ]
#32 Mr. Spell. demon r = MOOList [ "", "is", [ "demon" ] ]
#32 Mr. Spell. demol r = MOOList [ "i", "", [ "demolition", "demolish" ] ]
#32 Mr. Spell. sadi r = MOOList [ "", "s", [ "Sadie" ] ]
#32 Mr. Spell. democ r = MOOList [ "ra", "t", [ "democracy" ] ]
#32 Mr. Spell. epitax r = MOOList [ "", "", [ "epitaxy", "epitaxial" ] ]
#32 Mr. Spell. robo r = MOOList [ "t", "", [ "robotics", "robot" ] ]
#32 Mr. Spell. brock r = MOOList [ "", "", [ "brockle", "Brock" ] ]
#32 Mr. Spell. hadr r = MOOList [ "", "", [ "hadron", "Hadrian" ] ]
#32 Mr. Spell. speak r = MOOList [ "", "", [ "speakeasy", "speak" ] ]
#32 Mr. Spell. sadd r = MOOList [ "", "l", [ "sadden" ] ]
#32 Mr. Spell. presti r = MOOList [ "", "g", [ "prestidigitate" ] ]
#32 Mr. Spell. affore r = MOOList [ "st", "", [ "afforestation", "afforest" ] ]
#32 Mr. Spell. spear r = MOOList [ "", "", [ "spearmint", "spearhead", "spear" ] ]
#32 Mr. Spell. decide r = MOOList [ "", "", [ "decides", "decided", "decide" ] ]
#32 Mr. Spell. ellipso r = MOOList [ "", "i", [ "ellipsometer" ] ]
#32 Mr. Spell. sacr r = MOOList [ "", "ai", [ "sacrosanct", "sacred" ] ]
#32 Mr. Spell. robb r = MOOList [ "", "", [ "robbin", "robbery" ] ]
#32 Mr. Spell. espou r = MOOList [ "s", "", [ "espouse", "espousal" ] ]
#32 Mr. Spell. substantia r = MOOList [ "", "", [ "substantiate", "substantial" ] ]
#32 Mr. Spell. hadd r = MOOList [ "", "", [ "haddock", "Haddad" ] ]
#32 Mr. Spell. Danie r = MOOList [ "l", "", [ "Danielson", "Daniel" ] ]
#32 Mr. Spell. tungs r = MOOList [ "t", "", [ "tungsten", "tungstate" ] ]
#32 Mr. Spell. transmi r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. ampe r = MOOList [ "", "r", [ "Ampex" ] ]
#32 Mr. Spell. hack r = MOOList [ "", "", [ "hacksaw", "hackney", "hackmatack", "hackle", "Hackett", "hackberry", "hack" ] ]
#32 Mr. Spell. amph r = MOOList [ "", "i", [ "amphetamine" ] ]
#32 Mr. Spell. road r = MOOList [ "", "bs", [ "roadway", "roadhouse", "road" ] ]
#32 Mr. Spell. infantr r = MOOList [ "y", "m", [ "infantry" ] ]
#32 Mr. Spell. ampl r = MOOList [ "", "i", [ "amply", "ample" ] ]
#32 Mr. Spell. insign r = MOOList [ "i", "", [ "insignificant", "insignia" ] ]
#32 Mr. Spell. transmu r = MOOList [ "t", "", [ "transmute", "transmutation" ] ]
#32 Mr. Spell. gobb r = MOOList [ "le", "", [ "gobbledygook", "gobble" ] ]
#32 Mr. Spell. Jim r = MOOList [ "", "m", [ "Jimenez", "Jim" ] ]
#32 Mr. Spell. amou r = MOOList [ "nt", "", [ "amounts", "amount" ] ]
#32 Mr. Spell. phys r = MOOList [ "i", "co", [ "physique", "Physik" ] ]
#32 Mr. Spell. propor r = MOOList [ "tion", "", [ "proportionate", "proportion" ] ]
#32 Mr. Spell. propos r = MOOList [ "", "ei", [ "proposal", "propos" ] ]
#32 Mr. Spell. treat r = MOOList [ "", "", [ "treaty", "treatise", "treat" ] ]
#32 Mr. Spell. treas r = MOOList [ "", "ou", [ ] ]
#32 Mr. Spell. speci r = MOOList [ "", "ef", [ "specious", "specimen", "special" ] ]
#32 Mr. Spell. carbon r = MOOList [ "", "ai", [ "carbonyl", "Carbone", "Carbondale", "carbon" ] ]
#32 Mr. Spell. iden r = MOOList [ "ti", "", [ "identity", "identify", "identical" ] ]
#32 Mr. Spell. ideo r = MOOList [ "l", "", [ "ideology", "ideolect" ] ]
#32 Mr. Spell. amoe r = MOOList [ "ba", "", [ "amoebae", "amoeba" ] ]
#32 Mr. Spell. Telec r = MOOList [ "o", "", [ "teleconference", "telecommunicate" ] ]
#32 Mr. Spell. habi r = MOOList [ "", "t", [ "Habib" ] ]
#32 Mr. Spell. speck r = MOOList [ "", "", [ "speckle", "speck" ] ]
#32 Mr. Spell. carbox r = MOOList [ "y", "", [ "carboxylic", "carboxy" ] ]
#32 Mr. Spell. populi r = MOOList [ "s", "", [ "populist", "populism" ] ]
#32 Mr. Spell. tread r = MOOList [ "", "", [ "treadmill", "treadle", "tread" ] ]
#32 Mr. Spell. treac r = MOOList [ "her", "", [ "treachery", "treacherous" ] ]
#32 Mr. Spell. amon r = MOOList [ "g", "", [ "amongst", "among" ] ]
#32 Mr. Spell. spect r = MOOList [ "", "ar", [ "Spector" ] ]
#32 Mr. Spell. specu r = MOOList [ "la", "", [ "speculate", "specular" ] ]
#32 Mr. Spell. Jewel r = MOOList [ "", "", [ "jewelry", "Jewell", "jewel" ] ]
#32 Mr. Spell. amor r = MOOList [ "", "", [ "amort", "amorphous", "amoral" ] ]
#32 Mr. Spell. deve r = MOOList [ "lop", "", [ "develops", "development", "developed", "develop" ] ]
#32 Mr. Spell. Newf r = MOOList [ "ound", "", [ "Newfoundland", "newfound" ] ]
#32 Mr. Spell. Newe r = MOOList [ "", "l", [ "newest" ] ]
#32 Mr. Spell. idea r = MOOList [ "", "", [ "ideas", "ideate", "ideal", "idea" ] ]
#32 Mr. Spell. devi r = MOOList [ "", "als", [ "devious", "device" ] ]
#32 Mr. Spell. orange r = MOOList [ "", "", [ "orangeroot", "orange" ] ]
#32 Mr. Spell. devo r = MOOList [ "", "ntu", [ "devolve", "devoid" ] ]
#32 Mr. Spell. lexico r = MOOList [ "", "", [ "lexicon", "lexicography" ] ]
#32 Mr. Spell. anorthi r = MOOList [ "", "", [ "anorthite", "anorthic" ] ]
#32 Mr. Spell. sever r = MOOList [ "", "ae", [ "Severn", "sever" ] ]
#32 Mr. Spell. popula r = MOOList [ "", "t", [ "popular", "populace" ] ]
#32 Mr. Spell. Passag r = MOOList [ "e", "", [ "passageway", "passage" ] ]
#32 Mr. Spell. reasona r = MOOList [ "bl", "", [ "reasonably", "reasonable" ] ]
#32 Mr. Spell. Gren r = MOOList [ "", "", [ "Grenoble", "Grendel", "grenade" ] ]
#32 Mr. Spell. deut r = MOOList [ "er", "", [ "deuterium", "deuterate" ] ]
#32 Mr. Spell. transpa r = MOOList [ "", "", [ "transparent", "transpacific" ] ]
#32 Mr. Spell. seven r = MOOList [ "", "t", [ "sevenfold", "seven" ] ]
#32 Mr. Spell. drafts r = MOOList [ "", "m", [ "draftsperson" ] ]
#32 Mr. Spell. molybde r = MOOList [ "n", "", [ "molybdenum", "molybdenite" ] ]
#32 Mr. Spell. Rach r = MOOList [ "", "", [ "Rachmaninoff", "Rachel" ] ]
#32 Mr. Spell. Peter r = MOOList [ "s", "", [ "Peterson", "Petersen", "Petersburg" ] ]
#32 Mr. Spell. Gret r = MOOList [ "", "", [ "Gretchen", "Greta" ] ]
#32 Mr. Spell. Martin r = MOOList [ "", "i", [ "Martinson", "martingale", "Martinez", "martin" ] ]
#32 Mr. Spell. curio r = MOOList [ "", "", [ "curious", "curiosity", "curio" ] ]
#32 Mr. Spell. Hugg r = MOOList [ "in", "", [ "Huggins", "hugging" ] ]
#32 Mr. Spell. hypot r = MOOList [ "", "h", [ "hypotenuse" ] ]
#32 Mr. Spell. trust r = MOOList [ "", "", [ "trustworthy", "trustful", "trustee", "trust" ] ]
#32 Mr. Spell. soaps r = MOOList [ "", "", [ "soapsud", "soapstone" ] ]
#32 Mr. Spell. police r = MOOList [ "", "m", [ "police" ] ]
#32 Mr. Spell. Hugh r = MOOList [ "", "", [ "Hughes", "Hugh" ] ]
#32 Mr. Spell. advise r = MOOList [ "", "", [ "advisee", "advise" ] ]
#32 Mr. Spell. loa r = MOOList [ "", "mt", [ "loaves", "loan", "loaf", "load" ] ]
#32 Mr. Spell. Gabr r = MOOList [ "iel", "", [ "Gabrielle", "Gabriel" ] ]
#32 Mr. Spell. lob r = MOOList [ "", "su", [ "lobo", "loblolly", "lobe", "lobby", "lobar", "lob" ] ]
#32 Mr. Spell. sorro r = MOOList [ "w", "", [ "sorrowful", "sorrow" ] ]
#32 Mr. Spell. amme r = MOOList [ "", "", [ "ammeter", "Ammerman" ] ]
#32 Mr. Spell. hoste r = MOOList [ "", "", [ "hostess", "hostelry" ] ]
#32 Mr. Spell. snoop r = MOOList [ "", "", [ "snoopy", "snoop" ] ]
#32 Mr. Spell. flexu r = MOOList [ "r", "", [ "flexure", "flexural" ] ]
#32 Mr. Spell. adviso r = MOOList [ "r", "", [ "advisory", "advisor" ] ]
#32 Mr. Spell. bracke r = MOOList [ "", "", [ "bracket", "bracken" ] ]
#32 Mr. Spell. rollin r = MOOList [ "", "", [ "rolling", "Rollins" ] ]
#32 Mr. Spell. ammo r = MOOList [ "", "n", [ "ammo" ] ]
#32 Mr. Spell. los r = MOOList [ "", "s", [ "lost", "lose", "losable" ] ]
#32 Mr. Spell. lot r = MOOList [ "", "t", [ "lots", "lotus", "lotion", "lot" ] ]
#32 Mr. Spell. lou r = MOOList [ "", "dinsv", [ "Lourdes", "Lou" ] ]
#32 Mr. Spell. lov r = MOOList [ "e", "l", [ "loves", "lovebird", "love" ] ]
#32 Mr. Spell. dete r = MOOList [ "", "cnrs", [ ] ]
#32 Mr. Spell. low r = MOOList [ "", "e", [ "Lowry", "lowland", "lowdown", "lowboy", "low" ] ]
#32 Mr. Spell. loy r = MOOList [ "", "a", [ "loy" ] ]
#32 Mr. Spell. observat r = MOOList [ "", "", [ "observatory", "observation" ] ]
#32 Mr. Spell. checks r = MOOList [ "um", "m", [ "checksum" ] ]
#32 Mr. Spell. deto r = MOOList [ "", "n", [ "detoxify", "detour" ] ]
#32 Mr. Spell. detr r = MOOList [ "", "a", [ "Detroit", "detriment" ] ]
#32 Mr. Spell. loc r = MOOList [ "", "akou", [ "loci" ] ]
#32 Mr. Spell. dess r = MOOList [ "", "", [ "dessicate", "dessert" ] ]
#32 Mr. Spell. lod r = MOOList [ "", "g", [ "Lodowick", "lodestone" ] ]
#32 Mr. Spell. loe r = MOOList [ "", "", [ "loess", "Loeb" ] ]
#32 Mr. Spell. desu r = MOOList [ "", "", [ "desultory", "desuetude" ] ]
#32 Mr. Spell. lof r = MOOList [ "t", "", [ "lofty", "loft" ] ]
#32 Mr. Spell. dest r = MOOList [ "", "ir", [ ] ]
#32 Mr. Spell. Regim r = MOOList [ "e", "n", [ "regime" ] ]
#32 Mr. Spell. loi r = MOOList [ "", "n", [ "loiter", "Lois", "Loire" ] ]
#32 Mr. Spell. Regin r = MOOList [ "a", "", [ "Reginald", "Regina" ] ]
#32 Mr. Spell. lol r = MOOList [ "", "l", [ "Lola" ] ]
#32 Mr. Spell. viola r = MOOList [ "", "", [ "violate", "viola" ] ]
#32 Mr. Spell. lon r = MOOList [ "", "eg", [ "London" ] ]
#32 Mr. Spell. loo r = MOOList [ "", "kmps", [ "loot", "loon" ] ]
#32 Mr. Spell. lop r = MOOList [ "", "es", [ "lop" ] ]
#32 Mr. Spell. viole r = MOOList [ "", "", [ "violet", "violent" ] ]
#32 Mr. Spell. loq r = MOOList [ "ua", "c", [ "loquat" ] ]
#32 Mr. Spell. lor r = MOOList [ "", "de", [ "Lorraine", "Lorinda" ] ]
#32 Mr. Spell. deta r = MOOList [ "", "i", [ "detach" ] ]
#32 Mr. Spell. dese r = MOOList [ "", "cr", [ "desegregate" ] ]
#32 Mr. Spell. desi r = MOOList [ "", "dgr", [ "desist" ] ]
#32 Mr. Spell. adventu r = MOOList [ "r", "", [ "adventurous", "adventure" ] ]
#32 Mr. Spell. Neth r = MOOList [ "er", "", [ "netherworld", "Netherlands", "nether" ] ]
#32 Mr. Spell. deso r = MOOList [ "", "l", [ "desorption" ] ]
#32 Mr. Spell. tubu r = MOOList [ "l", "", [ "tubule", "tubular" ] ]
#32 Mr. Spell. desp r = MOOList [ "", "eio", [ "despair" ] ]
#32 Mr. Spell. derr r = MOOList [ "i", "", [ "derriere", "derrick" ] ]
#32 Mr. Spell. quota r = MOOList [ "", "", [ "quotation", "quota" ] ]
#32 Mr. Spell. Vander r = MOOList [ "", "", [ "Vanderpoel", "Vanderbilt" ] ]
#32 Mr. Spell. tube r = MOOList [ "", "r", [ "tube" ] ]
#32 Mr. Spell. seduc r = MOOList [ "", "t", [ "seduce" ] ]
#32 Mr. Spell. dera r = MOOList [ "", "", [ "derate", "derange", "derail" ] ]
#32 Mr. Spell. scorp r = MOOList [ "io", "", [ "scorpion", "Scorpio" ] ]
#32 Mr. Spell. succe r = MOOList [ "", "s", [ "succeed" ] ]
#32 Mr. Spell. scorn r = MOOList [ "", "", [ "scornful", "scorn" ] ]
#32 Mr. Spell. dere r = MOOList [ "", "", [ "derelict", "Derek", "deregulate", "dereference" ] ]
#32 Mr. Spell. cryptograp r = MOOList [ "h", "", [ "cryptography", "cryptographer" ] ]
#32 Mr. Spell. deri r = MOOList [ "", "sv", [ "deride" ] ]
#32 Mr. Spell. quoti r = MOOList [ "", "", [ "quoting", "quotient" ] ]
#32 Mr. Spell. score r = MOOList [ "", "", [ "scorecard", "scoreboard", "score" ] ]
#32 Mr. Spell. condem r = MOOList [ "n", "a", [ "condemn" ] ]
#32 Mr. Spell. conden r = MOOList [ "s", "", [ "condensible", "condense", "condensate" ] ]
#32 Mr. Spell. Apol r = MOOList [ "", "lo", [ ] ]
#32 Mr. Spell. dero r = MOOList [ "gat", "", [ "derogatory", "derogate" ] ]
#32 Mr. Spell. Joa r = MOOList [ "", "n", [ "Joaquin" ] ]
#32 Mr. Spell. Suda r = MOOList [ "n", "", [ "Sudanese", "Sudan" ] ]
#32 Mr. Spell. succu r = MOOList [ "", "", [ "succumb", "succubus" ] ]
#32 Mr. Spell. condes r = MOOList [ "cen", "", [ "condescension", "condescend" ] ]
#32 Mr. Spell. christ r = MOOList [ "", "eio", [ "Christy", "Christmas", "Christ" ] ]
#32 Mr. Spell. antigo r = MOOList [ "", "", [ "antigorite", "Antigone" ] ]
#32 Mr. Spell. Alpha r = MOOList [ "", "b", [ "alphanumeric", "alpha" ] ]
#32 Mr. Spell. Jos r = MOOList [ "", "e", [ "jostle", "joss", "Josiah", "Joshua" ] ]
#32 Mr. Spell. amin r = MOOList [ "o", "", [ "aminobenzoic", "amino" ] ]
#32 Mr. Spell. Jor r = MOOList [ "", "g", [ "Jordan" ] ]
#32 Mr. Spell. cathod r = MOOList [ "", "", [ "cathodic", "cathode" ] ]
#32 Mr. Spell. Jon r = MOOList [ "", "a", [ "jonquil", "Jones", "Jon" ] ]
#32 Mr. Spell. Jol r = MOOList [ "", "l", [ "jolt", "Joliet" ] ]
#32 Mr. Spell. Joh r = MOOList [ "", "an", [ ] ]
#32 Mr. Spell. Joe r = MOOList [ "", "", [ "joey", "Joel", "Joe" ] ]
#32 Mr. Spell. phenom r = MOOList [ "en", "ao", [ ] ]
#32 Mr. Spell. phenol r = MOOList [ "", "", [ "phenolic", "phenol" ] ]
#32 Mr. Spell. depo r = MOOList [ "", "rs", [ "depot" ] ]
#32 Mr. Spell. depr r = MOOList [ "", "ei", [ "deprave" ] ]
#32 Mr. Spell. lenti r = MOOList [ "", "", [ "lentil", "lenticular" ] ]
#32 Mr. Spell. gelat r = MOOList [ "in", "", [ "gelatinous", "gelatine", "gelatin" ] ]
#32 Mr. Spell. depu r = MOOList [ "t", "", [ "deputy", "depute", "deputation" ] ]
#32 Mr. Spell. amid r = MOOList [ "", "", [ "amidst", "amide", "amid" ] ]
#32 Mr. Spell. Joy r = MOOList [ "", "", [ "joystick", "joyride", "joyous", "joyful", "Joyce", "joy" ] ]
#32 Mr. Spell. Jov r = MOOList [ "", "i", [ "Jove", "Jovanovich" ] ]
#32 Mr. Spell. warra r = MOOList [ "nt", "", [ "warranty", "warrant" ] ]
#32 Mr. Spell. depa r = MOOList [ "rt", "m", [ "departure", "depart" ] ]
#32 Mr. Spell. apolo r = MOOList [ "g", "", [ "apology", "apologia", "apologetic" ] ]
#32 Mr. Spell. apoll r = MOOList [ "o", "", [ "Apollonian", "Apollo" ] ]
#32 Mr. Spell. depe r = MOOList [ "nd", "", [ "dependent", "depend" ] ]
#32 Mr. Spell. Hubb r = MOOList [ "", "", [ "hubby", "hubbub", "Hubbell", "Hubbard" ] ]
#32 Mr. Spell. depl r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. corpsm r = MOOList [ "", "", [ "corpsmen", "corpsman" ] ]
#32 Mr. Spell. militar r = MOOList [ "", "i", [ "military" ] ]
#32 Mr. Spell. Cera r = MOOList [ "mi", "", [ "ceramium", "ceramic" ] ]
#32 Mr. Spell. exoga r = MOOList [ "m", "", [ "exogamy", "exogamous" ] ]
#32 Mr. Spell. Hube r = MOOList [ "r", "", [ "Hubert", "Huber" ] ]
#32 Mr. Spell. deox r = MOOList [ "yribo", "", [ "deoxyribose", "deoxyribonucleic" ] ]
#32 Mr. Spell. gradu r = MOOList [ "a", "", [ "graduate", "gradual" ] ]
#32 Mr. Spell. scour r = MOOList [ "", "", [ "scourge", "scour" ] ]
#32 Mr. Spell. demur r = MOOList [ "", "r", [ "demure", "demur" ] ]
#32 Mr. Spell. perpetua r = MOOList [ "", "", [ "perpetuate", "perpetual" ] ]
#32 Mr. Spell. discreti r = MOOList [ "on", "", [ "discretionary", "discretion" ] ]
#32 Mr. Spell. McNa r = MOOList [ "", "", [ "McNaughton", "McNally" ] ]
#32 Mr. Spell. lug r = MOOList [ "", "eg", [ "lug" ] ]
#32 Mr. Spell. pyro r = MOOList [ "", "lx", [ "pyrotechnic", "pyrophosphate", "pyrometer", "pyroelectric" ] ]
#32 Mr. Spell. deno r = MOOList [ "", "tu", [ "denominate" ] ]
#32 Mr. Spell. Marcel r = MOOList [ "", "", [ "Marcello", "Marcel" ] ]
#32 Mr. Spell. dent r = MOOList [ "", "", [ "denture", "Denton", "dentistry", "dental", "dent" ] ]
#32 Mr. Spell. pyri r = MOOList [ "", "", [ "pyrite", "pyrimidine", "pyridine" ] ]
#32 Mr. Spell. dens r = MOOList [ "", "", [ "densitometer", "dense" ] ]
#32 Mr. Spell. denu r = MOOList [ "", "d", [ "denunciate", "denumerable" ] ]
#32 Mr. Spell. tachi r = MOOList [ "", "", [ "tachistoscope", "tachinid" ] ]
#32 Mr. Spell. checke r = MOOList [ "rb", "", [ "checkerboard", "checkerberry" ] ]
#32 Mr. Spell. corpus r = MOOList [ "", "", [ "corpuscular", "corpus" ] ]
#32 Mr. Spell. grace r = MOOList [ "", "", [ "graceful", "grace" ] ]
#32 Mr. Spell. lumbe r = MOOList [ "r", "m", [ "lumber" ] ]
#32 Mr. Spell. dend r = MOOList [ "rit", "", [ "dendritic", "dendrite" ] ]
#32 Mr. Spell. labil r = MOOList [ "", "", [ "lability", "labile" ] ]
#32 Mr. Spell. deni r = MOOList [ "", "a", [ "denied", "denizen", "denigrate" ] ]
#32 Mr. Spell. bromi r = MOOList [ "", "", [ "bromine", "bromide" ] ]
#32 Mr. Spell. pyra r = MOOList [ "", "m", [ "pyracanth" ] ]
#32 Mr. Spell. luk r = MOOList [ "e", "", [ "lukewarm", "lukemia", "luke" ] ]
#32 Mr. Spell. demo r = MOOList [ "", "cln", [ "demountable", "demote", "demography", "demodulate" ] ]
#32 Mr. Spell. lul r = MOOList [ "", "l", [ "lulu" ] ]
#32 Mr. Spell. lum r = MOOList [ "", "bip", [ "lummox", "lumen" ] ]
#32 Mr. Spell. lun r = MOOList [ "", "acdg", [ ] ]
#32 Mr. Spell. demu r = MOOList [ "", "r", [ "demultiplex" ] ]
#32 Mr. Spell. swing r = MOOList [ "", "", [ "swingy", "swingable", "swing" ] ]
#32 Mr. Spell. lur r = MOOList [ "", "", [ "lurk", "lurid", "lure", "lurch", "Lura" ] ]
#32 Mr. Spell. antici r = MOOList [ "pat", "", [ "anticipatory", "anticipate" ] ]
#32 Mr. Spell. lus r = MOOList [ "", "t", [ "lush", "luscious", "Lusaka" ] ]
#32 Mr. Spell. lut r = MOOList [ "", "eh", [ "Lutz", "lutanist" ] ]
#32 Mr. Spell. hypoc r = MOOList [ "", "hr", [ "hypocycloid" ] ]
#32 Mr. Spell. necessi r = MOOList [ "t", "", [ "necessity", "necessitate" ] ]
#32 Mr. Spell. lux r = MOOList [ "", "eu", [ "lux" ] ]
#32 Mr. Spell. labia r = MOOList [ "", "", [ "labial", "labia" ] ]
#32 Mr. Spell. frenc r = MOOList [ "h", "m", [ "French" ] ]
#32 Mr. Spell. Disn r = MOOList [ "ey", "", [ "Disneyland", "Disney" ] ]
#32 Mr. Spell. Lovel r = MOOList [ "", "a", [ "lovelorn" ] ]
#32 Mr. Spell. flue r = MOOList [ "", "", [ "fluent", "flue" ] ]
#32 Mr. Spell. discuss r = MOOList [ "", "", [ "discussion", "discussant", "discuss" ] ]
#32 Mr. Spell. Walla r = MOOList [ "", "", [ "Wallace", "wallaby" ] ]
#32 Mr. Spell. syndi r = MOOList [ "c", "", [ "syndicate", "syndic" ] ]
#32 Mr. Spell. fluf r = MOOList [ "f", "", [ "fluffy", "fluff" ] ]
#32 Mr. Spell. angs r = MOOList [ "t", "", [ "angstrom", "angst" ] ]
#32 Mr. Spell. angu r = MOOList [ "", "", [ "Angus", "angular", "anguish" ] ]
#32 Mr. Spell. begga r = MOOList [ "r", "", [ "beggary", "beggar" ] ]
#32 Mr. Spell. range r = MOOList [ "", "", [ "rangeland", "range" ] ]
#32 Mr. Spell. tende r = MOOList [ "", "r", [ "tendency" ] ]
#32 Mr. Spell. misce r = MOOList [ "", "l", [ "miscegenation" ] ]
#32 Mr. Spell. pervers r = MOOList [ "", "", [ "perversion", "perverse" ] ]
#32 Mr. Spell. angi r = MOOList [ "", "", [ "angiosperm", "Angie" ] ]
#32 Mr. Spell. Kenne r = MOOList [ "", "", [ "Kenney", "Kenneth", "kennel", "Kennedy", "Kennecott" ] ]
#32 Mr. Spell. insula r = MOOList [ "", "", [ "insulate", "insular" ] ]
#32 Mr. Spell. synch r = MOOList [ "ro", "n", [ "synchrotron" ] ]
#32 Mr. Spell. thicke r = MOOList [ "", "", [ "thicket", "thicken" ] ]
#32 Mr. Spell. honorari r = MOOList [ "", "", [ "honoraria", "honorarium" ] ]
#32 Mr. Spell. sawt r = MOOList [ "", "", [ "sawtooth", "sawtimber" ] ]
#32 Mr. Spell. Plut r = MOOList [ "", "o", [ "Plutarch" ] ]
#32 Mr. Spell. Thai r = MOOList [ "", "", [ "Thailand", "Thai" ] ]
#32 Mr. Spell. Jud r = MOOList [ "", "ai", [ "Judy", "Judson", "judo", "judge", "Jude", "Judd" ] ]
#32 Mr. Spell. pipe r = MOOList [ "", "", [ "pipette", "pipeline", "pipe" ] ]
#32 Mr. Spell. ignora r = MOOList [ "", "", [ "ignorant", "ignoramus" ] ]
#32 Mr. Spell. Minne r = MOOList [ "", "", [ "Minnesota", "Minneapolis" ] ]
#32 Mr. Spell. capacita r = MOOList [ "", "", [ "capacitate", "capacitance" ] ]
#32 Mr. Spell. Champa r = MOOList [ "", "", [ "Champaign", "champagne" ] ]
#32 Mr. Spell. rout r = MOOList [ "", "", [ "routine", "route", "rout" ] ]
#32 Mr. Spell. sawf r = MOOList [ "", "", [ "sawfly", "sawfish" ] ]
#32 Mr. Spell. Jur r = MOOList [ "", "ai", [ "jury", "juror", "jure" ] ]
#32 Mr. Spell. owne r = MOOList [ "", "r", [ "owned" ] ]
#32 Mr. Spell. valedicto r = MOOList [ "r", "", [ "valedictory", "valedictorian" ] ]
#32 Mr. Spell. roun r = MOOList [ "d", "h", [ "roundworm", "roundup", "roundtable", "roundoff", "roundabout", "round" ] ]
#32 Mr. Spell. Jul r = MOOList [ "", "ei", [ "July" ] ]
#32 Mr. Spell. change r = MOOList [ "", "", [ "changes", "changed", "changeover", "changeable", "change" ] ]
#32 Mr. Spell. Juk r = MOOList [ "e", "", [ "Jukes", "juke" ] ]
#32 Mr. Spell. gour r = MOOList [ "", "", [ "gourmet", "gourd" ] ]
#32 Mr. Spell. roug r = MOOList [ "", "h", [ "rouge" ] ]
#32 Mr. Spell. versa r = MOOList [ "", "t", [ "Versailles", "versa" ] ]
#32 Mr. Spell. savi r = MOOList [ "", "", [ "saving", "Saviour" ] ]
#32 Mr. Spell. indica r = MOOList [ "", "", [ "indicate", "indicant" ] ]
#32 Mr. Spell. Ruthe r = MOOList [ "", "", [ "Rutherford", "ruthenium" ] ]
#32 Mr. Spell. anec r = MOOList [ "dot", "", [ "anecdote", "anecdotal" ] ]
#32 Mr. Spell. promethe r = MOOList [ "", "", [ "Prometheus", "Promethean" ] ]
#32 Mr. Spell. savo r = MOOList [ "", "y", [ "Savonarola" ] ]
#32 Mr. Spell. roto r = MOOList [ "", "", [ "rototill", "rotor", "rotogravure" ] ]
#32 Mr. Spell. sava r = MOOList [ "", "gn", [ ] ]
#32 Mr. Spell. pink r = MOOList [ "", "i", [ "pink" ] ]
#32 Mr. Spell. pinh r = MOOList [ "", "", [ "pinhole", "pinhead" ] ]
#32 Mr. Spell. rotu r = MOOList [ "nd", "", [ "rotunda", "rotund" ] ]
#32 Mr. Spell. pine r = MOOList [ "", "", [ "Pinehurst", "pineapple", "pine" ] ]
#32 Mr. Spell. pint r = MOOList [ "", "", [ "pinto", "pintail", "pint" ] ]
#32 Mr. Spell. solidi r = MOOList [ "f", "", [ "solidifies", "solidify" ] ]
#32 Mr. Spell. pinn r = MOOList [ "a", "", [ "pinnate", "pinnacle" ] ]
#32 Mr. Spell. lym r = MOOList [ "", "p", [ "Lyman" ] ]
#32 Mr. Spell. verti r = MOOList [ "", "c", [ "vertigo" ] ]
#32 Mr. Spell. clerg r = MOOList [ "y", "m", [ "clergy" ] ]
#32 Mr. Spell. rota r = MOOList [ "", "r", [ "rotate" ] ]
#32 Mr. Spell. conspir r = MOOList [ "", "a", [ "conspire" ] ]
#32 Mr. Spell. saut r = MOOList [ "e", "", [ "sauterne", "saute" ] ]
#32 Mr. Spell. lyr r = MOOList [ "", "", [ "lyric", "Lyra" ] ]
#32 Mr. Spell. lys r = MOOList [ "", "e", [ "lysine" ] ]
#32 Mr. Spell. inhom r = MOOList [ "ogene", "", [ "inhomogeneous", "inhomogeneity" ] ]
#32 Mr. Spell. pinc r = MOOList [ "", "", [ "pincushion", "pinch" ] ]
#32 Mr. Spell. have r = MOOList [ "", "n", [ "have" ] ]
#32 Mr. Spell. verte r = MOOList [ "", "b", [ "vertex" ] ]
#32 Mr. Spell. stowa r = MOOList [ "", "", [ "stowaway", "stowage" ] ]
#32 Mr. Spell. protopl r = MOOList [ "asm", "", [ "protoplasmic", "protoplasm" ] ]
#32 Mr. Spell. havi r = MOOList [ "", "", [ "having", "Havilland" ] ]
#32 Mr. Spell. adjoi r = MOOList [ "n", "", [ "adjoint", "adjoin" ] ]
#32 Mr. Spell. haun r = MOOList [ "", "", [ "haunt", "haunch" ] ]
#32 Mr. Spell. botani r = MOOList [ "", "", [ "botanist", "botanic" ] ]
#32 Mr. Spell. anch r = MOOList [ "o", "r", [ "anchovy" ] ]
#32 Mr. Spell. haul r = MOOList [ "", "", [ "haulage", "haul" ] ]
#32 Mr. Spell. anci r = MOOList [ "", "", [ "ancillary", "ancient" ] ]
#32 Mr. Spell. glycerin r = MOOList [ "", "", [ "glycerine", "glycerinate", "glycerin" ] ]
#32 Mr. Spell. improv r = MOOList [ "", "i", [ "improve" ] ]
#32 Mr. Spell. rost r = MOOList [ "", "", [ "rostrum", "roster" ] ]
#32 Mr. Spell. Dion r = MOOList [ "ys", "", [ "Dionysus", "Dionysian" ] ]
#32 Mr. Spell. improp r = MOOList [ "", "e", [ "impropriety" ] ]
#32 Mr. Spell. angli r = MOOList [ "", "", [ "angling", "Anglican" ] ]
#32 Mr. Spell. rosa r = MOOList [ "", "", [ "rosary", "Rosalie", "Rosa" ] ]
#32 Mr. Spell. checksumm r = MOOList [ "", "", [ "checksumming", "checksummed" ] ]
#32 Mr. Spell. satu r = MOOList [ "r", "an", [ "Saturday" ] ]
#32 Mr. Spell. rose r = MOOList [ "", "bnt", [ "rosemary", "Roseland", "rose" ] ]
#32 Mr. Spell. haug r = MOOList [ "", "", [ "haughty", "Haugen" ] ]
#32 Mr. Spell. Carbo r = MOOList [ "", "nx", [ "carboy", "carborundum", "Carboloy", "carbohydrate" ] ]
#32 Mr. Spell. Else r = MOOList [ "", "", [ "elsewhere", "Elsevier", "else" ] ]
#32 Mr. Spell. sati r = MOOList [ "", "ars", [ "satin", "satiety" ] ]
#32 Mr. Spell. goss r = MOOList [ "", "", [ "gossip", "gossamer" ] ]
#32 Mr. Spell. strategi r = MOOList [ "", "", [ "strategist", "strategic" ] ]
#32 Mr. Spell. Elsi r = MOOList [ "", "", [ "Elsinore", "Elsie" ] ]
#32 Mr. Spell. insupp r = MOOList [ "", "", [ "insuppressible", "insupportable" ] ]
#32 Mr. Spell. ance r = MOOList [ "st", "ro", [ ] ]
#32 Mr. Spell. Trout r = MOOList [ "", "", [ "Troutman", "trout" ] ]
#32 Mr. Spell. sata r = MOOList [ "n", "", [ "satanic", "satan" ] ]
#32 Mr. Spell. pilg r = MOOList [ "rim", "", [ "pilgrimage", "pilgrim" ] ]
#32 Mr. Spell. pilf r = MOOList [ "er", "", [ "pilferage", "pilfer" ] ]
#32 Mr. Spell. covari r = MOOList [ "a", "", [ "covariate", "covariant" ] ]
#32 Mr. Spell. pile r = MOOList [ "", "", [ "pilewort", "pile" ] ]
#32 Mr. Spell. schizop r = MOOList [ "hreni", "", [ "schizophrenic", "schizophrenia" ] ]
#32 Mr. Spell. repeat r = MOOList [ "", "", [ "repeater", "repeat" ] ]
#32 Mr. Spell. southea r = MOOList [ "st", "", [ "southeastern", "southeast" ] ]
#32 Mr. Spell. Gave r = MOOList [ "", "", [ "gavel", "gave" ] ]
#32 Mr. Spell. pill r = MOOList [ "", "ao", [ "Pillsbury", "pill" ] ]
#32 Mr. Spell. gosh r = MOOList [ "", "", [ "goshawk", "gosh" ] ]
#32 Mr. Spell. Hatti r = MOOList [ "e", "", [ "Hattiesburg", "Hattie" ] ]
#32 Mr. Spell. avoca r = MOOList [ "", "", [ "avocate", "avocado" ] ]
#32 Mr. Spell. floo r = MOOList [ "", "dr", [ ] ]
#32 Mr. Spell. flop r = MOOList [ "", "", [ "floppy", "flop" ] ]
#32 Mr. Spell. souther r = MOOList [ "n", "", [ "southernmost", "southern" ] ]
#32 Mr. Spell. hate r = MOOList [ "", "", [ "hater", "hateful", "hate" ] ]
#32 Mr. Spell. flot r = MOOList [ "", "", [ "flotilla", "flotation" ] ]
#32 Mr. Spell. hatc r = MOOList [ "h", "", [ "hatchway", "hatchet", "hatch" ] ]
#32 Mr. Spell. flor r = MOOList [ "", "aei", [ ] ]
#32 Mr. Spell. flow r = MOOList [ "", "e", [ "flown", "flowchart", "flow" ] ]
#32 Mr. Spell. Chest r = MOOList [ "", "e", [ "chestnut", "chest" ] ]
#32 Mr. Spell. flou r = MOOList [ "", "nr", [ "flout" ] ]
#32 Mr. Spell. doublet r = MOOList [ "", "", [ "doubleton", "doublet" ] ]
#32 Mr. Spell. indign r = MOOList [ "", "a", [ "indignity" ] ]
#32 Mr. Spell. Welles r = MOOList [ "", "", [ "Wellesley", "Welles" ] ]
#32 Mr. Spell. anag r = MOOList [ "", "", [ "anagram", "anaglyph" ] ]
#32 Mr. Spell. effluv r = MOOList [ "i", "", [ "effluvium", "effluvia" ] ]
#32 Mr. Spell. floc r = MOOList [ "", "", [ "flock", "flocculate", "floc" ] ]
#32 Mr. Spell. anal r = MOOList [ "", "oy", [ "analgesic", "analeptic" ] ]
#32 Mr. Spell. hast r = MOOList [ "", "e", [ "hasty", "Hastings", "hast" ] ]
#32 Mr. Spell. gord r = MOOList [ "", "", [ "Gordon", "Gordian" ] ]
#32 Mr. Spell. chance r = MOOList [ "", "l", [ "chances", "chancery", "chance" ] ]
#32 Mr. Spell. flog r = MOOList [ "", "", [ "flogging", "flog" ] ]
#32 Mr. Spell. evaluat r = MOOList [ "", "", [ "evaluation", "evaluate" ] ]
#32 Mr. Spell. paint r = MOOList [ "", "", [ "paintbrush", "paint" ] ]
#32 Mr. Spell. gorg r = MOOList [ "", "e", [ "gorgon" ] ]
#32 Mr. Spell. Besse r = MOOList [ "", "", [ "Bessemer", "Bessel" ] ]
#32 Mr. Spell. anar r = MOOList [ "ch", "", [ "anarchy", "anarchic", "anarch" ] ]
#32 Mr. Spell. anas r = MOOList [ "t", "io", [ "Anastasia" ] ]
#32 Mr. Spell. sars r = MOOList [ "", "", [ "sarsparilla", "sarsaparilla" ] ]
#32 Mr. Spell. sard r = MOOList [ "", "", [ "sardonic", "sardine" ] ]
#32 Mr. Spell. indige r = MOOList [ "", "ns", [ ] ]
#32 Mr. Spell. Gaus r = MOOList [ "s", "", [ "Gaussian", "gauss" ] ]
#32 Mr. Spell. hash r = MOOList [ "", "", [ "hashish", "hash" ] ]
#32 Mr. Spell. traversa r = MOOList [ "", "", [ "traversal", "traversable" ] ]
#32 Mr. Spell. anac r = MOOList [ "", "h", [ "anaconda" ] ]
#32 Mr. Spell. harp r = MOOList [ "", "", [ "Harpy", "harpsichord", "harpoon", "harp" ] ]
#32 Mr. Spell. sara r = MOOList [ "", "", [ "Saratoga", "Sarasota", "Saran", "Sarah", "Saracen", "Sara" ] ]
#32 Mr. Spell. cerem r = MOOList [ "on", "i", [ "ceremony" ] ]
#32 Mr. Spell. Dill r = MOOList [ "", "", [ "Dillon", "dill" ] ]
#32 Mr. Spell. sarc r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. harm r = MOOList [ "", "o", [ "harmful", "harm" ] ]
#32 Mr. Spell. Grum r = MOOList [ "", "", [ "Grumman", "grumble" ] ]
#32 Mr. Spell. hars r = MOOList [ "h", "", [ "harshen", "harsh" ] ]
#32 Mr. Spell. makes r = MOOList [ "", "", [ "makes", "makeshift" ] ]
#32 Mr. Spell. harv r = MOOList [ "", "e", [ "Harvard" ] ]
#32 Mr. Spell. cereb r = MOOList [ "", "r", [ "cerebellum" ] ]
#32 Mr. Spell. offs r = MOOList [ "", "eh", [ "offstage", "offspring", "offsaddle" ] ]
#32 Mr. Spell. arteri r = MOOList [ "", "o", [ "arterial" ] ]
#32 Mr. Spell. hard r = MOOList [ "", "btwe", [ "hardy", "hardscrabble", "Hardin", "hardhat", "hardcopy", "hard" ] ]
#32 Mr. Spell. Rast r = MOOList [ "", "", [ "Rastus", "raster" ] ]
#32 Mr. Spell. formatt r = MOOList [ "", "", [ "formatting", "formatted" ] ]
#32 Mr. Spell. harb r = MOOList [ "in", "", [ "harbinger", "Harbin" ] ]
#32 Mr. Spell. river r = MOOList [ "", "", [ "riverside", "riverine", "riverfront", "riverbank", "river" ] ]
#32 Mr. Spell. hare r = MOOList [ "", "", [ "harem", "harelip", "hare" ] ]
#32 Mr. Spell. offe r = MOOList [ "", "nr", [ ] ]
#32 Mr. Spell. rook r = MOOList [ "", "", [ "rooky", "rookie", "rook" ] ]
#32 Mr. Spell. room r = MOOList [ "", "", [ "rooms", "roomy", "roommate", "roomful", "room" ] ]
#32 Mr. Spell. referend r = MOOList [ "", "", [ "referendum", "referenda" ] ]
#32 Mr. Spell. Rare r = MOOList [ "", "", [ "rarefy", "rare" ] ]
#32 Mr. Spell. roof r = MOOList [ "", "t", [ "roof" ] ]
#32 Mr. Spell. offi r = MOOList [ "c", "ei", [ ] ]
#32 Mr. Spell. instant r = MOOList [ "", "", [ "instantly", "instantiate", "instantaneous", "instant" ] ]
#32 Mr. Spell. Gasp r = MOOList [ "", "", [ "Gaspee", "gasp" ] ]
#32 Mr. Spell. vermi r = MOOList [ "", "", [ "vermin", "vermilion", "vermiculite" ] ]
#32 Mr. Spell. sapp r = MOOList [ "", "", [ "sappy", "sapphire" ] ]
#32 Mr. Spell. servic r = MOOList [ "e", "m", [ "serviceberry", "serviceable", "service" ] ]
#32 Mr. Spell. Burgu r = MOOList [ "nd", "", [ "Burgundy", "Burgundian" ] ]
#32 Mr. Spell. chroni r = MOOList [ "c", "", [ "chronicle", "chronic" ] ]
#32 Mr. Spell. tarpa r = MOOList [ "", "", [ "tarpaulin", "tarpaper" ] ]
#32 Mr. Spell. sapi r = MOOList [ "en", "", [ "sapient", "sapiens" ] ]
#32 Mr. Spell. goos r = MOOList [ "e", "", [ "gooseberry", "goose" ] ]
#32 Mr. Spell. Ford r = MOOList [ "", "", [ "Fordham", "ford" ] ]
#32 Mr. Spell. stole r = MOOList [ "", "", [ "stolen", "stole" ] ]
#32 Mr. Spell. denota r = MOOList [ "ti", "", [ "denotative", "denotation" ] ]
#32 Mr. Spell. tuto r = MOOList [ "r", "", [ "tutorial", "tutor" ] ]
#32 Mr. Spell. mai r = MOOList [ "", "dln", [ "maitre", "maim", "Maier" ] ]
#32 Mr. Spell. maj r = MOOList [ "", "e", [ "major" ] ]
#32 Mr. Spell. hapl r = MOOList [ "o", "i", [ "haplology" ] ]
#32 Mr. Spell. mak r = MOOList [ "", "e", [ "making" ] ]
#32 Mr. Spell. mal r = MOOList [ "", "acdefilnopt", [ "Malraux" ] ]
#32 Mr. Spell. hippo r = MOOList [ "", "c", [ "hippopotamus", "hippodrome", "hippo" ] ]
#32 Mr. Spell. formal r = MOOList [ "", "", [ "formaldehyde", "formal" ] ]
#32 Mr. Spell. mam r = MOOList [ "", "m", [ "mambo" ] ]
#32 Mr. Spell. man r = MOOList [ "", "adeghinostu", [ "manzanita", "many", "Manville", "manpower", "Manley", "mankind", "Manfred", "Manchester", "man" ] ]
#32 Mr. Spell. happ r = MOOList [ "", "e", [ "happy" ] ]
#32 Mr. Spell. vermo r = MOOList [ "", "", [ "vermouth", "Vermont" ] ]
#32 Mr. Spell. map r = MOOList [ "", "", [ "maple", "map" ] ]
#32 Mr. Spell. goof r = MOOList [ "", "", [ "goofy", "goof" ] ]
#32 Mr. Spell. mar r = MOOList [ "", "acgijklmqrstvy", [ "Marx", "maroon", "mare", "Mardi", "marble", "mar" ] ]
#32 Mr. Spell. good r = MOOList [ "", "wy", [ "Goodrich", "Goodman", "Goode", "goodbye", "good" ] ]
#32 Mr. Spell. mas r = MOOList [ "", "ceoqst", [ "mask", "mash" ] ]
#32 Mr. Spell. format r = MOOList [ "", "t", [ "formate", "format" ] ]
#32 Mr. Spell. chroma r = MOOList [ "t", "io", [ "chromate" ] ]
#32 Mr. Spell. beauti r = MOOList [ "f", "", [ "beautify", "beautiful" ] ]
#32 Mr. Spell. factor r = MOOList [ "", "", [ "factory", "factorial", "factor" ] ]
#32 Mr. Spell. militari r = MOOList [ "s", "", [ "militarist", "militarism" ] ]
#32 Mr. Spell. Gart r = MOOList [ "", "", [ "Garth", "garter" ] ]
#32 Mr. Spell. deline r = MOOList [ "a", "", [ "delineate", "delineament" ] ]
#32 Mr. Spell. chromi r = MOOList [ "", "", [ "chromium", "chromic" ] ]
#32 Mr. Spell. Redst r = MOOList [ "", "", [ "Redstone", "redstart" ] ]
#32 Mr. Spell. Waldo r = MOOList [ "", "", [ "Waldorf", "Waldo" ] ]
#32 Mr. Spell. mac r = MOOList [ "", "aDehKr", [ "Macon", "MacMillan", "macintosh", "MacGregor", "Macbeth", "Mac" ] ]
#32 Mr. Spell. pige r = MOOList [ "on", "", [ "pigeonhole", "pigeonfoot", "pigeonberry", "pigeon" ] ]
#32 Mr. Spell. surre r = MOOList [ "", "", [ "surrey", "surreptitious", "surrender", "surreal" ] ]
#32 Mr. Spell. predic r = MOOList [ "", "at", [ ] ]
#32 Mr. Spell. Elli r = MOOList [ "", "ops", [ ] ]
#32 Mr. Spell. tusc r = MOOList [ "a", "n", [ "Tuscarora", "Tuscaloosa" ] ]
#32 Mr. Spell. pigm r = MOOList [ "ent", "", [ "pigmentation", "pigment" ] ]
#32 Mr. Spell. surro r = MOOList [ "", "", [ "surround", "surrogate" ] ]
#32 Mr. Spell. pigg r = MOOList [ "", "i", [ "piggy" ] ]
#32 Mr. Spell. mat r = MOOList [ "", "cehirstu", [ "mat" ] ]
#32 Mr. Spell. eige r = MOOList [ "n", "sv", [ "eigenfunction" ] ]
#32 Mr. Spell. sani r = MOOList [ "", "t", [ "sanicle" ] ]
#32 Mr. Spell. periphe r = MOOList [ "r", "", [ "periphery", "peripheral" ] ]
#32 Mr. Spell. mau r = MOOList [ "", "r", [ "mauve", "mausoleum", "maul", "maudlin" ] ]
#32 Mr. Spell. Stockh r = MOOList [ "ol", "", [ "Stockholm", "stockholder" ] ]
#32 Mr. Spell. maw r = MOOList [ "", "", [ "Mawr", "mawkish", "maw" ] ]
#32 Mr. Spell. max r = MOOList [ "", "iw", [ "max" ] ]
#32 Mr. Spell. maz r = MOOList [ "", "", [ "mazurka", "maze", "Mazda" ] ]
#32 Mr. Spell. eigh r = MOOList [ "t", "e", [ "eighty", "eightieth", "eighth", "eightfold", "eight" ] ]
#32 Mr. Spell. sana r = MOOList [ "", "t", [ "Sana" ] ]
#32 Mr. Spell. turt r = MOOList [ "le", "", [ "turtleneck", "turtleback", "turtle" ] ]
#32 Mr. Spell. sand r = MOOList [ "", "abepw", [ "sandy", "Sandusky", "sandstone", "Sandra", "sandman", "Sandia", "sandhill", "sand" ] ]
#32 Mr. Spell. Phili r = MOOList [ "", "p", [ "Philistine" ] ]
#32 Mr. Spell. freedm r = MOOList [ "", "", [ "freedmen", "Freedman" ] ]
#32 Mr. Spell. sang r = MOOList [ "", "u", [ "sangaree", "sang" ] ]
#32 Mr. Spell. Cardi r = MOOList [ "", "o", [ "cardinal", "Cardiff", "cardiac" ] ]
#32 Mr. Spell. hang r = MOOList [ "", "amo", [ "hang" ] ]
#32 Mr. Spell. turk r = MOOList [ "", "", [ "Turkish", "turkey", "turk" ] ]
#32 Mr. Spell. stone r = MOOList [ "", "w", [ "Stonehenge", "stonecrop", "stone" ] ]
#32 Mr. Spell. fresh r = MOOList [ "", "m", [ "freshwater", "freshen", "fresh" ] ]
#32 Mr. Spell. turn r = MOOList [ "", "aeo", [ "turntable", "turnstone", "turnpike", "turnkey", "turnip", "turn" ] ]
#32 Mr. Spell. fresc r = MOOList [ "o", "", [ "frescoes", "fresco" ] ]
#32 Mr. Spell. roll r = MOOList [ "", "i", [ "rollback", "roll" ] ]
#32 Mr. Spell. chrono r = MOOList [ "", "g", [ "chronology" ] ]
#32 Mr. Spell. turp r = MOOList [ "", "", [ "turpitude", "turpentine" ] ]
#32 Mr. Spell. turb r = MOOList [ "", "io", [ "turbulent", "turban" ] ]
#32 Mr. Spell. samo r = MOOList [ "", "", [ "samovar", "Samoa" ] ]
#32 Mr. Spell. obser r = MOOList [ "v", "a", [ "observe" ] ]
#32 Mr. Spell. obseq r = MOOList [ "u", "", [ "obsequy", "obsequious" ] ]
#32 Mr. Spell. bounc r = MOOList [ "", "", [ "bouncy", "bounce" ] ]
#32 Mr. Spell. bound r = MOOList [ "", "", [ "boundary", "bound" ] ]
#32 Mr. Spell. obses r = MOOList [ "s", "i", [ "obsess" ] ]
#32 Mr. Spell. Font r = MOOList [ "", "a", [ "font" ] ]
#32 Mr. Spell. Temple r = MOOList [ "", "", [ "Templeton", "temple" ] ]
#32 Mr. Spell. pier r = MOOList [ "", "", [ "Pierson", "Pierre", "pierce", "pier" ] ]
#32 Mr. Spell. flic r = MOOList [ "k", "", [ "flickers", "flick" ] ]
#32 Mr. Spell. inexper r = MOOList [ "", "", [ "inexpert", "inexperience" ] ]
#32 Mr. Spell. adjud r = MOOList [ "", "", [ "adjudicate", "adjudge" ] ]
#32 Mr. Spell. flin r = MOOList [ "", "t", [ "fling", "flinch" ] ]
#32 Mr. Spell. hand r = MOOList [ "", "bcilmswy", [ "handout", "handkerchief", "handhold", "handgun", "handful", "Handel", "hand" ] ]
#32 Mr. Spell. flir r = MOOList [ "t", "a", [ "flirt" ] ]
#32 Mr. Spell. piet r = MOOList [ "", "", [ "piety", "pietism" ] ]
#32 Mr. Spell. flip r = MOOList [ "", "", [ "flippant", "flipflop", "flip" ] ]
#32 Mr. Spell. salv r = MOOList [ "", "a", [ "salvo", "salve" ] ]
#32 Mr. Spell. piec r = MOOList [ "e", "", [ "piecewise", "piecemeal", "piece" ] ]
#32 Mr. Spell. Claim r = MOOList [ "", "", [ "claimant", "claim" ] ]
#32 Mr. Spell. delec r = MOOList [ "ta", "", [ "delectate", "delectable" ] ]
#32 Mr. Spell. Kab r = MOOList [ "u", "", [ "Kabul", "Kabuki" ] ]
#32 Mr. Spell. Rank r = MOOList [ "", "i", [ "rankle", "rank" ] ]
#32 Mr. Spell. deleg r = MOOList [ "a", "", [ "delegate", "delegable" ] ]
#32 Mr. Spell. salo r = MOOList [ "", "o", [ "salon" ] ]
#32 Mr. Spell. hamm r = MOOList [ "", "o", [ "hammerhead" ] ]
#32 Mr. Spell. Hust r = MOOList [ "", "", [ "Huston", "hustle" ] ]
#32 Mr. Spell. Rand r = MOOList [ "", "o", [ "randy", "Randall", "Rand" ] ]
#32 Mr. Spell. salt r = MOOList [ "", "", [ "salty", "saltwater", "saltbush", "salt" ] ]
#32 Mr. Spell. salu r = MOOList [ "", "t", [ "salubrious" ] ]
#32 Mr. Spell. Kau r = MOOList [ "f", "", [ "Kaufman", "Kauffman" ] ]
#32 Mr. Spell. halv r = MOOList [ "", "e", [ "halvah" ] ]
#32 Mr. Spell. Kat r = MOOList [ "", "h", [ "Katz", "Katowice", "Katmandu", "Katie", "Kate" ] ]
#32 Mr. Spell. delet r = MOOList [ "", "e", [ "deletion" ] ]
#32 Mr. Spell. programme r = MOOList [ "", "r", [ "programmed" ] ]
#32 Mr. Spell. Kar r = MOOList [ "", "a", [ "karyatid", "Karp", "Karol", "karma", "Karl", "Karen" ] ]
#32 Mr. Spell. sall r = MOOList [ "", "", [ "sally", "sallow", "Salle" ] ]
#32 Mr. Spell. salm r = MOOList [ "on", "", [ "salmonella", "salmonberry", "salmon" ] ]
#32 Mr. Spell. Hutc r = MOOList [ "h", "i", [ "hutch" ] ]
#32 Mr. Spell. Susa r = MOOList [ "n", "", [ "Susanne", "Susan" ] ]
#32 Mr. Spell. sala r = MOOList [ "", "m", [ "salary", "salad", "salacious", "Salaam" ] ]
#32 Mr. Spell. hamb r = MOOList [ "urg", "", [ "hamburger", "Hamburg" ] ]
#32 Mr. Spell. Kaf r = MOOList [ "ka", "", [ "Kafkaesque", "Kafka" ] ]
#32 Mr. Spell. half r = MOOList [ "", "", [ "halfway", "halfhearted", "halfback", "half" ] ]
#32 Mr. Spell. mei r = MOOList [ "", "", [ "Meistersinger", "meiosis", "Meier" ] ]
#32 Mr. Spell. mel r = MOOList [ "", "ailov", [ "melt", "Melpomene", "melee", "meld", "Melcher", "Melbourne", "Mel" ] ]
#32 Mr. Spell. globu r = MOOList [ "l", "", [ "globulin", "globule", "globular" ] ]
#32 Mr. Spell. mem r = MOOList [ "", "bo", [ "Memphis", "memento" ] ]
#32 Mr. Spell. hali r = MOOList [ "", "", [ "halite", "Halifax", "halide", "halibut" ] ]
#32 Mr. Spell. Fold r = MOOList [ "", "", [ "foldout", "fold" ] ]
#32 Mr. Spell. men r = MOOList [ "", "adist", [ "Menzies", "menu", "Mennonite", "Menlo", "menhaden", "menfolk", "Menelaus", "men" ] ]
#32 Mr. Spell. Rama r = MOOList [ "", "", [ "Raman", "Ramada" ] ]
#32 Mr. Spell. hall r = MOOList [ "", "eo", [ "hallway", "hallucinate", "hallmark", "hall" ] ]
#32 Mr. Spell. ranch r = MOOList [ "", "", [ "rancho", "ranch" ] ]
#32 Mr. Spell. mes r = MOOList [ "", "cos", [ "mesquite", "mesmeric", "mesh", "mesenteric", "mesa" ] ]
#32 Mr. Spell. met r = MOOList [ "", "aehirt", [ "Metzler", "Metcalf", "met" ] ]
#32 Mr. Spell. halo r = MOOList [ "", "", [ "halogen", "halocarbon", "halo" ] ]
#32 Mr. Spell. Charles r = MOOList [ "", "", [ "Charleston", "Charles" ] ]
#32 Mr. Spell. hereina r = MOOList [ "", "", [ "hereinafter", "hereinabove" ] ]
#32 Mr. Spell. pico r = MOOList [ "", "", [ "picosecond", "picojoule", "picofarad" ] ]
#32 Mr. Spell. Elis r = MOOList [ "", "", [ "elision", "Elisha", "Elisabeth" ] ]
#32 Mr. Spell. picn r = MOOList [ "ic", "k", [ "picnic" ] ]
#32 Mr. Spell. nutrit r = MOOList [ "i", "o", [ "nutritive" ] ]
#32 Mr. Spell. Grot r = MOOList [ "", "", [ "Groton", "grotesque" ] ]
#32 Mr. Spell. pick r = MOOList [ "", "e", [ "picky", "pickup", "pickoff", "Pickman", "pickle", "Pickford", "pickaxe", "pick" ] ]
#32 Mr. Spell. Gang r = MOOList [ "", "l", [ "gangway", "gangster", "gangplank", "Ganges", "gang" ] ]
#32 Mr. Spell. mea r = MOOList [ "", "dlnst", [ "meager" ] ]
#32 Mr. Spell. mec r = MOOList [ "", "h", [ "mecum", "Mecca" ] ]
#32 Mr. Spell. Eliz r = MOOList [ "abeth", "", [ "Elizabethan", "Elizabeth" ] ]
#32 Mr. Spell. med r = MOOList [ "", "ail", [ "Medusa", "Medford", "Medea", "meddle" ] ]
#32 Mr. Spell. pict r = MOOList [ "", "u", [ "pictorial" ] ]
#32 Mr. Spell. mee r = MOOList [ "", "t", [ "meek" ] ]
#32 Mr. Spell. Gann r = MOOList [ "et", "", [ "Gannett", "gannet" ] ]
#32 Mr. Spell. meg r = MOOList [ "", "a", [ "megohm", "Meg" ] ]
#32 Mr. Spell. cooke r = MOOList [ "", "", [ "cookery", "Cooke" ] ]
#32 Mr. Spell. vertic r = MOOList [ "", "a", [ "vertices" ] ]
#32 Mr. Spell. survi r = MOOList [ "v", "", [ "survivor", "survive", "survival" ] ]
#32 Mr. Spell. rando r = MOOList [ "", "", [ "random", "Randolph" ] ]
#32 Mr. Spell. drago r = MOOList [ "", "n", [ "dragoon" ] ]
#32 Mr. Spell. industri r = MOOList [ "", "", [ "industries", "industrious", "industrial" ] ]
#32 Mr. Spell. picc r = MOOList [ "", "", [ "piccolo", "Piccadilly" ] ]
#32 Mr. Spell. formic r = MOOList [ "", "", [ "Formica", "formic" ] ]
#32 Mr. Spell. tune r = MOOList [ "", "", [ "tuned", "tuneful", "tune" ] ]
#32 Mr. Spell. Dougl r = MOOList [ "as", "", [ "Douglass", "Douglas" ] ]
#32 Mr. Spell. tung r = MOOList [ "", "s", [ "tung" ] ]
#32 Mr. Spell. fles r = MOOList [ "h", "", [ "fleshy", "flesh" ] ]
#32 Mr. Spell. Dough r = MOOList [ "", "", [ "doughnut", "Dougherty", "dough" ] ]
#32 Mr. Spell. store r = MOOList [ "", "", [ "Storey", "storeroom", "storekeep", "storehouse", "store" ] ]
#32 Mr. Spell. suspens r = MOOList [ "", "", [ "suspensor", "suspension", "suspense" ] ]
#32 Mr. Spell. sail r = MOOList [ "", "", [ "sailor", "sailfish", "sailboat", "sail" ] ]
#32 Mr. Spell. bourg r = MOOList [ "eois", "", [ "bourgeoisie", "bourgeois" ] ]
#32 Mr. Spell. flex r = MOOList [ "", "u", [ "flexible", "flex" ] ]
#32 Mr. Spell. bourb r = MOOList [ "", "", [ "bourbon", "Bourbaki" ] ]
#32 Mr. Spell. storm r = MOOList [ "", "", [ "stormy", "stormbound", "storm" ] ]
#32 Mr. Spell. tumu r = MOOList [ "lt", "", [ "tumultuous", "tumult" ] ]
#32 Mr. Spell. transiti r = MOOList [ "", "", [ "transitive", "transition" ] ]
#32 Mr. Spell. flea r = MOOList [ "", "", [ "fleawort", "fleabane", "flea" ] ]
#32 Mr. Spell. pian r = MOOList [ "", "i", [ "piano" ] ]
#32 Mr. Spell. hair r = MOOList [ "", "", [ "hairy", "hairpin", "hairdo", "haircut", "hair" ] ]
#32 Mr. Spell. conduct r = MOOList [ "", "", [ "conductor", "conductance", "conduct" ] ]
#32 Mr. Spell. tenac r = MOOList [ "i", "", [ "tenacity", "tenacious" ] ]
#32 Mr. Spell. ostra r = MOOList [ "", "c", [ "Ostrander" ] ]
#32 Mr. Spell. arcad r = MOOList [ "", "", [ "Arcadia", "arcade" ] ]
#32 Mr. Spell. story r = MOOList [ "", "", [ "storyteller", "storyboard", "story" ] ]
#32 Mr. Spell. flee r = MOOList [ "", "", [ "fleet", "fleeing", "fleece", "flee" ] ]
#32 Mr. Spell. abutt r = MOOList [ "", "", [ "abutting", "abutted" ] ]
#32 Mr. Spell. referent r = MOOList [ "", "", [ "referential", "referent" ] ]
#32 Mr. Spell. Gale r = MOOList [ "", "n", [ "gale" ] ]
#32 Mr. Spell. fled r = MOOList [ "", "g", [ "fled" ] ]
#32 Mr. Spell. arcan r = MOOList [ "", "", [ "arcane", "arcana" ] ]
#32 Mr. Spell. surve r = MOOList [ "", "y", [ "surveillant" ] ]
#32 Mr. Spell. flem r = MOOList [ "i", "", [ "flemish", "Fleming" ] ]
#32 Mr. Spell. Gall r = MOOList [ "", "aeiou", [ "gallstone", "gallberry", "gall" ] ]
#32 Mr. Spell. synap r = MOOList [ "", "s", [ "synaptic" ] ]
#32 Mr. Spell. missi r = MOOList [ "", "os", [ "missing", "missive", "missile" ] ]
#32 Mr. Spell. delig r = MOOList [ "ht", "", [ "delightful", "delight" ] ]
#32 Mr. Spell. delim r = MOOList [ "it", "", [ "delimitation", "delimit" ] ]
#32 Mr. Spell. tenta r = MOOList [ "", "", [ "tentative", "tentacle" ] ]
#32 Mr. Spell. Hepa r = MOOList [ "ti", "", [ "hepatitis", "hepatica" ] ]
#32 Mr. Spell. balle r = MOOList [ "", "t", [ "ballerina" ] ]
#32 Mr. Spell. artem r = MOOList [ "is", "", [ "artemisia", "Artemis" ] ]
#32 Mr. Spell. temp r = MOOList [ "", "elot", [ ] ]
#32 Mr. Spell. delic r = MOOList [ "", "a", [ "delicti", "delicious" ] ]
#32 Mr. Spell. delib r = MOOList [ "erate", "", [ "deliberately", "deliberate" ] ]
#32 Mr. Spell. wheez r = MOOList [ "", "", [ "wheezy", "wheeze" ] ]
#32 Mr. Spell. deliv r = MOOList [ "er", "", [ "delivery", "deliverance", "deliver" ] ]
#32 Mr. Spell. drama r = MOOList [ "", "t", [ "drama" ] ]
#32 Mr. Spell. Ker r = MOOList [ "", "nr", [ "kerygma", "kerosene", "Kermit", "kerchief" ] ]
#32 Mr. Spell. arter r = MOOList [ "", "i", [ "artery" ] ]
#32 Mr. Spell. missp r = MOOList [ "elling", "", [ "misspellings", "misspelling" ] ]
#32 Mr. Spell. deliq r = MOOList [ "uesce", "", [ "deliquescent", "deliquesce" ] ]
#32 Mr. Spell. repell r = MOOList [ "", "e", [ "repelling" ] ]
#32 Mr. Spell. Ken r = MOOList [ "", "nty", [ "Kensington", "keno", "Kendall", "ken" ] ]
#32 Mr. Spell. delin r = MOOList [ "", "e", [ "delinquent" ] ]
#32 Mr. Spell. Kel r = MOOList [ "", "l", [ "Kelvin", "Kelsey", "kelp" ] ]
#32 Mr. Spell. ballo r = MOOList [ "", "", [ "ballot", "balloon" ] ]
#32 Mr. Spell. defensi r = MOOList [ "", "", [ "defensive", "defensible" ] ]
#32 Mr. Spell. delir r = MOOList [ "i", "", [ "delirium", "delirious" ] ]
#32 Mr. Spell. mim r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. min r = MOOList [ "", "cdeinosu", [ "mint", "mink", "mingle", "minaret", "min" ] ]
#32 Mr. Spell. Sene r = MOOList [ "", "", [ "Senegal", "Seneca" ] ]
#32 Mr. Spell. Henr r = MOOList [ "", "i", [ "henry" ] ]
#32 Mr. Spell. inexpli r = MOOList [ "c", "", [ "inexplicit", "inexplicable" ] ]
#32 Mr. Spell. mir r = MOOList [ "", "a", [ "mirth", "mirror", "Miriam", "Mirfak", "mire" ] ]
#32 Mr. Spell. mis r = MOOList [ "", "aceost", [ "mislaid", "misnomer" ] ]
#32 Mr. Spell. tell r = MOOList [ "", "", [ "telling", "tells", "tellurium", "telltale", "teller", "tell" ] ]
#32 Mr. Spell. mix r = MOOList [ "", "", [ "mixup", "mixture", "mix" ] ]
#32 Mr. Spell. tele r = MOOList [ "", "cgopstv", [ "Telex", "telemeter", "telekinesis", "Telefunken", "Teledyne" ] ]
#32 Mr. Spell. synth r = MOOList [ "e", "s", [ "synthetic" ] ]
#32 Mr. Spell. mia r = MOOList [ "", "s", [ "Miami" ] ]
#32 Mr. Spell. mic r = MOOList [ "", "hkr", [ "mice", "mica" ] ]
#32 Mr. Spell. Gaine r = MOOList [ "s", "", [ "Gainesville", "Gaines" ] ]
#32 Mr. Spell. Seno r = MOOList [ "r", "", [ "senorita", "Senora", "senor" ] ]
#32 Mr. Spell. mig r = MOOList [ "", "hr", [ "Miguel", "mignon", "mig" ] ]
#32 Mr. Spell. synta r = MOOList [ "", "", [ "syntax", "syntactic" ] ]
#32 Mr. Spell. tensi r = MOOList [ "", "o", [ "tensile" ] ]
#32 Mr. Spell. quarry r = MOOList [ "", "m", [ "quarry" ] ]
#32 Mr. Spell. Hemp r = MOOList [ "", "", [ "Hempstead", "hemp" ] ]
#32 Mr. Spell. verteb r = MOOList [ "ra", "", [ "vertebrate", "vertebral", "vertebrae", "vertebra" ] ]
#32 Mr. Spell. dozen r = MOOList [ "", "", [ "dozens", "dozen" ] ]
#32 Mr. Spell. antiqua r = MOOList [ "", "r", [ "antiquated" ] ]
#32 Mr. Spell. quarre r = MOOList [ "l", "", [ "quarrelsome", "quarrel" ] ]
#32 Mr. Spell. Hend r = MOOList [ "", "r", [ "Henderson" ] ]
#32 Mr. Spell. educat r = MOOList [ "", "", [ "education", "educate" ] ]
#32 Mr. Spell. digre r = MOOList [ "ss", "", [ "digression", "digress" ] ]
#32 Mr. Spell. wheel r = MOOList [ "", "", [ "wheelhouse", "wheelchair", "wheelbase", "wheel" ] ]
#32 Mr. Spell. buffe r = MOOList [ "", "", [ "buffer", "buffet" ] ]
#32 Mr. Spell. Knut r = MOOList [ "s", "", [ "Knutson", "Knutsen" ] ]
#32 Mr. Spell. fault r = MOOList [ "", "", [ "faulty", "fault" ] ]
#32 Mr. Spell. acquit r = MOOList [ "", "t", [ "acquit" ] ]
#32 Mr. Spell. acquis r = MOOList [ "iti", "", [ "acquisitive", "acquisition" ] ]
#32 Mr. Spell. genera r = MOOList [ "", "lt", [ "genera" ] ]
#32 Mr. Spell. hazel r = MOOList [ "", "", [ "hazelnut", "hazel" ] ]
#32 Mr. Spell. receive r = MOOList [ "", "", [ "received", "receive" ] ]
#32 Mr. Spell. Kha r = MOOList [ "", "", [ "Khartoum", "khan", "khaki" ] ]
#32 Mr. Spell. multiplica r = MOOList [ "", "t", [ "multiplicand" ] ]
#32 Mr. Spell. Constanti r = MOOList [ "n", "", [ "Constantinople", "Constantine" ] ]
#32 Mr. Spell. anth r = MOOList [ "", "eor", [ ] ]
#32 Mr. Spell. anti r = MOOList [ "", "cgpqs", [ "antithetic", "Antioch", "antimony", "Antietam", "anti" ] ]
#32 Mr. Spell. acquie r = MOOList [ "sce", "", [ "acquiescent", "acquiesce" ] ]
#32 Mr. Spell. Tuscan r = MOOList [ "", "", [ "Tuscany", "Tuscan" ] ]
#32 Mr. Spell. Thor r = MOOList [ "", "ino", [ "Thorstein", "Thorpe", "Thoreau", "Thor" ] ]
#32 Mr. Spell. subje r = MOOList [ "ct", "i", [ "subjects", "subject" ] ]
#32 Mr. Spell. genero r = MOOList [ "", "", [ "generous", "generosity" ] ]
#32 Mr. Spell. Kim r = MOOList [ "", "b", [ "kimono", "Kim" ] ]
#32 Mr. Spell. cabine r = MOOList [ "t", "", [ "cabinetry", "cabinetmake", "cabinet" ] ]
#32 Mr. Spell. quartz r = MOOList [ "", "", [ "quartzite", "quartz" ] ]
#32 Mr. Spell. table r = MOOList [ "", "as", [ "tablet", "tableland", "tablecloth", "table" ] ]
#32 Mr. Spell. Holli r = MOOList [ "", "", [ "Hollister", "Hollingsworth" ] ]
#32 Mr. Spell. artif r = MOOList [ "", "i", [ "artifact" ] ]
#32 Mr. Spell. tender r = MOOList [ "", "", [ "tenderloin", "tenderfoot" ] ]
#32 Mr. Spell. Kie r = MOOList [ "", "", [ "Kiewit", "Kiev", "Kieffer" ] ]
#32 Mr. Spell. arche r = MOOList [ "", "t", [ "archery", "archenemy" ] ]
#32 Mr. Spell. Kid r = MOOList [ "", "dn", [ "kid" ] ]
#32 Mr. Spell. artis r = MOOList [ "", "", [ "artistry", "artisan" ] ]
#32 Mr. Spell. archa r = MOOList [ "", "i", [ "archangel", "archae" ] ]
#32 Mr. Spell. Hollo r = MOOList [ "w", "", [ "hollowware", "Holloway", "hollow" ] ]
#32 Mr. Spell. instruc r = MOOList [ "t", "", [ "instructor", "instruct" ] ]
#32 Mr. Spell. ante r = MOOList [ "", "n", [ "anterior", "antelope", "antedate", "antecedent", "antebellum", "anteater", "ante" ] ]
#32 Mr. Spell. communi r = MOOList [ "", "c", [ "community", "communique", "communion" ] ]
#32 Mr. Spell. mounta r = MOOList [ "in", "", [ "mountainside", "mountainous", "mountaineer", "mountain" ] ]
#32 Mr. Spell. quarti r = MOOList [ "", "", [ "quartile", "quartic" ] ]
#32 Mr. Spell. Hele r = MOOList [ "n", "", [ "Helene", "Helena", "Helen" ] ]
#32 Mr. Spell. Knud r = MOOList [ "s", "", [ "Knudson", "Knudsen" ] ]
#32 Mr. Spell. Typh r = MOOList [ "", "o", [ "typhus" ] ]
#32 Mr. Spell. Knuc r = MOOList [ "kle", "", [ "knuckleball", "knuckle" ] ]
#32 Mr. Spell. parenthes r = MOOList [ "", "", [ "parenthesis", "parentheses" ] ]
#32 Mr. Spell. certi r = MOOList [ "", "f", [ "certitude", "certiorari" ] ]
#32 Mr. Spell. Kit r = MOOList [ "", "ct", [ "kite", "Kitakyushu", "kit" ] ]
#32 Mr. Spell. submi r = MOOList [ "t", "t", [ "submit" ] ]
#32 Mr. Spell. Kir r = MOOList [ "", "ck", [ "Kirov", "Kirby" ] ]
#32 Mr. Spell. Kio r = MOOList [ "", "", [ "Kiowa", "kiosk" ] ]
#32 Mr. Spell. quarte r = MOOList [ "", "r", [ "quartet" ] ]
#32 Mr. Spell. certa r = MOOList [ "in", "", [ "certainty", "certain" ] ]
#32 Mr. Spell. guide r = MOOList [ "", "", [ "guidepost", "guideline", "guidebook", "guide" ] ]
#32 Mr. Spell. retrofitt r = MOOList [ "", "", [ "retrofitting", "retrofitted" ] ]
#32 Mr. Spell. Johanne r = MOOList [ "s", "", [ "Johannesburg", "Johannes" ] ]
#32 Mr. Spell. incapac r = MOOList [ "it", "", [ "incapacity", "incapacitate" ] ]
#32 Mr. Spell. instrum r = MOOList [ "ent", "", [ "instrumentation", "instrument" ] ]
#32 Mr. Spell. Flora r = MOOList [ "", "", [ "floral", "flora" ] ]
#32 Mr. Spell. Flore r = MOOList [ "n", "", [ "Florentine", "Florence" ] ]
#32 Mr. Spell. alabam r = MOOList [ "", "", [ "Alabamian", "Alabama" ] ]
#32 Mr. Spell. implica r = MOOList [ "", "", [ "implicate", "implicant" ] ]
#32 Mr. Spell. bootlegg r = MOOList [ "", "", [ "bootlegging", "bootlegger" ] ]
#32 Mr. Spell. suspe r = MOOList [ "", "n", [ "suspect" ] ]
#32 Mr. Spell. irreden r = MOOList [ "tis", "", [ "irredentist", "irredentism" ] ]
#32 Mr. Spell. Hein r = MOOList [ "", "", [ "Heinz", "Heinrich", "Heine" ] ]
#32 Mr. Spell. perfum r = MOOList [ "e", "", [ "perfumery", "perfume" ] ]
#32 Mr. Spell. suspi r = MOOList [ "cio", "", [ "suspicious", "suspicion" ] ]
#32 Mr. Spell. moa r = MOOList [ "", "", [ "moat", "moan" ] ]
#32 Mr. Spell. megal r = MOOList [ "omania", "", [ "megalomaniac", "megalomania" ] ]
#32 Mr. Spell. Benedic r = MOOList [ "t", "i", [ "Benedict" ] ]
#32 Mr. Spell. bodyb r = MOOList [ "uild", "", [ "bodybuilding", "bodybuilder" ] ]
#32 Mr. Spell. megab r = MOOList [ "", "", [ "megabyte", "megabit" ] ]
#32 Mr. Spell. typesett r = MOOList [ "", "", [ "typesetting", "typesetter" ] ]
#32 Mr. Spell. mor r = MOOList [ "", "aegioprst", [ "morn", "Mormon", "Morley", "morbid" ] ]
#32 Mr. Spell. mot r = MOOList [ "", "ehiot", [ "motley", "mot" ] ]
#32 Mr. Spell. mov r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. villai r = MOOList [ "n", "", [ "villainous", "villain" ] ]
#32 Mr. Spell. Aqui r = MOOList [ "", "", [ "Aquinas", "Aquila" ] ]
#32 Mr. Spell. Kle r = MOOList [ "", "", [ "Klein", "kleenex" ] ]
#32 Mr. Spell. hydroch r = MOOList [ "", "l", [ "hydrochemistry" ] ]
#32 Mr. Spell. megaw r = MOOList [ "", "", [ "megaword", "megawatt" ] ]
#32 Mr. Spell. mob r = MOOList [ "", "i", [ "mobster", "mobcap", "mob" ] ]
#32 Mr. Spell. moc r = MOOList [ "", "k", [ "moccasin" ] ]
#32 Mr. Spell. mod r = MOOList [ "", "eiu", [ "modal" ] ]
#32 Mr. Spell. teet r = MOOList [ "", "h", [ "teetotal", "teeter", "teet" ] ]
#32 Mr. Spell. mol r = MOOList [ "", "adeilty", [ "Moluccas", "Moloch" ] ]
#32 Mr. Spell. mom r = MOOList [ "", "e", [ "mommy" ] ]
#32 Mr. Spell. Holle r = MOOList [ "r", "", [ "Hollerith", "holler" ] ]
#32 Mr. Spell. moo r = MOOList [ "", "dnr", [ "moot", "moose", "moo" ] ]
#32 Mr. Spell. anor r = MOOList [ "", "t", [ "anorexia" ] ]
#32 Mr. Spell. histori r = MOOList [ "", "", [ "historiography", "historic", "historian" ] ]
#32 Mr. Spell. teen r = MOOList [ "", "", [ "teensy", "teenage", "teen" ] ]
#32 Mr. Spell. inappr r = MOOList [ "", "o", [ "inappreciable" ] ]
#32 Mr. Spell. ingrat r = MOOList [ "", "i", [ "ingrate" ] ]
#32 Mr. Spell. Segm r = MOOList [ "ent", "", [ "segmentation", "segment" ] ]
#32 Mr. Spell. anod r = MOOList [ "", "", [ "anodic", "anode" ] ]
#32 Mr. Spell. anom r = MOOList [ "", "a", [ "anomie" ] ]
#32 Mr. Spell. anon r = MOOList [ "ym", "", [ "anonymous", "anonymity" ] ]
#32 Mr. Spell. annu r = MOOList [ "", "l", [ "annunciate", "annum", "annuity", "annual" ] ]
#32 Mr. Spell. Schuy r = MOOList [ "l", "", [ "Schuylkill", "Schuyler" ] ]
#32 Mr. Spell. setti r = MOOList [ "ng", "", [ "settings", "setting" ] ]
#32 Mr. Spell. Kni r = MOOList [ "", "cg", [ "knives", "knit", "knife" ] ]
#32 Mr. Spell. Knox r = MOOList [ "", "", [ "Knoxville", "Knox" ] ]
#32 Mr. Spell. horri r = MOOList [ "", "", [ "horrify", "horrid", "horrible" ] ]
#32 Mr. Spell. decompo r = MOOList [ "s", "", [ "decomposition", "decompose", "decomposable" ] ]
#32 Mr. Spell. Schum r = MOOList [ "a", "", [ "Schumann", "Schumacher" ] ]
#32 Mr. Spell. hyperbolo r = MOOList [ "id", "", [ "hyperboloidal", "hyperboloid" ] ]
#32 Mr. Spell. Knot r = MOOList [ "", "t", [ "knot" ] ]
#32 Mr. Spell. tedi r = MOOList [ "", "", [ "tedium", "tedious" ] ]
#32 Mr. Spell. drawb r = MOOList [ "", "", [ "drawbridge", "drawback" ] ]
#32 Mr. Spell. Koc r = MOOList [ "h", "", [ "Kochab", "Koch" ] ]
#32 Mr. Spell. anna r = MOOList [ "", "l", [ "Annapolis", "Anna" ] ]
#32 Mr. Spell. Thim r = MOOList [ "b", "", [ "Thimbu", "thimble" ] ]
#32 Mr. Spell. Schul r = MOOList [ "", "", [ "Schulz", "Schultz" ] ]
#32 Mr. Spell. anne r = MOOList [ "", "", [ "annex", "Annette", "anneal", "Anne" ] ]
#32 Mr. Spell. mount r = MOOList [ "", "a", [ "mount" ] ]
#32 Mr. Spell. sharpe r = MOOList [ "", "", [ "sharpen", "Sharpe" ] ]
#32 Mr. Spell. incest r = MOOList [ "", "", [ "incestuous", "incest" ] ]
#32 Mr. Spell. anni r = MOOList [ "", "", [ "anniversary", "annihilate", "Annie" ] ]
#32 Mr. Spell. anno r = MOOList [ "", "yu", [ "annotate" ] ]
#32 Mr. Spell. impreg r = MOOList [ "na", "", [ "impregnate", "impregnable" ] ]
#32 Mr. Spell. Kor r = MOOList [ "", "", [ "Korea", "Koran" ] ]
#32 Mr. Spell. nutritio r = MOOList [ "", "", [ "nutritious", "nutrition" ] ]
#32 Mr. Spell. Kon r = MOOList [ "", "", [ "Konrad", "Kong" ] ]
#32 Mr. Spell. postp r = MOOList [ "", "or", [ ] ]
#32 Mr. Spell. fille r = MOOList [ "", "", [ "filled", "fillet" ] ]
#32 Mr. Spell. postu r = MOOList [ "", "", [ "posture", "postulate" ] ]
#32 Mr. Spell. imprec r = MOOList [ "", "", [ "imprecise", "imprecate" ] ]
#32 Mr. Spell. excita r = MOOList [ "t", "", [ "excitatory", "excitation" ] ]
#32 Mr. Spell. Koe r = MOOList [ "nig", "", [ "Koenigsberg", "Koenig" ] ]
#32 Mr. Spell. tech r = MOOList [ "", "n", [ "tech" ] ]
#32 Mr. Spell. Amper r = MOOList [ "", "", [ "ampersand", "ampere", "amperage" ] ]
#32 Mr. Spell. postm r = MOOList [ "", "a", [ "postmultiply", "postmortem", "postmen" ] ]
#32 Mr. Spell. posto r = MOOList [ "", "", [ "postorder", "postoperative" ] ]
#32 Mr. Spell. decompr r = MOOList [ "ess", "", [ "decompression", "decompress" ] ]
#32 Mr. Spell. puddi r = MOOList [ "ng", "", [ "puddingstone", "pudding" ] ]
#32 Mr. Spell. posta r = MOOList [ "", "", [ "postal", "postage" ] ]
#32 Mr. Spell. tenne r = MOOList [ "", "", [ "Tenney", "Tennessee", "Tenneco" ] ]
#32 Mr. Spell. postc r = MOOList [ "", "", [ "postcondition", "postcard" ] ]
#32 Mr. Spell. puddl r = MOOList [ "", "", [ "puddly", "puddle" ] ]
#32 Mr. Spell. poste r = MOOList [ "ri", "o", [ "posterity" ] ]
#32 Mr. Spell. Kow r = MOOList [ "", "a", [ "Kowloon" ] ]
#32 Mr. Spell. impres r = MOOList [ "", "s", [ "impresario" ] ]
#32 Mr. Spell. mrs r = MOOList [ "", "", [ "mrs.", "Mrs" ] ]
#32 Mr. Spell. ofte r = MOOList [ "n", "", [ "oftentimes", "often" ] ]
#32 Mr. Spell. featherbe r = MOOList [ "d", "", [ "featherbedding", "featherbed" ] ]
#32 Mr. Spell. frostb r = MOOList [ "it", "", [ "frostbitten", "frostbite" ] ]
#32 Mr. Spell. possi r = MOOList [ "bl", "", [ "possibly", "possible" ] ]
#32 Mr. Spell. hails r = MOOList [ "to", "", [ "hailstorm", "hailstone" ] ]
#32 Mr. Spell. behav r = MOOList [ "", "ie", [ ] ]
#32 Mr. Spell. teas r = MOOList [ "", "ep", [ ] ]
#32 Mr. Spell. tear r = MOOList [ "", "", [ "tearful", "teardrop", "tear" ] ]
#32 Mr. Spell. stablem r = MOOList [ "", "", [ "stablemen", "stableman" ] ]
#32 Mr. Spell. posse r = MOOList [ "", "ms", [ "posse" ] ]
#32 Mr. Spell. seismog r = MOOList [ "raph", "", [ "seismography", "seismograph" ] ]
#32 Mr. Spell. melodr r = MOOList [ "ama", "", [ "melodramatic", "melodrama" ] ]
#32 Mr. Spell. teak r = MOOList [ "", "", [ "teakwood", "teakettle" ] ]
#32 Mr. Spell. delus r = MOOList [ "i", "", [ "delusive", "delusion" ] ]
#32 Mr. Spell. team r = MOOList [ "", "s", [ "teamwork", "teammate", "team" ] ]
#32 Mr. Spell. Thet r = MOOList [ "", "", [ "Thetis", "theta" ] ]
#32 Mr. Spell. melodi r = MOOList [ "", "", [ "melodious", "melodic" ] ]
#32 Mr. Spell. teac r = MOOList [ "", "h", [ "teacup", "teacart" ] ]
#32 Mr. Spell. muc r = MOOList [ "", "", [ "mucus", "mucosa", "muck", "mucilage", "much" ] ]
#32 Mr. Spell. mue r = MOOList [ "", "", [ "muezzin", "Mueller" ] ]
#32 Mr. Spell. muf r = MOOList [ "f", "", [ "muffle", "muffin", "muff" ] ]
#32 Mr. Spell. mug r = MOOList [ "", "g", [ "mugho", "mug" ] ]
#32 Mr. Spell. secur r = MOOList [ "", "i", [ "secure" ] ]
#32 Mr. Spell. Kre r = MOOList [ "", "", [ "Kresge", "Kremlin", "Krebs" ] ]
#32 Mr. Spell. malad r = MOOList [ "", "a", [ "malady", "maladroit", "maladjust" ] ]
#32 Mr. Spell. Hunga r = MOOList [ "r", "", [ "Hungary", "Hungarian" ] ]
#32 Mr. Spell. Kra r = MOOList [ "", "ku", [ "Kramer", "kraft" ] ]
#32 Mr. Spell. Dixi r = MOOList [ "e", "", [ "dixieland", "Dixie" ] ]
#32 Mr. Spell. worthl r = MOOList [ "ess", "", [ "worthlessness", "worthless" ] ]
#32 Mr. Spell. hornb r = MOOList [ "", "l", [ "hornbeam" ] ]
#32 Mr. Spell. guilt r = MOOList [ "", "", [ "guilty", "guilt" ] ]
#32 Mr. Spell. synop r = MOOList [ "", "s", [ "synoptic" ] ]
#32 Mr. Spell. malar r = MOOList [ "ia", "", [ "malarial", "malaria" ] ]
#32 Mr. Spell. Kru r = MOOList [ "", "", [ "Kruse", "Kruger", "Krueger" ] ]
#32 Mr. Spell. importu r = MOOList [ "n", "", [ "importune", "importunate" ] ]
#32 Mr. Spell. Hebe r = MOOList [ "", "", [ "hebephrenic", "Hebe" ] ]
#32 Mr. Spell. guill r = MOOList [ "", "", [ "guillotine", "guillemot" ] ]
#32 Mr. Spell. Hebr r = MOOList [ "", "", [ "Hebrew", "Hebraic" ] ]
#32 Mr. Spell. Kri r = MOOList [ "", "s", [ "Krieger" ] ]
#32 Mr. Spell. guild r = MOOList [ "", "", [ "guildsman", "guildhall", "guild" ] ]
#32 Mr. Spell. synon r = MOOList [ "ym", "", [ "synonymy", "synonymous", "synonym" ] ]
#32 Mr. Spell. maxima r = MOOList [ "", "", [ "maximal", "maxima" ] ]
#32 Mr. Spell. obsti r = MOOList [ "na", "", [ "obstinate", "obstinacy" ] ]
#32 Mr. Spell. modif r = MOOList [ "", "i", [ "modify" ] ]
#32 Mr. Spell. Theo r = MOOList [ "", "dlr", [ "theocracy" ] ]
#32 Mr. Spell. mul r = MOOList [ "", "clt", [ "mulish", "mule", "mulberry", "mulatto" ] ]
#32 Mr. Spell. mum r = MOOList [ "", "", [ "mummy", "Mumford", "mumble", "mum" ] ]
#32 Mr. Spell. glori r = MOOList [ "", "a", [ "glorious", "glorify" ] ]
#32 Mr. Spell. piti r = MOOList [ "", "", [ "pitiful", "pitiable" ] ]
#32 Mr. Spell. pith r = MOOList [ "", "", [ "pithy", "pith" ] ]
#32 Mr. Spell. mur r = MOOList [ "", "dikr", [ "Murphy", "murmur", "mural" ] ]
#32 Mr. Spell. climat r = MOOList [ "", "", [ "climatology", "climatic", "climate" ] ]
#32 Mr. Spell. obstr r = MOOList [ "u", "", [ "obstruent", "obstruct" ] ]
#32 Mr. Spell. mus r = MOOList [ "", "cehiklt", [ "mussel" ] ]
#32 Mr. Spell. Summa r = MOOList [ "", "rt", [ "summand" ] ]
#32 Mr. Spell. mut r = MOOList [ "", "aitu", [ "mute" ] ]
#32 Mr. Spell. pitc r = MOOList [ "h", "", [ "pitchstone", "pitchfork", "pitchblende", "pitch" ] ]
#32 Mr. Spell. moder r = MOOList [ "", "", [ "modern", "moderate" ] ]
#32 Mr. Spell. anim r = MOOList [ "", "a", [ "animosity", "animism" ] ]
#32 Mr. Spell. europea r = MOOList [ "n", "", [ "europeans", "European" ] ]
#32 Mr. Spell. anio r = MOOList [ "n", "", [ "anionic", "anion" ] ]
#32 Mr. Spell. anis r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. pist r = MOOList [ "", "o", [ "pistachio" ] ]
#32 Mr. Spell. Heal r = MOOList [ "", "t", [ "Healy", "Healey", "heal" ] ]
#32 Mr. Spell. importa r = MOOList [ "", "", [ "importation", "important" ] ]
#32 Mr. Spell. Pauli r = MOOList [ "", "", [ "Pauline", "Pauli" ] ]
#32 Mr. Spell. kidnapp r = MOOList [ "", "", [ "kidnapping", "kidnapped" ] ]
#32 Mr. Spell. Pauls r = MOOList [ "", "", [ "Paulson", "Paulsen" ] ]
#32 Mr. Spell. amphib r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. roya r = MOOList [ "l", "", [ "royalty", "royal" ] ]
#32 Mr. Spell. pisc r = MOOList [ "", "", [ "Pisces", "Piscataway" ] ]
#32 Mr. Spell. piro r = MOOList [ "", "", [ "pirouette", "pirogue" ] ]
#32 Mr. Spell. lovela r = MOOList [ "", "", [ "Loveland", "Lovelace" ] ]
#32 Mr. Spell. Knig r = MOOList [ "ht", "", [ "Knightsbridge", "knight" ] ]
#32 Mr. Spell. anhy r = MOOList [ "dr", "i", [ "anhydrous" ] ]
#32 Mr. Spell. fluo r = MOOList [ "r", "ei", [ "fluorspar", "fluorocarbon" ] ]
#32 Mr. Spell. parliamenta r = MOOList [ "r", "", [ "parliamentary", "parliamentarian" ] ]
#32 Mr. Spell. haza r = MOOList [ "rd", "", [ "hazardous", "hazard" ] ]
#32 Mr. Spell. flus r = MOOList [ "", "", [ "fluster", "flush" ] ]
#32 Mr. Spell. haze r = MOOList [ "", "l", [ "haze" ] ]
#32 Mr. Spell. flut r = MOOList [ "", "", [ "flutter", "flute" ] ]
#32 Mr. Spell. Schwa r = MOOList [ "", "", [ "Schwartz", "Schwab" ] ]
#32 Mr. Spell. sanguine r = MOOList [ "", "", [ "sanguineous", "sanguine" ] ]
#32 Mr. Spell. pira r = MOOList [ "", "", [ "pirate", "Piraeus", "piracy" ] ]
#32 Mr. Spell. symbi r = MOOList [ "o", "", [ "symbiotic", "symbiosis" ] ]
#32 Mr. Spell. Kur r = MOOList [ "", "", [ "Kurt", "Kurd" ] ]
#32 Mr. Spell. suggesti r = MOOList [ "", "", [ "suggestive", "suggestion", "suggestible" ] ]
#32 Mr. Spell. mye r = MOOList [ "", "l", [ "Myers" ] ]
#32 Mr. Spell. manumit r = MOOList [ "", "", [ "manumitted", "manumit" ] ]
#32 Mr. Spell. mirac r = MOOList [ "", "", [ "miraculous", "miracle" ] ]
#32 Mr. Spell. theis r = MOOList [ "", "", [ "theist", "theism" ] ]
#32 Mr. Spell. proscr r = MOOList [ "i", "", [ "proscription", "proscribe" ] ]
#32 Mr. Spell. exposi r = MOOList [ "t", "o", [ "exposition", "exposit" ] ]
#32 Mr. Spell. leadsm r = MOOList [ "", "", [ "leadsmen", "leadsman" ] ]
#32 Mr. Spell. maje r = MOOList [ "st", "", [ "majesty", "majestic" ] ]
#32 Mr. Spell. symbo r = MOOList [ "l", "", [ "symbolic", "symbol" ] ]
#32 Mr. Spell. barone r = MOOList [ "", "", [ "baronet", "baroness" ] ]
#32 Mr. Spell. testam r = MOOList [ "ent", "", [ "testamentary", "testament" ] ]
#32 Mr. Spell. revela r = MOOList [ "t", "", [ "revelatory", "revelation" ] ]
#32 Mr. Spell. mail r = MOOList [ "", "m", [ "mailing", "mailbox", "mail" ] ]
#32 Mr. Spell. Armc r = MOOList [ "", "", [ "Armco", "armchair" ] ]
#32 Mr. Spell. meeti r = MOOList [ "ng", "", [ "meetings", "meeting", "meetinghouse" ] ]
#32 Mr. Spell. turbin r = MOOList [ "", "", [ "turbine", "turbinate" ] ]
#32 Mr. Spell. instit r = MOOList [ "ut", "", [ "institution", "institute" ] ]
#32 Mr. Spell. logi r = MOOList [ "", "c", [ "logistic" ] ]
#32 Mr. Spell. confide r = MOOList [ "", "n", [ "confide" ] ]
#32 Mr. Spell. instil r = MOOList [ "l", "", [ "instillation", "instill" ] ]
#32 Mr. Spell. Armo r = MOOList [ "", "", [ "Armour", "Armonk", "armoire" ] ]
#32 Mr. Spell. bail r = MOOList [ "", "", [ "bailiff", "Bailey", "bail" ] ]
#32 Mr. Spell. turbid r = MOOList [ "", "", [ "turbidity", "turbid" ] ]
#32 Mr. Spell. myo r = MOOList [ "", "cp", [ "myosin", "myoglobin", "myofibril" ] ]
#32 Mr. Spell. instin r = MOOList [ "ct", "", [ "instinctual", "instinct" ] ]
#32 Mr. Spell. confida r = MOOList [ "nt", "", [ "confidante", "confidant" ] ]
#32 Mr. Spell. numi r = MOOList [ "", "s", [ "numinous" ] ]
#32 Mr. Spell. probab r = MOOList [ "", "", [ "probably", "probabilist" ] ]
#32 Mr. Spell. myr r = MOOList [ "", "", [ "myrtle", "myrrh", "Myron", "myriad", "Myra" ] ]
#32 Mr. Spell. logg r = MOOList [ "", "", [ "logging", "loggerhead" ] ]
#32 Mr. Spell. aggres r = MOOList [ "s", "i", [ "aggressor" ] ]
#32 Mr. Spell. mys r = MOOList [ "", "t", [ "myself" ] ]
#32 Mr. Spell. myt r = MOOList [ "h", "", [ "mythology", "mythic", "myth" ] ]
#32 Mr. Spell. confirma r = MOOList [ "t", "", [ "confirmatory", "confirmation" ] ]
#32 Mr. Spell. complic r = MOOList [ "", "", [ "complicity", "complicate" ] ]
#32 Mr. Spell. productiv r = MOOList [ "", "", [ "productivity", "productive" ] ]
#32 Mr. Spell. complet r = MOOList [ "", "e", [ "completion" ] ]
#32 Mr. Spell. Wain r = MOOList [ "", "", [ "Wainwright", "wainscot" ] ]
#32 Mr. Spell. loga r = MOOList [ "", "r", [ "Logan" ] ]
#32 Mr. Spell. complem r = MOOList [ "ent", "a", [ "complement" ] ]
#32 Mr. Spell. Arle r = MOOList [ "n", "", [ "Arlene", "Arlen" ] ]
#32 Mr. Spell. nume r = MOOList [ "r", "aio", [ ] ]
#32 Mr. Spell. numb r = MOOList [ "", "e", [ "numb" ] ]
#32 Mr. Spell. cumu r = MOOList [ "l", "", [ "cumulus", "cumulate" ] ]
#32 Mr. Spell. Assai r = MOOList [ "", "l", [ "assai" ] ]
#32 Mr. Spell. contriv r = MOOList [ "", "", [ "contrive", "contrivance" ] ]
#32 Mr. Spell. cumb r = MOOList [ "er", "", [ "cumbersome", "Cumberland" ] ]
#32 Mr. Spell. contrit r = MOOList [ "", "", [ "contrition", "contrite" ] ]
#32 Mr. Spell. maha r = MOOList [ "yan", "", [ "Mahayanist", "Mahayana" ] ]
#32 Mr. Spell. complex r = MOOList [ "", "", [ "complexion", "complex" ] ]
#32 Mr. Spell. Wait r = MOOList [ "", "", [ "waitress", "Waite", "wait" ] ]
#32 Mr. Spell. magg r = MOOList [ "", "o", [ "Maggie" ] ]
#32 Mr. Spell. magi r = MOOList [ "", "cs", [ "magi" ] ]
#32 Mr. Spell. brin r = MOOList [ "", "dkg", [ "briny", "brine" ] ]
#32 Mr. Spell. brim r = MOOList [ "", "", [ "brimstone", "brimful", "brim" ] ]
#32 Mr. Spell. Arka r = MOOList [ "nsa", "", [ "Arkansas", "Arkansan" ] ]
#32 Mr. Spell. culp r = MOOList [ "", "a", [ "culprit" ] ]
#32 Mr. Spell. cult r = MOOList [ "", "iu", [ "cult" ] ]
#32 Mr. Spell. Britt r = MOOList [ "", "", [ "brittle", "Britten", "Brittany" ] ]
#32 Mr. Spell. bris r = MOOList [ "", "t", [ "brisk", "Brisbane" ] ]
#32 Mr. Spell. Atlantic r = MOOList [ "", "", [ "Atlantica", "atlantic" ] ]
#32 Mr. Spell. culv r = MOOList [ "er", "", [ "culvert", "Culver" ] ]
#32 Mr. Spell. magn r = MOOList [ "", "aeiu", [ "magnolia" ] ]
#32 Mr. Spell. cause r = MOOList [ "", "", [ "causes", "caused", "cause" ] ]
#32 Mr. Spell. sinus r = MOOList [ "", "o", [ "sinus" ] ]
#32 Mr. Spell. Brazil r = MOOList [ "", "", [ "Brazilian", "Brazil" ] ]
#32 Mr. Spell. brib r = MOOList [ "e", "", [ "bribery", "bribe" ] ]
#32 Mr. Spell. causa r = MOOList [ "", "", [ "causate", "causal" ] ]
#32 Mr. Spell. bria r = MOOList [ "", "", [ "briar", "Brian" ] ]
#32 Mr. Spell. brid r = MOOList [ "", "eg", [ "bridle", "bridal" ] ]
#32 Mr. Spell. intimat r = MOOList [ "e", "", [ "intimater", "intimate" ] ]
#32 Mr. Spell. bric r = MOOList [ "", "k", [ "Brice" ] ]
#32 Mr. Spell. brie r = MOOList [ "f", "", [ "briefcase", "brief" ] ]
#32 Mr. Spell. brig r = MOOList [ "", "ah", [ "Briggs", "brig" ] ]
#32 Mr. Spell. sagac r = MOOList [ "i", "", [ "sagacity", "sagacious" ] ]
#32 Mr. Spell. Lagr r = MOOList [ "ang", "", [ "Lagrangian", "Lagrange" ] ]
#32 Mr. Spell. bagg r = MOOList [ "", "", [ "baggy", "bagging", "baggage" ] ]
#32 Mr. Spell. Dicke r = MOOList [ "", "", [ "dickey", "Dickerson", "dickens" ] ]
#32 Mr. Spell. lodg r = MOOList [ "e", "", [ "lodgepole", "lodge" ] ]
#32 Mr. Spell. Israeli r = MOOList [ "", "", [ "Israelite", "Israeli" ] ]
#32 Mr. Spell. Clause r = MOOList [ "", "", [ "Clausen", "clause" ] ]
#32 Mr. Spell. folia r = MOOList [ "", "", [ "foliate", "foliage" ] ]
#32 Mr. Spell. locu r = MOOList [ "", "s", [ "locutor" ] ]
#32 Mr. Spell. diffr r = MOOList [ "act", "", [ "diffractometer", "diffract" ] ]
#32 Mr. Spell. contrib r = MOOList [ "ut", "o", [ "contribution", "contribute" ] ]
#32 Mr. Spell. diffi r = MOOList [ "", "c", [ "diffident" ] ]
#32 Mr. Spell. Bulb r = MOOList [ "", "", [ "bulblet", "bulb" ] ]
#32 Mr. Spell. diffe r = MOOList [ "", "or", [ ] ]
#32 Mr. Spell. Methu r = MOOList [ "", "", [ "Methuselah", "Methuen" ] ]
#32 Mr. Spell. text r = MOOList [ "", "u", [ "Textron", "textile", "textbook", "text" ] ]
#32 Mr. Spell. ninete r = MOOList [ "en", "", [ "nineteenth", "nineteen" ] ]
#32 Mr. Spell. loca r = MOOList [ "", "lt", [ ] ]
#32 Mr. Spell. mads r = MOOList [ "", "", [ "madstone", "Madsen" ] ]
#32 Mr. Spell. schemat r = MOOList [ "", "", [ "schematic", "schemata" ] ]
#32 Mr. Spell. loco r = MOOList [ "", "m", [ "locoweed" ] ]
#32 Mr. Spell. Lago r = MOOList [ "", "", [ "Lagos", "lagoon" ] ]
#32 Mr. Spell. diffu r = MOOList [ "s", "i", [ "diffuse" ] ]
#32 Mr. Spell. theol r = MOOList [ "og", "", [ "theology", "theologian" ] ]
#32 Mr. Spell. lobs r = MOOList [ "", "", [ "lobster", "lobscouse" ] ]
#32 Mr. Spell. texa r = MOOList [ "", "", [ "Texas", "Texan", "Texaco" ] ]
#32 Mr. Spell. lobu r = MOOList [ "l", "", [ "lobule", "lobular" ] ]
#32 Mr. Spell. child r = MOOList [ "", "", [ "children", "childish", "childbirth", "child" ] ]
#32 Mr. Spell. prosec r = MOOList [ "ut", "", [ "prosecutor", "prosecution", "prosecute" ] ]
#32 Mr. Spell. mada r = MOOList [ "", "m", [ "Madagascar" ] ]
#32 Mr. Spell. Koda r = MOOList [ "", "", [ "kodak", "Kodachrome" ] ]
#32 Mr. Spell. madm r = MOOList [ "", "", [ "madmen", "madman" ] ]
#32 Mr. Spell. complai r = MOOList [ "", "n", [ "complaisant" ] ]
#32 Mr. Spell. brev r = MOOList [ "", "e", [ "brevity" ] ]
#32 Mr. Spell. brew r = MOOList [ "", "", [ "Brewster", "brewery", "brew" ] ]
#32 Mr. Spell. macr r = MOOList [ "o", "ms", [ "macrophage", "macro" ] ]
#32 Mr. Spell. theor r = MOOList [ "", "e", [ "theory", "theorist" ] ]
#32 Mr. Spell. selectm r = MOOList [ "", "", [ "selectmen", "selectman" ] ]
#32 Mr. Spell. Perse r = MOOList [ "", "cv", [ "Perseus" ] ]
#32 Mr. Spell. Joann r = MOOList [ "", "", [ "Joanne", "Joanna" ] ]
#32 Mr. Spell. bact r = MOOList [ "eri", "a", [ "bacterium" ] ]
#32 Mr. Spell. nad r = MOOList [ "i", "", [ "nadir", "Nadine" ] ]
#32 Mr. Spell. bree r = MOOList [ "", "z", [ "breed", "breech" ] ]
#32 Mr. Spell. revere r = MOOList [ "", "n", [ "revere" ] ]
#32 Mr. Spell. loat r = MOOList [ "h", "", [ "loathsome", "loathe", "loath" ] ]
#32 Mr. Spell. spokes r = MOOList [ "", "m", [ "spokesperson" ] ]
#32 Mr. Spell. nai r = MOOList [ "", "rv", [ "nail", "naiad" ] ]
#32 Mr. Spell. maca r = MOOList [ "", "", [ "Macassar", "MacArthur", "macaque", "macabre" ] ]
#32 Mr. Spell. thenc r = MOOList [ "e", "", [ "thenceforth", "thence" ] ]
#32 Mr. Spell. nak r = MOOList [ "", "", [ "naked", "Nakayama" ] ]
#32 Mr. Spell. brem r = MOOList [ "", "", [ "bremsstrahlung", "Bremen" ] ]
#32 Mr. Spell. nam r = MOOList [ "", "e", [ "naming" ] ]
#32 Mr. Spell. captio r = MOOList [ "", "", [ "captious", "caption" ] ]
#32 Mr. Spell. nap r = MOOList [ "", "o", [ "Naples", "napkin", "nap" ] ]
#32 Mr. Spell. captiv r = MOOList [ "", "", [ "captive", "captivate" ] ]
#32 Mr. Spell. nar r = MOOList [ "", "cr", [ "nary", "Narbonne" ] ]
#32 Mr. Spell. pecul r = MOOList [ "", "", [ "peculiar", "peculate" ] ]
#32 Mr. Spell. bach r = MOOList [ "", "", [ "bachelor", "Bach" ] ]
#32 Mr. Spell. baci r = MOOList [ "ll", "", [ "bacillus", "bacilli" ] ]
#32 Mr. Spell. back r = MOOList [ "", "blpsw", [ "backyard", "backup", "backtrack", "backorder", "backhand", "background", "backfill", "backdrop", "back" ] ]
#32 Mr. Spell. loam r = MOOList [ "", "", [ "loamy", "loam" ] ]
#32 Mr. Spell. scient r = MOOList [ "i", "", [ "scientist", "scientific" ] ]
#32 Mr. Spell. brea r = MOOList [ "", "dkst", [ "bream", "breach" ] ]
#32 Mr. Spell. Peach r = MOOList [ "", "", [ "Peachtree", "peach" ] ]
#32 Mr. Spell. conca r = MOOList [ "", "", [ "concave", "concatenate" ] ]
#32 Mr. Spell. conce r = MOOList [ "", "inprs", [ "concede", "conceal" ] ]
#32 Mr. Spell. chinc r = MOOList [ "h", "", [ "chinchilla", "chinch" ] ]
#32 Mr. Spell. concl r = MOOList [ "", "u", [ "conclave" ] ]
#32 Mr. Spell. follo r = MOOList [ "w", "e", [ "following", "follow" ] ]
#32 Mr. Spell. conci r = MOOList [ "", "ls", [ "concierge" ] ]
#32 Mr. Spell. folli r = MOOList [ "c", "", [ "follicular", "follicle" ] ]
#32 Mr. Spell. conco r = MOOList [ "", "r", [ "concourse", "concomitant", "concoct" ] ]
#32 Mr. Spell. nas r = MOOList [ "", "Aht", [ "Nassau", "nascent" ] ]
#32 Mr. Spell. nau r = MOOList [ "", "st", [ "naughty" ] ]
#32 Mr. Spell. nav r = MOOList [ "", "aei", [ "navy" ] ]
#32 Mr. Spell. concr r = MOOList [ "et", "", [ "concretion", "concrete" ] ]
#32 Mr. Spell. concu r = MOOList [ "", "r", [ "concussion", "concubine" ] ]
#32 Mr. Spell. Stephens r = MOOList [ "", "", [ "Stephenson", "Stephens" ] ]
#32 Mr. Spell. tablesp r = MOOList [ "oon", "", [ "tablespoonful", "tablespoon" ] ]
#32 Mr. Spell. Magnu r = MOOList [ "", "", [ "Magnuson", "magnum" ] ]
#32 Mr. Spell. conde r = MOOList [ "", "mns", [ ] ]
#32 Mr. Spell. condi r = MOOList [ "", "", [ "condition", "condiment" ] ]
#32 Mr. Spell. folks r = MOOList [ "", "", [ "folksy", "folksong" ] ]
#32 Mr. Spell. testim r = MOOList [ "on", "", [ "testimony", "testimonial" ] ]
#32 Mr. Spell. Seve r = MOOList [ "", "nr", [ ] ]
#32 Mr. Spell. condo r = MOOList [ "", "", [ "condone", "condolence" ] ]
#32 Mr. Spell. condu r = MOOList [ "", "c", [ "conduit" ] ]
#32 Mr. Spell. testic r = MOOList [ "", "", [ "testicular", "testicle" ] ]
#32 Mr. Spell. tetr r = MOOList [ "a", "fh", [ "tetravalent", "tetragonal", "tetrachloride" ] ]
#32 Mr. Spell. Sewa r = MOOList [ "", "", [ "Seward", "sewage" ] ]
#32 Mr. Spell. chill r = MOOList [ "", "", [ "chilly", "chill" ] ]
#32 Mr. Spell. accentu r = MOOList [ "a", "", [ "accentuate", "accentual" ] ]
#32 Mr. Spell. observa r = MOOList [ "", "t", [ "observant" ] ]
#32 Mr. Spell. Assim r = MOOList [ "ila", "", [ "Assimilate", "assimilable" ] ]
#32 Mr. Spell. Lab r = MOOList [ "", "ior", [ "labyrinth", "label", "Laban", "lab" ] ]
#32 Mr. Spell. tess r = MOOList [ "", "", [ "tessellate", "Tess" ] ]
#32 Mr. Spell. test r = MOOList [ "", "ai", [ "tests", "testy", "testes", "testbed", "test" ] ]
#32 Mr. Spell. hardbo r = MOOList [ "", "", [ "hardboiled", "hardboard" ] ]
#32 Mr. Spell. brav r = MOOList [ "", "e", [ "bravura", "bravo", "bravado" ] ]
#32 Mr. Spell. befog r = MOOList [ "", "", [ "befogging", "befog" ] ]
#32 Mr. Spell. Lao r = MOOList [ "", "", [ "Laotian", "Laos", "Laocoon", "Lao" ] ]
#32 Mr. Spell. vitrio r = MOOList [ "l", "", [ "vitriolic", "vitriol" ] ]
#32 Mr. Spell. Lan r = MOOList [ "", "cdgkt", [ "Lansing", "lane", "Lana" ] ]
#32 Mr. Spell. Lam r = MOOList [ "", "abeip", [ "lam" ] ]
#32 Mr. Spell. interpola r = MOOList [ "t", "", [ "interpolatory", "interpolate" ] ]
#32 Mr. Spell. braz r = MOOList [ "", "i", [ "Brazzaville", "brazen" ] ]
#32 Mr. Spell. Lak r = MOOList [ "e", "", [ "lakeside", "Lakehurst", "lake" ] ]
#32 Mr. Spell. alfred r = MOOList [ "", "", [ "Alfredo", "Alfred" ] ]
#32 Mr. Spell. Lai r = MOOList [ "", "d", [ "laity", "laissez", "lair", "lain" ] ]
#32 Mr. Spell. counte r = MOOList [ "", "r", [ "countenance" ] ]
#32 Mr. Spell. hydropho r = MOOList [ "bi", "", [ "hydrophobic", "hydrophobia" ] ]
#32 Mr. Spell. hurra r = MOOList [ "", "", [ "hurray", "hurrah" ] ]
#32 Mr. Spell. neg r = MOOList [ "", "lor", [ "negate" ] ]
#32 Mr. Spell. county r = MOOList [ "", "", [ "countywide", "county" ] ]
#32 Mr. Spell. alumna r = MOOList [ "", "", [ "alumnae", "alumna" ] ]
#32 Mr. Spell. nei r = MOOList [ "", "", [ "neither", "Neil" ] ]
#32 Mr. Spell. cudd r = MOOList [ "l", "", [ "cuddly", "cuddle" ] ]
#32 Mr. Spell. brac r = MOOList [ "", "ek", [ "bract" ] ]
#32 Mr. Spell. mustac r = MOOList [ "h", "", [ "mustachio", "mustache" ] ]
#32 Mr. Spell. terr r = MOOList [ "", "aei", [ "terry", "terror" ] ]
#32 Mr. Spell. neo r = MOOList [ "", "lnp", [ "neodymium", "neoclassic" ] ]
#32 Mr. Spell. nep r = MOOList [ "", "t", [ "nephew", "nepenthe", "Nepal" ] ]
#32 Mr. Spell. countr r = MOOList [ "", "yi", [ ] ]
#32 Mr. Spell. brak r = MOOList [ "e", "", [ "brakeman", "brake" ] ]
#32 Mr. Spell. barbari r = MOOList [ "", "", [ "barbarism", "barbaric", "barbarian" ] ]
#32 Mr. Spell. nes r = MOOList [ "", "t", [ "Ness" ] ]
#32 Mr. Spell. bran r = MOOList [ "", "dc", [ "brant", "Braniff", "bran" ] ]
#32 Mr. Spell. net r = MOOList [ "", "ht", [ "network", "net" ] ]
#32 Mr. Spell. Arca r = MOOList [ "", "dn", [ ] ]
#32 Mr. Spell. neu r = MOOList [ "", "rt", [ "Neumann" ] ]
#32 Mr. Spell. tern r = MOOList [ "", "", [ "ternary", "tern" ] ]
#32 Mr. Spell. inscri r = MOOList [ "", "", [ "inscription", "inscribe" ] ]
#32 Mr. Spell. term r = MOOList [ "", "i", [ "terms", "term" ] ]
#32 Mr. Spell. terp r = MOOList [ "sichore", "", [ "terpsichorean", "Terpsichore" ] ]
#32 Mr. Spell. tera r = MOOList [ "to", "", [ "teratology", "teratogenic" ] ]
#32 Mr. Spell. neb r = MOOList [ "", "u", [ "Nebraska" ] ]
#32 Mr. Spell. corporat r = MOOList [ "", "i", [ "corporate" ] ]
#32 Mr. Spell. nec r = MOOList [ "", "ekrt", [ ] ]
#32 Mr. Spell. nee r = MOOList [ "", "d", [ "nee" ] ]
#32 Mr. Spell. Heus r = MOOList [ "e", "", [ "Heuser", "Heusen" ] ]
#32 Mr. Spell. conge r = MOOList [ "", "ns", [ "congeal" ] ]
#32 Mr. Spell. O'Co r = MOOList [ "nn", "", [ "O'Connor", "O'Connell" ] ]
#32 Mr. Spell. complete r = MOOList [ "", "", [ "completely", "complete" ] ]
#32 Mr. Spell. Hete r = MOOList [ "ro", "gs", [ "heterozygous", "heterodyne", "heterocyclic" ] ]
#32 Mr. Spell. congr r = MOOList [ "", "ae", [ "congruent" ] ]
#32 Mr. Spell. Hett r = MOOList [ "", "", [ "Hetty", "Hettie" ] ]
#32 Mr. Spell. controv r = MOOList [ "er", "s", [ "controvertible" ] ]
#32 Mr. Spell. tetrahedra r = MOOList [ "", "", [ "tetrahedral", "tetrahedra" ] ]
#32 Mr. Spell. Emma r = MOOList [ "", "", [ "Emmanuel", "emma" ] ]
#32 Mr. Spell. pedag r = MOOList [ "og", "", [ "pedagogy", "pedagogue", "pedagogic" ] ]
#32 Mr. Spell. pedan r = MOOList [ "t", "", [ "pedantry", "pedantic", "pedant" ] ]
#32 Mr. Spell. befor r = MOOList [ "e", "", [ "beforehand", "before" ] ]
#32 Mr. Spell. Sera r = MOOList [ "", "p", [ "seraglio", "sera" ] ]
#32 Mr. Spell. Arab r = MOOList [ "", "i", [ "Araby", "arabesque", "Arab" ] ]
#32 Mr. Spell. Budd r = MOOList [ "", "h", [ "buddy", "Budd" ] ]
#32 Mr. Spell. baker r = MOOList [ "", "", [ "bakery", "Bakersfield" ] ]
#32 Mr. Spell. Rhode r = MOOList [ "", "s", [ "Rhode" ] ]
#32 Mr. Spell. Hesi r = MOOList [ "ta", "t", [ "hesitant" ] ]
#32 Mr. Spell. Hess r = MOOList [ "", "", [ "Hessian", "Hesse", "Hess" ] ]
#32 Mr. Spell. Thur r = MOOList [ "", "", [ "Thursday", "Thurman" ] ]
#32 Mr. Spell. prosod r = MOOList [ "", "", [ "prosody", "prosodic" ] ]
#32 Mr. Spell. conif r = MOOList [ "er", "", [ "coniferous", "conifer" ] ]
#32 Mr. Spell. Leh r = MOOList [ "", "", [ "Lehman", "Lehigh" ] ]
#32 Mr. Spell. neuroa r = MOOList [ "n", "a", [ "neuroanotomy" ] ]
#32 Mr. Spell. Leb r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. Lea r = MOOList [ "", "cdfknprstv", [ "league", "lea" ] ]
#32 Mr. Spell. Herb r = MOOList [ "", "", [ "Herbert", "herb" ] ]
#32 Mr. Spell. Hera r = MOOList [ "", "", [ "herald", "Heraclitus", "Hera" ] ]
#32 Mr. Spell. Herc r = MOOList [ "ule", "", [ "Hercules", "Herculean" ] ]
#32 Mr. Spell. complim r = MOOList [ "ent", "", [ "complimentary", "compliment" ] ]
#32 Mr. Spell. graves r = MOOList [ "", "", [ "gravestone", "Graves" ] ]
#32 Mr. Spell. neuron r = MOOList [ "", "", [ "neuronal", "neuron" ] ]
#32 Mr. Spell. neurop r = MOOList [ "", "", [ "neuropsychiatric", "neurophysiology", "neuropathology" ] ]
#32 Mr. Spell. Leo r = MOOList [ "", "np", [ "Leo" ] ]
#32 Mr. Spell. neuros r = MOOList [ "", "", [ "neurosis", "neuroses" ] ]
#32 Mr. Spell. Len r = MOOList [ "", "gint", [ "lens", "Lenore", "lend", "Lena", "Len" ] ]
#32 Mr. Spell. Hert r = MOOList [ "z", "", [ "Hertzog", "hertz" ] ]
#32 Mr. Spell. anyw r = MOOList [ "", "", [ "anywhere", "anyway" ] ]
#32 Mr. Spell. Herm r = MOOList [ "", "aei", [ "Hermosa" ] ]
#32 Mr. Spell. Lei r = MOOList [ "", "gt", [ "leisure", "Leila" ] ]
#32 Mr. Spell. Hero r = MOOList [ "", "i", [ "heron", "heroes", "Herodotus", "hero" ] ]
#32 Mr. Spell. control r = MOOList [ "", "l", [ "control" ] ]
#32 Mr. Spell. tenu r = MOOList [ "", "", [ "tenure", "tenuous" ] ]
#32 Mr. Spell. nim r = MOOList [ "", "b", [ "NIMH" ] ]
#32 Mr. Spell. nin r = MOOList [ "", "e", [ "ninth", "Nina" ] ]
#32 Mr. Spell. confe r = MOOList [ "", "cdrs", [ ] ]
#32 Mr. Spell. nio r = MOOList [ "b", "", [ "niobium", "Niobe" ] ]
#32 Mr. Spell. nip r = MOOList [ "", "p", [ "nip" ] ]
#32 Mr. Spell. Emig r = MOOList [ "ra", "", [ "emigrate", "emigrant" ] ]
#32 Mr. Spell. anyb r = MOOList [ "ody", "", [ "anybody'd", "anybody" ] ]
#32 Mr. Spell. ingra r = MOOList [ "", "t", [ "Ingram" ] ]
#32 Mr. Spell. confi r = MOOList [ "", "dgrs", [ "confine" ] ]
#32 Mr. Spell. Emil r = MOOList [ "", "", [ "Emily", "Emilio", "Emile", "Emil" ] ]
#32 Mr. Spell. nit r = MOOList [ "", "r", [ "nitty", "nitpick", "nit" ] ]
#32 Mr. Spell. confo r = MOOList [ "", "r", [ "confound", "confocal" ] ]
#32 Mr. Spell. confl r = MOOList [ "", "", [ "confluent", "conflict", "conflagrate" ] ]
#32 Mr. Spell. Chican r = MOOList [ "", "", [ "Chicano", "chicanery" ] ]
#32 Mr. Spell. teno r = MOOList [ "", "", [ "tenor", "tenon" ] ]
#32 Mr. Spell. confr r = MOOList [ "", "o", [ "confrere" ] ]
#32 Mr. Spell. tent r = MOOList [ "", "a", [ "tenth", "tenterhooks", "tent" ] ]
#32 Mr. Spell. tens r = MOOList [ "", "i", [ "tenspot", "tensor", "tense" ] ]
#32 Mr. Spell. tene r = MOOList [ "", "", [ "tenet", "tenement", "tenebrous" ] ]
#32 Mr. Spell. facet r = MOOList [ "", "", [ "facetious", "facet" ] ]
#32 Mr. Spell. Peril r = MOOList [ "", "", [ "perilous", "Perilla", "peril" ] ]
#32 Mr. Spell. muddl r = MOOList [ "e", "", [ "muddlehead", "muddle" ] ]
#32 Mr. Spell. nia r = MOOList [ "", "", [ "Niamey", "Niagara", "niacin" ] ]
#32 Mr. Spell. nib r = MOOList [ "", "", [ "Nibelung", "nibble", "nib" ] ]
#32 Mr. Spell. nic r = MOOList [ "", "ehko", [ "Nicaragua" ] ]
#32 Mr. Spell. tena r = MOOList [ "", "c", [ "tenant", "tenable" ] ]
#32 Mr. Spell. nih r = MOOList [ "", "i", [ "NIH" ] ]
#32 Mr. Spell. chirp r = MOOList [ "", "", [ "chirps", "chirp" ] ]
#32 Mr. Spell. tend r = MOOList [ "", "e", [ "tendon", "tend" ] ]
#32 Mr. Spell. verdi r = MOOList [ "", "", [ "verdict", "Verdi" ] ]
#32 Mr. Spell. mimick r = MOOList [ "", "", [ "mimicking", "mimicked" ] ]
#32 Mr. Spell. wiggl r = MOOList [ "", "", [ "wiggly", "wiggle" ] ]
#32 Mr. Spell. Carol r = MOOList [ "", "i", [ "Carolyn", "carol" ] ]
#32 Mr. Spell. conspira r = MOOList [ "", "t", [ "conspiracy" ] ]
#32 Mr. Spell. wiggi r = MOOList [ "n", "", [ "Wiggins", "wigging" ] ]
#32 Mr. Spell. adulte r = MOOList [ "r", "", [ "adultery", "adulterous", "adulterate" ] ]
#32 Mr. Spell. chiva r = MOOList [ "lr", "", [ "chivalry", "chivalrous" ] ]
#32 Mr. Spell. caution r = MOOList [ "", "", [ "cautionary", "caution" ] ]
#32 Mr. Spell. fields r = MOOList [ "", "", [ "fields", "fieldstone" ] ]
#32 Mr. Spell. Beau r = MOOList [ "", "t", [ "beaux", "Beauregard", "Beaumont", "Beaujolais", "beau" ] ]
#32 Mr. Spell. Barnet r = MOOList [ "", "", [ "Barnett", "Barnet" ] ]
#32 Mr. Spell. Titu r = MOOList [ "", "", [ "Titus", "titular" ] ]
#32 Mr. Spell. loya r = MOOList [ "l", "", [ "loyalty", "loyal" ] ]
#32 Mr. Spell. skull r = MOOList [ "", "", [ "skullduggery", "skullcap", "skull" ] ]
#32 Mr. Spell. groun r = MOOList [ "d", "s", [ "groundwork", "ground" ] ]
#32 Mr. Spell. group r = MOOList [ "", "", [ "groups", "groupoid", "group" ] ]
#32 Mr. Spell. decoll r = MOOList [ "", "", [ "decollimate", "decolletage" ] ]
#32 Mr. Spell. washbo r = MOOList [ "", "", [ "washbowl", "washboard" ] ]
#32 Mr. Spell. surge r = MOOList [ "", "", [ "surgery", "surgeon", "surge" ] ]
#32 Mr. Spell. tempt r = MOOList [ "", "", [ "temptress", "temptation", "tempt" ] ]
#32 Mr. Spell. lumino r = MOOList [ "", "", [ "luminous", "luminosity" ] ]
#32 Mr. Spell. Carne r = MOOList [ "", "", [ "carney", "Carnegie", "carne" ] ]
#32 Mr. Spell. saxon r = MOOList [ "", "", [ "Saxony", "Saxon" ] ]
#32 Mr. Spell. Augus r = MOOList [ "t", "", [ "Augustus", "Augustine", "Augusta", "august" ] ]
#32 Mr. Spell. mayo r = MOOList [ "", "r", [ "mayonnaise", "Mayo" ] ]
#32 Mr. Spell. Lie r = MOOList [ "", "u", [ "lien", "Liechtenstein", "lie" ] ]
#32 Mr. Spell. maya r = MOOList [ "", "", [ "mayapple", "Maya" ] ]
#32 Mr. Spell. verba r = MOOList [ "", "", [ "verbatim", "verbal" ] ]
#32 Mr. Spell. harmonic r = MOOList [ "", "", [ "harmonica", "harmonic" ] ]
#32 Mr. Spell. Maxim r = MOOList [ "", "a", [ "maximum", "Maximilian", "maxim" ] ]
#32 Mr. Spell. maxi r = MOOList [ "", "m", [ "Maxine" ] ]
#32 Mr. Spell. Carme r = MOOList [ "", "", [ "Carmen", "Carmela" ] ]
#32 Mr. Spell. botto r = MOOList [ "m", "", [ "bottommost", "bottom" ] ]
#32 Mr. Spell. Transit r = MOOList [ "", "i", [ "transitory", "Transite", "transit" ] ]
#32 Mr. Spell. verbo r = MOOList [ "s", "", [ "verbosity", "verbose" ] ]
#32 Mr. Spell. Lis r = MOOList [ "", "t", [ "Lissajous", "lisp", "lisle", "Lise", "Lisbon", "Lisa" ] ]
#32 Mr. Spell. caver r = MOOList [ "n", "", [ "cavernous", "cavern" ] ]
#32 Mr. Spell. Somal r = MOOList [ "", "", [ "Somali", "somal" ] ]
#32 Mr. Spell. cavem r = MOOList [ "", "", [ "cavemen", "caveman" ] ]
#32 Mr. Spell. Lio r = MOOList [ "n", "e", [ "lion" ] ]
#32 Mr. Spell. Lin r = MOOList [ "", "degko", [ "Linus", "lint", "linseed", "liniment", "Lincoln", "Lin" ] ]
#32 Mr. Spell. Lim r = MOOList [ "", "beip", [ "limousine", "Lima", "lim" ] ]
#32 Mr. Spell. conje r = MOOList [ "ctur", "", [ "conjecture", "conjectural" ] ]
#32 Mr. Spell. conjo r = MOOList [ "in", "", [ "conjoint", "conjoin" ] ]
#32 Mr. Spell. courtes r = MOOList [ "", "", [ "courtesy", "courtesan" ] ]
#32 Mr. Spell. Carli r = MOOList [ "", "", [ "Carlisle", "Carlin" ] ]
#32 Mr. Spell. clean r = MOOList [ "", "", [ "cleanup", "cleanse", "clean" ] ]
#32 Mr. Spell. Chad r = MOOList [ "", "", [ "Chadwick", "Chad" ] ]
#32 Mr. Spell. bottl r = MOOList [ "e", "", [ "bottleneck", "bottle" ] ]
#32 Mr. Spell. facil r = MOOList [ "", "", [ "facilitate", "facile" ] ]
#32 Mr. Spell. Engl r = MOOList [ "", "aei", [ ] ]
#32 Mr. Spell. clear r = MOOList [ "", "", [ "Clearwater", "clearheaded", "clearance", "clear" ] ]
#32 Mr. Spell. conju r = MOOList [ "", "gn", [ "conjure" ] ]
#32 Mr. Spell. pacifis r = MOOList [ "", "", [ "pacifist", "pacifism" ] ]
#32 Mr. Spell. cleav r = MOOList [ "", "", [ "cleave", "cleavage" ] ]
#32 Mr. Spell. scie r = MOOList [ "n", "t", [ "science" ] ]
#32 Mr. Spell. lous r = MOOList [ "", "e", [ "lousy" ] ]
#32 Mr. Spell. woul r = MOOList [ "d", "", [ "wouldn't", "would" ] ]
#32 Mr. Spell. bryo r = MOOList [ "", "p", [ "bryozoa" ] ]
#32 Mr. Spell. decont r = MOOList [ "rol", "l", [ "decontrol" ] ]
#32 Mr. Spell. Antar r = MOOList [ "", "c", [ "Antares" ] ]
#32 Mr. Spell. deconv r = MOOList [ "ol", "", [ "deconvolve", "deconvolution" ] ]
#32 Mr. Spell. loud r = MOOList [ "", "s", [ "loud" ] ]
#32 Mr. Spell. Kowa r = MOOList [ "l", "", [ "Kowalski", "Kowalewski" ] ]
#32 Mr. Spell. schi r = MOOList [ "", "sz", [ "Schiller" ] ]
#32 Mr. Spell. schl r = MOOList [ "", "i", [ "Schloss", "Schlesinger" ] ]
#32 Mr. Spell. Antho r = MOOList [ "", "", [ "Anthony", "anthology" ] ]
#32 Mr. Spell. schn r = MOOList [ "", "a", [ "Schneider" ] ]
#32 Mr. Spell. stip r = MOOList [ "", "", [ "stipulate", "stipple", "stipend" ] ]
#32 Mr. Spell. scha r = MOOList [ "", "", [ "Schantz", "Schafer", "Schaefer" ] ]
#32 Mr. Spell. radian r = MOOList [ "", "", [ "radiant", "radian" ] ]
#32 Mr. Spell. circums r = MOOList [ "", "cpt", [ ] ]
#32 Mr. Spell. sche r = MOOList [ "", "m", [ "scherzo", "Schenectady", "schelling", "schedule" ] ]
#32 Mr. Spell. picnicke r = MOOList [ "", "", [ "picnicker", "picnicked" ] ]
#32 Mr. Spell. lott r = MOOList [ "", "e", [ "Lottie" ] ]
#32 Mr. Spell. circumv r = MOOList [ "ent", "", [ "circumvented", "circumvention", "circumvent" ] ]
#32 Mr. Spell. southwe r = MOOList [ "st", "", [ "southwestern", "southwest" ] ]
#32 Mr. Spell. stil r = MOOList [ "", "el", [ "stilt" ] ]
#32 Mr. Spell. bawd r = MOOList [ "", "", [ "bawdy", "bawd" ] ]
#32 Mr. Spell. stim r = MOOList [ "ul", "a", [ "stimulus", "stimuli" ] ]
#32 Mr. Spell. stin r = MOOList [ "", "gk", [ "stint" ] ]
#32 Mr. Spell. interfe r = MOOList [ "r", "e", [ "interferometer" ] ]
#32 Mr. Spell. nos r = MOOList [ "", "et", [ ] ]
#32 Mr. Spell. stic r = MOOList [ "k", "l", [ "sticky", "sticktight", "stickpin", "stick" ] ]
#32 Mr. Spell. not r = MOOList [ "", "aeio", [ "notwithstanding", "Nottingham", "Notre", "nothing", "notch", "not" ] ]
#32 Mr. Spell. nou r = MOOList [ "", "", [ "nouveau", "nourish", "noun", "Nouakchott" ] ]
#32 Mr. Spell. nov r = MOOList [ "", "aeio", [ "Nov" ] ]
#32 Mr. Spell. absorb r = MOOList [ "", "", [ "absorbent", "absorb" ] ]
#32 Mr. Spell. stif r = MOOList [ "", "f", [ "stifle" ] ]
#32 Mr. Spell. now r = MOOList [ "", "", [ "nowise", "nowhere", "nowaday", "now" ] ]
#32 Mr. Spell. verit r = MOOList [ "", "", [ "verity", "veritable" ] ]
#32 Mr. Spell. stig r = MOOList [ "ma", "", [ "stigmata", "stigma" ] ]
#32 Mr. Spell. fascic r = MOOList [ "", "", [ "fasciculate", "fascicle" ] ]
#32 Mr. Spell. Vouc r = MOOList [ "h", "", [ "vouchsafe", "vouch" ] ]
#32 Mr. Spell. metallurgi r = MOOList [ "", "", [ "metallurgist", "metallurgic" ] ]
#32 Mr. Spell. Polari r = MOOList [ "", "s", [ "polariton", "polarimeter" ] ]
#32 Mr. Spell. noc r = MOOList [ "turn", "", [ "nocturne", "nocturnal" ] ]
#32 Mr. Spell. Carri r = MOOList [ "", "", [ "carrion", "Carrie", "carriage" ] ]
#32 Mr. Spell. pedia r = MOOList [ "tric", "", [ "pediatrician", "pediatric" ] ]
#32 Mr. Spell. nod r = MOOList [ "", "u", [ "node", "nodal", "nod" ] ]
#32 Mr. Spell. absorp r = MOOList [ "ti", "", [ "absorptive", "absorption" ] ]
#32 Mr. Spell. loss r = MOOList [ "", "", [ "lossy", "loss" ] ]
#32 Mr. Spell. Frenchm r = MOOList [ "", "", [ "Frenchmen", "Frenchman" ] ]
#32 Mr. Spell. fascis r = MOOList [ "", "", [ "fascist", "fascism" ] ]
#32 Mr. Spell. noi r = MOOList [ "s", "e", [ "noisy" ] ]
#32 Mr. Spell. Carra r = MOOList [ "", "", [ "Carrara", "carrageen" ] ]
#32 Mr. Spell. typese r = MOOList [ "t", "t", [ "typeset" ] ]
#32 Mr. Spell. nom r = MOOList [ "", "aio", [ "nomenclature" ] ]
#32 Mr. Spell. non r = MOOList [ "", "ce", [ "non-recursive", "nonsensic", "nonogenarian", "nondescript", "non" ] ]
#32 Mr. Spell. noo r = MOOList [ "", "n", [ "noose", "nook", "noodle" ] ]
#32 Mr. Spell. matu r = MOOList [ "r", "", [ "mature", "maturate" ] ]
#32 Mr. Spell. worr r = MOOList [ "", "", [ "worry", "worrisome" ] ]
#32 Mr. Spell. ellips r = MOOList [ "", "o", [ "ellipsis", "ellipse" ] ]
#32 Mr. Spell. wors r = MOOList [ "", "eh", [ "worst" ] ]
#32 Mr. Spell. interce r = MOOList [ "pt", "", [ "interceptor", "interception", "intercept" ] ]
#32 Mr. Spell. incurr r = MOOList [ "", "e", [ "incurring" ] ]
#32 Mr. Spell. matr r = MOOList [ "", "io", [ ] ]
#32 Mr. Spell. worl r = MOOList [ "d", "", [ "worldwide", "world" ] ]
#32 Mr. Spell. Burro r = MOOList [ "", "", [ "burrow", "Burroughs", "burro" ] ]
#32 Mr. Spell. worm r = MOOList [ "", "", [ "wormy", "worm" ] ]
#32 Mr. Spell. work r = MOOList [ "", "bmps", [ "worktable", "workout", "workload", "workhorse", "workforce", "workday", "workaday", "working", "worked", "work" ] ]
#32 Mr. Spell. jimm r = MOOList [ "", "", [ "jimmy", "Jimmie" ] ]
#32 Mr. Spell. suppos r = MOOList [ "", "", [ "supposition", "suppose", "supposable" ] ]
#32 Mr. Spell. lumina r = MOOList [ "", "", [ "luminary", "luminance" ] ]
#32 Mr. Spell. suppor r = MOOList [ "t", "", [ "supports", "support" ] ]
#32 Mr. Spell. word r = MOOList [ "", "s", [ "wordy", "word" ] ]
#32 Mr. Spell. bronchi r = MOOList [ "", "o", [ "bronchitis", "bronchial", "bronchi" ] ]
#32 Mr. Spell. matc r = MOOList [ "h", "", [ "matching", "matchmake", "matchbook", "match" ] ]
#32 Mr. Spell. mati r = MOOList [ "", "n", [ "Matisse", "Matilda" ] ]
#32 Mr. Spell. math r = MOOList [ "", "ei", [ "math" ] ]
#32 Mr. Spell. conni r = MOOList [ "", "v", [ "Connie" ] ]
#32 Mr. Spell. mast r = MOOList [ "", "ei", [ "masturbate", "mastodon", "mast" ] ]
#32 Mr. Spell. lord r = MOOList [ "", "", [ "lordosis", "lord" ] ]
#32 Mr. Spell. bate r = MOOList [ "", "", [ "bater", "Bateman", "bateau", "bate" ] ]
#32 Mr. Spell. scen r = MOOList [ "", "e", [ "scent", "scenic", "scenario" ] ]
#32 Mr. Spell. Laud r = MOOList [ "", "a", [ "Lauderdale", "laud" ] ]
#32 Mr. Spell. bath r = MOOList [ "", "r", [ "Bathurst", "bathtub", "bathos", "bathe", "bath" ] ]
#32 Mr. Spell. Platon r = MOOList [ "i", "s", [ "platonic" ] ]
#32 Mr. Spell. circumc r = MOOList [ "i", "s", [ "circumcircle" ] ]
#32 Mr. Spell. maso r = MOOList [ "", "cn", [ ] ]
#32 Mr. Spell. masq r = MOOList [ "ue", "", [ "masquerade", "masque" ] ]
#32 Mr. Spell. grown r = MOOList [ "", "", [ "grownup", "grown" ] ]
#32 Mr. Spell. circumf r = MOOList [ "", "e", [ "circumflex" ] ]
#32 Mr. Spell. cavil r = MOOList [ "", "", [ "cavilling", "cavil" ] ]
#32 Mr. Spell. gangl r = MOOList [ "", "i", [ "gangland" ] ]
#32 Mr. Spell. dramat r = MOOList [ "", "i", [ "dramaturgy" ] ]
#32 Mr. Spell. fungi r = MOOList [ "", "", [ "fungicide", "fungible", "fungi" ] ]
#32 Mr. Spell. batt r = MOOList [ "", "el", [ "battalion", "batt" ] ]
#32 Mr. Spell. bast r = MOOList [ "", "", [ "bastion", "baste", "bastard" ] ]
#32 Mr. Spell. twin r = MOOList [ "", "", [ "twinkle", "twinge", "twine", "twin" ] ]
#32 Mr. Spell. masc r = MOOList [ "", "", [ "masculine", "mascara" ] ]
#32 Mr. Spell. twis r = MOOList [ "t", "", [ "twisty", "twist" ] ]
#32 Mr. Spell. twir r = MOOList [ "l", "", [ "twirly", "twirl" ] ]
#32 Mr. Spell. brui r = MOOList [ "", "", [ "bruit", "bruise" ] ]
#32 Mr. Spell. twit r = MOOList [ "", "c", [ "twit" ] ]
#32 Mr. Spell. twig r = MOOList [ "", "", [ "twigging", "twig" ] ]
#32 Mr. Spell. brun r = MOOList [ "", "", [ "brunt", "Brunswick", "Bruno", "Brunhilde", "brunette", "brunch" ] ]
#32 Mr. Spell. brut r = MOOList [ "", "", [ "brute", "brutal" ] ]
#32 Mr. Spell. twil r = MOOList [ "", "", [ "twill", "twilight" ] ]
#32 Mr. Spell. brus r = MOOList [ "", "h", [ "Brussels", "brusque" ] ]
#32 Mr. Spell. mars r = MOOList [ "", "h", [ "marsupial", "Marseilles" ] ]
#32 Mr. Spell. Walte r = MOOList [ "r", "", [ "Walters", "Walter" ] ]
#32 Mr. Spell. marr r = MOOList [ "", "io", [ "marry" ] ]
#32 Mr. Spell. base r = MOOList [ "", "blmp", [ "based", "base" ] ]
#32 Mr. Spell. repelle r = MOOList [ "", "", [ "repellent", "repelled" ] ]
#32 Mr. Spell. mart r = MOOList [ "", "eiy", [ "Martha", "mart" ] ]
#32 Mr. Spell. bash r = MOOList [ "", "", [ "bashful", "bashaw", "bash" ] ]
#32 Mr. Spell. Lom r = MOOList [ "", "b", [ "Lome" ] ]
#32 Mr. Spell. facto r = MOOList [ "", "r", [ "facto" ] ]
#32 Mr. Spell. basi r = MOOList [ "", "lc", [ "basis", "basin", "basidiomycetes" ] ]
#32 Mr. Spell. marq r = MOOList [ "u", "e", [ "marquis" ] ]
#32 Mr. Spell. freew r = MOOList [ "", "", [ "freewheel", "freeway" ] ]
#32 Mr. Spell. consu r = MOOList [ "", "lm", [ ] ]
#32 Mr. Spell. bask r = MOOList [ "", "e", [ "bask" ] ]
#32 Mr. Spell. portr r = MOOList [ "a", "iy", [ ] ]
#32 Mr. Spell. stev r = MOOList [ "e", "n", [ "stevedore", "Steve" ] ]
#32 Mr. Spell. stew r = MOOList [ "", "a", [ "stew" ] ]
#32 Mr. Spell. steepl r = MOOList [ "e", "", [ "steeplechase", "steeplebush", "steeple" ] ]
#32 Mr. Spell. Log r = MOOList [ "", "agi", [ "logout", "logjam", "loge", "log" ] ]
#32 Mr. Spell. Lati r = MOOList [ "", "nt", [ ] ]
#32 Mr. Spell. freem r = MOOList [ "", "", [ "freemen", "freeman" ] ]
#32 Mr. Spell. marv r = MOOList [ "", "e", [ "Marvin" ] ]
#32 Mr. Spell. conta r = MOOList [ "", "gmi", [ "contact" ] ]
#32 Mr. Spell. amphibo r = MOOList [ "l", "", [ "amphibology", "amphibole" ] ]
#32 Mr. Spell. Wate r = MOOList [ "r", "flms", [ "watery", "waterway", "Watertown", "waterproof", "Waterhouse", "Watergate", "watercourse", "Waterbury", "water" ] ]
#32 Mr. Spell. stel r = MOOList [ "la", "", [ "stellar", "Stella" ] ]
#32 Mr. Spell. porti r = MOOList [ "", "", [ "portico", "Portia" ] ]
#32 Mr. Spell. conte r = MOOList [ "", "mnsx", [ ] ]
#32 Mr. Spell. bart r = MOOList [ "", "eho", [ "Bartlett" ] ]
#32 Mr. Spell. amphibi r = MOOList [ "", "", [ "amphibious", "amphibian" ] ]
#32 Mr. Spell. sten r = MOOList [ "", "co", [ ] ]
#32 Mr. Spell. lops r = MOOList [ "", "", [ "lopsided", "lopseed" ] ]
#32 Mr. Spell. step r = MOOList [ "", "h", [ "stepwise", "stepson", "steprelation", "steppe", "stepmother", "stepchild", "step" ] ]
#32 Mr. Spell. revers r = MOOList [ "", "i", [ "reverse", "reversal" ] ]
#32 Mr. Spell. conti r = MOOList [ "", "gn", [ ] ]
#32 Mr. Spell. ster r = MOOList [ "", "en", [ "steroid", "sterling", "sterile", "steradian" ] ]
#32 Mr. Spell. mara r = MOOList [ "", "", [ "maraud", "marathon" ] ]
#32 Mr. Spell. mark r = MOOList [ "", "eos", [ "Markham", "mark" ] ]
#32 Mr. Spell. stee r = MOOList [ "", "lp", [ "steeve", "steer", "Steen", "steed" ] ]
#32 Mr. Spell. porta r = MOOList [ "", "", [ "portable", "portal", "portage" ] ]
#32 Mr. Spell. marm r = MOOList [ "", "", [ "marmot", "marmalade" ] ]
#32 Mr. Spell. Claud r = MOOList [ "", "i", [ "Claude" ] ]
#32 Mr. Spell. marg r = MOOList [ "", "ai", [ "Marguerite", "Margo", "Margery" ] ]
#32 Mr. Spell. downst r = MOOList [ "", "", [ "downstream", "downstairs" ] ]
#32 Mr. Spell. trumpe r = MOOList [ "", "", [ "trumpet", "trumpery" ] ]
#32 Mr. Spell. porte r = MOOList [ "", "n", [ "porterhouse", "Porte" ] ]
#32 Mr. Spell. basa r = MOOList [ "l", "", [ "basalt", "basal" ] ]
#32 Mr. Spell. squatte r = MOOList [ "", "", [ "squatter", "squatted" ] ]
#32 Mr. Spell. conto r = MOOList [ "", "", [ "contour", "contort" ] ]
#32 Mr. Spell. contu r = MOOList [ "", "", [ "contusion", "contumacy" ] ]
#32 Mr. Spell. interro r = MOOList [ "gat", "", [ "interrogatory", "interrogate" ] ]
#32 Mr. Spell. contr r = MOOList [ "", "aio", [ "contretemps" ] ]
#32 Mr. Spell. bare r = MOOList [ "", "f", [ "bare" ] ]
#32 Mr. Spell. interru r = MOOList [ "pt", "i", [ "interrupt" ] ]
#32 Mr. Spell. barg r = MOOList [ "", "", [ "barge", "bargain" ] ]
#32 Mr. Spell. stea r = MOOList [ "", "dlmr", [ "steak" ] ]
#32 Mr. Spell. chronog r = MOOList [ "raph", "", [ "chronography", "chronograph" ] ]
#32 Mr. Spell. bari r = MOOList [ "", "", [ "barium", "baritone" ] ]
#32 Mr. Spell. bark r = MOOList [ "", "", [ "barkeep", "bark" ] ]
#32 Mr. Spell. instal r = MOOList [ "l", "", [ "installed", "installation", "install" ] ]
#32 Mr. Spell. instan r = MOOList [ "", "t", [ "instance" ] ]
#32 Mr. Spell. baro r = MOOList [ "", "n", [ "baroque", "barometer" ] ]
#32 Mr. Spell. Buxt r = MOOList [ "", "", [ "Buxton", "Buxtehude" ] ]
#32 Mr. Spell. wool r = MOOList [ "", "", [ "Woolworth", "woolgather", "wool" ] ]
#32 Mr. Spell. barr r = MOOList [ "", "aeiy", [ "barrow", "Barr" ] ]
#32 Mr. Spell. loop r = MOOList [ "", "", [ "loophole", "loop" ] ]
#32 Mr. Spell. freeh r = MOOList [ "", "", [ "freehold", "freehand" ] ]
#32 Mr. Spell. loos r = MOOList [ "e", "", [ "loosestrife", "loosen", "looseleaf", "loose" ] ]
#32 Mr. Spell. radioa r = MOOList [ "", "", [ "radioastronomy", "radioactive" ] ]
#32 Mr. Spell. mocke r = MOOList [ "r", "", [ "mockery", "mockernut" ] ]
#32 Mr. Spell. freed r = MOOList [ "", "m", [ "freedom" ] ]
#32 Mr. Spell. western r = MOOList [ "", "", [ "westernmost", "western" ] ]
#32 Mr. Spell. radioc r = MOOList [ "", "h", [ "radiocarbon" ] ]
#32 Mr. Spell. Brahms r = MOOList [ "", "", [ "Brahmsian", "Brahms" ] ]
#32 Mr. Spell. Arth r = MOOList [ "", "", [ "Arthur", "arthritis" ] ]
#32 Mr. Spell. Lark r = MOOList [ "", "", [ "larkspur", "Larkin", "lark" ] ]
#32 Mr. Spell. look r = MOOList [ "", "", [ "looks", "looking", "looked", "lookup", "lookout", "look" ] ]
#32 Mr. Spell. nub r = MOOList [ "i", "", [ "nubile", "Nubia" ] ]
#32 Mr. Spell. cryptanalys r = MOOList [ "", "", [ "cryptanalyst", "cryptanalysis" ] ]
#32 Mr. Spell. nuc r = MOOList [ "l", "e", [ "nuclide" ] ]
#32 Mr. Spell. these r = MOOList [ "", "", [ "Theseus", "theses", "these" ] ]
#32 Mr. Spell. nud r = MOOList [ "", "", [ "nudge", "nude" ] ]
#32 Mr. Spell. Lare r = MOOList [ "", "", [ "Lares", "Laredo" ] ]
#32 Mr. Spell. absolu r = MOOList [ "t", "", [ "absolution", "absolute" ] ]
#32 Mr. Spell. motiv r = MOOList [ "", "", [ "motive", "motivate" ] ]
#32 Mr. Spell. Lars r = MOOList [ "", "", [ "Larson", "Larsen", "Lars" ] ]
#32 Mr. Spell. supple r = MOOList [ "", "", [ "supplementary", "supple" ] ]
#32 Mr. Spell. nutr r = MOOList [ "i", "t", [ "nutrient", "nutria" ] ]
#32 Mr. Spell. wond r = MOOList [ "", "e", [ "wondrous" ] ]
#32 Mr. Spell. suppli r = MOOList [ "", "", [ "supplied", "supplicate" ] ]
#32 Mr. Spell. taran r = MOOList [ "t", "", [ "tarantula", "tarantara" ] ]
#32 Mr. Spell. scat r = MOOList [ "", "t", [ "scathe", "scat" ] ]
#32 Mr. Spell. rampa r = MOOList [ "", "", [ "rampart", "rampant", "rampage" ] ]
#32 Mr. Spell. interpo r = MOOList [ "l", "a", [ "Interpol" ] ]
#32 Mr. Spell. Indoc r = MOOList [ "", "", [ "indoctrinate", "Indochina" ] ]
#32 Mr. Spell. therm r = MOOList [ "", "io", [ "thermal" ] ]
#32 Mr. Spell. Bethe r = MOOList [ "", "", [ "Bethesda", "bethel" ] ]
#32 Mr. Spell. scal r = MOOList [ "", "a", [ "scalp", "scallop", "scale", "scald" ] ]
#32 Mr. Spell. cutt r = MOOList [ "", "l", [ "cutthroat" ] ]
#32 Mr. Spell. scam r = MOOList [ "", "", [ "scamp", "scam" ] ]
#32 Mr. Spell. scan r = MOOList [ "", "dt", [ "scan" ] ]
#32 Mr. Spell. interpr r = MOOList [ "et", "", [ "interpreter", "interpretive", "interpretation", "interpret" ] ]
#32 Mr. Spell. scap r = MOOList [ "", "u", [ "scapegoat" ] ]
#32 Mr. Spell. Antig r = MOOList [ "", "o", [ "antigen" ] ]
#32 Mr. Spell. scab r = MOOList [ "", "", [ "scabrous", "scabious", "scabbard", "scab" ] ]
#32 Mr. Spell. long r = MOOList [ "", "hie", [ "longue", "longtime", "longstanding", "longleg", "Longfellow", "long" ] ]
#32 Mr. Spell. there r = MOOList [ "", "af'otu", [ "therewith", "Theresa", "therein", "thereby", "there" ] ]
#32 Mr. Spell. columb r = MOOList [ "", "i", [ "Columbus" ] ]
#32 Mr. Spell. Clark r = MOOList [ "", "", [ "Clarke", "Clark" ] ]
#32 Mr. Spell. thera r = MOOList [ "p", "", [ "therapy", "therapist", "therapeutic" ] ]
#32 Mr. Spell. lone r = MOOList [ "", "", [ "lonesome", "lone" ] ]
#32 Mr. Spell. nug r = MOOList [ "", "", [ "nugget", "nugatory" ] ]
#32 Mr. Spell. consc r = MOOList [ "", "ir", [ ] ]
#32 Mr. Spell. column r = MOOList [ "", "", [ "columnar", "column" ] ]
#32 Mr. Spell. consa r = MOOList [ "nguine", "", [ "consanguineous", "consanguine" ] ]
#32 Mr. Spell. twel r = MOOList [ "", "", [ "twelve", "twelfth" ] ]
#32 Mr. Spell. osten r = MOOList [ "", "", [ "ostentatious", "ostensible" ] ]
#32 Mr. Spell. twen r = MOOList [ "t", "", [ "twenty", "twentieth" ] ]
#32 Mr. Spell. nul r = MOOList [ "l", "", [ "Nullstellensatz", "nullify", "null" ] ]
#32 Mr. Spell. woma r = MOOList [ "n", "", [ "womanhood", "woman" ] ]
#32 Mr. Spell. num r = MOOList [ "", "eib", [ ] ]
#32 Mr. Spell. conse r = MOOList [ "", "cnqr", [ ] ]
#32 Mr. Spell. Clare r = MOOList [ "", "n", [ "claret", "Claremont", "Clare" ] ]
#32 Mr. Spell. womb r = MOOList [ "", "", [ "wombat", "womb" ] ]
#32 Mr. Spell. osteo r = MOOList [ "", "p", [ "osteology" ] ]
#32 Mr. Spell. wolv r = MOOList [ "e", "", [ "wolves", "wolve" ] ]
#32 Mr. Spell. philan r = MOOList [ "throp", "", [ "philanthropy", "philanthropic", "philanthrope" ] ]
#32 Mr. Spell. twee r = MOOList [ "", "d", [ "tweeze" ] ]
#32 Mr. Spell. consi r = MOOList [ "", "dgs", [ ] ]
#32 Mr. Spell. nur r = MOOList [ "", "s", [ "nurture" ] ]
#32 Mr. Spell. cutl r = MOOList [ "", "e", [ "cutlass" ] ]
#32 Mr. Spell. cuto r = MOOList [ "", "", [ "cutover", "cutout", "cutoff" ] ]
#32 Mr. Spell. conso r = MOOList [ "", "lnr", [ ] ]
#32 Mr. Spell. nut r = MOOList [ "", "r", [ "nutshell", "nutmeg", "nuthatch", "nutcrack", "nutate", "nut" ] ]
#32 Mr. Spell. consp r = MOOList [ "i", "r", [ "conspicuous" ] ]
#32 Mr. Spell. downtr r = MOOList [ "", "", [ "downtrodden", "downtrend" ] ]
#32 Mr. Spell. mano r = MOOList [ "", "", [ "manor", "manometer" ] ]
#32 Mr. Spell. stay r = MOOList [ "", "", [ "stays", "stayed", "stay" ] ]
#32 Mr. Spell. mann r = MOOList [ "", "e", [ "manna", "Mann" ] ]
#32 Mr. Spell. cust r = MOOList [ "", "o", [ "Custer" ] ]
#32 Mr. Spell. intermi r = MOOList [ "t", "", [ "intermittent", "intermit" ] ]
#32 Mr. Spell. stap r = MOOList [ "", "hl", [ ] ]
#32 Mr. Spell. Brist r = MOOList [ "", "", [ "Bristol", "bristle" ] ]
#32 Mr. Spell. Tigr r = MOOList [ "", "", [ "Tigris", "tigress" ] ]
#32 Mr. Spell. star r = MOOList [ "", "ckltv", [ "starship", "Starr", "stargaze", "starfish", "stare", "stardom", "starboard", "star" ] ]
#32 Mr. Spell. stas r = MOOList [ "", "", [ "stasis", "stash" ] ]
#32 Mr. Spell. jigg r = MOOList [ "", "", [ "jiggle", "jigging" ] ]
#32 Mr. Spell. mans r = MOOList [ "", "e", [ "manslaughter", "mansion", "Mansfield" ] ]
#32 Mr. Spell. stau r = MOOList [ "", "n", [ "Stauffer" ] ]
#32 Mr. Spell. mant r = MOOList [ "", "il", [ "mantrap", "mantel" ] ]
#32 Mr. Spell. stai r = MOOList [ "", "r", [ "stain", "staid" ] ]
#32 Mr. Spell. Picket r = MOOList [ "", "", [ "Pickett", "picket" ] ]
#32 Mr. Spell. delica r = MOOList [ "", "t", [ "delicacy" ] ]
#32 Mr. Spell. mana r = MOOList [ "", "g", [ "manatee", "Manama", "mana" ] ]
#32 Mr. Spell. stal r = MOOList [ "", "el", [ "stalwart", "stalk", "Stalin", "stalactite" ] ]
#32 Mr. Spell. bant r = MOOList [ "", "u", [ "banter", "bantam" ] ]
#32 Mr. Spell. stan r = MOOList [ "", "cdn", [ "stanza", "Stanton", "Stanley", "stank", "Stanhope", "Stanford", "Stan" ] ]
#32 Mr. Spell. loll r = MOOList [ "", "", [ "lolly", "lollipop", "loll" ] ]
#32 Mr. Spell. cush r = MOOList [ "", "i", [ "Cushman" ] ]
#32 Mr. Spell. McKen r = MOOList [ "", "", [ "McKenzie", "McKenna" ] ]
#32 Mr. Spell. mang r = MOOList [ "", "e", [ "mangle", "manganese" ] ]
#32 Mr. Spell. stab r = MOOList [ "", "l", [ "stabile", "stab" ] ]
#32 Mr. Spell. mani r = MOOList [ "", "afp", [ "Manitoba", "Manila", "manikin", "manic" ] ]
#32 Mr. Spell. stac r = MOOList [ "", "", [ "Stacy", "stack", "staccato" ] ]
#32 Mr. Spell. manh r = MOOList [ "", "", [ "manhole", "Manhattan" ] ]
#32 Mr. Spell. stad r = MOOList [ "i", "", [ "stadium", "stadia" ] ]
#32 Mr. Spell. neural r = MOOList [ "", "", [ "neuralgia", "neural" ] ]
#32 Mr. Spell. nurs r = MOOList [ "e", "", [ "nursery", "nurse" ] ]
#32 Mr. Spell. mane r = MOOList [ "", "", [ "maneuver", "mane" ] ]
#32 Mr. Spell. stag r = MOOList [ "", "en", [ "stagy", "stag" ] ]
#32 Mr. Spell. mand r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. Rober r = MOOList [ "t", "", [ "Robertson", "Roberto", "Roberta", "Robert" ] ]
#32 Mr. Spell. mothe r = MOOList [ "r", "", [ "mothers", "motherland", "mother" ] ]
#32 Mr. Spell. mamm r = MOOList [ "", "a", [ "mammoth" ] ]
#32 Mr. Spell. broo r = MOOList [ "", "dkm", [ ] ]
#32 Mr. Spell. curs r = MOOList [ "", "o", [ "cursive", "curse" ] ]
#32 Mr. Spell. bana r = MOOList [ "", "", [ "banana", "banal", "Banach" ] ]
#32 Mr. Spell. regimen r = MOOList [ "", "t", [ "regimen" ] ]
#32 Mr. Spell. curr r = MOOList [ "", "aie", [ "curry" ] ]
#32 Mr. Spell. Antoi r = MOOList [ "ne", "", [ "Antoinette", "Antoine" ] ]
#32 Mr. Spell. brot r = MOOList [ "h", "e", [ "broth" ] ]
#32 Mr. Spell. Anton r = MOOList [ "", "y", [ "Antonio", "Anton" ] ]
#32 Mr. Spell. curt r = MOOList [ "", "a", [ "curtsey", "Curtis", "curt" ] ]
#32 Mr. Spell. band r = MOOList [ "", "sw", [ "bandy", "bandpass", "bandit", "bandgap", "bandage", "band" ] ]
#32 Mr. Spell. bane r = MOOList [ "", "", [ "baneful", "baneberry", "bane" ] ]
#32 Mr. Spell. wiretapp r = MOOList [ "", "", [ "wiretapping", "wiretapper" ] ]
#32 Mr. Spell. Musk r = MOOList [ "", "eo", [ "muskrat", "muskmelon", "musk" ] ]
#32 Mr. Spell. curv r = MOOList [ "", "a", [ "curvilinear", "curve" ] ]
#32 Mr. Spell. brou r = MOOList [ "", "", [ "brouhaha", "brought" ] ]
#32 Mr. Spell. bang r = MOOList [ "", "l", [ "Bangui", "Bangor", "bangkok", "bang" ] ]
#32 Mr. Spell. Swed r = MOOList [ "", "e", [ "Swedish" ] ]
#32 Mr. Spell. brow r = MOOList [ "", "n", [ "browse", "browbeaten", "brow" ] ]
#32 Mr. Spell. bibli r = MOOList [ "", "o", [ "biblical" ] ]
#32 Mr. Spell. Volt r = MOOList [ "", "a", [ "voltmeter", "Volterra", "volt" ] ]
#32 Mr. Spell. Swea r = MOOList [ "", "t", [ "swear" ] ]
#32 Mr. Spell. bani r = MOOList [ "s", "", [ "banister", "banish" ] ]
#32 Mr. Spell. verac r = MOOList [ "i", "", [ "veracity", "veracious" ] ]
#32 Mr. Spell. bank r = MOOList [ "", "r", [ "banks", "bank" ] ]
#32 Mr. Spell. bisma r = MOOList [ "r", "", [ "Bismark", "Bismarck" ] ]
#32 Mr. Spell. Luf r = MOOList [ "t", "", [ "Luftwaffe", "Lufthansa" ] ]
#32 Mr. Spell. inhab r = MOOList [ "it", "a", [ "inhabit" ] ]
#32 Mr. Spell. curb r = MOOList [ "", "", [ "curbside", "curb" ] ]
#32 Mr. Spell. broa r = MOOList [ "", "d", [ "broach" ] ]
#32 Mr. Spell. interna r = MOOList [ "", "", [ "international", "internal" ] ]
#32 Mr. Spell. Lud r = MOOList [ "", "", [ "Ludwig", "Ludlow", "ludicrous" ] ]
#32 Mr. Spell. cure r = MOOList [ "", "", [ "cured", "cure" ] ]
#32 Mr. Spell. Luc r = MOOList [ "", "ikr", [ "lucy", "Lucerne", "Lucas" ] ]
#32 Mr. Spell. curd r = MOOList [ "", "", [ "curdle", "curd" ] ]
#32 Mr. Spell. broc r = MOOList [ "", "k", [ "brochure", "broccoli", "brocade" ] ]
#32 Mr. Spell. Lub r = MOOList [ "", "r", [ "Lubell", "Lubbock" ] ]
#32 Mr. Spell. inhal r = MOOList [ "", "", [ "inhale", "inhalation" ] ]
#32 Mr. Spell. curi r = MOOList [ "", "o", [ "curium", "curie", "curia" ] ]
#32 Mr. Spell. veran r = MOOList [ "da", "", [ "verandah", "veranda" ] ]
#32 Mr. Spell. curl r = MOOList [ "", "", [ "curlicue", "curlew", "curl" ] ]
#32 Mr. Spell. brok r = MOOList [ "e", "", [ "brokerage", "broken", "broke" ] ]
#32 Mr. Spell. bron r = MOOList [ "", "cz", [ "Bronx", "Brontosaurus" ] ]
#32 Mr. Spell. brom r = MOOList [ "", "i", [ "Bromley", "Bromfield" ] ]
#32 Mr. Spell. mall r = MOOList [ "", "eo", [ "mallard", "mall" ] ]
#32 Mr. Spell. antony r = MOOList [ "", "", [ "antonym", "Antony" ] ]
#32 Mr. Spell. sympt r = MOOList [ "om", "", [ "symptomatic", "symptom" ] ]
#32 Mr. Spell. maln r = MOOList [ "", "", [ "malnutrition", "malnourished" ] ]
#32 Mr. Spell. mali r = MOOList [ "", "cg", [ "Mali" ] ]
#32 Mr. Spell. angel r = MOOList [ "", "i", [ "Angelo", "angelfish", "Angeles", "Angela", "angel" ] ]
#32 Mr. Spell. corpora r = MOOList [ "", "t", [ "corporal", "corpora" ] ]
#32 Mr. Spell. Venet r = MOOList [ "", "", [ "Veneto", "Venetian" ] ]
#32 Mr. Spell. Lang r = MOOList [ "", "u", [ "Langmuir", "Langley", "Lange", "Lang" ] ]
#32 Mr. Spell. exhausti r = MOOList [ "", "", [ "exhaustive", "exhaustion", "exhaustible" ] ]
#32 Mr. Spell. Lanc r = MOOList [ "", "a", [ "lance" ] ]
#32 Mr. Spell. surfa r = MOOList [ "c", "", [ "surfactant", "surface" ] ]
#32 Mr. Spell. malp r = MOOList [ "", "", [ "malpractice", "malposed" ] ]
#32 Mr. Spell. sympo r = MOOList [ "si", "", [ "symposium", "symposia" ] ]
#32 Mr. Spell. conva r = MOOList [ "", "l", [ "Convair" ] ]
#32 Mr. Spell. stock r = MOOList [ "", "h", [ "stocky", "Stockton", "stockroom", "stockpile", "stockbroker", "stockade", "stock" ] ]
#32 Mr. Spell. balm r = MOOList [ "", "", [ "balmy", "balm" ] ]
#32 Mr. Spell. conve r = MOOList [ "", "nry", [ "convex", "convect" ] ]
#32 Mr. Spell. templ r = MOOList [ "", "e", [ "template" ] ]
#32 Mr. Spell. tempo r = MOOList [ "", "r", [ "tempo" ] ]
#32 Mr. Spell. bals r = MOOList [ "a", "", [ "balsam", "balsa" ] ]
#32 Mr. Spell. convi r = MOOList [ "", "", [ "convivial", "convince", "convict" ] ]
#32 Mr. Spell. male r = MOOList [ "", "", [ "malevolent", "maledict", "male" ] ]
#32 Mr. Spell. mald r = MOOList [ "", "i", [ "Malden" ] ]
#32 Mr. Spell. convo r = MOOList [ "", "l", [ "convoy", "convoke", "convocate" ] ]
#32 Mr. Spell. malf r = MOOList [ "", "o", [ "malfunction", "malfeasant" ] ]
#32 Mr. Spell. tempe r = MOOList [ "", "rs", [ ] ]
#32 Mr. Spell. conjug r = MOOList [ "a", "", [ "conjugate", "conjugacy", "conjugal" ] ]
#32 Mr. Spell. malc r = MOOList [ "o", "n", [ "Malcolm" ] ]
#32 Mr. Spell. convu r = MOOList [ "ls", "i", [ "convulse" ] ]
#32 Mr. Spell. cupr r = MOOList [ "", "", [ "cuprous", "cupric" ] ]
#32 Mr. Spell. leader r = MOOList [ "", "", [ "leaders", "leader" ] ]
#32 Mr. Spell. saturat r = MOOList [ "e", "", [ "saturater", "saturate" ] ]
#32 Mr. Spell. conjun r = MOOList [ "ct", "", [ "conjuncture", "conjunct" ] ]
#32 Mr. Spell. bald r = MOOList [ "", "", [ "baldy", "Baldwin", "baldpate", "bald" ] ]
#32 Mr. Spell. bale r = MOOList [ "", "", [ "baleful", "baleen", "bale" ] ]
#32 Mr. Spell. Wald r = MOOList [ "", "o", [ "Waldron", "Walden" ] ]
#32 Mr. Spell. Burm r = MOOList [ "", "", [ "Burmese", "Burma" ] ]
#32 Mr. Spell. Rosen r = MOOList [ "", "b", [ "Rosenzweig", "Rosenthal", "Rosen" ] ]
#32 Mr. Spell. documenta r = MOOList [ "", "", [ "documentation", "documentary" ] ]
#32 Mr. Spell. Burn r = MOOList [ "", "", [ "burnt", "Burnside", "burnout", "burnish", "Burnham", "Burnett", "burn" ] ]
#32 Mr. Spell. kines r = MOOList [ "", "", [ "kinesthesis", "kinesic" ] ]
#32 Mr. Spell. Lama r = MOOList [ "r", "", [ "Lamarck", "Lamar" ] ]
#32 Mr. Spell. ball r = MOOList [ "", "aeo", [ "ballyhoo", "ballroom", "ballfield", "ball" ] ]
#32 Mr. Spell. sympa r = MOOList [ "th", "", [ "sympathy", "sympathetic" ] ]
#32 Mr. Spell. they' r = MOOList [ "", "", [ "they've", "they're", "they'll", "they'd" ] ]
#32 Mr. Spell. nym r = MOOList [ "ph", "o", [ "nymph" ] ]
#32 Mr. Spell. symph r = MOOList [ "on", "", [ "symphony", "symphonic" ] ]
#32 Mr. Spell. Burt r = MOOList [ "", "", [ "Burtt", "Burton", "Burt" ] ]
#32 Mr. Spell. Muri r = MOOList [ "", "", [ "Muriel", "muriatic" ] ]
#32 Mr. Spell. Frank r = MOOList [ "", "f", [ "franklin", "Frankel", "frank" ] ]
#32 Mr. Spell. Walt r = MOOList [ "", "ez", [ "Walton", "Waltham", "Walt" ] ]
#32 Mr. Spell. centrifuga r = MOOList [ "", "", [ "centrifugate", "centrifugal" ] ]
#32 Mr. Spell. cupi r = MOOList [ "d", "", [ "cupidity", "Cupid" ] ]
#32 Mr. Spell. make r = MOOList [ "", "s", [ "makeup", "make" ] ]
#32 Mr. Spell. neuroana r = MOOList [ "tom", "", [ "neuroanatomy", "neuroanatomic" ] ]
#32 Mr. Spell. purpose r = MOOList [ "", "", [ "purposeful", "purpose" ] ]
#32 Mr. Spell. neon r = MOOList [ "", "a", [ "neon" ] ]
#32 Mr. Spell. neol r = MOOList [ "", "", [ "neologism", "neolithic" ] ]
#32 Mr. Spell. protea r = MOOList [ "", "", [ "protease", "protean" ] ]
#32 Mr. Spell. squir r = MOOList [ "", "em", [ "squirt", "squirrel" ] ]
#32 Mr. Spell. protec r = MOOList [ "t", "o", [ "protect" ] ]
#32 Mr. Spell. tract r = MOOList [ "", "", [ "tractor", "tract" ] ]
#32 Mr. Spell. yachts r = MOOList [ "m", "", [ "yachtsmen", "yachtsman" ] ]
#32 Mr. Spell. mutan r = MOOList [ "", "", [ "mutant", "mutandis" ] ]
#32 Mr. Spell. moroc r = MOOList [ "c", "", [ "Morocco", "Moroccan" ] ]
#32 Mr. Spell. Grima r = MOOList [ "", "", [ "Grimaldi", "grimace" ] ]
#32 Mr. Spell. respir r = MOOList [ "", "a", [ "respire" ] ]
#32 Mr. Spell. public r = MOOList [ "", "", [ "publication", "public" ] ]
#32 Mr. Spell. mutat r = MOOList [ "", "", [ "mutatis", "mutate" ] ]
#32 Mr. Spell. neop r = MOOList [ "", "", [ "neoprene", "neophyte" ] ]
#32 Mr. Spell. Grime r = MOOList [ "", "", [ "Grimes", "grime" ] ]
#32 Mr. Spell. proteo r = MOOList [ "ly", "", [ "proteolytic", "proteolysis" ] ]
#32 Mr. Spell. Bere r = MOOList [ "", "a", [ "beret", "Berenices", "bereft", "Beresford" ] ]
#32 Mr. Spell. protes r = MOOList [ "t", "a", [ "protest" ] ]
#32 Mr. Spell. trace r = MOOList [ "", "", [ "traceback", "tracery", "traceable", "trace" ] ]
#32 Mr. Spell. heave r = MOOList [ "", "n", [ "heave" ] ]
#32 Mr. Spell. track r = MOOList [ "", "", [ "trackage", "track" ] ]
#32 Mr. Spell. absci r = MOOList [ "ssa", "", [ "abscissae", "abscissa" ] ]
#32 Mr. Spell. Berm r = MOOList [ "", "", [ "Bermuda", "Berman" ] ]
#32 Mr. Spell. Bern r = MOOList [ "", "aei", [ "Bernstein", "Bernoulli", "Bernhard", "Bern" ] ]
#32 Mr. Spell. Mauri r = MOOList [ "", "ct", [ "Maurine" ] ]
#32 Mr. Spell. Berl r = MOOList [ "i", "", [ "Berlitz", "Berlioz", "Berlin" ] ]
#32 Mr. Spell. dysp r = MOOList [ "", "", [ "dysprosium", "dysplasia", "dyspeptic" ] ]
#32 Mr. Spell. cream r = MOOList [ "", "", [ "creamy", "creamery", "cream" ] ]
#32 Mr. Spell. heavy r = MOOList [ "", "", [ "heavyweight", "heavy" ] ]
#32 Mr. Spell. creak r = MOOList [ "", "", [ "creaky", "creak" ] ]
#32 Mr. Spell. purit r = MOOList [ "an", "", [ "puritanic", "Puritan" ] ]
#32 Mr. Spell. eugeni r = MOOList [ "", "", [ "eugenic", "Eugenia" ] ]
#32 Mr. Spell. creat r = MOOList [ "", "ei", [ "creature" ] ]
#32 Mr. Spell. purin r = MOOList [ "", "", [ "purine", "Purina" ] ]
#32 Mr. Spell. organi r = MOOList [ "", "z", [ "organismic", "organic" ] ]
#32 Mr. Spell. infin r = MOOList [ "it", "eu", [ "infinity", "infinitive" ] ]
#32 Mr. Spell. astri r = MOOList [ "", "", [ "astringent", "astride" ] ]
#32 Mr. Spell. infim r = MOOList [ "", "", [ "infimum", "infima" ] ]
#32 Mr. Spell. squire r = MOOList [ "", "", [ "squirehood", "squire" ] ]
#32 Mr. Spell. cens r = MOOList [ "", "ou", [ ] ]
#32 Mr. Spell. astro r = MOOList [ "", "np", [ ] ]
#32 Mr. Spell. persona r = MOOList [ "", "l", [ "personage", "persona" ] ]
#32 Mr. Spell. cent r = MOOList [ "", "eiru", [ "centaur", "cent" ] ]
#32 Mr. Spell. astra r = MOOList [ "", "", [ "astray", "astral", "astraddle" ] ]
#32 Mr. Spell. infir r = MOOList [ "m", "", [ "infirmary", "infirm" ] ]
#32 Mr. Spell. squirm r = MOOList [ "", "", [ "squirmy", "squirm" ] ]
#32 Mr. Spell. dange r = MOOList [ "r", "", [ "dangerous", "danger" ] ]
#32 Mr. Spell. seria r = MOOList [ "", "", [ "seriatim", "serial" ] ]
#32 Mr. Spell. drows r = MOOList [ "", "", [ "drowsy", "drowse" ] ]
#32 Mr. Spell. Lyn r = MOOList [ "", "c", [ "lynx", "Lynn" ] ]
#32 Mr. Spell. Chry r = MOOList [ "s", "", [ "chrysolite", "Chrysler", "chrysanthemum" ] ]
#32 Mr. Spell. efflo r = MOOList [ "resce", "", [ "efflorescent", "effloresce" ] ]
#32 Mr. Spell. efflu r = MOOList [ "", "v", [ "effluent" ] ]
#32 Mr. Spell. yell r = MOOList [ "", "o", [ "yell" ] ]
#32 Mr. Spell. sprig r = MOOList [ "", "", [ "sprightly", "sprig" ] ]
#32 Mr. Spell. sprin r = MOOList [ "", "g", [ "sprint", "sprinkle" ] ]
#32 Mr. Spell. infla r = MOOList [ "", "mt", [ ] ]
#32 Mr. Spell. Benn r = MOOList [ "", "", [ "Benny", "Bennington", "Bennett" ] ]
#32 Mr. Spell. idiot r = MOOList [ "", "", [ "idiotic", "idiot" ] ]
#32 Mr. Spell. idios r = MOOList [ "yncra", "", [ "idiosyncratic", "idiosyncrasy" ] ]
#32 Mr. Spell. passio r = MOOList [ "n", "", [ "passionate", "passion" ] ]
#32 Mr. Spell. countera r = MOOList [ "", "", [ "counterattack", "counterargument", "counteract" ] ]
#32 Mr. Spell. lifes r = MOOList [ "", "", [ "lifestyle", "lifespan" ] ]
#32 Mr. Spell. phosphore r = MOOList [ "sce", "", [ "phosphorescent", "phosphoresce" ] ]
#32 Mr. Spell. counterf r = MOOList [ "", "", [ "counterflow", "counterfeit" ] ]
#32 Mr. Spell. Bent r = MOOList [ "", "h", [ "Benton", "Bentley", "bent" ] ]
#32 Mr. Spell. prefer r = MOOList [ "", "er", [ "prefer" ] ]
#32 Mr. Spell. infle r = MOOList [ "", "", [ "inflexible", "inflect" ] ]
#32 Mr. Spell. passiv r = MOOList [ "", "", [ "passive", "passivate" ] ]
#32 Mr. Spell. Benz r = MOOList [ "", "e", [ "Benz" ] ]
#32 Mr. Spell. counterm r = MOOList [ "", "", [ "countermen", "counterman" ] ]
#32 Mr. Spell. explora r = MOOList [ "t", "", [ "exploratory", "exploration" ] ]
#32 Mr. Spell. cell r = MOOList [ "", "u", [ "cellophane", "cellar", "cell" ] ]
#32 Mr. Spell. pistol r = MOOList [ "", "", [ "pistole", "pistol" ] ]
#32 Mr. Spell. counterp r = MOOList [ "", "or", [ "counterpart" ] ]
#32 Mr. Spell. counters r = MOOList [ "", "", [ "countersunk", "countersink" ] ]
#32 Mr. Spell. trade r = MOOList [ "", "s", [ "tradeoff", "trademark", "trade" ] ]
#32 Mr. Spell. lifeb r = MOOList [ "", "", [ "lifeboat", "lifeblood" ] ]
#32 Mr. Spell. apha r = MOOList [ "si", "", [ "aphasic", "aphasia" ] ]
#32 Mr. Spell. tradi r = MOOList [ "tion", "", [ "tradition", "traditional" ] ]
#32 Mr. Spell. purga r = MOOList [ "t", "i", [ "purgatory" ] ]
#32 Mr. Spell. prefec r = MOOList [ "t", "", [ "prefecture", "prefect" ] ]
#32 Mr. Spell. idiom r = MOOList [ "", "", [ "idiomatic", "idiom" ] ]
#32 Mr. Spell. Milli r = MOOList [ "", "o", [ "millipede", "millinery", "Millikan", "Millie" ] ]
#32 Mr. Spell. credu r = MOOList [ "l", "", [ "credulous", "credulity" ] ]
#32 Mr. Spell. Melv r = MOOList [ "i", "", [ "Melvin", "Melville" ] ]
#32 Mr. Spell. reduce r = MOOList [ "", "", [ "reduced", "reduce" ] ]
#32 Mr. Spell. infec r = MOOList [ "t", "", [ "infectious", "infect" ] ]
#32 Mr. Spell. Bonne r = MOOList [ "", "", [ "Bonneville", "bonnet" ] ]
#32 Mr. Spell. cele r = MOOList [ "", "brs", [ ] ]
#32 Mr. Spell. patern r = MOOList [ "", "", [ "paternoster", "paternal" ] ]
#32 Mr. Spell. Cyri r = MOOList [ "l", "", [ "Cyrillic", "Cyril" ] ]
#32 Mr. Spell. trage r = MOOList [ "d", "", [ "tragedy", "tragedian" ] ]
#32 Mr. Spell. dives r = MOOList [ "t", "", [ "divestiture", "divest" ] ]
#32 Mr. Spell. cattl r = MOOList [ "e", "m", [ "cattle" ] ]
#32 Mr. Spell. diver r = MOOList [ "", "gs", [ "divert" ] ]
#32 Mr. Spell. tragi r = MOOList [ "c", "", [ "tragicomic", "tragic" ] ]
#32 Mr. Spell. creed r = MOOList [ "", "", [ "creedal", "creed" ] ]
#32 Mr. Spell. thumb r = MOOList [ "", "", [ "thumbnail", "thumb" ] ]
#32 Mr. Spell. selena r = MOOList [ "", "", [ "selenate", "Selena" ] ]
#32 Mr. Spell. Bene r = MOOList [ "", "df", [ "benevolent", "Benelux", "beneath" ] ]
#32 Mr. Spell. Bend r = MOOList [ "", "", [ "Bendix", "bend" ] ]
#32 Mr. Spell. Beng r = MOOList [ "al", "", [ "Bengali", "Bengal" ] ]
#32 Mr. Spell. creek r = MOOList [ "", "", [ "creekside", "creek" ] ]
#32 Mr. Spell. seleni r = MOOList [ "", "", [ "selenium", "selenite" ] ]
#32 Mr. Spell. hears r = MOOList [ "", "", [ "Hearst", "hearse", "hearsay" ] ]
#32 Mr. Spell. Chom r = MOOList [ "", "", [ "Chomsky", "chomp" ] ]
#32 Mr. Spell. Bell r = MOOList [ "", "aimy", [ "bellwether", "bellum", "bellow", "bellhop", "bellflower", "belle", "bellboy", "bell" ] ]
#32 Mr. Spell. heart r = MOOList [ "", "b", [ "hearty", "hearth", "heartfelt", "hearten", "heart" ] ]
#32 Mr. Spell. creep r = MOOList [ "", "", [ "creepy", "creep" ] ]
#32 Mr. Spell. Chop r = MOOList [ "", "", [ "choppy", "Chopin", "chop" ] ]
#32 Mr. Spell. butte r = MOOList [ "", "r", [ "butte" ] ]
#32 Mr. Spell. bobbi r = MOOList [ "", "", [ "bobbin", "Bobbie" ] ]
#32 Mr. Spell. oak r = MOOList [ "", "l", [ "oakwood", "oaken", "oak" ] ]
#32 Mr. Spell. Belt r = MOOList [ "", "", [ "Beltsville", "belt" ] ]
#32 Mr. Spell. butto r = MOOList [ "", "n", [ "buttock" ] ]
#32 Mr. Spell. bucket r = MOOList [ "", "", [ "bucketfull", "bucket" ] ]
#32 Mr. Spell. styl r = MOOList [ "", "ie", [ "stylus" ] ]
#32 Mr. Spell. interve r = MOOList [ "n", "", [ "intervention", "intervenor", "intervene" ] ]
#32 Mr. Spell. quadric r = MOOList [ "", "", [ "quadriceps", "quadric" ] ]
#32 Mr. Spell. infer r = MOOList [ "", "enr", [ "infertile", "inferior", "infer" ] ]
#32 Mr. Spell. infes r = MOOList [ "t", "", [ "infestation", "infest" ] ]
#32 Mr. Spell. quadril r = MOOList [ "", "l", [ "quadrilateral" ] ]
#32 Mr. Spell. maide r = MOOList [ "n", "", [ "maidenhair", "maiden" ] ]
#32 Mr. Spell. infel r = MOOList [ "icit", "", [ "infelicity", "infelicitous" ] ]
#32 Mr. Spell. telev r = MOOList [ "is", "", [ "television", "televise" ] ]
#32 Mr. Spell. obd r = MOOList [ "ura", "", [ "obdurate", "obduracy" ] ]
#32 Mr. Spell. obe r = MOOList [ "", "", [ "obey", "obese", "Oberlin", "obelisk", "obeisant", "obedient" ] ]
#32 Mr. Spell. obf r = MOOList [ "uscat", "", [ "obfuscatory", "obfuscate" ] ]
#32 Mr. Spell. teles r = MOOList [ "cop", "", [ "telescopic", "telescope" ] ]
#32 Mr. Spell. proces r = MOOList [ "s", "i", [ "processed", "processor", "process" ] ]
#32 Mr. Spell. stanch r = MOOList [ "", "", [ "stanchion", "stanch" ] ]
#32 Mr. Spell. interst r = MOOList [ "i", "", [ "interstitial", "interstice" ] ]
#32 Mr. Spell. telet r = MOOList [ "", "y", [ "telethon" ] ]
#32 Mr. Spell. obj r = MOOList [ "e", "c", [ "objet" ] ]
#32 Mr. Spell. teleo r = MOOList [ "", "", [ "teleost", "teleology" ] ]
#32 Mr. Spell. obl r = MOOList [ "", "i", [ "oblong", "oblate" ] ]
#32 Mr. Spell. telep r = MOOList [ "", "ahr", [ ] ]
#32 Mr. Spell. obo r = MOOList [ "", "", [ "oboist", "oboe" ] ]
#32 Mr. Spell. aper r = MOOList [ "", "", [ "aperture", "aperiodic" ] ]
#32 Mr. Spell. oas r = MOOList [ "", "", [ "oasis", "oases" ] ]
#32 Mr. Spell. oat r = MOOList [ "", "", [ "oatmeal", "oath", "oat" ] ]
#32 Mr. Spell. bittern r = MOOList [ "", "", [ "bitternut", "bittern" ] ]
#32 Mr. Spell. interse r = MOOList [ "ct", "", [ "intersection", "intersect" ] ]
#32 Mr. Spell. trail r = MOOList [ "", "", [ "trailside", "trailhead", "trailblaze", "trail" ] ]
#32 Mr. Spell. dyna r = MOOList [ "", "ms", [ ] ]
#32 Mr. Spell. train r = MOOList [ "", "em", [ "training", "train" ] ]
#32 Mr. Spell. heath r = MOOList [ "", "e", [ "Heathkit", "heath" ] ]
#32 Mr. Spell. Belg r = MOOList [ "", "i", [ "Belgrade" ] ]
#32 Mr. Spell. trait r = MOOList [ "", "o", [ "trait" ] ]
#32 Mr. Spell. Abid r = MOOList [ "", "", [ "Abidjan", "abide" ] ]
#32 Mr. Spell. Leaven r = MOOList [ "", "", [ "Leavenworth", "leaven" ] ]
#32 Mr. Spell. residua r = MOOList [ "", "", [ "residuary", "residual" ] ]
#32 Mr. Spell. purch r = MOOList [ "as", "", [ "purchase", "purchasable" ] ]
#32 Mr. Spell. teleg r = MOOList [ "ra", "p", [ "telegram" ] ]
#32 Mr. Spell. obs r = MOOList [ "", "ceot", [ "obsidian" ] ]
#32 Mr. Spell. obt r = MOOList [ "", "r", [ "obtain" ] ]
#32 Mr. Spell. dispensa r = MOOList [ "", "", [ "dispensate", "dispensary", "dispensable" ] ]
#32 Mr. Spell. obv r = MOOList [ "", "i", [ "obverse" ] ]
#32 Mr. Spell. crede r = MOOList [ "n", "t", [ "credenza" ] ]
#32 Mr. Spell. scur r = MOOList [ "", "r", [ "scurvy" ] ]
#32 Mr. Spell. proced r = MOOList [ "ur", "e", [ "procedural" ] ]
#32 Mr. Spell. scut r = MOOList [ "", "", [ "scutum", "scuttle" ] ]
#32 Mr. Spell. credi r = MOOList [ "", "t", [ "credible" ] ]
#32 Mr. Spell. suffic r = MOOList [ "", "", [ "sufficient", "suffice" ] ]
#32 Mr. Spell. scuf r = MOOList [ "f", "", [ "scuffle", "scuff" ] ]
#32 Mr. Spell. standa r = MOOList [ "rd", "", [ "standards", "standard" ] ]
#32 Mr. Spell. scul r = MOOList [ "", "p", [ "scull" ] ]
#32 Mr. Spell. occ r = MOOList [ "", "ilu", [ "occasion" ] ]
#32 Mr. Spell. divid r = MOOList [ "e", "", [ "dividend", "divide" ] ]
#32 Mr. Spell. mutin r = MOOList [ "", "", [ "mutiny", "mutineer" ] ]
#32 Mr. Spell. applicat r = MOOList [ "", "", [ "applications", "applicate" ] ]
#32 Mr. Spell. odi r = MOOList [ "", "", [ "odium", "odious", "Odin" ] ]
#32 Mr. Spell. meteori r = MOOList [ "", "t", [ "meteoric" ] ]
#32 Mr. Spell. squal r = MOOList [ "", "", [ "squall", "squalid" ] ]
#32 Mr. Spell. squaw r = MOOList [ "", "", [ "squawroot", "squawk", "squawbush", "squaw" ] ]
#32 Mr. Spell. nego r = MOOList [ "tia", "", [ "negotiate", "negotiable" ] ]
#32 Mr. Spell. odo r = MOOList [ "", "", [ "odorous", "odometer" ] ]
#32 Mr. Spell. negl r = MOOList [ "", "i", [ "neglect" ] ]
#32 Mr. Spell. procla r = MOOList [ "", "", [ "proclamation", "proclaim" ] ]
#32 Mr. Spell. phonem r = MOOList [ "", "", [ "phonemic", "phoneme" ] ]
#32 Mr. Spell. squas r = MOOList [ "h", "", [ "squashy", "squashberry", "squash" ] ]
#32 Mr. Spell. butyr r = MOOList [ "", "", [ "butyric", "butyrate" ] ]
#32 Mr. Spell. Ashe r = MOOList [ "", "", [ "Asheville", "Asher", "ashen" ] ]
#32 Mr. Spell. squat r = MOOList [ "", "t", [ "squat" ] ]
#32 Mr. Spell. solicito r = MOOList [ "", "", [ "solicitous", "solicitor" ] ]
#32 Mr. Spell. oct r = MOOList [ "", "aeio", [ "Oct" ] ]
#32 Mr. Spell. ambig r = MOOList [ "u", "", [ "ambiguous", "ambiguity" ] ]
#32 Mr. Spell. Mao r = MOOList [ "", "", [ "Maori", "Mao" ] ]
#32 Mr. Spell. Ashl r = MOOList [ "", "", [ "Ashley", "Ashland" ] ]
#32 Mr. Spell. divis r = MOOList [ "", "i", [ "divisor" ] ]
#32 Mr. Spell. Norman r = MOOList [ "", "", [ "Normandy", "Norman" ] ]
#32 Mr. Spell. malcon r = MOOList [ "", "", [ "malcontent", "malconduct" ] ]
#32 Mr. Spell. Mah r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. divin r = MOOList [ "", "", [ "divine", "divination" ] ]
#32 Mr. Spell. Mag r = MOOList [ "", "gin", [ "Magruder", "magpie", "Magog", "magma", "magenta", "Magdalene", "magazine" ] ]
#32 Mr. Spell. homebu r = MOOList [ "ild", "", [ "homebuilding", "homebuilder" ] ]
#32 Mr. Spell. ribos r = MOOList [ "", "", [ "ribosome", "ribose" ] ]
#32 Mr. Spell. offici r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. Mae r = MOOList [ "", "", [ "maestro", "Maelstrom", "Mae" ] ]
#32 Mr. Spell. Mad r = MOOList [ "", "ademrs", [ "Madonna", "Madison", "madhouse", "madcap", "mad" ] ]
#32 Mr. Spell. stum r = MOOList [ "", "p", [ "stumble" ] ]
#32 Mr. Spell. McD r = MOOList [ "", "o", [ "McDermott", "McDaniel" ] ]
#32 Mr. Spell. stun r = MOOList [ "", "", [ "stunt", "stunk", "stung", "stun" ] ]
#32 Mr. Spell. office r = MOOList [ "", "", [ "offices", "officemate", "officeholder", "office" ] ]
#32 Mr. Spell. McC r = MOOList [ "", "alo", [ "McCullough", "McCracken" ] ]
#32 Mr. Spell. comba r = MOOList [ "t", "", [ "combatted", "combatant", "combat" ] ]
#32 Mr. Spell. stup r = MOOList [ "", "e", [ "stupor", "stupid" ] ]
#32 Mr. Spell. McA r = MOOList [ "", "", [ "McAllister", "McAdams" ] ]
#32 Mr. Spell. stur r = MOOList [ "", "", [ "Sturm", "sturgeon", "sturdy", "Sturbridge" ] ]
#32 Mr. Spell. infra r = MOOList [ "", "", [ "infrastructure", "infrared", "infract", "infra" ] ]
#32 Mr. Spell. calumn r = MOOList [ "", "", [ "calumny", "calumniate" ] ]
#32 Mr. Spell. Abel r = MOOList [ "", "", [ "Abelson", "Abelian", "Abel" ] ]
#32 Mr. Spell. stuf r = MOOList [ "f", "", [ "stuffy", "stuff" ] ]
#32 Mr. Spell. May r = MOOList [ "", "afo", [ "mayst", "Maynard", "mayhem", "Mayer", "maybe", "may" ] ]
#32 Mr. Spell. combi r = MOOList [ "n", "a", [ "combine" ] ]
#32 Mr. Spell. strong r = MOOList [ "", "", [ "strongroom", "stronghold", "strong" ] ]
#32 Mr. Spell. Mav r = MOOList [ "", "", [ "Mavis", "maverick" ] ]
#32 Mr. Spell. Aristoc r = MOOList [ "ra", "t", [ "aristocracy" ] ]
#32 Mr. Spell. Aber r = MOOList [ "", "r", [ "Abernathy", "Aberdeen" ] ]
#32 Mr. Spell. natio r = MOOList [ "n", "", [ "nations", "national", "nationwide", "nation" ] ]
#32 Mr. Spell. apar r = MOOList [ "t", "", [ "apartheid", "apart" ] ]
#32 Mr. Spell. apat r = MOOList [ "", "h", [ "apatite" ] ]
#32 Mr. Spell. stub r = MOOList [ "", "b", [ "stub" ] ]
#32 Mr. Spell. combu r = MOOList [ "sti", "", [ "combustion", "combustible" ] ]
#32 Mr. Spell. stuc r = MOOList [ "", "", [ "stuck", "stucco" ] ]
#32 Mr. Spell. McN r = MOOList [ "", "a", [ "McNulty", "McNeil" ] ]
#32 Mr. Spell. McM r = MOOList [ "", "", [ "McMullen", "McMillan", "McMahon" ] ]
#32 Mr. Spell. McL r = MOOList [ "", "e", [ "McLaughlin" ] ]
#32 Mr. Spell. McK r = MOOList [ "", "ei", [ "McKnight", "McKay" ] ]
#32 Mr. Spell. McI r = MOOList [ "nt", "", [ "McIntyre", "McIntosh" ] ]
#32 Mr. Spell. squad r = MOOList [ "", "", [ "squadron", "squad" ] ]
#32 Mr. Spell. oed r = MOOList [ "ip", "", [ "Oedipus", "Oedipal" ] ]
#32 Mr. Spell. McG r = MOOList [ "", "ior", [ "McGuire", "McGee" ] ]
#32 Mr. Spell. Aristot r = MOOList [ "", "e", [ "Aristotle" ] ]
#32 Mr. Spell. McF r = MOOList [ "a", "", [ "McFarland", "McFadden" ] ]
#32 Mr. Spell. need r = MOOList [ "", "l", [ "needs", "needing", "needed", "needy", "needn't", "needham", "needful", "need" ] ]
#32 Mr. Spell. bureaucrat r = MOOList [ "", "", [ "bureaucratic", "bureaucrat" ] ]
#32 Mr. Spell. thirte r = MOOList [ "en", "", [ "thirteenth", "thirteen" ] ]
#32 Mr. Spell. scru r = MOOList [ "", "pt", [ "scruffy", "scrumptious", "scrub" ] ]
#32 Mr. Spell. oft r = MOOList [ "", "e", [ "oft" ] ]
#32 Mr. Spell. purpo r = MOOList [ "s", "e", [ "purposive" ] ]
#32 Mr. Spell. scro r = MOOList [ "", "l", [ "scrounge", "scrotum", "scrooge" ] ]
#32 Mr. Spell. declara r = MOOList [ "t", "io", [ ] ]
#32 Mr. Spell. scre r = MOOList [ "", "ew", [ "scream" ] ]
#32 Mr. Spell. Armad r = MOOList [ "", "", [ "armadillo", "armada" ] ]
#32 Mr. Spell. scri r = MOOList [ "", "bmp", [ "scriven" ] ]
#32 Mr. Spell. off r = MOOList [ "", "eis", [ "offload", "offhand", "offbeat", "offal", "off" ] ]
#32 Mr. Spell. Albert r = MOOList [ "", "", [ "Alberto", "Alberta", "Albert" ] ]
#32 Mr. Spell. O'D r = MOOList [ "", "", [ "O'Dwyer", "O'Donnell", "O'Dell" ] ]
#32 Mr. Spell. O'C r = MOOList [ "", "o", [ "o'clock" ] ]
#32 Mr. Spell. ambit r = MOOList [ "io", "", [ "ambitious", "ambition" ] ]
#32 Mr. Spell. exulta r = MOOList [ "", "", [ "exultation", "exultant" ] ]
#32 Mr. Spell. scra r = MOOList [ "", "mptw", [ "Scranton", "scraggly", "scrabble" ] ]
#32 Mr. Spell. ogr r = MOOList [ "e", "", [ "ogress", "ogre" ] ]
#32 Mr. Spell. Chis r = MOOList [ "", "", [ "Chisholm", "chisel" ] ]
#32 Mr. Spell. serap r = MOOList [ "", "", [ "seraphim", "serape" ] ]
#32 Mr. Spell. necr r = MOOList [ "o", "m", [ "necrotic", "necrosis", "necropsy" ] ]
#32 Mr. Spell. mains r = MOOList [ "t", "", [ "mainstream", "mainstay" ] ]
#32 Mr. Spell. planta r = MOOList [ "", "", [ "plantation", "plantain" ] ]
#32 Mr. Spell. maint r = MOOList [ "", "", [ "maintenance", "maintain" ] ]
#32 Mr. Spell. O'S r = MOOList [ "", "", [ "O'Sullivan", "O'Shea", "o's" ] ]
#32 Mr. Spell. sooths r = MOOList [ "ay", "", [ "soothsayer", "soothsay" ] ]
#32 Mr. Spell. mainl r = MOOList [ "", "", [ "mainly", "mainline", "mainland" ] ]
#32 Mr. Spell. stru r = MOOList [ "", "c", [ "strut", "strung", "strum", "struggle" ] ]
#32 Mr. Spell. nect r = MOOList [ "ar", "", [ "nectary", "nectarine", "nectareous", "nectar" ] ]
#32 Mr. Spell. indecis r = MOOList [ "i", "", [ "indecisive", "indecision" ] ]
#32 Mr. Spell. stri r = MOOList [ "", "cdknpv", [ "strife", "striate" ] ]
#32 Mr. Spell. predica r = MOOList [ "", "", [ "predicate", "predicament" ] ]
#32 Mr. Spell. comed r = MOOList [ "", "", [ "comedy", "comedian" ] ]
#32 Mr. Spell. authori r = MOOList [ "ta", "", [ "authoritative", "authoritarian" ] ]
#32 Mr. Spell. memora r = MOOList [ "", "bn", [ ] ]
#32 Mr. Spell. Beec r = MOOList [ "h", "", [ "beechwood", "Beecham", "beech" ] ]
#32 Mr. Spell. ohm r = MOOList [ "", "", [ "ohmmeter", "ohmic", "ohm" ] ]
#32 Mr. Spell. stro r = MOOList [ "", "bmnp", [ "strove", "stroll", "stroke", "strode" ] ]
#32 Mr. Spell. stra r = MOOList [ "", "bintw", [ "stray", "Strauss", "strap", "straggle", "strafe", "straddle" ] ]
#32 Mr. Spell. neck r = MOOList [ "", "l", [ "necktie", "neck" ] ]
#32 Mr. Spell. regio r = MOOList [ "n", "", [ "regions", "region" ] ]
#32 Mr. Spell. suppo r = MOOList [ "", "sr", [ ] ]
#32 Mr. Spell. suppl r = MOOList [ "", "ei", [ "supply", "supplant" ] ]
#32 Mr. Spell. stre r = MOOList [ "", "aenps", [ "strewn", "stretch" ] ]
#32 Mr. Spell. rough r = MOOList [ "", "", [ "roughly", "roughshod", "roughneck", "roughish", "roughen", "roughcast", "rough" ] ]
#32 Mr. Spell. seques r = MOOList [ "t", "", [ "sequestration", "sequester" ] ]
#32 Mr. Spell. philos r = MOOList [ "oph", "", [ "philosophy", "philosophic", "philosoph" ] ]
#32 Mr. Spell. regis r = MOOList [ "", "t", [ "Regis" ] ]
#32 Mr. Spell. nece r = MOOList [ "ss", "i", [ "necessary" ] ]
#32 Mr. Spell. absol r = MOOList [ "", "u", [ "absolve" ] ]
#32 Mr. Spell. Abbo r = MOOList [ "t", "", [ "Abbott", "abbot" ] ]
#32 Mr. Spell. Beet r = MOOList [ "", "", [ "beetle", "Beethoven", "beet" ] ]
#32 Mr. Spell. morta r = MOOList [ "", "", [ "mortar", "mortal" ] ]
#32 Mr. Spell. comet r = MOOList [ "", "", [ "cometh", "cometary", "comet" ] ]
#32 Mr. Spell. Mer r = MOOList [ "", "cegilr", [ "Mervin", "mermaid" ] ]
#32 Mr. Spell. absor r = MOOList [ "", "bp", [ ] ]
#32 Mr. Spell. suppr r = MOOList [ "ess", "i", [ "suppressor", "suppress" ] ]
#32 Mr. Spell. Greenb r = MOOList [ "", "e", [ "Greenbriar", "Greenblatt" ] ]
#32 Mr. Spell. nebu r = MOOList [ "l", "a", [ "nebulous" ] ]
#32 Mr. Spell. influ r = MOOList [ "", "e", [ "influx" ] ]
#32 Mr. Spell. Chic r = MOOList [ "", "ak", [ "chicory", "chic" ] ]
#32 Mr. Spell. predict r = MOOList [ "", "", [ "predictor", "predict" ] ]
#32 Mr. Spell. oil r = MOOList [ "", "m", [ "oily", "oilseed", "oilcloth", "oil" ] ]
#32 Mr. Spell. yeas r = MOOList [ "t", "", [ "yeasty", "yeast" ] ]
#32 Mr. Spell. presump r = MOOList [ "ti", "", [ "presumptive", "presumption" ] ]
#32 Mr. Spell. year r = MOOList [ "", "", [ "yearn", "yearbook", "years", "year" ] ]
#32 Mr. Spell. Bedf r = MOOList [ "", "", [ "Bedford", "bedfast" ] ]
#32 Mr. Spell. Shatte r = MOOList [ "r", "", [ "shatterproof", "shatter" ] ]
#32 Mr. Spell. scoo r = MOOList [ "", "", [ "scoot", "scoop" ] ]
#32 Mr. Spell. scop r = MOOList [ "", "", [ "scops", "scopic", "scope" ] ]
#32 Mr. Spell. morti r = MOOList [ "", "", [ "mortise", "mortify", "mortician" ] ]
#32 Mr. Spell. scor r = MOOList [ "", "enp", [ "scoria", "scorch" ] ]
#32 Mr. Spell. mortg r = MOOList [ "ag", "e", [ "mortgagor" ] ]
#32 Mr. Spell. scot r = MOOList [ "", "st", [ "Scotland", "Scotia", "scotch", "Scot" ] ]
#32 Mr. Spell. scou r = MOOList [ "", "r", [ "scout", "scoundrel" ] ]
#32 Mr. Spell. Mex r = MOOList [ "ic", "", [ "Mexico", "Mexican" ] ]
#32 Mr. Spell. confiden r = MOOList [ "t", "", [ "confidential", "confident" ] ]
#32 Mr. Spell. squee r = MOOList [ "", "", [ "squeeze", "squeegee" ] ]
#32 Mr. Spell. squea r = MOOList [ "", "k", [ "squeamish", "squeal" ] ]
#32 Mr. Spell. composi r = MOOList [ "t", "", [ "compositor", "composition", "composite" ] ]
#32 Mr. Spell. neat r = MOOList [ "", "e", [ "neath", "neat" ] ]
#32 Mr. Spell. near r = MOOList [ "", "", [ "nearing", "nearly", "nearsighted", "nearby", "near" ] ]
#32 Mr. Spell. mailm r = MOOList [ "", "", [ "mailmen", "mailman" ] ]
#32 Mr. Spell. octag r = MOOList [ "on", "", [ "octagonal", "octagon" ] ]
#32 Mr. Spell. octah r = MOOList [ "edr", "a", [ "octahedron" ] ]
#32 Mr. Spell. space r = MOOList [ "", "s", [ "spacetime", "spacecraft", "space" ] ]
#32 Mr. Spell. Beca r = MOOList [ "", "", [ "because", "became", "becalm" ] ]
#32 Mr. Spell. supre r = MOOList [ "m", "", [ "supremum", "supreme", "supremacy" ] ]
#32 Mr. Spell. protop r = MOOList [ "", "l", [ "Protophyta" ] ]
#32 Mr. Spell. credent r = MOOList [ "", "", [ "credential", "credent" ] ]
#32 Mr. Spell. octan r = MOOList [ "", "", [ "octant", "octane" ] ]
#32 Mr. Spell. protot r = MOOList [ "yp", "", [ "prototypic", "prototype" ] ]
#32 Mr. Spell. stow r = MOOList [ "", "a", [ "stow" ] ]
#32 Mr. Spell. simpl r = MOOList [ "", "ei", [ "simply" ] ]
#32 Mr. Spell. protoz r = MOOList [ "oa", "", [ "protozoan", "Protozoa" ] ]
#32 Mr. Spell. price r = MOOList [ "", "", [ "prices", "price" ] ]
#32 Mr. Spell. prick r = MOOList [ "", "", [ "prickle", "prick" ] ]
#32 Mr. Spell. ston r = MOOList [ "", "e", [ "stony" ] ]
#32 Mr. Spell. stoo r = MOOList [ "", "", [ "stoop", "stool", "stooge", "stood" ] ]
#32 Mr. Spell. Forbea r = MOOList [ "r", "", [ "forbearance", "forbear" ] ]
#32 Mr. Spell. stop r = MOOList [ "", "", [ "stopwatch", "stoppage", "stopover", "stopgap", "stopcock", "stopband", "stop" ] ]
#32 Mr. Spell. Semit r = MOOList [ "", "", [ "Semitic", "Semite" ] ]
#32 Mr. Spell. stor r = MOOList [ "", "emy", [ "stork", "storage" ] ]
#32 Mr. Spell. Hendr r = MOOList [ "ick", "", [ "Hendrickson", "Hendrick" ] ]
#32 Mr. Spell. Kelle r = MOOList [ "", "", [ "Kelley", "Keller" ] ]
#32 Mr. Spell. informa r = MOOList [ "", "t", [ "informant", "informal" ] ]
#32 Mr. Spell. stoi r = MOOList [ "c", "", [ "stoichiometry", "stoic" ] ]
#32 Mr. Spell. stol r = MOOList [ "", "e", [ "stolid" ] ]
#32 Mr. Spell. stom r = MOOList [ "", "", [ "stomp", "stomach" ] ]
#32 Mr. Spell. Sherw r = MOOList [ "", "", [ "Sherwood", "Sherwin" ] ]
#32 Mr. Spell. morri r = MOOList [ "", "s", [ "Morrill" ] ]
#32 Mr. Spell. Chen r = MOOList [ "", "", [ "chenille", "Cheney", "Chen" ] ]
#32 Mr. Spell. stoc r = MOOList [ "", "k", [ "stochastic" ] ]
#32 Mr. Spell. Cher r = MOOList [ "", "u", [ "Cheryl", "chert", "cherry", "Cherokee", "cherish" ] ]
#32 Mr. Spell. Ches r = MOOList [ "", "t", [ "chess", "Cheshire", "Chesapeake" ] ]
#32 Mr. Spell. neona r = MOOList [ "t", "", [ "neonate", "neonatal" ] ]
#32 Mr. Spell. Chev r = MOOList [ "", "r", [ "chevy", "chevalier" ] ]
#32 Mr. Spell. sequen r = MOOList [ "t", "", [ "sequential", "sequent" ] ]
#32 Mr. Spell. supra r = MOOList [ "", "", [ "supranational", "supra" ] ]
#32 Mr. Spell. Jorgen r = MOOList [ "s", "", [ "Jorgenson", "Jorgensen" ] ]
#32 Mr. Spell. perpetu r = MOOList [ "", "a", [ "perpetuity" ] ]
#32 Mr. Spell. intellige r = MOOList [ "nt", "", [ "intelligentsia", "intelligent" ] ]
#32 Mr. Spell. comin r = MOOList [ "", "", [ "coming", "Cominform" ] ]
#32 Mr. Spell. sooth r = MOOList [ "", "s", [ "soothe", "sooth" ] ]
#32 Mr. Spell. Niel r = MOOList [ "s", "", [ "Nielson", "Nielsen" ] ]
#32 Mr. Spell. Mid r = MOOList [ "", "dgsw", [ "midterm", "midrange", "midpoint", "midnight", "midmorn", "midland", "midband", "Midas", "mid" ] ]
#32 Mr. Spell. hierar r = MOOList [ "ch", "", [ "hierarchy", "hierarchic", "hierarchal" ] ]
#32 Mr. Spell. arran r = MOOList [ "ge", "", [ "arrangeable", "arrange" ] ]
#32 Mr. Spell. supe r = MOOList [ "r", "bfilnsv", [ "superposable", "supercilious", "superannuate", "super" ] ]
#32 Mr. Spell. Olig r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. ola r = MOOList [ "", "", [ "Olav", "Olaf" ] ]
#32 Mr. Spell. toile r = MOOList [ "t", "", [ "toiletry", "toilet" ] ]
#32 Mr. Spell. alterna r = MOOList [ "t", "", [ "alternative", "alternate" ] ]
#32 Mr. Spell. Poll r = MOOList [ "", "ou", [ "pollinate", "pollen", "Pollard", "poll" ] ]
#32 Mr. Spell. old r = MOOList [ "", "es", [ "oldy", "old" ] ]
#32 Mr. Spell. Mit r = MOOList [ "", "eort", [ "mitigate", "Mitchell", "MIT" ] ]
#32 Mr. Spell. ole r = MOOList [ "", "", [ "oleomargarine", "olefin", "oleander" ] ]
#32 Mr. Spell. prosti r = MOOList [ "tut", "", [ "prostitution", "prostitute" ] ]
#32 Mr. Spell. event r = MOOList [ "", "u", [ "eventide", "eventful", "event" ] ]
#32 Mr. Spell. oli r = MOOList [ "", "gv", [ "Olin" ] ]
#32 Mr. Spell. gala r = MOOList [ "", "ct", [ "galaxy", "Galapagos", "gala" ] ]
#32 Mr. Spell. Mil r = MOOList [ "", "adeiklt", [ "Milwaukee", "milord", "milch" ] ]
#32 Mr. Spell. omn r = MOOList [ "i", "p", [ "omniscient", "omnibus" ] ]
#32 Mr. Spell. dict r = MOOList [ "", "ai", [ "dictum" ] ]
#32 Mr. Spell. sunt r = MOOList [ "an", "n", [ "suntan" ] ]
#32 Mr. Spell. boson r = MOOList [ "", "", [ "bosonic", "boson" ] ]
#32 Mr. Spell. plen r = MOOList [ "", "it", [ "plenum", "plenary" ] ]
#32 Mr. Spell. oma r = MOOList [ "", "", [ "Oman", "Omaha" ] ]
#32 Mr. Spell. omb r = MOOList [ "uds", "", [ "ombudsperson", "ombudsman" ] ]
#32 Mr. Spell. weathers r = MOOList [ "trip", "", [ "weatherstripping", "weatherstrip" ] ]
#32 Mr. Spell. ome r = MOOList [ "", "", [ "omen", "omelet", "omega" ] ]
#32 Mr. Spell. sunl r = MOOList [ "i", "", [ "sunlit", "sunlight" ] ]
#32 Mr. Spell. Madam r = MOOList [ "", "", [ "Madame", "madam" ] ]
#32 Mr. Spell. pleu r = MOOList [ "ra", "", [ "pleural", "pleura" ] ]
#32 Mr. Spell. omi r = MOOList [ "", "t", [ "omission", "ominous", "omicron" ] ]
#32 Mr. Spell. dich r = MOOList [ "", "o", [ "dichloride" ] ]
#32 Mr. Spell. dick r = MOOList [ "", "e", [ "Dickson", "Dickinson", "dickcissel", "dick" ] ]
#32 Mr. Spell. suns r = MOOList [ "", "h", [ "sunspot", "sunset", "sunscreen" ] ]
#32 Mr. Spell. varian r = MOOList [ "", "", [ "variant", "Varian" ] ]
#32 Mr. Spell. sund r = MOOList [ "", "e", [ "sundry", "sundown", "sundial", "Sunday" ] ]
#32 Mr. Spell. ono r = MOOList [ "", "m", [ "Onondaga" ] ]
#32 Mr. Spell. Nico r = MOOList [ "", "t", [ "Nicosia", "Nicodemus" ] ]
#32 Mr. Spell. elep r = MOOList [ "hant", "", [ "elephantine", "elephant" ] ]
#32 Mr. Spell. trave r = MOOList [ "", "lr", [ "travesty" ] ]
#32 Mr. Spell. rais r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. sunf r = MOOList [ "", "", [ "sunflower", "sunfish" ] ]
#32 Mr. Spell. sung r = MOOList [ "", "", [ "sunglasses", "sung" ] ]
#32 Mr. Spell. onr r = MOOList [ "ush", "", [ "onrushing", "onrush" ] ]
#32 Mr. Spell. ons r = MOOList [ "", "", [ "onslaught", "onset" ] ]
#32 Mr. Spell. ont r = MOOList [ "", "o", [ "Ontario" ] ]
#32 Mr. Spell. sunk r = MOOList [ "", "", [ "sunken", "sunk" ] ]
#32 Mr. Spell. Nich r = MOOList [ "", "o", [ "nichrome", "niche" ] ]
#32 Mr. Spell. rail r = MOOList [ "", "", [ "railway", "railroad", "raillery", "railhead", "railbird", "rail" ] ]
#32 Mr. Spell. elev r = MOOList [ "", "e", [ "elevate" ] ]
#32 Mr. Spell. sinew r = MOOList [ "", "", [ "sinewy", "sinew" ] ]
#32 Mr. Spell. rain r = MOOList [ "", "", [ "rainy", "rainstorm", "rainfall", "raindrop", "raincoat", "rainbow", "rain" ] ]
#32 Mr. Spell. sunb r = MOOList [ "", "u", [ "sunbonnet", "sunbeam" ] ]
#32 Mr. Spell. pleb r = MOOList [ "", "", [ "plebian", "plebeian" ] ]
#32 Mr. Spell. gambi r = MOOList [ "", "", [ "gambit", "Gambia" ] ]
#32 Mr. Spell. plea r = MOOList [ "", "s", [ "pleat", "plead", "plea" ] ]
#32 Mr. Spell. hund r = MOOList [ "red", "", [ "hundredth", "hundredfold", "hundred" ] ]
#32 Mr. Spell. elea r = MOOList [ "", "", [ "Eleazar", "Eleanor" ] ]
#32 Mr. Spell. onc r = MOOList [ "", "o", [ "once" ] ]
#32 Mr. Spell. distributi r = MOOList [ "", "", [ "distributive", "distribution" ] ]
#32 Mr. Spell. elec r = MOOList [ "t", "or", [ "elect" ] ]
#32 Mr. Spell. summ r = MOOList [ "", "aei", [ "summon" ] ]
#32 Mr. Spell. eleg r = MOOList [ "", "", [ "elegy", "elegiac", "elegant" ] ]
#32 Mr. Spell. onl r = MOOList [ "", "o", [ "online", "only" ] ]
#32 Mr. Spell. elem r = MOOList [ "ent", "", [ "elementary", "element" ] ]
#32 Mr. Spell. diam r = MOOList [ "", "a", [ "diamond", "diameter" ] ]
#32 Mr. Spell. dial r = MOOList [ "", "e", [ "dialysis", "dialup", "dialogue", "dial" ] ]
#32 Mr. Spell. hump r = MOOList [ "", "", [ "humpty", "Humphrey", "humpback", "hump" ] ]
#32 Mr. Spell. villa r = MOOList [ "", "i", [ "village", "villa" ] ]
#32 Mr. Spell. diap r = MOOList [ "", "h", [ "diapason", "diaper" ] ]
#32 Mr. Spell. sincer r = MOOList [ "e", "", [ "sincerely", "sincere" ] ]
#32 Mr. Spell. diat r = MOOList [ "", "ho", [ ] ]
#32 Mr. Spell. Runn r = MOOList [ "", "", [ "running", "Runnymede", "runneth" ] ]
#32 Mr. Spell. Cice r = MOOList [ "ro", "", [ "Ciceronian", "Cicero" ] ]
#32 Mr. Spell. gail r = MOOList [ "", "", [ "gaillardia", "Gail" ] ]
#32 Mr. Spell. congesti r = MOOList [ "", "", [ "congestive", "congestion" ] ]
#32 Mr. Spell. gloria r = MOOList [ "", "", [ "Gloriana", "Gloria" ] ]
#32 Mr. Spell. abstr r = MOOList [ "", "a", [ "abstruse" ] ]
#32 Mr. Spell. Greenw r = MOOList [ "", "", [ "greenwood", "Greenwich", "greenware" ] ]
#32 Mr. Spell. billio r = MOOList [ "n", "", [ "billions", "billionth", "billion" ] ]
#32 Mr. Spell. sult r = MOOList [ "", "a", [ "sultry" ] ]
#32 Mr. Spell. huma r = MOOList [ "n", "", [ "humanitarian", "humane", "human" ] ]
#32 Mr. Spell. diac r = MOOList [ "", "", [ "diacritic", "diachronic" ] ]
#32 Mr. Spell. Czec r = MOOList [ "h", "", [ "Czechoslovakia", "Czech" ] ]
#32 Mr. Spell. print r = MOOList [ "", "", [ "printout", "printmake", "print" ] ]
#32 Mr. Spell. diab r = MOOList [ "", "e", [ "diabolic", "diabase" ] ]
#32 Mr. Spell. sulk r = MOOList [ "", "", [ "sulky", "sulk" ] ]
#32 Mr. Spell. humi r = MOOList [ "", "dl", [ ] ]
#32 Mr. Spell. diag r = MOOList [ "", "nr", [ "diagonal" ] ]
#32 Mr. Spell. fogg r = MOOList [ "", "", [ "foggy", "fogging" ] ]
#32 Mr. Spell. owner r = MOOList [ "", "", [ "owners", "owner" ] ]
#32 Mr. Spell. humm r = MOOList [ "", "", [ "hummock", "hummingbird", "Hummel" ] ]
#32 Mr. Spell. Fair r = MOOList [ "", "f", [ "fairly", "fairy", "fairway", "Fairport", "fairgoer", "Fairchild", "fair" ] ]
#32 Mr. Spell. regrett r = MOOList [ "", "", [ "regretting", "regretted", "regrettable" ] ]
#32 Mr. Spell. grip r = MOOList [ "", "", [ "grippe", "gripe", "grip" ] ]
#32 Mr. Spell. commo r = MOOList [ "", "dn", [ "commotion" ] ]
#32 Mr. Spell. opt r = MOOList [ "", "hio", [ "opt" ] ]
#32 Mr. Spell. grin r = MOOList [ "", "d", [ "grin" ] ]
#32 Mr. Spell. sulf r = MOOList [ "", "aiu", [ "sulfonamide" ] ]
#32 Mr. Spell. opu r = MOOList [ "", "", [ "opus", "opulent" ] ]
#32 Mr. Spell. grit r = MOOList [ "", "", [ "gritty", "grit" ] ]
#32 Mr. Spell. princ r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. gris r = MOOList [ "", "t", [ "Griswold", "grisly" ] ]
#32 Mr. Spell. everg r = MOOList [ "", "", [ "evergreen", "Everglades" ] ]
#32 Mr. Spell. ambul r = MOOList [ "a", "", [ "ambulatory", "ambulant" ] ]
#32 Mr. Spell. infus r = MOOList [ "", "i", [ "infuse" ] ]
#32 Mr. Spell. igno r = MOOList [ "", "r", [ "ignominious", "ignoble" ] ]
#32 Mr. Spell. commu r = MOOList [ "", "nt", [ ] ]
#32 Mr. Spell. vertica r = MOOList [ "l", "", [ "vertically", "vertical" ] ]
#32 Mr. Spell. igni r = MOOList [ "t", "", [ "ignition", "ignite" ] ]
#32 Mr. Spell. griz r = MOOList [ "zl", "", [ "grizzly", "grizzle" ] ]
#32 Mr. Spell. ambus r = MOOList [ "", "", [ "ambush", "ambuscade" ] ]
#32 Mr. Spell. venera r = MOOList [ "", "", [ "venerate", "venerable" ] ]
#32 Mr. Spell. grie r = MOOList [ "", "v", [ "grief" ] ]
#32 Mr. Spell. Rung r = MOOList [ "", "", [ "Runge", "rung" ] ]
#32 Mr. Spell. grid r = MOOList [ "", "", [ "gridiron", "griddle", "grid" ] ]
#32 Mr. Spell. opi r = MOOList [ "", "n", [ "opium", "opiate" ] ]
#32 Mr. Spell. every r = MOOList [ "", "", [ "everywhere", "everything", "everyone", "everyman", "everyday", "everybody", "every" ] ]
#32 Mr. Spell. grim r = MOOList [ "", "ae", [ "Grimm", "grim" ] ]
#32 Mr. Spell. gril r = MOOList [ "l", "", [ "grillwork", "grille", "grill" ] ]
#32 Mr. Spell. opp r = MOOList [ "", "or", [ "Oppenheimer" ] ]
#32 Mr. Spell. purve r = MOOList [ "y", "", [ "purveyor", "purvey" ] ]
#32 Mr. Spell. prima r = MOOList [ "", "", [ "primate", "primary", "primal", "primacy", "prima" ] ]
#32 Mr. Spell. play r = MOOList [ "", "bwe", [ "playing", "plays", "playtime", "playroom", "playoff", "playmate", "playhouse", "playground", "playful", "playa", "play" ] ]
#32 Mr. Spell. Shelt r = MOOList [ "", "", [ "Shelton", "shelter" ] ]
#32 Mr. Spell. prime r = MOOList [ "", "", [ "primed", "primeval", "prime" ] ]
#32 Mr. Spell. gagg r = MOOList [ "", "", [ "gaggle", "gagging" ] ]
#32 Mr. Spell. Shell r = MOOList [ "", "", [ "Shelley", "shell" ] ]
#32 Mr. Spell. ora r = MOOList [ "", "nt", [ "oral", "oracle" ] ]
#32 Mr. Spell. orb r = MOOList [ "", "i", [ "orb" ] ]
#32 Mr. Spell. occid r = MOOList [ "ent", "", [ "occidental", "occident" ] ]
#32 Mr. Spell. Madel r = MOOList [ "", "", [ "Madeline", "Madeleine" ] ]
#32 Mr. Spell. plai r = MOOList [ "", "n", [ "plaid" ] ]
#32 Mr. Spell. metamorphi r = MOOList [ "", "", [ "metamorphism", "metamorphic" ] ]
#32 Mr. Spell. plag r = MOOList [ "", "iu", [ ] ]
#32 Mr. Spell. Olde r = MOOList [ "n", "", [ "Oldenburg", "olden" ] ]
#32 Mr. Spell. raff r = MOOList [ "", "i", [ "Rafferty" ] ]
#32 Mr. Spell. plat r = MOOList [ "", "eio", [ "platypus", "Platte", "platform", "plat" ] ]
#32 Mr. Spell. plas r = MOOList [ "", "mt", [ ] ]
#32 Mr. Spell. heroin r = MOOList [ "", "", [ "heroine", "heroin" ] ]
#32 Mr. Spell. singl r = MOOList [ "e", "t", [ "singlehanded", "single" ] ]
#32 Mr. Spell. plan r = MOOList [ "", "ekotn", [ "plans", "Planck", "planar", "plan" ] ]
#32 Mr. Spell. metamorpho r = MOOList [ "s", "", [ "metamorphosis", "metamorphose" ] ]
#32 Mr. Spell. smith r = MOOList [ "", "", [ "smithy", "Smithson", "Smithfield", "smithereens", "smith" ] ]
#32 Mr. Spell. ort r = MOOList [ "", "h", [ "Ortega" ] ]
#32 Mr. Spell. Fric r = MOOList [ "", "", [ "friction", "Frick", "fricative" ] ]
#32 Mr. Spell. Mon r = MOOList [ "", "aegikorst", [ "monument", "Monmouth", "Monday" ] ]
#32 Mr. Spell. cresc r = MOOList [ "en", "", [ "crescent", "crescendo" ] ]
#32 Mr. Spell. Moi r = MOOList [ "", "s", [ "moire", "Moines", "moiety" ] ]
#32 Mr. Spell. plac r = MOOList [ "", "ae", [ "placid" ] ]
#32 Mr. Spell. Moh r = MOOList [ "", "a", [ "Mohr" ] ]
#32 Mr. Spell. determina r = MOOList [ "", "", [ "determinate", "determinant" ] ]
#32 Mr. Spell. Gull r = MOOList [ "", "", [ "gully", "gullible", "gullet", "Gullah", "gull" ] ]
#32 Mr. Spell. elas r = MOOList [ "t", "", [ "elastomer", "elastic" ] ]
#32 Mr. Spell. Moe r = MOOList [ "", "", [ "Moen", "Moe" ] ]
#32 Mr. Spell. Frie r = MOOList [ "", "dn", [ "frieze" ] ]
#32 Mr. Spell. beatif r = MOOList [ "", "", [ "beatify", "beatific" ] ]
#32 Mr. Spell. Frig r = MOOList [ "", "hi", [ "Frigga", "frigate" ] ]
#32 Mr. Spell. osc r = MOOList [ "", "i", [ "Oscar" ] ]
#32 Mr. Spell. Tibet r = MOOList [ "", "", [ "Tibetan", "Tibet" ] ]
#32 Mr. Spell. orc r = MOOList [ "h", "ei", [ "orchard" ] ]
#32 Mr. Spell. ord r = MOOList [ "", "ei", [ "ordnance", "ordain" ] ]
#32 Mr. Spell. ore r = MOOList [ "", "gs", [ "ore" ] ]
#32 Mr. Spell. org r = MOOList [ "", "a", [ "orgy", "orgiastic" ] ]
#32 Mr. Spell. crest r = MOOList [ "", "", [ "Crestview", "crestfallen", "crest" ] ]
#32 Mr. Spell. suit r = MOOList [ "", "", [ "suitor", "suite", "suitcase", "suit" ] ]
#32 Mr. Spell. ori r = MOOList [ "", "egno", [ "orifice" ] ]
#32 Mr. Spell. orn r = MOOList [ "", "a", [ "ornery" ] ]
#32 Mr. Spell. Mou r = MOOList [ "", "lnrst", [ ] ]
#32 Mr. Spell. orp r = MOOList [ "h", "a", [ "Orphic", "Orpheus" ] ]
#32 Mr. Spell. Mos r = MOOList [ "", "eqs", [ "most", "Moslem", "Moscow", "mosaic" ] ]
#32 Mr. Spell. ost r = MOOList [ "", "er", [ ] ]
#32 Mr. Spell. suic r = MOOList [ "id", "", [ "suicide", "suicidal" ] ]
#32 Mr. Spell. hardwo r = MOOList [ "", "", [ "hardworking", "hardwood" ] ]
#32 Mr. Spell. creti r = MOOList [ "n", "", [ "cretinous", "cretin" ] ]
#32 Mr. Spell. focu r = MOOList [ "s", "", [ "focussed", "focus" ] ]
#32 Mr. Spell. radi r = MOOList [ "", "acou", [ "radix", "radish", "radii" ] ]
#32 Mr. Spell. prohibiti r = MOOList [ "", "", [ "prohibitive", "prohibition" ] ]
#32 Mr. Spell. involv r = MOOList [ "", "e", [ "involving" ] ]
#32 Mr. Spell. victoria r = MOOList [ "", "", [ "Victorian", "Victoria" ] ]
#32 Mr. Spell. pursu r = MOOList [ "", "", [ "pursuit", "pursue", "pursuant" ] ]
#32 Mr. Spell. caden r = MOOList [ "", "", [ "cadenza", "cadent" ] ]
#32 Mr. Spell. comma r = MOOList [ "", "n", [ "comma" ] ]
#32 Mr. Spell. osm r = MOOList [ "", "o", [ "osmium" ] ]
#32 Mr. Spell. comme r = MOOList [ "", "nr", [ "commemorate" ] ]
#32 Mr. Spell. involu r = MOOList [ "", "t", [ "involuntary" ] ]
#32 Mr. Spell. oss r = MOOList [ "", "", [ "ossify", "osseous" ] ]
#32 Mr. Spell. commi r = MOOList [ "", "st", [ "commingle" ] ]
#32 Mr. Spell. newt r = MOOList [ "", "o", [ "newts", "newt" ] ]
#32 Mr. Spell. news r = MOOList [ "", "mp", [ "Newsweek", "newsstand", "newsreel", "newsletter", "newscast", "newsboy", "news" ] ]
#32 Mr. Spell. race r = MOOList [ "", "", [ "raceway", "racetrack", "race" ] ]
#32 Mr. Spell. grey r = MOOList [ "", "", [ "greylag", "greyhound", "grey" ] ]
#32 Mr. Spell. proprio r = MOOList [ "cepti", "", [ "proprioceptive", "proprioception" ] ]
#32 Mr. Spell. gadg r = MOOList [ "et", "", [ "gadgetry", "gadget" ] ]
#32 Mr. Spell. rack r = MOOList [ "", "e", [ "rack" ] ]
#32 Mr. Spell. Pock r = MOOList [ "et", "", [ "pocketful", "pocketbook", "pocket" ] ]
#32 Mr. Spell. faste r = MOOList [ "", "", [ "faster", "fasten" ] ]
#32 Mr. Spell. proprie r = MOOList [ "t", "", [ "propriety", "proprietor", "proprietary" ] ]
#32 Mr. Spell. oth r = MOOList [ "e", "r", [ "Othello" ] ]
#32 Mr. Spell. newb r = MOOList [ "o", "", [ "newborn", "Newbold" ] ]
#32 Mr. Spell. grea r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. newc r = MOOList [ "", "", [ "newcomer", "Newcastle" ] ]
#32 Mr. Spell. gree r = MOOList [ "", "dn", [ "greet", "Greer", "Greek", "Greece" ] ]
#32 Mr. Spell. sugg r = MOOList [ "est", "i", [ "suggest" ] ]
#32 Mr. Spell. regul r = MOOList [ "", "a", [ "Regulus" ] ]
#32 Mr. Spell. newl r = MOOList [ "", "", [ "newlywed", "newline" ] ]
#32 Mr. Spell. spani r = MOOList [ "", "", [ "Spanish", "spaniel", "Spaniard" ] ]
#32 Mr. Spell. greg r = MOOList [ "", "", [ "Gregory", "Gregg", "gregarious", "Greg" ] ]
#32 Mr. Spell. sprou r = MOOList [ "", "", [ "sprout", "Sproul" ] ]
#32 Mr. Spell. portrai r = MOOList [ "t", "", [ "portraiture", "portrait" ] ]
#32 Mr. Spell. pandem r = MOOList [ "", "", [ "pandemonium", "pandemic" ] ]
#32 Mr. Spell. occul r = MOOList [ "t", "", [ "occultate", "occult" ] ]
#32 Mr. Spell. ouz r = MOOList [ "", "", [ "ouzo", "ouzel" ] ]
#32 Mr. Spell. Frey r = MOOList [ "", "", [ "Freya", "Frey" ] ]
#32 Mr. Spell. agric r = MOOList [ "", "u", [ "Agricola" ] ]
#32 Mr. Spell. Jacobs r = MOOList [ "", "", [ "Jacobson", "Jacobsen" ] ]
#32 Mr. Spell. foam r = MOOList [ "", "", [ "foamy", "foamflower", "foam" ] ]
#32 Mr. Spell. occur r = MOOList [ "", "r", [ "occur" ] ]
#32 Mr. Spell. ova r = MOOList [ "", "", [ "ovate", "ovary", "oval", "ova" ] ]
#32 Mr. Spell. Harle r = MOOList [ "", "", [ "Harley", "Harlem" ] ]
#32 Mr. Spell. rabi r = MOOList [ "", "", [ "Rabin", "rabies", "rabid" ] ]
#32 Mr. Spell. ove r = MOOList [ "", "nr", [ ] ]
#32 Mr. Spell. portray r = MOOList [ "", "", [ "portrayal", "portray" ] ]
#32 Mr. Spell. occup r = MOOList [ "", "a", [ "occupy" ] ]
#32 Mr. Spell. neve r = MOOList [ "", "r", [ "neve" ] ]
#32 Mr. Spell. oug r = MOOList [ "ht", "", [ "oughtn't", "ought" ] ]
#32 Mr. Spell. coachm r = MOOList [ "", "", [ "coachmen", "coachman" ] ]
#32 Mr. Spell. neva r = MOOList [ "", "", [ "Nevada", "Neva" ] ]
#32 Mr. Spell. apri r = MOOList [ "", "", [ "April", "apricot" ] ]
#32 Mr. Spell. rabb r = MOOList [ "", "i", [ "rabble", "rabbet" ] ]
#32 Mr. Spell. transmitta r = MOOList [ "", "", [ "transmittance", "transmittal", "transmittable" ] ]
#32 Mr. Spell. Jacobi r = MOOList [ "", "", [ "Jacobite", "Jacobian", "Jacobi" ] ]
#32 Mr. Spell. our r = MOOList [ "", "s", [ "our" ] ]
#32 Mr. Spell. apro r = MOOList [ "", "", [ "apropos", "apron" ] ]
#32 Mr. Spell. out r = MOOList [ "", "l", [ "output", "outside", "outrageous", "outermost", "out" ] ]
#32 Mr. Spell. neut r = MOOList [ "", "r", [ "neuter" ] ]
#32 Mr. Spell. neur r = MOOList [ "", "ao", [ "neuritis" ] ]
#32 Mr. Spell. transmitte r = MOOList [ "", "", [ "transmitter", "transmitted" ] ]
#32 Mr. Spell. gabb r = MOOList [ "", "", [ "gabbro", "gabble" ] ]
#32 Mr. Spell. Fred r = MOOList [ "", "de", [ "Fredrickson", "Fredholm", "Fred" ] ]
#32 Mr. Spell. crewm r = MOOList [ "", "", [ "crewmen", "crewman" ] ]
#32 Mr. Spell. compa r = MOOList [ "", "cnrst", [ "Compagnie" ] ]
#32 Mr. Spell. holste r = MOOList [ "", "", [ "holster", "Holstein" ] ]
#32 Mr. Spell. Fren r = MOOList [ "", "c", [ "frenzy", "frenetic" ] ]
#32 Mr. Spell. ovi r = MOOList [ "", "", [ "oviform", "Ovid" ] ]
#32 Mr. Spell. compe r = MOOList [ "", "lnt", [ ] ]
#32 Mr. Spell. tramp r = MOOList [ "", "", [ "trample", "tramp" ] ]
#32 Mr. Spell. Freu r = MOOList [ "d", "", [ "Freudian", "Freud" ] ]
#32 Mr. Spell. compi r = MOOList [ "l", "", [ "compile", "compilation" ] ]
#32 Mr. Spell. compl r = MOOList [ "", "aei", [ "comply" ] ]
#32 Mr. Spell. trapezo r = MOOList [ "id", "", [ "trapezoidal", "trapezoid" ] ]
#32 Mr. Spell. orthog r = MOOList [ "", "", [ "orthography", "orthogonal" ] ]
#32 Mr. Spell. nett r = MOOList [ "le", "", [ "nettlesome", "nettle" ] ]
#32 Mr. Spell. compr r = MOOList [ "", "e", [ "compromise", "comprise" ] ]
#32 Mr. Spell. appr r = MOOList [ "", "aeo", [ "apprise" ] ]
#32 Mr. Spell. Youngs r = MOOList [ "t", "", [ "Youngstown", "youngster" ] ]
#32 Mr. Spell. orthod r = MOOList [ "o", "nx", [ ] ]
#32 Mr. Spell. compo r = MOOList [ "", "ns", [ "compound", "compote", "comport" ] ]
#32 Mr. Spell. compu r = MOOList [ "", "lt", [ ] ]
#32 Mr. Spell. inges r = MOOList [ "t", "i", [ "ingest" ] ]
#32 Mr. Spell. compt r = MOOList [ "", "", [ "comptroller", "Compton" ] ]
#32 Mr. Spell. oxa r = MOOList [ "l", "", [ "oxalic", "oxalate" ] ]
#32 Mr. Spell. schema r = MOOList [ "", "t", [ "schema" ] ]
#32 Mr. Spell. oxe r = MOOList [ "", "", [ "oxeye", "oxen" ] ]
#32 Mr. Spell. Billi r = MOOList [ "", "o", [ "Billiken", "Billie", "billiard" ] ]
#32 Mr. Spell. systemi r = MOOList [ "", "", [ "systemization", "systemic" ] ]
#32 Mr. Spell. gray r = MOOList [ "", "", [ "graywacke", "Grayson", "graybeard", "gray" ] ]
#32 Mr. Spell. appa r = MOOList [ "", "lr", [ "appanage" ] ]
#32 Mr. Spell. Dutchm r = MOOList [ "", "", [ "Dutchmen", "Dutchman" ] ]
#32 Mr. Spell. Mud r = MOOList [ "", "d", [ "mudsling", "mudguard", "mud" ] ]
#32 Mr. Spell. grav r = MOOList [ "", "ei", [ "gravy" ] ]
#32 Mr. Spell. classif r = MOOList [ "", "", [ "classify", "classificatory" ] ]
#32 Mr. Spell. owl r = MOOList [ "", "", [ "owly", "owl" ] ]
#32 Mr. Spell. appe r = MOOList [ "", "aln", [ "appetite", "appertain" ] ]
#32 Mr. Spell. yest r = MOOList [ "er", "", [ "yesteryear", "yesterday" ] ]
#32 Mr. Spell. orthop r = MOOList [ "", "", [ "orthophosphate", "orthopedic" ] ]
#32 Mr. Spell. own r = MOOList [ "", "e", [ "own" ] ]
#32 Mr. Spell. graz r = MOOList [ "", "", [ "grazing", "graze" ] ]
#32 Mr. Spell. appl r = MOOList [ "", "aei", [ "apply" ] ]
#32 Mr. Spell. appo r = MOOList [ "", "is", [ "apport" ] ]
#32 Mr. Spell. oxy r = MOOList [ "gen", "", [ "oxygenate", "oxygen" ] ]
#32 Mr. Spell. grai r = MOOList [ "", "n", [ "grail" ] ]
#32 Mr. Spell. syllo r = MOOList [ "gis", "", [ "syllogistic", "syllogism" ] ]
#32 Mr. Spell. petri r = MOOList [ "", "", [ "petrify", "petri" ] ]
#32 Mr. Spell. graf r = MOOList [ "", "", [ "graft", "Graff" ] ]
#32 Mr. Spell. apos r = MOOList [ "t", "", [ "apostrophe", "apostolic", "apostle", "apostate" ] ]
#32 Mr. Spell. gram r = MOOList [ "ma", "r", [ "grammatic" ] ]
#32 Mr. Spell. apot r = MOOList [ "he", "", [ "apotheosis", "apothegm", "apothecary" ] ]
#32 Mr. Spell. embedd r = MOOList [ "", "e", [ "embedding", "embeddable" ] ]
#32 Mr. Spell. priva r = MOOList [ "", "", [ "private", "privacy" ] ]
#32 Mr. Spell. Muo r = MOOList [ "n", "", [ "Muong", "muon" ] ]
#32 Mr. Spell. petro r = MOOList [ "", "l", [ "petroglyph", "petrochemical" ] ]
#32 Mr. Spell. Mun r = MOOList [ "", "ci", [ "Munson", "mung", "mundane" ] ]
#32 Mr. Spell. grap r = MOOList [ "", "eh", [ "grapple" ] ]
#32 Mr. Spell. trape r = MOOList [ "z", "o", [ "trapezium" ] ]
#32 Mr. Spell. gran r = MOOList [ "", "ditu", [ "Granville", "granola", "granny", "granary" ] ]
#32 Mr. Spell. grat r = MOOList [ "", "eiu", [ "grata" ] ]
#32 Mr. Spell. nest r = MOOList [ "", "", [ "nested", "Nestor", "nestle", "nest" ] ]
#32 Mr. Spell. gras r = MOOList [ "", "s", [ "grasp" ] ]
#32 Mr. Spell. baptiste r = MOOList [ "", "", [ "baptistery", "Baptiste" ] ]
#32 Mr. Spell. Asto r = MOOList [ "", "r", [ "astound", "astonish" ] ]
#32 Mr. Spell. oxi r = MOOList [ "d", "a", [ "oxide" ] ]
#32 Mr. Spell. suck r = MOOList [ "", "", [ "suckling", "suck" ] ]
#32 Mr. Spell. literat r = MOOList [ "", "", [ "literature", "literate" ] ]
#32 Mr. Spell. homeom r = MOOList [ "orph", "", [ "homeomorphic", "homeomorph" ] ]
#32 Mr. Spell. diploi r = MOOList [ "d", "", [ "diploidy", "diploid" ] ]
#32 Mr. Spell. cess r = MOOList [ "", "", [ "Cessna", "cession", "cessation" ] ]
#32 Mr. Spell. apoc r = MOOList [ "", "ar", [ ] ]
#32 Mr. Spell. diplom r = MOOList [ "a", "t", [ "diplomacy", "diploma" ] ]
#32 Mr. Spell. spark r = MOOList [ "", "", [ "sparky", "Sparkman", "sparkle", "spark" ] ]
#32 Mr. Spell. succ r = MOOList [ "", "eu", [ "succinct" ] ]
#32 Mr. Spell. Muz r = MOOList [ "", "", [ "muzzle", "Muzo", "Muzak" ] ]
#32 Mr. Spell. grad r = MOOList [ "", "u", [ "Grady", "gradient", "grade", "gradate", "grad" ] ]
#32 Mr. Spell. grac r = MOOList [ "", "e", [ "grackle", "gracious" ] ]
#32 Mr. Spell. Bets r = MOOList [ "", "", [ "Betsy", "Betsey" ] ]
#32 Mr. Spell. electr r = MOOList [ "", "eio", [ "Electra" ] ]
#32 Mr. Spell. electo r = MOOList [ "r", "a", [ "elector" ] ]
#32 Mr. Spell. Rudo r = MOOList [ "l", "", [ "Rudolph", "Rudolf" ] ]
#32 Mr. Spell. quadran r = MOOList [ "", "g", [ "quadrant" ] ]
#32 Mr. Spell. subs r = MOOList [ "", "itu", [ "subservient" ] ]
#32 Mr. Spell. subt r = MOOList [ "", "elr", [ ] ]
#32 Mr. Spell. quadrat r = MOOList [ "", "", [ "quadrature", "quadratic" ] ]
#32 Mr. Spell. subu r = MOOList [ "rb", "", [ "suburbia", "suburb" ] ]
#32 Mr. Spell. nerv r = MOOList [ "", "", [ "nervous", "nerve" ] ]
#32 Mr. Spell. subv r = MOOList [ "er", "", [ "subvert", "subversive" ] ]
#32 Mr. Spell. Rudy r = MOOList [ "", "", [ "Rudyard", "Rudy" ] ]
#32 Mr. Spell. subj r = MOOList [ "", "e", [ "subjunctive" ] ]
#32 Mr. Spell. sylla r = MOOList [ "b", "i", [ "syllabus", "syllable" ] ]
#32 Mr. Spell. subl r = MOOList [ "im", "", [ "subliminal", "sublimate" ] ]
#32 Mr. Spell. transcrip r = MOOList [ "t", "", [ "transcription", "transcript" ] ]
#32 Mr. Spell. tranq r = MOOList [ "uil", "", [ "tranquillity", "tranquil" ] ]
#32 Mr. Spell. subm r = MOOList [ "", "i", [ "submersible" ] ]
#32 Mr. Spell. cert r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. intima r = MOOList [ "", "t", [ "intimal", "intimacy" ] ]
#32 Mr. Spell. cerv r = MOOList [ "", "", [ "cervix", "Cervantes" ] ]
#32 Mr. Spell. Assy r = MOOList [ "ri", "", [ "Assyriology", "Assyria" ] ]
#32 Mr. Spell. trans r = MOOList [ "", "acdefgilmopsv", [ "Transylvania" ] ]
#32 Mr. Spell. planet r = MOOList [ "", "a", [ "planetoid", "planetesimal", "planet" ] ]
#32 Mr. Spell. searc r = MOOList [ "h", "", [ "searching", "searchlight", "search" ] ]
#32 Mr. Spell. tensio r = MOOList [ "n", "", [ "tensional", "tension" ] ]
#32 Mr. Spell. Bess r = MOOList [ "", "e", [ "Bessie", "Bess" ] ]
#32 Mr. Spell. cere r = MOOList [ "", "bm", [ "cereus", "Ceres", "cereal" ] ]
#32 Mr. Spell. Xero r = MOOList [ "", "", [ "Xerox", "xerography" ] ]
#32 Mr. Spell. judica r = MOOList [ "", "t", [ "judicable" ] ]
#32 Mr. Spell. ceri r = MOOList [ "", "", [ "cerium", "cerise" ] ]
#32 Mr. Spell. normal r = MOOList [ "", "", [ "normally", "normalcy", "normal" ] ]
#32 Mr. Spell. gastron r = MOOList [ "om", "", [ "gastronomy", "gastronome" ] ]
#32 Mr. Spell. arrow r = MOOList [ "", "", [ "arrowroot", "arrowhead", "arrow" ] ]
#32 Mr. Spell. chick r = MOOList [ "", "", [ "chickweed", "chicken", "chickadee", "chick" ] ]
#32 Mr. Spell. seaso r = MOOList [ "n", "", [ "seasonal", "season" ] ]
#32 Mr. Spell. Bete r = MOOList [ "l", "", [ "Betelgeuse", "betel" ] ]
#32 Mr. Spell. demurre r = MOOList [ "", "", [ "demurrer", "demurred" ] ]
#32 Mr. Spell. prism r = MOOList [ "", "", [ "prismatic", "prism" ] ]
#32 Mr. Spell. temper r = MOOList [ "", "a", [ "temper" ] ]
#32 Mr. Spell. tempes r = MOOList [ "t", "", [ "tempestuous", "tempest" ] ]
#32 Mr. Spell. judici r = MOOList [ "", "a", [ "judicious" ] ]
#32 Mr. Spell. Jerem r = MOOList [ "", "", [ "Jeremy", "Jeremiah" ] ]
#32 Mr. Spell. servo r = MOOList [ "", "", [ "servomechanism", "servo" ] ]
#32 Mr. Spell. respira r = MOOList [ "t", "o", [ "respiration" ] ]
#32 Mr. Spell. computer r = MOOList [ "", "", [ "computers", "computer" ] ]
#32 Mr. Spell. servi r = MOOList [ "", "c", [ "servitor", "servile", "serviette" ] ]
#32 Mr. Spell. Mere r = MOOList [ "", "", [ "merely", "meretricious", "Meredith", "mere" ] ]
#32 Mr. Spell. nept r = MOOList [ "un", "", [ "neptunium", "Neptune" ] ]
#32 Mr. Spell. Rube r = MOOList [ "", "", [ "Ruben", "Rube" ] ]
#32 Mr. Spell. serve r = MOOList [ "", "", [ "server", "served", "serve" ] ]
#32 Mr. Spell. definite r = MOOList [ "", "", [ "definitely", "definite" ] ]
#32 Mr. Spell. definiti r = MOOList [ "", "", [ "definitive", "definition" ] ]
#32 Mr. Spell. Myc r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. constituti r = MOOList [ "", "", [ "constitutive", "constitution" ] ]
#32 Mr. Spell. Shear r = MOOList [ "", "", [ "Shearer", "shear" ] ]
#32 Mr. Spell. arrog r = MOOList [ "a", "", [ "arrogate", "arrogant" ] ]
#32 Mr. Spell. Merr r = MOOList [ "", "iy", [ ] ]
#32 Mr. Spell. distil r = MOOList [ "l", "", [ "distillery", "distillate" ] ]
#32 Mr. Spell. distin r = MOOList [ "", "", [ "distinguish", "distinct" ] ]
#32 Mr. Spell. Myn r = MOOList [ "", "", [ "Mynheer", "mynah" ] ]
#32 Mr. Spell. Schli r = MOOList [ "", "", [ "Schlitz", "schlieren" ] ]
#32 Mr. Spell. Shei r = MOOList [ "", "", [ "Sheila", "sheik" ] ]
#32 Mr. Spell. demitt r = MOOList [ "", "", [ "demitting", "demitted" ] ]
#32 Mr. Spell. exempt r = MOOList [ "", "", [ "exemption", "exempt" ] ]
#32 Mr. Spell. ditt r = MOOList [ "", "", [ "ditty", "ditto" ] ]
#32 Mr. Spell. Shel r = MOOList [ "", "lt", [ "shelve", "shelf", "Sheldon", "Shelby" ] ]
#32 Mr. Spell. exempl r = MOOList [ "", "a", [ "exemplify" ] ]
#32 Mr. Spell. Shed r = MOOList [ "", "", [ "Shedir", "shed" ] ]
#32 Mr. Spell. invio r = MOOList [ "la", "", [ "inviolate", "inviolable" ] ]
#32 Mr. Spell. Berni r = MOOList [ "", "e", [ "Bernini", "Bernice" ] ]
#32 Mr. Spell. knic r = MOOList [ "k", "", [ "Knickerbocker", "knick" ] ]
#32 Mr. Spell. invit r = MOOList [ "", "e", [ "invitation" ] ]
#32 Mr. Spell. Berne r = MOOList [ "", "", [ "Bernet", "berne" ] ]
#32 Mr. Spell. Allis r = MOOList [ "", "", [ "Allison", "Allis" ] ]
#32 Mr. Spell. decontroll r = MOOList [ "", "", [ "decontrolling", "decontrolled" ] ]
#32 Mr. Spell. Univ r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. volunta r = MOOList [ "r", "", [ "voluntary", "voluntarism" ] ]
#32 Mr. Spell. Berna r = MOOList [ "", "r", [ "Bernadine" ] ]
#32 Mr. Spell. Laurent r = MOOList [ "", "", [ "Laurentian", "Laurent" ] ]
#32 Mr. Spell. disq r = MOOList [ "ui", "", [ "disquisition", "disquietude" ] ]
#32 Mr. Spell. congra r = MOOList [ "tulat", "", [ "congratulatory", "congratulate" ] ]
#32 Mr. Spell. metro r = MOOList [ "", "p", [ "metronome", "metro" ] ]
#32 Mr. Spell. disp r = MOOList [ "", "aeou", [ "display" ] ]
#32 Mr. Spell.submitted rc = MOOList [ "glowing", "mostly", "appears", "reading", "warning", "lowercase", "faux", "picked", "letters", "singer", "logged", "teleport", "becomes", "refuses", "disturbed", "technically", "entries", "randomly", "seriously", "probabilities", "choosing", "stranger", "similarities", "letter", "mostly", "profusely", "writer", "liking", "reasoned", "shortened", "spelling", "abbreviated", "humor", "evidence", "firmly", "direction", "posting", "disconnected", "timing", "grammatically", "assuming", "permissions", "correctly", "caller", "containing", "generating", "unhelpful", "regardless", "occurence", "replaced", "capitalised", "precede", "pules", "neftehkefeh", "thinking", "stirring", "feelings", "weddings", "who's", "cars", "thinks", "dusting", "premenstrual", "trichome", "figment", "pages", "appears", "drags", "screaming", "teleport", "twirling", "suddenly", "jumps", "clawed", "shoulders", "yanking", "ceiling", "jumps", "sucked", "refuses", "THX", "teleport", "logged", "teleport", "replace", "voters", "sessile", "sessile", "splinter", "speaker", "horns", "stretches", "dividing", "encounter", "catapulted", "housekeeper", "purling", "RPG", "formation", "legs", "generations", "shoulders", "ends", "animation", "wearing", "modifies", "pushes", "suggesting", "evening", "pushes", "suggesting", "determined", "manners", "overalls", "accounting", "stripes", "disappear", "sleeves", "customize", "fastening", "feeling", "rising", "morning", "myst", "cunt", "glasses", "wearing", "teleports", "refuses", "logged", "expels", "featureless", "hastily", "crafted", "pages", "shapes", "crumpled", "folded", "badly", "bootlace", "chewing", "drops", "picks", "sees", "priority", "giver", "authorise", "embossed", "contains", "secrets", "Illuminati" ]
#32 Mr. Spell. diss r = MOOList [ "", "ei", [ "dissuade", "dissociate" ] ]
#32 Mr. Spell. disr r = MOOList [ "upt", "i", [ "disrupt" ] ]
#32 Mr. Spell. dist r = MOOList [ "", "airu", [ "distort" ] ]
#32 Mr. Spell. than r = MOOList [ "", "k", [ "than" ] ]
#32 Mr. Spell. skate r = MOOList [ "", "", [ "skater", "skate" ] ]
#32 Mr. Spell. clergym r = MOOList [ "", "", [ "clergymen", "clergyman" ] ]
#32 Mr. Spell. razo r = MOOList [ "r", "", [ "razorback", "razor" ] ]
#32 Mr. Spell. that r = MOOList [ "", "'", [ "thatch", "that" ] ]
#32 Mr. Spell. congre r = MOOList [ "", "s", [ "congregate" ] ]
#32 Mr. Spell. plun r = MOOList [ "", "", [ "plunk", "plunge", "plunder" ] ]
#32 Mr. Spell. disa r = MOOList [ "", "", [ "disappears", "disagree", "disastrous", "disambiguate", "disaccharide" ] ]
#32 Mr. Spell. plum r = MOOList [ "", "b", [ "plump", "plummet", "plume", "plumage", "plum" ] ]
#32 Mr. Spell. disc r = MOOList [ "", "eioru", [ "discarded", "disc" ] ]
#32 Mr. Spell. thal r = MOOList [ "", "l", [ "Thalia" ] ]
#32 Mr. Spell. disd r = MOOList [ "ain", "", [ "disdainful", "disdain" ] ]
#32 Mr. Spell. disg r = MOOList [ "", "", [ "disgustful", "disgruntle" ] ]
#32 Mr. Spell. dish r = MOOList [ "", "w", [ "dishevel", "dish" ] ]
#32 Mr. Spell. plus r = MOOList [ "", "h", [ "plus" ] ]
#32 Mr. Spell. dism r = MOOList [ "", "", [ "dismissal", "dismal" ] ]
#32 Mr. Spell. elut r = MOOList [ "", "", [ "elution", "elute" ] ]
#32 Mr. Spell. dirt r = MOOList [ "", "", [ "dirty", "dirt" ] ]
#32 Mr. Spell. plug r = MOOList [ "", "g", [ "plugboard", "plug" ] ]
#32 Mr. Spell. paradig r = MOOList [ "m", "", [ "paradigmatic", "paradigm" ] ]
#32 Mr. Spell. pluc r = MOOList [ "k", "", [ "plucky", "pluck" ] ]
#32 Mr. Spell. pac r = MOOList [ "", "eik", [ "pact" ] ]
#32 Mr. Spell. pad r = MOOList [ "", "d", [ "padre", "padlock", "pad" ] ]
#32 Mr. Spell. abras r = MOOList [ "i", "", [ "abrasive", "abrasion" ] ]
#32 Mr. Spell. pag r = MOOList [ "", "e", [ "pagoda", "paginate", "pagan" ] ]
#32 Mr. Spell. pai r = MOOList [ "", "nr", [ "paisley", "pail", "paid" ] ]
#32 Mr. Spell. rocka r = MOOList [ "", "", [ "rockaway", "rockabye" ] ]
#32 Mr. Spell. dire r = MOOList [ "", "c", [ "dire" ] ]
#32 Mr. Spell. pal r = MOOList [ "", "aeilmo", [ "palsy", "palpable", "palfrey", "pal" ] ]
#32 Mr. Spell. foxh r = MOOList [ "", "o", [ "Foxhall" ] ]
#32 Mr. Spell. bluebi r = MOOList [ "", "", [ "bluebird", "bluebill" ] ]
#32 Mr. Spell. vacat r = MOOList [ "", "", [ "vacationland", "vacate" ] ]
#32 Mr. Spell. pan r = MOOList [ "", "acdeiot", [ "pansy", "panjandrum", "panhandle", "pang", "pan" ] ]
#32 Mr. Spell. bluebo r = MOOList [ "", "", [ "bluebook", "bluebonnet" ] ]
#32 Mr. Spell. Shap r = MOOList [ "", "", [ "Shapiro", "shape" ] ]
#32 Mr. Spell. pap r = MOOList [ "", "aepy", [ "Papua", "paprika", "papoose", "papillary", "pap" ] ]
#32 Mr. Spell. sidewi r = MOOList [ "", "", [ "sidewise", "sidewinder" ] ]
#32 Mr. Spell. Jessi r = MOOList [ "", "", [ "Jessie", "Jessica" ] ]
#32 Mr. Spell. sidewa r = MOOList [ "", "l", [ "sideway" ] ]
#32 Mr. Spell. Merca r = MOOList [ "", "", [ "Mercator", "mercantile" ] ]
#32 Mr. Spell. andes r = MOOList [ "", "i", [ "Andes" ] ]
#32 Mr. Spell. inhere r = MOOList [ "", "", [ "inherent", "inhere" ] ]
#32 Mr. Spell. Gusta r = MOOList [ "", "v", [ "Gustafson" ] ]
#32 Mr. Spell. minima r = MOOList [ "", "", [ "minimax", "minimal", "minima" ] ]
#32 Mr. Spell. northwe r = MOOList [ "st", "", [ "northwestern", "northwest" ] ]
#32 Mr. Spell. inheri r = MOOList [ "t", "", [ "inherited", "inheritor", "inheritance", "inherit" ] ]
#32 Mr. Spell. ephemeri r = MOOList [ "", "", [ "ephemeris", "ephemerides" ] ]
#32 Mr. Spell. Shaf r = MOOList [ "", "", [ "shaft", "Shaffer", "Shafer" ] ]
#32 Mr. Spell. dipl r = MOOList [ "o", "im", [ ] ]
#32 Mr. Spell. par r = MOOList [ "", "aceiklorst", [ "parvenu", "parquet", "pardon", "parboil", "par" ] ]
#32 Mr. Spell. dominic r = MOOList [ "", "", [ "Dominick", "Dominican", "Dominic" ] ]
#32 Mr. Spell. assum r = MOOList [ "", "", [ "assumption", "assume" ] ]
#32 Mr. Spell. rocke r = MOOList [ "", "", [ "rocket", "Rockefeller" ] ]
#32 Mr. Spell. pav r = MOOList [ "", "", [ "Pavlov", "pavilion", "pave", "pavanne" ] ]
#32 Mr. Spell. felici r = MOOList [ "", "t", [ "Felicia" ] ]
#32 Mr. Spell. paw r = MOOList [ "", "n", [ "Pawtucket", "paw" ] ]
#32 Mr. Spell. knee r = MOOList [ "", "", [ "kneel", "kneecap", "knee" ] ]
#32 Mr. Spell. assur r = MOOList [ "", "", [ "assure", "assurance" ] ]
#32 Mr. Spell. pay r = MOOList [ "", "", [ "payroll", "payoff", "Payne", "paymaster", "payday", "paycheck", "pay" ] ]
#32 Mr. Spell. perve r = MOOList [ "r", "s", [ "pervert" ] ]
#32 Mr. Spell. what' r = MOOList [ "", "", [ "what're", "what'd" ] ]
#32 Mr. Spell. Beard r = MOOList [ "", "", [ "Beardsley", "beard" ] ]
#32 Mr. Spell. perva r = MOOList [ "", "s", [ "pervade" ] ]
#32 Mr. Spell. langu r = MOOList [ "", "i", [ "language" ] ]
#32 Mr. Spell. Austra r = MOOList [ "li", "", [ "australite", "Australis", "Australia" ] ]
#32 Mr. Spell. rheuma r = MOOList [ "ti", "", [ "rheumatism", "rheumatic" ] ]
#32 Mr. Spell. invei r = MOOList [ "g", "", [ "inveigle", "inveigh" ] ]
#32 Mr. Spell. Faye r = MOOList [ "tte", "", [ "Fayetteville", "Fayette" ] ]
#32 Mr. Spell. shipb r = MOOList [ "", "u", [ "shipboard" ] ]
#32 Mr. Spell. inver r = MOOList [ "", "st", [ "Inverness" ] ]
#32 Mr. Spell. inves r = MOOList [ "t", "io", [ "investment", "invest" ] ]
#32 Mr. Spell. tempor r = MOOList [ "a", "r", [ "temporal" ] ]
#32 Mr. Spell. inven r = MOOList [ "t", "io", [ "invent" ] ]
#32 Mr. Spell. influent r = MOOList [ "", "", [ "influential", "influent" ] ]
#32 Mr. Spell. diph r = MOOList [ "th", "", [ "diphthong", "diphtheria" ] ]
#32 Mr. Spell. resolu r = MOOList [ "t", "", [ "resolution", "resolute" ] ]
#32 Mr. Spell. perus r = MOOList [ "", "", [ "peruse", "perusal" ] ]
#32 Mr. Spell. foun r = MOOList [ "", "dt", [ ] ]
#32 Mr. Spell. shipm r = MOOList [ "", "a", [ "shipmen" ] ]
#32 Mr. Spell. foul r = MOOList [ "", "", [ "foulmouth", "foul" ] ]
#32 Mr. Spell. four r = MOOList [ "", "st", [ "Fourier", "fourfold", "four" ] ]
#32 Mr. Spell. appendi r = MOOList [ "", "", [ "appendix", "appendices" ] ]
#32 Mr. Spell. diop r = MOOList [ "", "", [ "diopter", "Diophantine" ] ]
#32 Mr. Spell. dior r = MOOList [ "", "", [ "diorite", "diorama" ] ]
#32 Mr. Spell. ravi r = MOOList [ "", "", [ "ravish", "ravine" ] ]
#32 Mr. Spell. defect r = MOOList [ "", "", [ "defector", "defect" ] ]
#32 Mr. Spell. artifice r = MOOList [ "", "", [ "artificer", "artifice" ] ]
#32 Mr. Spell. retrog r = MOOList [ "r", "e", [ "retrograde" ] ]
#32 Mr. Spell. retrof r = MOOList [ "it", "t", [ "retrofit" ] ]
#32 Mr. Spell. Nab r = MOOList [ "", "", [ "Nabisco", "nab" ] ]
#32 Mr. Spell. horsem r = MOOList [ "", "", [ "horsemen", "horseman" ] ]
#32 Mr. Spell. horsep r = MOOList [ "", "", [ "horsepower", "horseplay" ] ]
#32 Mr. Spell. honor r = MOOList [ "", "a", [ "honorific", "honoree" ] ]
#32 Mr. Spell. rave r = MOOList [ "", "n", [ "ravel", "rave" ] ]
#32 Mr. Spell. perti r = MOOList [ "n", "", [ "pertinent", "pertinacious" ] ]
#32 Mr. Spell. guarante r = MOOList [ "e", "", [ "guaranteeing", "guarantee" ] ]
#32 Mr. Spell. dioc r = MOOList [ "es", "", [ "diocese", "diocesan" ] ]
#32 Mr. Spell. pertu r = MOOList [ "rb", "", [ "perturbate", "perturb" ] ]
#32 Mr. Spell. horsew r = MOOList [ "om", "", [ "horsewomen", "horsewoman" ] ]
#32 Mr. Spell. Schna r = MOOList [ "", "", [ "schnapps", "Schnabel" ] ]
#32 Mr. Spell. pearl r = MOOList [ "", "", [ "pearlstone", "pearlite", "pearl" ] ]
#32 Mr. Spell. Nan r = MOOList [ "", "", [ "Nantucket", "nanosecond", "Nanking", "Nanette", "Nancy", "Nan" ] ]
#32 Mr. Spell. dinn r = MOOList [ "er", "", [ "dinnerware", "dinnertime" ] ]
#32 Mr. Spell. suze r = MOOList [ "rain", "", [ "suzerainty", "suzerain" ] ]
#32 Mr. Spell. horsef r = MOOList [ "l", "", [ "horsefly", "horseflesh" ] ]
#32 Mr. Spell. expansi r = MOOList [ "", "", [ "expansive", "expansion", "expansible" ] ]
#32 Mr. Spell. caste r = MOOList [ "", "", [ "casteth", "caste" ] ]
#32 Mr. Spell. ornam r = MOOList [ "ent", "", [ "ornamentation", "ornament" ] ]
#32 Mr. Spell. Nag r = MOOList [ "", "", [ "Nagy", "Nagoya", "nagging", "Nagasaki", "nag" ] ]
#32 Mr. Spell. martyr r = MOOList [ "", "", [ "martyrdom", "martyr" ] ]
#32 Mr. Spell. Nipp r = MOOList [ "", "", [ "Nippon", "nipple" ] ]
#32 Mr. Spell. letterm r = MOOList [ "", "", [ "lettermen", "letterman" ] ]
#32 Mr. Spell. pee r = MOOList [ "", "p", [ "peer", "peel", "peek", "pee" ] ]
#32 Mr. Spell. gaun r = MOOList [ "t", "", [ "gauntlet", "gaunt" ] ]
#32 Mr. Spell. gaul r = MOOList [ "", "", [ "Gaulle", "gauleiter", "Gaul" ] ]
#32 Mr. Spell. Steward r = MOOList [ "", "", [ "stewardess", "steward" ] ]
#32 Mr. Spell. sidest r = MOOList [ "ep", "", [ "sidestepping", "sidestep" ] ]
#32 Mr. Spell. persi r = MOOList [ "", "s", [ "persimmon", "persiflage", "Persia" ] ]
#32 Mr. Spell. pel r = MOOList [ "", "ltv", [ "pelican", "Pelham" ] ]
#32 Mr. Spell. savan r = MOOList [ "", "", [ "savant", "Savannah" ] ]
#32 Mr. Spell. pem r = MOOList [ "", "", [ "pemmican", "Pembroke" ] ]
#32 Mr. Spell. Naz r = MOOList [ "", "ai", [ ] ]
#32 Mr. Spell. pen r = MOOList [ "", "acdeimnstu", [ "Penrose", "Penh", "penguin", "pen" ] ]
#32 Mr. Spell. persu r = MOOList [ "a", "s", [ "persuade" ] ]
#32 Mr. Spell. peo r = MOOList [ "", "", [ "Peoria", "people", "peony" ] ]
#32 Mr. Spell. pep r = MOOList [ "", "ps", [ "peptide", "pep" ] ]
#32 Mr. Spell. perso r = MOOList [ "n", "a", [ "personnel", "personify", "person" ] ]
#32 Mr. Spell. per r = MOOList [ "", "cefijkmpstuv", [ "Perry", "perquisite", "peroxide", "pernicious", "Perle", "perhaps", "Pergamon", "perdition", "per" ] ]
#32 Mr. Spell. songb r = MOOList [ "", "", [ "songbook", "songbag" ] ]
#32 Mr. Spell. pes r = MOOList [ "", "st", [ ] ]
#32 Mr. Spell. Nat r = MOOList [ "", "ahiu", [ "natty", "NATO", "Natchez", "Nate", "Nat" ] ]
#32 Mr. Spell. pet r = MOOList [ "", "eirtu", [ "pets", "petal", "pet" ] ]
#32 Mr. Spell. persp r = MOOList [ "", "i", [ "perspective" ] ]
#32 Mr. Spell. ding r = MOOList [ "", "", [ "dingy", "dingo", "dinghy", "ding" ] ]
#32 Mr. Spell. dimi r = MOOList [ "n", "u", [ "diminish" ] ]
#32 Mr. Spell. refra r = MOOList [ "", "c", [ "refrain" ] ]
#32 Mr. Spell. plow r = MOOList [ "", "", [ "plowshare", "plowman", "plow" ] ]
#32 Mr. Spell. shirt r = MOOList [ "", "", [ "shirtmake", "shirt" ] ]
#32 Mr. Spell. ratt r = MOOList [ "", "l", [ "rattail" ] ]
#32 Mr. Spell. rate r = MOOList [ "", "", [ "rates", "rater", "rate" ] ]
#32 Mr. Spell. fost r = MOOList [ "er", "", [ "fosterite", "foster" ] ]
#32 Mr. Spell. gauc r = MOOList [ "he", "", [ "gaucherie", "gauche" ] ]
#32 Mr. Spell. foss r = MOOList [ "", "i", [ "Foss" ] ]
#32 Mr. Spell. casse r = MOOList [ "", "", [ "cassette", "casserole" ] ]
#32 Mr. Spell. rati r = MOOList [ "", "o", [ "ratify" ] ]
#32 Mr. Spell. pea r = MOOList [ "", "cklrs", [ "peat", "peanut", "peafowl", "Peabody", "pea" ] ]
#32 Mr. Spell. complementar r = MOOList [ "", "", [ "complementary", "complementarity" ] ]
#32 Mr. Spell. pec r = MOOList [ "", "tu", [ "Pecos", "peck", "peccary", "pecan" ] ]
#32 Mr. Spell. ped r = MOOList [ "", "aei", [ "Pedro", "peddle" ] ]
#32 Mr. Spell. gaug r = MOOList [ "", "e", [ "Gauguin" ] ]
#32 Mr. Spell. perspic r = MOOList [ "", "u", [ "perspicacious" ] ]
#32 Mr. Spell. Achi r = MOOList [ "", "", [ "aching", "Achilles", "achieve" ] ]
#32 Mr. Spell. knap r = MOOList [ "", "", [ "knapsack", "Knapp" ] ]
#32 Mr. Spell. discret r = MOOList [ "", "i", [ "discrete" ] ]
#32 Mr. Spell. dime r = MOOList [ "", "", [ "dimethyl", "dimension", "dime" ] ]
#32 Mr. Spell. oilm r = MOOList [ "", "", [ "oilmen", "oilman" ] ]
#32 Mr. Spell. fork r = MOOList [ "", "", [ "forklift", "fork" ] ]
#32 Mr. Spell. pew r = MOOList [ "", "", [ "pewter", "pewee", "pew" ] ]
#32 Mr. Spell. rasp r = MOOList [ "", "", [ "raspberry", "rasp" ] ]
#32 Mr. Spell. form r = MOOList [ "", "aiue", [ "forms", "Formosa", "form" ] ]
#32 Mr. Spell. Pott r = MOOList [ "", "", [ "Potts", "pottery" ] ]
#32 Mr. Spell. lanth r = MOOList [ "an", "", [ "lanthanum", "lanthanide" ] ]
#32 Mr. Spell. gate r = MOOList [ "", "", [ "gateway", "Gates", "gate" ] ]
#32 Mr. Spell. fors r = MOOList [ "", "a", [ "Forsythe", "forswear", "forsook" ] ]
#32 Mr. Spell. fort r = MOOList [ "", "ehiru", [ "forty", "fortnight", "fort" ] ]
#32 Mr. Spell. appear r = MOOList [ "", "", [ "appearance", "appear" ] ]
#32 Mr. Spell. appeas r = MOOList [ "", "", [ "appease", "appeasable" ] ]
#32 Mr. Spell. dilu r = MOOList [ "", "t", [ "diluent" ] ]
#32 Mr. Spell. mayor r = MOOList [ "", "", [ "mayoral", "mayor" ] ]
#32 Mr. Spell. Patte r = MOOList [ "r", "", [ "Patterson", "pattern" ] ]
#32 Mr. Spell. gast r = MOOList [ "", "r", [ "Gaston" ] ]
#32 Mr. Spell. forc r = MOOList [ "", "e", [ "forcible" ] ]
#32 Mr. Spell. diversio r = MOOList [ "n", "", [ "diversionary", "diversion" ] ]
#32 Mr. Spell. fora r = MOOList [ "", "", [ "foray", "forage" ] ]
#32 Mr. Spell. grub r = MOOList [ "", "", [ "grubby", "grub" ] ]
#32 Mr. Spell. forb r = MOOList [ "", "eio", [ "forbade" ] ]
#32 Mr. Spell. dila r = MOOList [ "", "t", [ "dilapidate" ] ]
#32 Mr. Spell. forg r = MOOList [ "", "eio", [ "forgave" ] ]
#32 Mr. Spell. fore r = MOOList [ "", "s", [ "forever", "forensic", "foreign", "fore" ] ]
#32 Mr. Spell. forf r = MOOList [ "e", "i", [ "forfend" ] ]
#32 Mr. Spell. dile r = MOOList [ "", "", [ "dilettante", "dilemma" ] ]
#32 Mr. Spell. Monte r = MOOList [ "", "v", [ "Monterey", "Montenegrin", "monte" ] ]
#32 Mr. Spell. Monta r = MOOList [ "", "g", [ "Montana" ] ]
#32 Mr. Spell. Pose r = MOOList [ "", "", [ "posey", "poseur", "Poseidon", "pose" ] ]
#32 Mr. Spell. rotar r = MOOList [ "", "", [ "rotary", "Rotarian" ] ]
#32 Mr. Spell. Faus r = MOOList [ "t", "", [ "Faustus", "Faustian", "Faust" ] ]
#32 Mr. Spell. Cind r = MOOList [ "", "e", [ "Cindy" ] ]
#32 Mr. Spell. gari r = MOOList [ "", "", [ "garish", "Garibaldi" ] ]
#32 Mr. Spell. phl r = MOOList [ "o", "", [ "phlox", "phloem" ] ]
#32 Mr. Spell. Nea r = MOOList [ "", "rt", [ "Neapolitan", "Neanderthal", "Neal" ] ]
#32 Mr. Spell. garn r = MOOList [ "e", "", [ "garnet", "garner" ] ]
#32 Mr. Spell. Montr r = MOOList [ "", "", [ "Montreal", "Montrachet" ] ]
#32 Mr. Spell. pho r = MOOList [ "", "enst", [ "phobic" ] ]
#32 Mr. Spell. garl r = MOOList [ "", "", [ "garlic", "garland" ] ]
#32 Mr. Spell. garr r = MOOList [ "", "i", [ "Garry", "garrulous", "Garrett" ] ]
#32 Mr. Spell. phr r = MOOList [ "ase", "", [ "phraseology", "phrasemake", "phrase" ] ]
#32 Mr. Spell. promisc r = MOOList [ "u", "", [ "promiscuous", "promiscuity" ] ]
#32 Mr. Spell. Nev r = MOOList [ "", "ae", [ "Nevins" ] ]
#32 Mr. Spell. Ner r = MOOList [ "", "v", [ "Nero", "nereid" ] ]
#32 Mr. Spell. Fati r = MOOList [ "", "", [ "Fatima", "fatigue" ] ]
#32 Mr. Spell. garb r = MOOList [ "", "", [ "garble", "garbage", "garb" ] ]
#32 Mr. Spell. Shakespeare r = MOOList [ "", "", [ "Shakespearean", "Shakespeare" ] ]
#32 Mr. Spell. Nel r = MOOList [ "", "ls", [ ] ]
#32 Mr. Spell. garg r = MOOList [ "", "", [ "gargle", "gargantuan" ] ]
#32 Mr. Spell. gard r = MOOList [ "", "e", [ "Gardner" ] ]
#32 Mr. Spell. Bertr r = MOOList [ "a", "", [ "Bertrand", "Bertram" ] ]
#32 Mr. Spell. pil r = MOOList [ "", "efgl", [ "pilot", "Pilate" ] ]
#32 Mr. Spell. craftsp r = MOOList [ "e", "", [ "craftsperson", "craftspeople" ] ]
#32 Mr. Spell. pim r = MOOList [ "p", "", [ "pimple", "pimp" ] ]
#32 Mr. Spell. craftsm r = MOOList [ "", "", [ "craftsmen", "craftsman" ] ]
#32 Mr. Spell. pinki r = MOOList [ "", "", [ "pinkish", "pinkie" ] ]
#32 Mr. Spell. pin r = MOOList [ "", "cehknst", [ "pinxter", "pinwheel", "pinpoint", "pinochle", "pinion", "ping", "pinball", "pinafore", "pin" ] ]
#32 Mr. Spell. pio r = MOOList [ "", "n", [ "pious", "Piotr" ] ]
#32 Mr. Spell. pip r = MOOList [ "", "e", [ "pipsissewa", "pip" ] ]
#32 Mr. Spell. piq r = MOOList [ "u", "", [ "pique", "piquant" ] ]
#32 Mr. Spell. rapt r = MOOList [ "", "", [ "rapture", "rapt" ] ]
#32 Mr. Spell. pit r = MOOList [ "", "chit", [ "pity", "pituitary", "Pitney", "pitman", "pitfall", "piteous", "pit" ] ]
#32 Mr. Spell. piv r = MOOList [ "ot", "", [ "pivotal", "pivot" ] ]
#32 Mr. Spell. pix r = MOOList [ "", "", [ "pixy", "pixel" ] ]
#32 Mr. Spell. New r = MOOList [ "", "bceflst", [ "Newport", "Newman", "Newark", "new" ] ]
#32 Mr. Spell. Berth r = MOOList [ "", "", [ "Bertha", "berth" ] ]
#32 Mr. Spell. rapi r = MOOList [ "", "", [ "rapier", "rapid" ] ]
#32 Mr. Spell. refer r = MOOList [ "", "er", [ "refer" ] ]
#32 Mr. Spell. phy r = MOOList [ "", "ls", [ "phytoplankton", "phycomycetes" ] ]
#32 Mr. Spell. fool r = MOOList [ "", "", [ "fooled", "foolproof", "foolish", "foolhardy", "fool" ] ]
#32 Mr. Spell. perspir r = MOOList [ "", "", [ "perspire", "perspiration" ] ]
#32 Mr. Spell. rapp r = MOOList [ "", "", [ "rapprochement", "rapport" ] ]
#32 Mr. Spell. pia r = MOOList [ "", "n", [ "piazza" ] ]
#32 Mr. Spell. zigz r = MOOList [ "ag", "", [ "zigzag", "zigzagging" ] ]
#32 Mr. Spell. pid r = MOOList [ "", "", [ "pidgin", "piddle" ] ]
#32 Mr. Spell. pie r = MOOList [ "", "crt", [ "piezoelectric", "Piedmont", "pie" ] ]
#32 Mr. Spell. foot r = MOOList [ "", "bmpswe", [ "footnote", "foothill", "footfall", "footage", "foot" ] ]
#32 Mr. Spell. pig r = MOOList [ "", "egm", [ "pigtail", "pigskin", "pigroot", "pigpen", "pig" ] ]
#32 Mr. Spell. Bingh r = MOOList [ "am", "", [ "Binghamton", "Bingham" ] ]
#32 Mr. Spell. food r = MOOList [ "", "", [ "foodstuff", "food" ] ]
#32 Mr. Spell. Fara r = MOOList [ "d", "", [ "Faraday", "farad" ] ]
#32 Mr. Spell. muscu r = MOOList [ "la", "", [ "musculature", "muscular" ] ]
#32 Mr. Spell. modific r = MOOList [ "ation", "", [ "modifications", "modification" ] ]
#32 Mr. Spell. piz r = MOOList [ "z", "", [ "pizzicato", "pizza" ] ]
#32 Mr. Spell. crumb r = MOOList [ "", "", [ "crumble", "crumb" ] ]
#32 Mr. Spell. sust r = MOOList [ "", "", [ "sustenance", "sustain" ] ]
#32 Mr. Spell. digr r = MOOList [ "", "e", [ "digram" ] ]
#32 Mr. Spell. susp r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. susc r = MOOList [ "ept", "", [ "susceptible", "susceptance" ] ]
#32 Mr. Spell. crump r = MOOList [ "", "", [ "crumple", "crump" ] ]
#32 Mr. Spell. rans r = MOOList [ "", "", [ "ransom", "ransack" ] ]
#32 Mr. Spell. virtuosi r = MOOList [ "", "", [ "virtuosity", "virtuosi" ] ]
#32 Mr. Spell. Pont r = MOOList [ "", "i", [ "pont" ] ]
#32 Mr. Spell. fond r = MOOList [ "", "", [ "fondle", "fond" ] ]
#32 Mr. Spell. rang r = MOOList [ "", "e", [ "rangy", "Rangoon", "rang" ] ]
#32 Mr. Spell. dige r = MOOList [ "st", "i", [ "digest" ] ]
#32 Mr. Spell. gant r = MOOList [ "", "", [ "gantry", "gantlet" ] ]
#32 Mr. Spell. Pool r = MOOList [ "", "", [ "Poole", "pool" ] ]
#32 Mr. Spell. digi r = MOOList [ "t", "a", [ "digit" ] ]
#32 Mr. Spell. present r = MOOList [ "", "", [ "presently", "presenting", "presented", "present", "presentation" ] ]
#32 Mr. Spell. therefo r = MOOList [ "r", "", [ "therefore", "therefor" ] ]
#32 Mr. Spell. surp r = MOOList [ "", "", [ "surprise", "surplus", "surpass" ] ]
#32 Mr. Spell. surr r = MOOList [ "", "eo", [ ] ]
#32 Mr. Spell. travers r = MOOList [ "", "a", [ "traverse" ] ]
#32 Mr. Spell. surt r = MOOList [ "", "", [ "surtout", "surtax" ] ]
#32 Mr. Spell. ranc r = MOOList [ "", "h", [ "rancorous", "rancid" ] ]
#32 Mr. Spell. dign r = MOOList [ "i", "t", [ "dignify" ] ]
#32 Mr. Spell. surv r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. Lexic r = MOOList [ "", "o", [ "lexical" ] ]
#32 Mr. Spell. grow r = MOOList [ "", "n", [ "growing", "growth", "growl", "grow" ] ]
#32 Mr. Spell. grov r = MOOList [ "e", "", [ "Grover", "grovel", "grove" ] ]
#32 Mr. Spell. surj r = MOOList [ "ecti", "", [ "surjective", "surjection" ] ]
#32 Mr. Spell. grou r = MOOList [ "", "np", [ "grout" ] ]
#32 Mr. Spell. accompl r = MOOList [ "i", "", [ "accomplish", "accomplice" ] ]
#32 Mr. Spell. producti r = MOOList [ "", "v", [ "production" ] ]
#32 Mr. Spell. plo r = MOOList [ "", "w", [ "plover", "plot", "plop", "plod" ] ]
#32 Mr. Spell. plia r = MOOList [ "", "", [ "pliant", "pliable" ] ]
#32 Mr. Spell. Nig r = MOOList [ "", "egh", [ ] ]
#32 Mr. Spell. surm r = MOOList [ "", "", [ "surmount", "surmise" ] ]
#32 Mr. Spell. Nie r = MOOList [ "", "l", [ "Nietzsche", "niece" ] ]
#32 Mr. Spell. rebelli r = MOOList [ "", "o", [ "rebelling" ] ]
#32 Mr. Spell. plu r = MOOList [ "", "cgmnst", [ "plural", "pluperfect" ] ]
#32 Mr. Spell. accompa r = MOOList [ "n", "i", [ "accompany" ] ]
#32 Mr. Spell. Russ r = MOOList [ "", "e", [ "russula", "Russo", "Russia", "Russ" ] ]
#32 Mr. Spell. ramp r = MOOList [ "", "a", [ "ramp" ] ]
#32 Mr. Spell. guess r = MOOList [ "", "", [ "guesswork", "guess" ] ]
#32 Mr. Spell. surc r = MOOList [ "", "", [ "surcharge", "surcease" ] ]
#32 Mr. Spell. Evans r = MOOList [ "", "", [ "Evansville", "Evanston", "Evans" ] ]
#32 Mr. Spell. sure r = MOOList [ "", "", [ "surety", "sure" ] ]
#32 Mr. Spell. Semina r = MOOList [ "", "r", [ "seminal" ] ]
#32 Mr. Spell. surf r = MOOList [ "", "a", [ "surfeit", "surf" ] ]
#32 Mr. Spell. surg r = MOOList [ "", "e", [ "surgical" ] ]
#32 Mr. Spell. husb r = MOOList [ "and", "m", [ "husbandry", "husband" ] ]
#32 Mr. Spell. Rutl r = MOOList [ "", "", [ "Rutledge", "Rutland" ] ]
#32 Mr. Spell. hurl r = MOOList [ "", "", [ "hurley", "hurl" ] ]
#32 Mr. Spell. foli r = MOOList [ "", "a", [ "folio" ] ]
#32 Mr. Spell. diff r = MOOList [ "", "eiru", [ ] ]
#32 Mr. Spell. pla r = MOOList [ "", "cginsty", [ "plaza", "plausible", "plaque" ] ]
#32 Mr. Spell. groo r = MOOList [ "", "", [ "groove", "groom" ] ]
#32 Mr. Spell. modifi r = MOOList [ "", "c", [ "modified" ] ]
#32 Mr. Spell. ple r = MOOList [ "", "abinu", [ "Plexiglas", "plethora", "pledge" ] ]
#32 Mr. Spell. elim r = MOOList [ "inat", "", [ "eliminating", "eliminate" ] ]
#32 Mr. Spell. folk r = MOOList [ "", "s", [ "folklore", "folk" ] ]
#32 Mr. Spell. foll r = MOOList [ "", "io", [ "folly" ] ]
#32 Mr. Spell. hurt r = MOOList [ "", "", [ "hurty", "hurtle", "hurt" ] ]
#32 Mr. Spell. gros r = MOOList [ "", "s", [ "Grosvenor", "grosbeak" ] ]
#32 Mr. Spell. pli r = MOOList [ "", "a", [ "Pliocene", "Pliny", "plight" ] ]
#32 Mr. Spell. Nil r = MOOList [ "", "", [ "nilpotent", "Nile", "nil" ] ]
#32 Mr. Spell. hurr r = MOOList [ "", "a", [ "hurry", "hurricane" ] ]
#32 Mr. Spell. Nik r = MOOList [ "", "", [ "Nikolai", "Nikko" ] ]
#32 Mr. Spell. livin r = MOOList [ "g", "", [ "living", "Livingston" ] ]
#32 Mr. Spell. game r = MOOList [ "", "", [ "games", "gamecock", "game" ] ]
#32 Mr. Spell. Oliv r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. diet r = MOOList [ "", "", [ "Dietz", "diety", "Dietrich", "dietician", "diethylstilbestrol", "dietetic", "dietary", "diet" ] ]
#32 Mr. Spell. Gust r = MOOList [ "", "a", [ "gusty", "gusto", "gust" ] ]
#32 Mr. Spell. hurd r = MOOList [ "", "", [ "hurdle", "Hurd" ] ]
#32 Mr. Spell. groc r = MOOList [ "er", "", [ "grocery", "grocer" ] ]
#32 Mr. Spell. proxima r = MOOList [ "", "", [ "proximate", "proximal" ] ]
#32 Mr. Spell. inquisiti r = MOOList [ "", "", [ "inquisitive", "inquisition" ] ]
#32 Mr. Spell. groa r = MOOList [ "", "", [ "groat", "groan" ] ]
#32 Mr. Spell. Rush r = MOOList [ "", "", [ "Rushmore", "rush" ] ]
#32 Mr. Spell. newspaperm r = MOOList [ "", "", [ "newspapermen", "newspaperman" ] ]
#32 Mr. Spell. subjecti r = MOOList [ "v", "", [ "subjective", "subjectivity" ] ]
#32 Mr. Spell. galv r = MOOList [ "", "a", [ "Galveston" ] ]
#32 Mr. Spell. retrie r = MOOList [ "v", "", [ "retrieve", "retrieval" ] ]
#32 Mr. Spell. invol r = MOOList [ "", "uv", [ ] ]
#32 Mr. Spell. supp r = MOOList [ "", "lor", [ ] ]
#32 Mr. Spell. supr r = MOOList [ "", "ae", [ ] ]
#32 Mr. Spell. gamb r = MOOList [ "", "i", [ "gambol", "gamble" ] ]
#32 Mr. Spell. diel r = MOOList [ "", "", [ "dielectric", "dieldrin" ] ]
#32 Mr. Spell. compensat r = MOOList [ "", "", [ "compensatory", "compensate" ] ]
#32 Mr. Spell. emis r = MOOList [ "s", "i", [ "emissary" ] ]
#32 Mr. Spell. emit r = MOOList [ "", "t", [ "emit" ] ]
#32 Mr. Spell. withdra r = MOOList [ "w", "", [ "withdrawn", "withdrawal", "withdraw" ] ]
#32 Mr. Spell. Luci r = MOOList [ "", "a", [ "Lucius", "Lucille", "Lucifer", "lucid" ] ]
#32 Mr. Spell. colorat r = MOOList [ "", "", [ "coloratura", "colorate" ] ]
#32 Mr. Spell. Haber r = MOOList [ "", "", [ "Haberman", "haberdashery" ] ]
#32 Mr. Spell. sequi r = MOOList [ "", "", [ "sequitur", "sequin" ] ]
#32 Mr. Spell. flags r = MOOList [ "t", "", [ "flagstone", "Flagstaff" ] ]
#32 Mr. Spell. sept r = MOOList [ "", "aeiu", [ "sept" ] ]
#32 Mr. Spell. grounds r = MOOList [ "", "", [ "groundskeep", "groundsel" ] ]
#32 Mr. Spell. sepu r = MOOList [ "", "", [ "sepulchral", "sepuchral" ] ]
#32 Mr. Spell. residen r = MOOList [ "t", "", [ "residential", "resident" ] ]
#32 Mr. Spell. seque r = MOOList [ "", "ns", [ "sequel" ] ]
#32 Mr. Spell. bitter r = MOOList [ "", "n", [ "bittersweet", "bitterroot" ] ]
#32 Mr. Spell. Packa r = MOOList [ "", "", [ "Packard", "package" ] ]
#32 Mr. Spell. mercuri r = MOOList [ "", "", [ "mercuric", "mercurial" ] ]
#32 Mr. Spell. along r = MOOList [ "", "", [ "alongside", "along" ] ]
#32 Mr. Spell. sepa r = MOOList [ "", "r", [ "sepal" ] ]
#32 Mr. Spell. Rhodes r = MOOList [ "", "", [ "Rhodesia", "Rhodes" ] ]
#32 Mr. Spell. poo r = MOOList [ "", "l", [ "poor", "poop", "pooh", "poodle", "pooch" ] ]
#32 Mr. Spell. galac r = MOOList [ "t", "", [ "galactose", "galactic" ] ]
#32 Mr. Spell. pop r = MOOList [ "", "lu", [ "poppy", "popish", "pope", "pop" ] ]
#32 Mr. Spell. irrev r = MOOList [ "", "e", [ "irrevocable" ] ]
#32 Mr. Spell. por r = MOOList [ "", "cnopt", [ "porridge", "pork", "pore" ] ]
#32 Mr. Spell. pos r = MOOList [ "", "eist", [ "posy", "Posner", "posh", "posable" ] ]
#32 Mr. Spell. pot r = MOOList [ "", "abet", [ "potpourri", "Potomac", "potlatch", "potion", "pothole", "pot" ] ]
#32 Mr. Spell. executi r = MOOList [ "", "v", [ "execution" ] ]
#32 Mr. Spell. thro r = MOOList [ "", "anuw", [ "throttle", "thrombosis", "throes", "throb" ] ]
#32 Mr. Spell. pow r = MOOList [ "", "de", [ "pow" ] ]
#32 Mr. Spell. latitudi r = MOOList [ "na", "", [ "latitudinary", "latitudinal" ] ]
#32 Mr. Spell. irrem r = MOOList [ "", "", [ "irremovable", "irremediable" ] ]
#32 Mr. Spell. Gera r = MOOList [ "", "l", [ "Gerard", "geranium" ] ]
#32 Mr. Spell. inext r = MOOList [ "", "", [ "inextricable", "inextinguishable" ] ]
#32 Mr. Spell. irrep r = MOOList [ "", "r", [ "irreplaceable", "irreparable" ] ]
#32 Mr. Spell. thru r = MOOList [ "", "s", [ "Thruway", "thrum" ] ]
#32 Mr. Spell. inexp r = MOOList [ "", "el", [ "inexpressible", "inexpiable" ] ]
#32 Mr. Spell. irres r = MOOList [ "", "op", [ "irresistible" ] ]
#32 Mr. Spell. irred r = MOOList [ "", "e", [ "irreducible" ] ]
#32 Mr. Spell. Gerh r = MOOList [ "ard", "", [ "Gerhardt", "Gerhard" ] ]
#32 Mr. Spell. thri r = MOOList [ "", "f", [ "thrive", "thrips", "thrill", "thrice" ] ]
#32 Mr. Spell. flage r = MOOList [ "", "", [ "flageolet", "flagellate" ] ]
#32 Mr. Spell. poc r = MOOList [ "", "k", [ "Pocono" ] ]
#32 Mr. Spell. pod r = MOOList [ "", "i", [ "podge", "pod" ] ]
#32 Mr. Spell. poe r = MOOList [ "", "t", [ "poesy", "poem", "Poe" ] ]
#32 Mr. Spell. pog r = MOOList [ "", "", [ "pogrom", "pogo" ] ]
#32 Mr. Spell. thra r = MOOList [ "", "", [ "thrash", "thrall" ] ]
#32 Mr. Spell. poi r = MOOList [ "", "ns", [ "poignant", "poi" ] ]
#32 Mr. Spell. horizont r = MOOList [ "al", "", [ "horizontally", "horizontal" ] ]
#32 Mr. Spell. pok r = MOOList [ "e", "", [ "pokerface", "poke" ] ]
#32 Mr. Spell. Germ r = MOOList [ "", "ai", [ "germ" ] ]
#32 Mr. Spell. thre r = MOOList [ "", "aes", [ "threw", "threonine" ] ]
#32 Mr. Spell. pom r = MOOList [ "", "p", [ "Pomona", "pomegranate", "pomade" ] ]
#32 Mr. Spell. irrec r = MOOList [ "", "o", [ "irreclaimable" ] ]
#32 Mr. Spell. spectrog r = MOOList [ "ra", "p", [ "spectrogram" ] ]
#32 Mr. Spell. sent r = MOOList [ "", "ei", [ "sentry", "sent" ] ]
#32 Mr. Spell. claust r = MOOList [ "rophobi", "", [ "claustrophobic", "claustrophobia" ] ]
#32 Mr. Spell. deferr r = MOOList [ "", "", [ "deferring", "deferred", "deferrable" ] ]
#32 Mr. Spell. spectros r = MOOList [ "cop", "", [ "spectroscopy", "spectroscopic", "spectroscope" ] ]
#32 Mr. Spell. effica r = MOOList [ "c", "", [ "efficacy", "efficacious" ] ]
#32 Mr. Spell. sens r = MOOList [ "", "iou", [ "sense", "sensate" ] ]
#32 Mr. Spell. send r = MOOList [ "", "", [ "sends", "sending", "send" ] ]
#32 Mr. Spell. bedsp r = MOOList [ "r", "", [ "bedspring", "bedspread" ] ]
#32 Mr. Spell. telegrap r = MOOList [ "h", "", [ "telegraphy", "telegraph" ] ]
#32 Mr. Spell. serend r = MOOList [ "ipit", "", [ "serendipity", "serendipitous" ] ]
#32 Mr. Spell. catas r = MOOList [ "troph", "", [ "catastrophic", "catastrophe" ] ]
#32 Mr. Spell. seni r = MOOList [ "", "", [ "senior", "senile" ] ]
#32 Mr. Spell. catat r = MOOList [ "oni", "", [ "catatonic", "catatonia" ] ]
#32 Mr. Spell. indisp r = MOOList [ "", "o", [ "indisputable", "indispensable" ] ]
#32 Mr. Spell. indist r = MOOList [ "in", "", [ "indistinguishable", "indistinct" ] ]
#32 Mr. Spell. Swart r = MOOList [ "", "h", [ "swart" ] ]
#32 Mr. Spell. sena r = MOOList [ "t", "", [ "senatorial", "senate" ] ]
#32 Mr. Spell. catal r = MOOList [ "", "y", [ "catalpa", "catalogue", "Catalina" ] ]
#32 Mr. Spell. henc r = MOOList [ "", "eh", [ ] ]
#32 Mr. Spell. Shre r = MOOList [ "", "w", [ "Shreveport", "shred" ] ]
#32 Mr. Spell. stickl r = MOOList [ "e", "", [ "stickleback", "stickle" ] ]
#32 Mr. Spell. Geor r = MOOList [ "g", "e", [ "Georgia" ] ]
#32 Mr. Spell. protru r = MOOList [ "", "s", [ "protrude" ] ]
#32 Mr. Spell. versat r = MOOList [ "", "", [ "versatile", "versatec" ] ]
#32 Mr. Spell. indisc r = MOOList [ "", "r", [ "indiscoverable", "indiscernible" ] ]
#32 Mr. Spell. tyra r = MOOList [ "n", "n", [ "tyrant" ] ]
#32 Mr. Spell. pra r = MOOList [ "", "cginy", [ "Pravda", "Pratt", "praseodymium", "pram", "praecox", "Prado" ] ]
#32 Mr. Spell. bedro r = MOOList [ "", "", [ "bedroom", "bedrock" ] ]
#32 Mr. Spell. solita r = MOOList [ "", "", [ "solitary", "solitaire" ] ]
#32 Mr. Spell. judicat r = MOOList [ "", "", [ "judicature", "judicatory" ] ]
#32 Mr. Spell. embedde r = MOOList [ "", "", [ "embedder", "embedded" ] ]
#32 Mr. Spell. semi r = MOOList [ "", "nt", [ "Semiramis", "semi" ] ]
#32 Mr. Spell. programmer r = MOOList [ "", "", [ "programmers", "programmer" ] ]
#32 Mr. Spell. sema r = MOOList [ "", "", [ "semaphore", "semantic" ] ]
#32 Mr. Spell. centre r = MOOList [ "", "", [ "centre", "centrex" ] ]
#32 Mr. Spell. temporar r = MOOList [ "", "", [ "temporarily", "temporary" ] ]
#32 Mr. Spell. thou r = MOOList [ "", "gs", [ "thou" ] ]
#32 Mr. Spell. pru r = MOOList [ "", "d", [ "Prussia", "prurient", "prune" ] ]
#32 Mr. Spell. policem r = MOOList [ "", "", [ "policemen", "policeman" ] ]
#32 Mr. Spell. maniac r = MOOList [ "", "", [ "maniacal", "maniac" ] ]
#32 Mr. Spell. Nol r = MOOList [ "", "", [ "nolo", "Noll", "Nolan" ] ]
#32 Mr. Spell. centri r = MOOList [ "", "f", [ "centrist", "centric" ] ]
#32 Mr. Spell. ballet r = MOOList [ "", "", [ "balletomane", "ballet" ] ]
#32 Mr. Spell. emer r = MOOList [ "", "gi", [ "Emery", "Emerson", "emerald" ] ]
#32 Mr. Spell. sell r = MOOList [ "", "", [ "sells", "selling", "sellout", "sell" ] ]
#32 Mr. Spell. hemi r = MOOList [ "", "s", [ "Hemingway" ] ]
#32 Mr. Spell. thom r = MOOList [ "", "", [ "Thomson", "Thompson", "Thomistic", "Thomas" ] ]
#32 Mr. Spell. Noe r = MOOList [ "", "", [ "Noetherian", "Noel" ] ]
#32 Mr. Spell. hemo r = MOOList [ "", "r", [ "hemosiderin", "hemolytic", "hemoglobin" ] ]
#32 Mr. Spell. ptA r = MOOList [ "", "", [ "ptarmigan", "PTA" ] ]
#32 Mr. Spell. swelt r = MOOList [ "", "", [ "swelter", "swelt" ] ]
#32 Mr. Spell. regal r = MOOList [ "", "", [ "regalia", "regale", "regal" ] ]
#32 Mr. Spell. psa r = MOOList [ "l", "", [ "psalter", "psalm" ] ]
#32 Mr. Spell. Nob r = MOOList [ "", "elo", [ "nob" ] ]
#32 Mr. Spell. OPa r = MOOList [ "", "l", [ "opaque", "opacity" ] ]
#32 Mr. Spell. Noa r = MOOList [ "", "", [ "Noah", "NOAA" ] ]
#32 Mr. Spell. help r = MOOList [ "", "", [ "helps", "helpmate", "helpful", "help" ] ]
#32 Mr. Spell. sele r = MOOList [ "", "cn", [ ] ]
#32 Mr. Spell. pre r = MOOList [ "", "acdeflmpstv", [ "prey", "prexy", "prerogative", "Prentice", "prejudice", "pregnant" ] ]
#32 Mr. Spell. self r = MOOList [ "", "", [ "Selfridge", "selfish", "selfadjoint", "self" ] ]
#32 Mr. Spell. logar r = MOOList [ "ithm", "", [ "logarithmic", "logarithm" ] ]
#32 Mr. Spell. inert r = MOOList [ "", "i", [ "inertance", "inert" ] ]
#32 Mr. Spell. pri r = MOOList [ "", "cegmnosvz", [ "Pritchard", "pride", "Priam" ] ]
#32 Mr. Spell. muske r = MOOList [ "", "", [ "musket", "muskellunge", "Muskegon" ] ]
#32 Mr. Spell. colla r = MOOList [ "", "gprt", [ "collaborate" ] ]
#32 Mr. Spell. animad r = MOOList [ "ver", "", [ "animadvert", "animadversion" ] ]
#32 Mr. Spell. colle r = MOOList [ "", "cg", [ "collet", "colleague" ] ]
#32 Mr. Spell. typo r = MOOList [ "", "g", [ "typology", "typo" ] ]
#32 Mr. Spell. pro r = MOOList [ "", "bcdfghjklmnoprstuvwx", [ "pro" ] ]
#32 Mr. Spell. musko r = MOOList [ "x", "", [ "muskoxen", "muskox" ] ]
#32 Mr. Spell. ascen r = MOOList [ "", "d", [ "ascent", "ascension" ] ]
#32 Mr. Spell. Nor r = MOOList [ "", "dmtw", [ "Norris", "Norfolk", "Noreen", "Nora", "nor" ] ]
#32 Mr. Spell. colli r = MOOList [ "", "en", [ "collision", "collimate", "collide" ] ]
#32 Mr. Spell. collo r = MOOList [ "", "q", [ "colloidal", "collocation" ] ]
#32 Mr. Spell. type r = MOOList [ "", "sw", [ "typed", "typeface", "type" ] ]
#32 Mr. Spell. Lockh r = MOOList [ "", "", [ "Lockheed", "Lockhart" ] ]
#32 Mr. Spell. psy r = MOOList [ "", "c", [ "psyllium" ] ]
#32 Mr. Spell. typi r = MOOList [ "", "", [ "typing", "typify", "typic" ] ]
#32 Mr. Spell. benefit r = MOOList [ "", "", [ "benefits", "benefit" ] ]
#32 Mr. Spell. heli r = MOOList [ "", "co", [ "helix", "helium" ] ]
#32 Mr. Spell. norther r = MOOList [ "", "n", [ "northerly" ] ]
#32 Mr. Spell. collu r = MOOList [ "", "", [ "collusion", "collude" ] ]
#32 Mr. Spell. helm r = MOOList [ "", "s", [ "Helmut", "Helmholtz", "helmet", "helm" ] ]
#32 Mr. Spell. handicrafts r = MOOList [ "m", "", [ "handicraftsmen", "handicraftsman" ] ]
#32 Mr. Spell. Rema r = MOOList [ "", "ni", [ "remark" ] ]
#32 Mr. Spell. mechanis r = MOOList [ "", "", [ "mechanist", "mechanism" ] ]
#32 Mr. Spell. hell r = MOOList [ "", "e", [ "hello", "hellish", "hellgrammite", "hellfire", "hellbender", "hell" ] ]
#32 Mr. Spell. galen r = MOOList [ "", "", [ "galenite", "galena", "Galen" ] ]
#32 Mr. Spell. Remu r = MOOList [ "", "", [ "Remus", "remunerate" ] ]
#32 Mr. Spell. Epis r = MOOList [ "", "cot", [ ] ]
#32 Mr. Spell. northea r = MOOList [ "st", "", [ "northeastern", "northeast" ] ]
#32 Mr. Spell. benefic r = MOOList [ "", "ei", [ ] ]
#32 Mr. Spell. Olive r = MOOList [ "", "", [ "Olivetti", "olive" ] ]
#32 Mr. Spell. Shoc r = MOOList [ "k", "", [ "Shockley", "shock" ] ]
#32 Mr. Spell. america r = MOOList [ "", "n", [ "America" ] ]
#32 Mr. Spell. numbe r = MOOList [ "", "r", [ "numbed" ] ]
#32 Mr. Spell. churchm r = MOOList [ "", "", [ "churchmen", "churchman" ] ]
#32 Mr. Spell. Ephe r = MOOList [ "", "ms", [ ] ]
#32 Mr. Spell. churchg r = MOOList [ "o", "", [ "churchgoing", "churchgoer" ] ]
#32 Mr. Spell. puc r = MOOList [ "", "k", [ "Puccini" ] ]
#32 Mr. Spell. pud r = MOOList [ "d", "il", [ ] ]
#32 Mr. Spell. hered r = MOOList [ "it", "", [ "heredity", "hereditary" ] ]
#32 Mr. Spell. Polyp r = MOOList [ "", "h", [ "polyploidy" ] ]
#32 Mr. Spell. chromatograp r = MOOList [ "h", "", [ "chromatography", "chromatograph" ] ]
#32 Mr. Spell. constructi r = MOOList [ "", "", [ "construction", "constructible" ] ]
#32 Mr. Spell. vacuo r = MOOList [ "", "l", [ "vacuous", "vacuo" ] ]
#32 Mr. Spell. herea r = MOOList [ "", "", [ "hereafter", "hereabout" ] ]
#32 Mr. Spell. seiz r = MOOList [ "", "", [ "seizure", "seize" ] ]
#32 Mr. Spell. churchw r = MOOList [ "om", "", [ "churchwomen", "churchwoman" ] ]
#32 Mr. Spell. herei r = MOOList [ "n", "a", [ "hereinbelow", "herein" ] ]
#32 Mr. Spell. Gemi r = MOOList [ "n", "", [ "Gemini", "geminate" ] ]
#32 Mr. Spell. cater r = MOOList [ "", "", [ "caterpillar", "cater" ] ]
#32 Mr. Spell. heret r = MOOList [ "", "o", [ "heretic" ] ]
#32 Mr. Spell. embl r = MOOList [ "em", "", [ "emblematic", "emblem" ] ]
#32 Mr. Spell. hereu r = MOOList [ "n", "", [ "hereunto", "hereunder" ] ]
#32 Mr. Spell. electri r = MOOList [ "", "c", [ "electrify" ] ]
#32 Mr. Spell. amate r = MOOList [ "ur", "", [ "amateurish", "amateur" ] ]
#32 Mr. Spell. seis r = MOOList [ "m", "o", [ "seismic" ] ]
#32 Mr. Spell. commend r = MOOList [ "", "a", [ "commend" ] ]
#32 Mr. Spell. categ r = MOOList [ "or", "", [ "category", "categoric" ] ]
#32 Mr. Spell. electre r = MOOList [ "", "", [ "electret", "electress" ] ]
#32 Mr. Spell. posterio r = MOOList [ "r", "", [ "posteriori", "posterior" ] ]
#32 Mr. Spell. embo r = MOOList [ "", "d", [ "embower", "embouchure", "emboss", "embolden" ] ]
#32 Mr. Spell. headl r = MOOList [ "", "i", [ "headland" ] ]
#32 Mr. Spell. electro r = MOOList [ "", "celnp", [ "electrode", "electro" ] ]
#32 Mr. Spell. embr r = MOOList [ "", "aoy", [ "embrittle" ] ]
#32 Mr. Spell. pue r = MOOList [ "", "r", [ "pueblo" ] ]
#32 Mr. Spell. puf r = MOOList [ "f", "", [ "puffy", "puffin", "puffery", "puffball", "puff" ] ]
#32 Mr. Spell. communicati r = MOOList [ "on", "", [ "communications", "communication" ] ]
#32 Mr. Spell. board r = MOOList [ "", "", [ "boardinghouse", "board" ] ]
#32 Mr. Spell. headw r = MOOList [ "", "a", [ "headwind" ] ]
#32 Mr. Spell. comment r = MOOList [ "", "a", [ "comment" ] ]
#32 Mr. Spell. heir r = MOOList [ "", "", [ "heirarchy", "heiress", "heir" ] ]
#32 Mr. Spell. emba r = MOOList [ "", "r", [ "embattle", "embassy", "embank", "embalm" ] ]
#32 Mr. Spell. commens r = MOOList [ "ura", "", [ "commensurate", "commensurable" ] ]
#32 Mr. Spell. heads r = MOOList [ "", "mt", [ "headset" ] ]
#32 Mr. Spell. pum r = MOOList [ "", "p", [ "pummel", "pumice", "puma" ] ]
#32 Mr. Spell. lympho r = MOOList [ "", "", [ "lymphoma", "lymphocyte" ] ]
#32 Mr. Spell. pun r = MOOList [ "", "cdik", [ "puny", "punt", "punster", "pungent", "pun" ] ]
#32 Mr. Spell. embe r = MOOList [ "", "d", [ "embezzle", "ember", "embellish" ] ]
#32 Mr. Spell. pup r = MOOList [ "", "ap", [ "pupil", "pup" ] ]
#32 Mr. Spell. pur r = MOOList [ "", "cgilpsv", [ "purr", "pure", "Purdue" ] ]
#32 Mr. Spell. Devon r = MOOList [ "", "", [ "Devonshire", "Devon" ] ]
#32 Mr. Spell. put r = MOOList [ "", "t", [ "puts", "Putnam", "putative", "put" ] ]
#32 Mr. Spell. color r = MOOList [ "", "a", [ "colors", "colorimeter", "color" ] ]
#32 Mr. Spell. catho r = MOOList [ "", "d", [ "catholic" ] ]
#32 Mr. Spell. pesti r = MOOList [ "", "l", [ "pesticide" ] ]
#32 Mr. Spell. eman r = MOOList [ "", "", [ "Emanuel", "emancipate", "emanate" ] ]
#32 Mr. Spell. blind r = MOOList [ "", "", [ "blindfold", "blind" ] ]
#32 Mr. Spell. heig r = MOOList [ "h", "t", [ "heigh" ] ]
#32 Mr. Spell. heroi r = MOOList [ "", "n", [ "heroism", "heroic" ] ]
#32 Mr. Spell. centen r = MOOList [ "", "", [ "centennial", "centenary" ] ]
#32 Mr. Spell. medic r = MOOList [ "", "ia", [ "medico", "medic" ] ]
#32 Mr. Spell. media r = MOOList [ "", "", [ "mediate", "median", "medial", "media" ] ]
#32 Mr. Spell. southe r = MOOList [ "", "ar", [ "Southey" ] ]
#32 Mr. Spell. center r = MOOList [ "", "", [ "centerpiece", "centerline", "center" ] ]
#32 Mr. Spell. aque r = MOOList [ "", "", [ "aqueous", "aqueduct" ] ]
#32 Mr. Spell. spaces r = MOOList [ "", "", [ "spaceship", "spaces", "spacesuit" ] ]
#32 Mr. Spell. distri r = MOOList [ "", "b", [ "district" ] ]
#32 Mr. Spell. Addis r = MOOList [ "", "", [ "Addison", "Addis" ] ]
#32 Mr. Spell. Bergs r = MOOList [ "", "", [ "Bergstrom", "Bergson" ] ]
#32 Mr. Spell. emac r = MOOList [ "", "", [ "emacs", "emaciate" ] ]
#32 Mr. Spell. medio r = MOOList [ "cr", "", [ "mediocrity", "mediocre" ] ]
#32 Mr. Spell. Bergl r = MOOList [ "", "", [ "Berglund", "Bergland" ] ]
#32 Mr. Spell. segr r = MOOList [ "ega", "", [ "segregate", "segregant" ] ]
#32 Mr. Spell. simpli r = MOOList [ "", "cf", [ "simplistic" ] ]
#32 Mr. Spell. aqua r = MOOList [ "", "r", [ "aquatic", "aqua" ] ]
#32 Mr. Spell. simple r = MOOList [ "", "", [ "simplex", "simpleton", "simpleminded", "simplectic", "simple" ] ]
#32 Mr. Spell. volta r = MOOList [ "", "i", [ "voltage", "Volta" ] ]
#32 Mr. Spell. galvani r = MOOList [ "", "", [ "galvanism", "galvanic" ] ]
#32 Mr. Spell. insect r = MOOList [ "", "", [ "insecticide", "insect" ] ]
#32 Mr. Spell. infan r = MOOList [ "t", "r", [ "infantile", "infant" ] ]
#32 Mr. Spell. boatm r = MOOList [ "", "", [ "boatmen", "boatman" ] ]
#32 Mr. Spell. infam r = MOOList [ "", "", [ "infamy", "infamous" ] ]
#32 Mr. Spell. manife r = MOOList [ "st", "", [ "manifestation", "manifest" ] ]
#32 Mr. Spell. southw r = MOOList [ "", "e", [ "southward" ] ]
#32 Mr. Spell. thin r = MOOList [ "", "g", [ "thinnish", "think", "thine", "thin" ] ]
#32 Mr. Spell. thio r = MOOList [ "", "", [ "thiouracil", "thiocyanate" ] ]
#32 Mr. Spell. refut r = MOOList [ "", "", [ "refute", "refutation" ] ]
#32 Mr. Spell. thir r = MOOList [ "", "st", [ "third" ] ]
#32 Mr. Spell. this r = MOOList [ "", "t", [ "this'll", "this" ] ]
#32 Mr. Spell. thie r = MOOList [ "", "v", [ "thief" ] ]
#32 Mr. Spell. Syll r = MOOList [ "", "ao", [ ] ]
#32 Mr. Spell. refug r = MOOList [ "e", "", [ "refugee", "refuge" ] ]
#32 Mr. Spell. thic r = MOOList [ "k", "e", [ "thickish", "thick" ] ]
#32 Mr. Spell. judicia r = MOOList [ "", "", [ "judiciary", "judicial" ] ]
#32 Mr. Spell. Sylv r = MOOList [ "", "a", [ "Sylvia", "Sylvester" ] ]
#32 Mr. Spell. Blanch r = MOOList [ "", "", [ "Blanche", "Blanchard", "blanch" ] ]
#32 Mr. Spell. Acade r = MOOList [ "m", "i", [ "academy" ] ]
#32 Mr. Spell. know r = MOOList [ "", "l", [ "knows", "known", "knowhow", "knoweth", "know" ] ]
#32 Mr. Spell. pagea r = MOOList [ "nt", "", [ "pageantry", "pageant" ] ]
#32 Mr. Spell. seem r = MOOList [ "", "i", [ "seems", "seemed", "seem" ] ]
#32 Mr. Spell. knoc r = MOOList [ "k", "", [ "knockout", "knockdown", "knock" ] ]
#32 Mr. Spell. shive r = MOOList [ "r", "", [ "shivery", "shiver" ] ]
#32 Mr. Spell. knob r = MOOList [ "", "", [ "knobby", "knob" ] ]
#32 Mr. Spell. chicag r = MOOList [ "o", "", [ "Chicagoan", "Chicago" ] ]
#32 Mr. Spell. seep r = MOOList [ "", "", [ "seepage", "seep" ] ]
#32 Mr. Spell. seed r = MOOList [ "", "", [ "seedy", "seedling", "seedbed", "seed" ] ]
#32 Mr. Spell. sweat r = MOOList [ "", "", [ "sweaty", "sweatshirt", "sweater", "sweatband", "sweat" ] ]
#32 Mr. Spell. droop r = MOOList [ "", "", [ "droopy", "droop" ] ]
#32 Mr. Spell. pyr r = MOOList [ "", "aeio", [ "Pyrrhic" ] ]
#32 Mr. Spell. effec r = MOOList [ "t", "u", [ "effects", "effective", "effect" ] ]
#32 Mr. Spell. sedu r = MOOList [ "", "c", [ "sedulous" ] ]
#32 Mr. Spell. colon r = MOOList [ "", "i", [ "colony", "colonnade", "colonel", "colon" ] ]
#32 Mr. Spell. Milto r = MOOList [ "n", "", [ "Miltonic", "Milton" ] ]
#32 Mr. Spell. Berke r = MOOList [ "l", "", [ "berkelium", "Berkeley" ] ]
#32 Mr. Spell. inconsid r = MOOList [ "era", "", [ "inconsiderate", "inconsiderable" ] ]
#32 Mr. Spell. musta r = MOOList [ "", "c", [ "mustard", "mustang" ] ]
#32 Mr. Spell. sede r = MOOList [ "", "", [ "seder", "sedentary" ] ]
#32 Mr. Spell. Reev r = MOOList [ "e", "", [ "Reeves", "reeve" ] ]
#32 Mr. Spell. bucks r = MOOList [ "", "", [ "buckskin", "buckshot" ] ]
#32 Mr. Spell. sedi r = MOOList [ "", "mt", [ ] ]
#32 Mr. Spell. flatt r = MOOList [ "e", "", [ "flattery", "flatten" ] ]
#32 Mr. Spell. Shil r = MOOList [ "", "", [ "Shiloh", "shill" ] ]
#32 Mr. Spell. hedg r = MOOList [ "e", "", [ "hedgehog", "hedge" ] ]
#32 Mr. Spell. sleep r = MOOList [ "", "", [ "sleepy", "sleepwalk", "sleep" ] ]
#32 Mr. Spell. seda r = MOOList [ "", "", [ "sedate", "sedan" ] ]
#32 Mr. Spell. flatu r = MOOList [ "", "", [ "flatus", "flatulent" ] ]
#32 Mr. Spell. sleet r = MOOList [ "", "", [ "sleety", "sleet" ] ]
#32 Mr. Spell. secr r = MOOList [ "e", "t", [ "secrecy" ] ]
#32 Mr. Spell. sect r = MOOList [ "", "", [ "sector", "section", "sectarian", "sect" ] ]
#32 Mr. Spell. hedo r = MOOList [ "nis", "", [ "hedonist", "hedonism" ] ]
#32 Mr. Spell. secu r = MOOList [ "", "r", [ "secular" ] ]
#32 Mr. Spell. bucke r = MOOList [ "", "t", [ "buckeye" ] ]
#32 Mr. Spell. downs r = MOOList [ "", "t", [ "downspout", "downslope", "downside" ] ]
#32 Mr. Spell. downt r = MOOList [ "", "r", [ "downturn", "downtown" ] ]
#32 Mr. Spell. secl r = MOOList [ "u", "", [ "seclusion", "seclude" ] ]
#32 Mr. Spell. downw r = MOOList [ "", "", [ "downwind", "downward" ] ]
#32 Mr. Spell. seco r = MOOList [ "nd", "", [ "seconds", "secondhand", "secondary", "second" ] ]
#32 Mr. Spell. Allen r = MOOList [ "", "", [ "Allentown", "Allen" ] ]
#32 Mr. Spell. sece r = MOOList [ "", "", [ "secession", "secede" ] ]
#32 Mr. Spell. irrit r = MOOList [ "a", "t", [ "irritant", "irritable" ] ]
#32 Mr. Spell. sledg r = MOOList [ "e", "", [ "sledgehammer", "sledge" ] ]
#32 Mr. Spell. periph r = MOOList [ "", "e", [ "periphrastic" ] ]
#32 Mr. Spell. sacrif r = MOOList [ "ic", "", [ "sacrificial", "sacrifice" ] ]
#32 Mr. Spell. they r = MOOList [ "", "'", [ "they" ] ]
#32 Mr. Spell. Leonar r = MOOList [ "d", "", [ "Leonardo", "Leonard" ] ]
#32 Mr. Spell. pessimi r = MOOList [ "s", "", [ "pessimist", "pessimism" ] ]
#32 Mr. Spell. anhydri r = MOOList [ "", "", [ "anhydrite", "anhydride" ] ]
#32 Mr. Spell. homogene r = MOOList [ "", "", [ "homogeneous", "homogeneity" ] ]
#32 Mr. Spell. heck r = MOOList [ "", "", [ "Heckman", "heckle", "heck" ] ]
#32 Mr. Spell. ther r = MOOList [ "", "aem", [ ] ]
#32 Mr. Spell. thes r = MOOList [ "", "e", [ "thespian", "thesis", "thesaurus" ] ]
#32 Mr. Spell. flash r = MOOList [ "", "", [ "flashy", "flashlight", "flashback", "flash" ] ]
#32 Mr. Spell. Lotte r = MOOList [ "", "", [ "lottery", "Lotte" ] ]
#32 Mr. Spell. blocka r = MOOList [ "", "", [ "blockage", "blockade" ] ]
#32 Mr. Spell. hect r = MOOList [ "", "", [ "hector", "hectic" ] ]
#32 Mr. Spell. downp r = MOOList [ "", "", [ "downpour", "downplay" ] ]
#32 Mr. Spell. thei r = MOOList [ "", "s", [ "their" ] ]
#32 Mr. Spell. gallo r = MOOList [ "", "nw", [ "gallop" ] ]
#32 Mr. Spell. discre r = MOOList [ "", "t", [ "discrepant", "discreet" ] ]
#32 Mr. Spell. volun r = MOOList [ "t", "a", [ "volunteer" ] ]
#32 Mr. Spell. explor r = MOOList [ "", "a", [ "explore" ] ]
#32 Mr. Spell. explos r = MOOList [ "i", "", [ "explosive", "explosion" ] ]
#32 Mr. Spell. then r = MOOList [ "", "c", [ "then" ] ]
#32 Mr. Spell. volum r = MOOList [ "", "e", [ "voluminous" ] ]
#32 Mr. Spell. them r = MOOList [ "", "", [ "themselves", "theme", "thematic", "them" ] ]
#32 Mr. Spell. discri r = MOOList [ "mina", "t", [ "discriminant", "discriminable" ] ]
#32 Mr. Spell. glyceri r = MOOList [ "", "n", [ "glyceride" ] ]
#32 Mr. Spell. heca r = MOOList [ "t", "", [ "hecatomb", "Hecate" ] ]
#32 Mr. Spell. thea r = MOOList [ "", "", [ "theatric", "Thea" ] ]
#32 Mr. Spell. sacril r = MOOList [ "eg", "", [ "sacrilegious", "sacrilege" ] ]
#32 Mr. Spell. Atti r = MOOList [ "", "c", [ "attitude", "attire" ] ]
#32 Mr. Spell. custom r = MOOList [ "", "e", [ "customhouse", "customary", "custom" ] ]
#32 Mr. Spell. herma r = MOOList [ "n", "", [ "Hermann", "Herman" ] ]
#32 Mr. Spell. defens r = MOOList [ "", "i", [ "defense" ] ]
#32 Mr. Spell. sideli r = MOOList [ "", "", [ "sideline", "sidelight" ] ]
#32 Mr. Spell. gallu r = MOOList [ "", "", [ "gallus", "Gallup" ] ]
#32 Mr. Spell. seaw r = MOOList [ "", "", [ "seaweed", "seaward" ] ]
#32 Mr. Spell. adhes r = MOOList [ "i", "", [ "adhesive", "adhesion" ] ]
#32 Mr. Spell. galla r = MOOList [ "", "n", [ "Gallagher" ] ]
#32 Mr. Spell. elys r = MOOList [ "", "", [ "elysian", "Elysee" ] ]
#32 Mr. Spell. adher r = MOOList [ "e", "", [ "adherent", "adhere" ] ]
#32 Mr. Spell. moral r = MOOList [ "", "", [ "morale", "moral" ] ]
#32 Mr. Spell. hermi r = MOOList [ "t", "", [ "hermitian", "Hermite" ] ]
#32 Mr. Spell. custod r = MOOList [ "", "i", [ "custody" ] ]
#32 Mr. Spell. exploi r = MOOList [ "t", "", [ "exploitation", "exploit" ] ]
#32 Mr. Spell. rebellio r = MOOList [ "", "", [ "rebellious", "rebellion" ] ]
#32 Mr. Spell. sear r = MOOList [ "", "c", [ "sear" ] ]
#32 Mr. Spell. galli r = MOOList [ "", "", [ "gallivant", "gallium", "gallinule" ] ]
#32 Mr. Spell. seas r = MOOList [ "", "o", [ "seaside", "seashore" ] ]
#32 Mr. Spell. seat r = MOOList [ "", "", [ "Seattle", "seater", "seat" ] ]
#32 Mr. Spell. galle r = MOOList [ "", "", [ "galley", "gallery" ] ]
#32 Mr. Spell. seag r = MOOList [ "", "", [ "seagull", "Seagram" ] ]
#32 Mr. Spell. heav r = MOOList [ "", "ey", [ ] ]
#32 Mr. Spell. diva r = MOOList [ "", "", [ "divan", "divalent", "diva" ] ]
#32 Mr. Spell. heat r = MOOList [ "", "h", [ "heater", "heat" ] ]
#32 Mr. Spell. seal r = MOOList [ "", "", [ "sealant", "seal" ] ]
#32 Mr. Spell. dive r = MOOList [ "", "rs", [ "dive" ] ]
#32 Mr. Spell. seam r = MOOList [ "", "", [ "seamy", "seamstress", "seamen", "seaman", "seam" ] ]
#32 Mr. Spell. sean r = MOOList [ "", "", [ "seance", "Sean" ] ]
#32 Mr. Spell. healt r = MOOList [ "h", "", [ "healthy", "healthful", "health" ] ]
#32 Mr. Spell. divi r = MOOList [ "", "dns", [ ] ]
#32 Mr. Spell. sweep r = MOOList [ "", "", [ "sweepstake", "sweep" ] ]
#32 Mr. Spell. thyroi r = MOOList [ "d", "", [ "thyroidal", "thyroid" ] ]
#32 Mr. Spell. bliss r = MOOList [ "", "", [ "blissful", "bliss" ] ]
#32 Mr. Spell. seaf r = MOOList [ "", "", [ "seafood", "seafare" ] ]
#32 Mr. Spell. divo r = MOOList [ "rce", "", [ "divorcee", "divorce" ] ]
#32 Mr. Spell. numis r = MOOList [ "mati", "", [ "numismatist", "numismatic" ] ]
#32 Mr. Spell. head r = MOOList [ "", "lsw", [ "header", "heady", "headroom", "headquarter", "headphone", "headmaster", "headdress", "headboard", "headache", "head" ] ]
#32 Mr. Spell. sonor r = MOOList [ "", "", [ "sonorous", "sonority", "Sonora" ] ]
#32 Mr. Spell. sweet r = MOOList [ "", "", [ "sweetish", "sweetheart", "sweeten", "sweet" ] ]
#32 Mr. Spell. hear r = MOOList [ "", "st", [ "hearken", "heard", "hear" ] ]
#32 Mr. Spell. defend r = MOOList [ "", "", [ "defendant", "defend" ] ]
#32 Mr. Spell. logic r = MOOList [ "", "", [ "logician", "logic" ] ]
#32 Mr. Spell:description this n/a this
return ((this.description + " There are ") + tostr(this.entries)) + " words in the online dictionary.";
-------------------------------------------------------------------------------
#32 Mr. Spell:valid this n/a this
return (this:find_exact(args[1]) != $failed_match) || (args[1] in player.dict);
-------------------------------------------------------------------------------
#32 Mr. Spell:get_input this n/a this
set_task_perms(caller_perms());
source = args[1];
data = {};
ref = $code_utils:parse_propref(source);
if (ref)
"User entered a prop. Deal with it.";
{thing, prop} = ref;
thing = $string_utils:match_object(thing, player.location);
if (!valid(thing))
player:tell("No such object: ", ref[1]);
data = $failed_match;
elseif ((!prop) || (`thing.(tostr(prop)) ! ANY' == E_PROPNF))
player:tell("There is no such property `", prop, "' on object ", thing, ".");
data = $failed_match;
else
data = `thing.(tostr(prop)) ! ANY';
if (typeof(data) == STR)
data = {data};
endif
$command_utils:suspend_if_needed(3);
if (typeof(data) == ERR)
player:tell("Error: ", tostr(data));
data = $failed_match;
elseif (typeof(data) != LIST)
player:tell("Spellchecker needs a string or list as input.");
data = $failed_match;
endif
endif
else
ref = $code_utils:parse_verbref(source);
if (ref)
"User entered a verb. Deal with it.";
{thing, verb} = ref;
thing = $string_utils:match_object(thing, player.location);
if (!valid(thing))
player:tell("No such object: ", ref[1]);
data = $failed_match;
elseif (`verb_info(thing, verb) ! ANY' == E_VERBNF)
player:tell("There is no such verb `", verb, "' on object ", thing, ".");
data = $failed_match;
else
data = `verb_code(thing, verb) ! ANY => {}';
for i in [1..length(data)]
if (!index(data[i], "\""))
data[i] = "";
else
data[i] = data[i][index(data[i], "\"") + 1..$];
data[i] = data[i][1..rindex(data[i], "\"") - 1];
foo = "";
while (index(data[i], "\""))
foo = foo + data[i][1..index(data[i], "\"") - 1];
foo = foo + " ";
data[i] = data[i][index(data[i], "\"") + 1..$];
data[i] = data[i][index(data[i], "\"") + 1..$];
endwhile
if (foo == "")
foo = data[i];
else
foo = foo + data[i];
endif
data[i] = $string_utils:trim(foo);
endif
endfor
endif
else
"User entered word/phrase on command line.";
data = {argstr};
endif
endif
for i in [1..length(data)]
$command_utils:suspend_if_needed(1);
if (typeof(data[i]) != STR)
data[i] = "";
endif
data[i] = $string_utils:strip_chars(data[i], "!@#$%^&*()_+1234567890={}[]`<>?:;,./|\"~'");
endfor
return data;
-------------------------------------------------------------------------------
#32 Mr. Spell:guess_words this n/a this
nastyword = args[1];
guesses = {};
"Transpose adjacent characters";
nastyword = nastyword + " ";
for i in [1..length(nastyword) - 1]
foo = ((nastyword[1..i - 1] + nastyword[i + 1]) + nastyword[i]) + nastyword[i + 2..$];
foo = $string_utils:trim(foo);
if (this:valid(foo))
guesses = listappend(guesses, foo);
endif
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
nastyword = $string_utils:trim(nastyword);
"Erase each character - check for an extra typoed character";
for i in [1..length(nastyword)]
foo = nastyword[1..i - 1] + nastyword[i + 1..$];
if (this:valid(foo))
guesses = listappend(guesses, foo);
endif
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
"Alter one character";
for i in [1..length(nastyword)]
for ii in ({"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "'", "-"})
foo = (nastyword[1..i - 1] + ii) + nastyword[i + 1..$];
if (this:valid(foo))
guesses = listappend(guesses, foo);
endif
endfor
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
"insert one character";
for i in [1..length(nastyword)]
for ii in ({"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "'", "-"})
foo = (nastyword[1..i - 1] + ii) + nastyword[i..$];
if (this:valid(foo))
guesses = listappend(guesses, foo);
endif
endfor
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
"Get some close matches from the database verbs themselves";
if ((foo = this:find_all(nastyword)) != ERR)
if ((foo != $failed_match) && (foo != $ambiguous_match))
if (length(foo) < 6)
for i in (foo)
guesses = listappend(guesses, i);
endfor
endif
endif
endif
"Clean up and go home";
guesses = $list_utils:remove_duplicates(guesses);
guesses = $list_utils:sort(guesses);
return guesses;
-------------------------------------------------------------------------------
#32 Mr. Spell:find_exact this n/a this
if ((ticks_left() < 1000) || (seconds_left() < 3))
suspend(0);
endif
return pass(@args);
-------------------------------------------------------------------------------
#32 Mr. Spell:sort this n/a this
"sort({x1,x3,x2},{1,3,2}) => {x1,x2,x3}";
lst = args[1];
unsorted_keys = (use_sorted_lst = length(args) >= 2) ? args[2] | lst;
sorted_lst = sorted_keys = {};
for e in (unsorted_keys)
l = $list_utils:find_insert(sorted_keys, e);
sorted_keys = listinsert(sorted_keys, e, l);
if (use_sorted_lst)
sorted_lst = listinsert(sorted_lst, lst[length(sorted_keys)], l);
endif
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
return sorted_lst || sorted_keys;
-------------------------------------------------------------------------------
#32 Mr. Spell:_every_key this n/a this
info = this.(" " + args[1]);
prefix = args[1] + info[1];
r = info[3];
for i in [1..length(branches = info[2])]
for new in (this:_every_key(prefix + branches[i]))
r = setadd(r, new);
if ((ticks_left() < 500) || (seconds_left() < 2))
this:_suspend(0);
endif
endfor
endfor
return r;
-------------------------------------------------------------------------------
#32 Mr. Spell:_suspend this n/a this
if (caller == this)
suspend(@args);
endif
-------------------------------------------------------------------------------
#32 Mr. Spell:insert delete delete2 this n/a this
"N.B.  use :add_word/:remove_word to actually change the contents of this db";
":insert(string) -- see $generic_db:insert";
":delete(string) -- see $generic_db:delete";
":delete2(string) -- see $generic_db:delete2";
if (caller == this)
$command_utils:suspend_if_needed(0);
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#32 Mr. Spell:add_word this n/a this
":add_word(string) -- adds word to the spell database";
"Returns true iff this word wasn't already there.";
cp = caller_perms();
if ((caller == this) || ((cp in this.trusted) || $perm_utils:controls(cp, this)))
result = this:insert(@args);
result || (this.entries = this.entries + 1);
return !result;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#32 Mr. Spell:remove_word this n/a this
":remove_word(string) -- removes word from the spell database";
"Returns true iff word was actually there to be removed.";
cp = caller_perms();
if ((caller == this) || ((cp in this.trusted) || $perm_utils:controls(cp, this)))
result = this:delete(@args);
result && (this.entries = this.entries - 1);
return result;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#32 Mr. Spell:submit this n/a this
":submit(word) -- add a word to this.submitted";
this.submitted = {@this.submitted, args[1]};
-------------------------------------------------------------------------------
#32 Mr. Spell:purge_entire_database this n/a this
"$spell:purge_entire_database - a nasty verb that will zap the whole dictionary.";
"usage: eval $spell:purge_entire_database()     ";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
if (!player.wizard)
return E_PERM;
endif
player:tell("WARNING: This will ERASE all the entries in the online dictionary! IF YOU ARE SURE YOU WISH TO DO THIS, TYPE `PURGE' NOW. Any other input with abort the command.");
input = $command_utils:read();
if (input != "purge")
player:tell("ABORTED. Database left as is.");
else
this:clearall_big(@args);
endif
-------------------------------------------------------------------------------
#32 Mr. Spell:random this n/a this
"returns a random word from the dictionary. maybe useful for games and things";
"that need a unique word. accepts no arguments.";
word = "";
while (word == "")
x = random(26);
y = random(26);
if (seconds_left() < 2)
suspend(0);
endif
lettera = $string_utils.alphabet[x];
letterb = $string_utils.alphabet[y];
foo = $spell:find_all(lettera + letterb);
if (foo != {})
word = foo[random($)];
endif
endwhile
return word;
-------------------------------------------------------------------------------
#32 Mr. Spell:help_msg none n/a none
return this.description;
-------------------------------------------------------------------------------
#32 Mr. Spell:init_for_core this n/a this
if (!caller_perms().wizard)
return;
endif
pass(@args);
$spell.trusted = {};
-------------------------------------------------------------------------------
#32 Mr. Spell:clear-submitted none in front of this
if (!(player in this.trusted))
player:tell("Sorry, you can't do that.");
return E_PERM;
endif
this.submitted = {};
player:tell("$spell.submitted = {};");
-------------------------------------------------------------------------------
#32 Mr. Spell:proxy_for_core this n/a this
return this;
-------------------------------------------------------------------------------
================================#33 sequence utilities===============================================
#33 sequence utilities:add remove this n/a this
"   add(seq,start[,end]) => seq with range added.";
"remove(seq,start[,end]) => seq with range removed.";
"  both assume start<=end.";
remove = verb == "remove";
seq = args[1];
start = args[2];
s = (start == $minint) ? 1 | $list_utils:find_insert(seq, start - 1);
if (length(args) < 3)
return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}};
else
e = $list_utils:find_insert(seq, after = args[3] + 1);
return {@seq[1..s - 1], @((s + remove) % 2) ? {start} | {}, @((e + remove) % 2) ? {after} | {}, @seq[e..$]};
endif
-------------------------------------------------------------------------------
#33 sequence utilities:contains this n/a this
":contains(seq,elt) => true iff elt is in seq.";
return ($list_utils:find_insert(@args) + 1) % 2;
-------------------------------------------------------------------------------
#33 sequence utilities:complement this n/a this
":complement(seq[,lower[,upper]]) => the sequence containing all integers *not* in seq.";
"If lower/upper are given, the resulting sequence is restricted to the specified range.";
"Bad things happen if seq is not a subset of [lower..upper]";
{seq, ?lower = $minint, ?upper = $nothing} = args;
if (upper != $nothing)
if (seq[$] >= (upper = upper + 1))
seq[$..$] = {};
else
seq[$ + 1..$] = {upper};
endif
endif
if (seq && (seq[1] <= lower))
return listdelete(seq, 1);
else
return {lower, @seq};
endif
-------------------------------------------------------------------------------
#33 sequence utilities:union this n/a this
":union(seq1,seq2,...)        => union of all sequences...";
if ({} in args)
args = $list_utils:setremove_all(args, {});
endif
if (length(args) <= 1)
return args ? args[1] | {};
endif
return this:_union(@args);
-------------------------------------------------------------------------------
#33 sequence utilities:tostr this n/a this
"tostr(seq [,delimiter]) -- turns a sequence into a string, delimiting ranges with delimiter, defaulting to .. (e.g. 5..7)";
{seq, ?separator = ".."} = args;
if (!seq)
return "empty";
endif
e = tostr((seq[1] == $minint) ? "" | seq[1]);
len = length(seq);
for i in [2..len]
e = e + ((i % 2) ? tostr(", ", seq[i]) | ((seq[i] == (seq[i - 1] + 1)) ? "" | tostr(separator, seq[i] - 1)));
endfor
return e + ((len % 2) ? separator | "");
-------------------------------------------------------------------------------
#33 sequence utilities:for this n/a this
":for([n,]seq,obj,verb,@args) => for s in (seq) obj:verb(s,@args); endfor";
set_task_perms(caller_perms());
if (typeof(n = args[1]) == INT)
args = listdelete(args, 1);
else
n = 1;
endif
{seq, object, vname, @args} = args;
if (seq[1] == $minint)
return E_RANGE;
endif
for r in [1..length(seq) / 2]
for i in [seq[(2 * r) - 1]..seq[2 * r] - 1]
if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)
return;
endif
endfor
endfor
if (length(seq) % 2)
i = seq[$];
while (1)
if (typeof(object:(vname)(@listinsert(args, i, n))) == ERR)
return;
endif
i = i + 1;
endwhile
endif
-------------------------------------------------------------------------------
#33 sequence utilities:extract this n/a this
"extract(seq,array) => list of elements of array with indices in seq.";
{seq, array} = args;
if (alen = length(array))
e = $list_utils:find_insert(seq, 1);
s = $list_utils:find_insert(seq, alen);
seq = {@(e % 2) ? {} | {1}, @seq[e..s - 1], @(s % 2) ? {} | {alen + 1}};
ret = {};
for i in [1..length(seq) / 2]
$command_utils:suspend_if_needed(0);
ret = {@ret, @array[seq[(2 * i) - 1]..seq[2 * i] - 1]};
endfor
return ret;
else
return {};
endif
-------------------------------------------------------------------------------
#33 sequence utilities:tolist this n/a this
seq = args[1];
if (!seq)
return {};
else
if (length(seq) % 2)
seq = {@seq, $minint};
endif
l = {};
for i in [1..length(seq) / 2]
for j in [seq[(2 * i) - 1]..seq[2 * i] - 1]
l = {@l, j};
endfor
endfor
return l;
endif
-------------------------------------------------------------------------------
#33 sequence utilities:from_list this n/a this
":fromlist(list) => corresponding sequence.";
return this:from_sorted_list($list_utils:sort(args[1]));
-------------------------------------------------------------------------------
#33 sequence utilities:from_sorted_list this n/a this
":from_sorted_list(sorted_list) => corresponding sequence.";
if (!(lst = args[1]))
return {};
else
seq = {i = lst[1]};
next = i + 1;
for i in (listdelete(lst, 1))
if (i != next)
seq = {@seq, next, i};
endif
next = i + 1;
endfor
return (next == $minint) ? seq | {@seq, next};
endif
-------------------------------------------------------------------------------
#33 sequence utilities:first this n/a this
return (seq = args[1]) ? seq[1] | E_NONE;
-------------------------------------------------------------------------------
#33 sequence utilities:last this n/a this
return (seq = args[1]) ? (length(seq) % 2) ? $minint - 1 | (seq[$] - 1) | E_NONE;
-------------------------------------------------------------------------------
#33 sequence utilities:size this n/a this
":size(seq) => number of elements in seq";
"  for sequences consisting of more than half of the 4294967298 available integers, this returns a negative number, which can either be interpreted as (cardinality - 4294967298) or -(size of complement sequence)";
n = 0;
for i in (seq = args[1])
n = i - n;
endfor
return (length(seq) % 2) ? $minint - n | n;
-------------------------------------------------------------------------------
#33 sequence utilities:from_string this n/a this
":from_string(string) => corresponding sequence or E_INVARG";
"  string should be a comma separated list of numbers and";
"  number..number ranges";
su = $string_utils;
if (!(words = su:explode(su:strip_chars(args[1], " "), ",")))
return {};
endif
parts = {};
for word in (words)
to = index(word, "..");
if ((!to) && su:is_numeric(word))
part = {toint(word), toint(word) + 1};
elseif (to)
if (to == 1)
start = $minint;
elseif (su:is_numeric(start = word[1..to - 1]))
start = toint(start);
else
return E_INVARG;
endif
end = word[to + 2..length(word)];
if (!end)
part = {start};
elseif (!su:is_numeric(end))
return E_INVARG;
elseif ((end = toint(end)) >= start)
part = {start, end + 1};
else
part = {};
endif
else
return E_INVARG;
endif
parts = {@parts, part};
endfor
return this:union(@parts);
-------------------------------------------------------------------------------
#33 sequence utilities:firstn this n/a this
":firstn(seq,n) => first n elements of seq as a sequence.";
if ((n = args[2]) <= 0)
return {};
endif
l = length(seq = args[1]);
s = 1;
while (s <= l)
n = n + seq[s];
if ((s >= l) || (n <= seq[s + 1]))
return {@seq[1..s], n};
endif
n = n - seq[s + 1];
s = s + 2;
endwhile
return seq;
-------------------------------------------------------------------------------
#33 sequence utilities:lastn this n/a this
":lastn(seq,n) => last n elements of seq as a sequence.";
n = args[2];
if ((l = length(seq = args[1])) % 2)
return {$minint - n};
else
s = l;
while (s)
n = seq[s] - n;
if (n >= seq[s - 1])
return {n, @seq[s..l]};
endif
n = seq[s - 1] - n;
s = s - 2;
endwhile
return seq;
endif
-------------------------------------------------------------------------------
#33 sequence utilities:range this n/a this
":range(start,end) => sequence corresponding to [start..end] range";
return ((start = args[1]) <= (end = args[2])) ? {start, end + 1} | {};
-------------------------------------------------------------------------------
#33 sequence utilities:expand this n/a this
":expand(seq,eseq[,include=0])";
"eseq is assumed to be a finite sequence consisting of intervals ";
"[f1..a1-1],[f2..a2-1],...  We map each element i of seq to";
"  i               if               i < f1";
"  i+(a1-f1)       if         f1 <= i < f2-(a1-f1)";
"  i+(a1-f1+a2-f2) if f2-(a1-f1) <= i < f3-(a2-f2)-(a1-f1)";
"  ...";
"returning the resulting sequence if include=0,";
"returning the resulting sequence unioned with eseq if include=1;";
{old, insert, ?include = 0} = args;
exclude = !include;
if (!insert)
return old;
elseif ((length(insert) % 2) || (insert[1] == $minint))
return E_TYPE;
endif
olast = length(old);
ilast = length(insert);
"... find first o for which old[o] >= insert[1]...";
ifirst = insert[i = 1];
o = $list_utils:find_insert(old, ifirst - 1);
if (o > olast)
return ((olast % 2) == exclude) ? {@old, @insert} | old;
endif
new = old[1..o - 1];
oe = old[o];
diff = 0;
while (1)
"INVARIANT: oe == old[o]+diff";
"INVARIANT: oe >= ifirst == insert[i]";
"... at this point we need to dispose of the interval ifirst..insert[i+1]";
if (oe == ifirst)
new = {@new, insert[i + ((o % 2) == exclude)]};
if (o >= olast)
return ((olast % 2) == exclude) ? {@new, @insert[i + 2..ilast]} | new;
endif
o = o + 1;
else
if ((o % 2) != exclude)
new = {@new, @insert[i..i + 1]};
endif
endif
"... advance i...";
diff = (diff + insert[i + 1]) - ifirst;
if ((i = i + 2) > ilast)
for oe in (old[o..olast])
new = {@new, oe + diff};
endfor
return new;
endif
ifirst = insert[i];
"... find next o for which old[o]+diff >= ifirst )...";
while ((oe = old[o] + diff) < ifirst)
new = {@new, oe};
if (o >= olast)
return ((olast % 2) == exclude) ? {@new, @insert[i..ilast]} | new;
endif
o = o + 1;
endwhile
endwhile
-------------------------------------------------------------------------------
#33 sequence utilities:contract this n/a this
":contract(seq,cseq)";
"cseq is assumed to be a finite sequence consisting of intervals ";
"[f1..a1-1],[f2..a2-1],...  From seq, we remove any elements that ";
"are in those ranges and map each remaining element i to";
"  i               if       i < f1";
"  i-(a1-f1)       if a1 <= i < f2";
"  i-(a1-f1+a2-f2) if a2 <= i < f3 ...";
"returning the resulting sequence.";
"";
"For any finite sequence cseq, the following always holds:";
"  :contract(:expand(seq,cseq,include),cseq)==seq";
{old, removed} = args;
if (!removed)
return old;
elseif (((rlen = length(removed)) % 2) || (removed[1] == $minint))
return E_TYPE;
endif
rfirst = removed[1];
ofirst = $list_utils:find_insert(old, rfirst - 1);
new = old[1..ofirst - 1];
diff = 0;
rafter = removed[r = 2];
for o in [ofirst..olast = length(old)]
while (old[o] > rafter)
if ((o - ofirst) % 2)
new = {@new, rfirst - diff};
ofirst = o;
endif
diff = (diff + rafter) - rfirst;
if (r >= rlen)
for oe in (old[o..olast])
new = {@new, oe - diff};
endfor
return new;
endif
rfirst = removed[r + 1];
rafter = removed[r = r + 2];
endwhile
if (old[o] < rfirst)
new = {@new, old[o] - diff};
ofirst = o + 1;
endif
endfor
return ((olast - ofirst) % 2) ? new | {@new, rfirst - diff};
-------------------------------------------------------------------------------
#33 sequence utilities:_union this n/a this
":_union(seq,seq,...)";
"assumes all seqs are nonempty and that there are at least 2";
nargs = length(args);
"args  -- list of sequences.";
"nexts -- nexts[i] is the index in args[i] of the start of the first";
"         interval not yet incorporated in the return sequence.";
"heap  -- a binary tree of indices into args/nexts represented as a list where";
"         heap[1] is the root and the left and right children of heap[i]";
"         are heap[2*i] and heap[2*i+1] respectively.  ";
"         Parent index h is <= both children in the sense of args[h][nexts[h]].";
"         heap[i]==0 indicates a nonexistant child; we fill out the array with";
"         zeros so that length(heap)>2*length(args).";
"...initialize heap...";
heap = {0, 0, 0, 0, 0};
nexts = {1, 1};
hlen2 = 2;
while (hlen2 < nargs)
nexts = {@nexts, @nexts};
heap = {@heap, @heap};
hlen2 = hlen2 * 2;
endwhile
for n in [-nargs..-1]
s1 = args[i = -n][1];
while ((hleft = heap[2 * i]) && (s1 > (m = min(la = args[hleft][1], (hright = heap[(2 * i) + 1]) ? args[hright][1] | $maxint))))
if (m == la)
heap[i] = hleft;
i = 2 * i;
else
heap[i] = hright;
i = (2 * i) + 1;
endif
endwhile
heap[i] = -n;
endfor
"...";
"...find first interval...";
h = heap[1];
rseq = {args[h][1]};
if (length(args[h]) < 2)
return rseq;
endif
current_end = args[h][2];
nexts[h] = 3;
"...";
while (1)
if (length(args[h]) >= nexts[h])
"...this sequence has some more intervals in it...";
else
"...no more intevals left in this sequence, grab another...";
h = heap[1] = heap[nargs];
heap[nargs] = 0;
if ((nargs = nargs - 1) > 1)
elseif (args[h][nexts[h]] > current_end)
return {@rseq, current_end, @args[h][nexts[h]..$]};
elseif ((i = $list_utils:find_insert(args[h], current_end)) % 2)
return {@rseq, current_end, @args[h][i..$]};
else
return {@rseq, @args[h][i..$]};
endif
endif
"...";
"...sink the top sequence...";
i = 1;
first = args[h][nexts[h]];
while ((hleft = heap[2 * i]) && (first > (m = min(la = args[hleft][nexts[hleft]], (hright = heap[(2 * i) + 1]) ? args[hright][nexts[hright]] | $maxint))))
if (m == la)
heap[i] = hleft;
i = 2 * i;
else
heap[i] = hright;
i = (2 * i) + 1;
endif
endwhile
heap[i] = h;
"...";
"...check new top sequence ...";
if (args[h = heap[1]][nexts[h]] > current_end)
"...hey, a new interval! ...";
rseq = {@rseq, current_end, args[h][nexts[h]]};
if (length(args[h]) <= nexts[h])
return rseq;
endif
current_end = args[h][nexts[h] + 1];
nexts[h] = nexts[h] + 2;
else
"...first interval overlaps with current one ...";
i = $list_utils:find_insert(args[h], current_end);
if (i % 2)
nexts[h] = i;
elseif (i > length(args[h]))
return rseq;
else
current_end = args[h][i];
nexts[h] = i + 1;
endif
endif
endwhile
-------------------------------------------------------------------------------
#33 sequence utilities:intersection this n/a this
":intersection(seq1,seq2,...) => intersection of all sequences...";
if ((U = {$minint}) in args)
args = $list_utils:setremove_all(args, U);
endif
if (length(args) <= 1)
return args ? args[1] | U;
endif
return this:complement(this:_union(@$list_utils:map_arg(this, "complement", args)));
-------------------------------------------------------------------------------
================================#34 Quota-Log===============================================
#34 Quota-Log:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = 1;
else
raise(E_PERM);
endif
-------------------------------------------------------------------------------
================================#35 you===============================================
#35 you.help_msg rc = MOOList [ "This object is useful for announcing messages that switch between third and second person when addressed to the appropriate parties in a room.", "", "Verbs:", "", "  :verb_sub(STR verbspec) -> conjugates the given verb into singular form", "  :say_action(message [,who [,thing, [,where]]]) -> appropriately pronoun ", "      substituted message announced to where, which defaults to who.location", "      where who defaults to player.", "  Ex:  if player=#123 (Munchkin), dobj=#456 (Frebblebit), and iobj=#789", "       (Bob) and they are all in the same room,", "       $you:say_action("%N %<waves> happily to %d and %i.") would do this:", "", "Munchkin sees:       You wave happily to Frebblebit and Bob.", "Frebblebit sees:     Munchkin waves happily to you and Bob.", "Bob sees:            Munchkin waves happily to Frebblebit and you.", "Everyone else sees:  Munchkin waves happily to Frebblebit and Bob." ]
#35 you.conjugations r = MOOList [ [ "is", "are" ], [ "was", "were" ], [ "does", "do" ], [ "has", "have" ] ]
#35 you:verb_sub this n/a this
"$you:verb_sub(STR verbspec) -> returns verbspec conjugated for singular use as if `you' were saying it.";
return $gender_utils:get_conj(args[1], this);
x = args[1];
len = length(x);
if ((len > 3) && (rindex(x, "n't") == (len - 3)))
return this:verb_sub(x[1..len - 3]) + "n't";
endif
for y in (this.conjugations)
if (x == y[1])
return y[2];
endif
endfor
for y in ({{"ches", "ch"}, {"ies", "y"}, {"sses", "ss"}, {"shes", "sh"}, {"s", ""}})
if ((len > length(y[1])) && (rindex(x, y[1]) == ((len - length(y[1])) + 1)))
return x[1..len - length(y[1])] + y[2];
endif
endfor
return x;
-------------------------------------------------------------------------------
#35 you:say_action this n/a this
"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])";
"announce 'message' with pronoun substitution as if it were just ";
"  where:announce_all_but(excluding-whom, ";
"    $string_utils:pronoun_sub(message, who, thing, where));";
"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.";
"who       default player";
"thing     default object that called this verb";
"where     default who.location";
"excluding default {}";
{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;
you = this;
if (typeof(msg) == LIST)
tell = "";
for x in (msg)
tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);
endfor
else
tell = msg;
endif
if (!(who in excluding))
who:tell($string_utils:pronoun_sub(this:fixpos(tell, "%n"), you, thing, where));
endif
if ($object_utils:has_callable_verb(where, "announce_all_but"))
where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));
endif
if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))
x = dobj;
dobj = you;
x:tell($string_utils:pronoun_sub(this:fixpos(tell, "%d"), who, thing, where));
dobj = x;
endif
if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))
x = iobj;
iobj = you;
x:tell($string_utils:pronoun_sub(this:fixpos(tell, "%i"), who, thing, where));
iobj = x;
endif
-------------------------------------------------------------------------------
#35 you:fixpos this n/a this
"This is horribly dwimmy.  E.g. %x's gets turned into your, %X's gets turned into Your, and %X'S gets turned into YOUR. --Nosredna";
upper = $string_utils:uppercase(args[2]);
allupper = upper + "'S";
upper = upper + "'s";
lower = $string_utils:lowercase(args[2]) + "'s";
return strsub(strsub(strsub(args[1], lower, "your", 1), upper, "Your", 1), allupper, "YOUR", 1);
-------------------------------------------------------------------------------
#35 you:reflexive this n/a this
"Copied from you (#67923):reflexive [verb author Blob (#21528)] at Wed Jul 13 05:09:32 2005 PDT";
":reflexive(msg, %[di])";
"Make a message reflexive by replacing %d or %i with %r.";
{msg, pos} = args;
upper = $string_utils:uppercase(pos) + "'s";
lower = $string_utils:lowercase(pos) + "'s";
msg = strsub(msg, lower, "%p", 1);
msg = strsub(msg, upper, "%P", 1);
msg = strsub(msg, pos, "%r", 1);
msg = strsub(msg, $string_utils:uppercase(pos), "%R", 1);
return msg;
-------------------------------------------------------------------------------
#35 you:say_action_reflexive this n/a this
"$you:say_action(message [,who [,thing, [,where [, excluding-whom]]]])";
"announce 'message' with pronoun substitution as if it were just ";
"  where:announce_all_but(excluding-whom, ";
"    $string_utils:pronoun_sub(message, who, thing, where));";
"except that who (player), dobj, and iobj get modified messages, with the appropriate use of 'you' instead of their name, and except that `excluding-whom' isn't really a valid variable name.";
"who       default player";
"thing     default object that called this verb";
"where     default who.location";
"excluding default {}";
{msg, ?who = player, ?thing = caller, ?where = who.location, ?excluding = {}} = args;
you = this;
if (typeof(msg) == LIST)
tell = "";
for x in (msg)
tell = tell + ((typeof(x) == STR) ? x | x[random(length(x))]);
endfor
else
tell = msg;
endif
if (who == dobj)
tell = this:reflexive(tell, "%d");
endif
if (who == iobj)
tell = this:reflexive(tell, "%i");
endif
if (!(who in excluding))
msg = tell;
x = dobj;
y = iobj;
dobj = (dobj == who) ? you | dobj;
iobj = (iobj == who) ? you | iobj;
who:tell($string_utils:pronoun_sub(this:fixpos(msg, "%n"), you, thing, where));
dobj = x;
iobj = y;
endif
if ($object_utils:has_callable_verb(where, "announce_all_but"))
where:announce_all_but({dobj, who, iobj, @excluding}, $string_utils:pronoun_sub(tell, who, thing, where));
endif
if ((valid(dobj) && (dobj != who)) && (!(dobj in excluding)))
x = dobj;
y = iobj;
msg = this:fixpos(tell, "%d");
if (dobj == iobj)
iobj = you;
msg = this:fixpos(msg, "%i");
endif
dobj = you;
x:tell($string_utils:pronoun_sub(msg, who, thing, where));
dobj = x;
iobj = y;
endif
if (valid(iobj) && (!(iobj in {who, dobj, @excluding})))
x = iobj;
iobj = you;
x:tell($string_utils:pronoun_sub(this:fixpos(tell, "%i"), who, thing, where));
iobj = x;
endif
-------------------------------------------------------------------------------
================================#36 Hacker===============================================
#36 Hacker:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.mail_forward = {$owner};
endif
-------------------------------------------------------------------------------
================================#37 Generic Database===============================================
#37 Generic Database.   = MOOList [ "", "", [ ], [ ] ]
#37 Generic Database.data r = MOONumber 4
#37 Generic Database.node_perms rc = MOOString "r"
#37 Generic Database:find find_key this n/a this
"find(string[,n]) => datum corresponding to string with the search starting at node \" \"+string[1..n], n defaults to 0 (root node), $ambiguous_match or $failed_match";
"find_key(string[,n]) is like :find but returns the full string key rather than the associated datum.  Note that if several string keys present in the db share a common prefix, :find_key(prefix) will return $ambiguous_match, but if there is a unique datum associated with all of these strings :find(prefix) will return it rather than $ambiguous_match.";
"Assumes n<=length(string)";
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
data = (verb == "find") ? this.data | 3;
if (i = search in info[3])
"...exact match for one of the strings in this node...";
return info[data][i];
elseif (index(info[1], rest) == 1)
"...ambiguous iff there's more than one object represented in this node..";
return this:_only(prefix, data);
elseif (index(rest, info[1]) != 1)
"...search string doesn't agree with common portion...";
return $failed_match;
elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))
"...search string follows one of continuations leading to other nodes...";
return this:(verb)(search, nsofar);
else
"...search string may partially match one of the strings in this node...";
for i in [1..length(exacts = info[3])]
if (index(exacts[i], search) == 1)
return info[data][i];
endif
endfor
return $failed_match;
endif
-------------------------------------------------------------------------------
#37 Generic Database:find_exact this n/a this
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
if (i = search in info[3])
return info[this.data][i];
elseif ((length(rest) <= (common = length(info[1]))) || (rest[1..common] != info[1]))
return $failed_match;
elseif (index(info[2], search[(sofar + common) + 1]))
return this:find_exact(search, (sofar + common) + 1);
else
return $failed_match;
endif
-------------------------------------------------------------------------------
#37 Generic Database:find_all find_all_keys this n/a this
":find_all(string [,n=0])";
"assumes n <= length(string)";
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
data = (verb == "find_all") ? this.data | 3;
if (index(info[1], rest) == 1)
"...return entire subtree.";
return this:((data == 3) ? "_every_key" | "_every")(prefix);
elseif (index(rest, info[1]) != 1)
"...common portion doesn't agree.";
return {};
elseif (index(info[2], rest[1 + (common = length(info[1]))]))
"...matching strings are in a subnode.";
return this:(verb)(search, (sofar + common) + 1);
else
"...matching string is in info[3].  length(rest) > common,";
"...so there will be at most one matching string.";
for i in [1..length(info[3])]
if (index(info[3][i], search) == 1)
return {info[data][i]};
endif
endfor
return {};
endif
-------------------------------------------------------------------------------
#37 Generic Database:_only this n/a this
":_only(prefix,data) => if all strings in this node have the same datum, return it, otherwise, return $ambiguous_match.";
if (caller != this)
raise(E_PERM);
endif
{prefix, data} = args;
info = this.(" " + prefix);
if (data == 3)
"... life is much simpler if there's no separate datum.";
"... if there's more than one string here, we barf.";
if (info[2] || (length(info[3]) > 1))
return $ambiguous_match;
elseif (info[3])
return info[3][1];
else
"..this can only happen with the root node of an empty db.";
return $failed_match;
endif
elseif (info[2])
what = this:_only(tostr(prefix, info[1], info[2][1]), data);
if (what == $ambiguous_match)
return what;
endif
elseif (info[data])
what = info[data][1];
info[data] = listdelete(info[data], 1);
else
"..this can only happen with the root node of an empty db.";
return $failed_match;
endif
for x in (info[data])
if (what != x)
return $ambiguous_match;
endif
endfor
for i in [2..length(info[2])]
if (what != this:_only(tostr(prefix, info[1], info[2][i]), data))
return $ambiguous_match;
endif
endfor
return what;
-------------------------------------------------------------------------------
#37 Generic Database:_every this n/a this
if (caller != this)
raise(E_PERM);
endif
info = this.(" " + args[1]);
prefix = args[1] + info[1];
r = $list_utils:remove_duplicates(info[4]);
for i in [1..length(branches = info[2])]
for new in (this:_every(prefix + branches[i]))
r = setadd(r, new);
endfor
endfor
return r;
-------------------------------------------------------------------------------
#37 Generic Database:_every_key this n/a this
if (caller != this)
raise(E_PERM);
endif
info = this.(" " + args[1]);
prefix = args[1] + info[1];
r = info[3];
for i in [1..length(branches = info[2])]
for new in (this:_every_key(prefix + branches[i]))
r = setadd(r, new);
$command_utils:suspend_if_needed(0);
endfor
$command_utils:suspend_if_needed(0);
endfor
return r;
-------------------------------------------------------------------------------
#37 Generic Database:insert this n/a this
":insert([n,]string,datum) -- inserts <string,datum> correspondence into tree starting at node \" \"+string[1..n], n defaulting to 0 (root node).";
"Assumes length(string) >= n";
"Returns {old_datum} (or 1) if there was a <string,old_datum> correspondence there before, otherwise returns 0";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
has_datum = this.data > 3;
if (typeof(sofar = args[1]) == INT)
search = args[2];
datum = has_datum ? args[3] | 0;
else
search = sofar;
sofar = 0;
datum = has_datum ? args[2] | 0;
endif
prefix = search[1..sofar];
info = this.(" " + prefix);
if (i = search in info[3])
"... exact match ...";
if (has_datum)
previous = {info[this.data][i]};
info[this.data][i] = datum;
this:set_node(prefix, @info);
return previous;
else
return 1;
endif
endif
rest = search;
rest[1..sofar] = "";
if (index(rest, info[1]) != 1)
"... find where new string disagrees with common portion...";
c = $string_utils:common(rest, info[1]) + 1;
"... make a new node with a shorter common portion....";
this:make_node(prefix + info[1][1..c], @listset(info, info[1][c + 1..$], 1));
this:set_node(prefix, info[1][1..c - 1], info[1][c], {search}, @has_datum ? {{datum}} | {});
return 0;
elseif (rest == info[1])
".. new string == common portion, insert...";
info[3] = {@info[3], search};
if (has_datum)
info[this.data] = {@info[this.data], datum};
endif
this:set_node(prefix, @info);
return 0;
elseif (index(info[2], search[nsofar = (sofar + length(info[1])) + 1]))
"... new string matches pre-existing continuation. insert in subnode....";
return this:insert(nsofar, search, datum);
else
"... new string may blow away one of the exact matches (i.e., matches one of them up to the first character beyond the common portion) in which case we need to create a new subnode....";
s = search[1..nsofar];
for m in (info[3])
if (index(m, s) == 1)
i = m in info[3];
"... we know m != search ...";
"... string m has been blown away.  create new node ...";
cbegin = cafter = length(s) + 1;
cend = $string_utils:common(search, m);
this:make_node(s, m[cbegin..cend], "", {search, m}, @has_datum ? {{datum, info[this.data][i]}} | {});
this:set_node(prefix, info[1], info[2] + s[nsofar], listdelete(info[3], i), @has_datum ? {listdelete(info[this.data], i)} | {});
return 0;
endif
endfor
"... new string hasn't blown away any of the exact matches, insert it as a new exact match...";
info[3] = {search, @info[3]};
if (has_datum)
info[this.data] = {datum, @info[this.data]};
endif
this:set_node(prefix, @info);
return 0;
endif
-------------------------------------------------------------------------------
#37 Generic Database:delete this n/a this
":delete(string[,n]) deletes any <string,something> pair from the tree starting at node \" \"+string[1..n], n defaulting to 0 (root node)";
"Returns {something} if such a pair existed, otherwise returns 0";
"If that node is not the root node and ends up containing only one string and no subnodes, we kill it and return {something,string2,something2} where <string2,something2> is the remaining pair.";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
{search, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
if (i = search in info[3])
previous = {info[this.data][i]};
info[3] = listdelete(info[3], i);
if (this.data > 3)
info[this.data] = listdelete(info[this.data], i);
endif
elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))
"... hmm string isn't in here...";
return 0;
elseif ((previous = this:delete(search, d)) && (length(previous) > 1))
i = index(info[2], search[d]);
info[2][i..i] = "";
info[3] = {previous[2], @info[3]};
if (this.data > 3)
info[this.data] = {previous[3], @info[this.data]};
endif
previous = previous[1..1];
else
return previous;
endif
if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))
this:set_node(prefix, @info);
return previous;
elseif (info[3])
this:kill_node(prefix);
return {@previous, info[3][1], info[this.data][1]};
else
sub = this.(" " + (p = tostr(prefix, info[1], info[2])));
this:kill_node(p);
this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));
return previous;
endif
-------------------------------------------------------------------------------
#37 Generic Database:delete2 this n/a this
":delete2(string,datum[,n]) deletes the pair <string,datum> from the tree starting at node \" \"+string[1..n], n defaulting to 0 (root node)";
"Similar to :delete except that if the entry for that string has a different associated datum, it will not be removed.  ";
":delete2(string,datum) is equivalent to ";
" ";
"  if(this:find_exact(string)==datum) ";
"    this:delete(string); ";
"  endif";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
{search, datum, ?sofar = 0} = args;
rest = search;
prefix = search[1..sofar];
rest[1..sofar] = "";
info = this.(" " + prefix);
if (i = search in info[3])
previous = {info[this.data][i]};
if (previous[1] != datum)
return previous;
endif
info[3] = listdelete(info[3], i);
if (this.data > 3)
info[this.data] = listdelete(info[this.data], i);
endif
elseif ((rest == info[1]) || ((index(rest, info[1]) != 1) || (!index(info[2], search[d = (sofar + length(info[1])) + 1]))))
"... hmm string isn't in here...";
return 0;
elseif ((previous = this:delete2(search, datum, d)) && (length(previous) > 1))
i = index(info[2], search[d]);
info[2][i..i] = "";
info[3] = {previous[2], @info[3]};
if (this.data > 3)
info[this.data] = {previous[3], @info[this.data]};
endif
previous = previous[1..1];
else
return previous;
endif
if ((!prefix) || ((length(info[3]) + length(info[2])) != 1))
this:set_node(prefix, @info);
return previous;
elseif (info[3])
this:kill_node(prefix);
return {@previous, info[3][1], info[this.data][1]};
else
sub = this.(" " + (p = tostr(prefix, info[1], info[2])));
this:kill_node(p);
this:set_node(prefix, @listset(sub, tostr(info[1], info[2], sub[1]), 1));
return previous;
endif
-------------------------------------------------------------------------------
#37 Generic Database:set_node this n/a this
return (caller != this) ? E_PERM | (this.(" " + args[1]) = listdelete(args, 1));
-------------------------------------------------------------------------------
#37 Generic Database:make_node this n/a this
"WIZARDLY";
return (caller != this) ? E_PERM | add_property(this, " " + args[1], listdelete(args, 1), {$generic_db.owner, this.node_perms});
-------------------------------------------------------------------------------
#37 Generic Database:kill_node this n/a this
"WIZARDLY";
return (caller != this) ? E_PERM | delete_property(this, " " + args[1]);
-------------------------------------------------------------------------------
#37 Generic Database:clearall this n/a this
"WIZARDLY";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
if (args && ((d = args[1]) in {3, 4}))
this.data = d;
endif
root = {"", "", {}, @(this.data > 3) ? {{}} | {}};
"...since the for loop contains a suspend, we want to keep people";
"...from getting at properties which are now garbage but which we";
"...haven't had a chance to wipe yet.  Somebody might yet succeed";
"...in adding something; thus we have the outer while loop.";
this:set_node("", 37);
while (this.(" ") != root)
this:set_node("", @root);
for p in (properties(this))
if ((p[1] == " ") && (p != " "))
delete_property(this, p);
endif
"...Bleah; db is inconsistent now....";
"...At worst someone will add something that references an";
"...existing property.  He will deserve to die...";
$command_utils:suspend_if_needed(0);
endfor
endwhile
-------------------------------------------------------------------------------
#37 Generic Database:clearall_big this n/a this
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
this:_kill_subtrees("", 0);
this:clearall(@args);
-------------------------------------------------------------------------------
#37 Generic Database:_kill_subtrees this n/a this
":_kill_subtree(node,count)...wipes out all subtrees";
"...returns count + number of nodes removed...";
if (!($perm_utils:controls(caller_perms(), this) || (caller == this)))
return E_PERM;
endif
info = this.(" " + (prefix = args[1]));
count = args[2];
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", count);
suspend(0);
endif
for i in [1..length(info[2])]
count = this:_kill_subtrees(n = tostr(prefix, info[1], info[2][i]), count) + 1;
this:kill_node(n);
endfor
return count;
-------------------------------------------------------------------------------
#37 Generic Database:depth this n/a this
info = this.(" " + (prefix = (args || {""})[1]));
depth = 0;
string = prefix;
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", prefix);
suspend(0);
endif
for i in [1..length(info[2])]
if ((r = this:depth(tostr(prefix, info[1], info[2][i])))[1] > depth)
depth = r[1];
string = r[2];
endif
endfor
return {depth + 1, string};
-------------------------------------------------------------------------------
#37 Generic Database:count_entries this n/a this
info = this.(" " + (prefix = args[1]));
count = length(info[3]) + args[2];
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", count);
suspend(0);
endif
for i in [1..length(info[2])]
count = this:count_entries(tostr(prefix, info[1], info[2][i]), count);
endfor
return count;
-------------------------------------------------------------------------------
#37 Generic Database:count_chars this n/a this
info = this.(" " + (prefix = args[1]));
count = args[2];
for s in (info[3])
count = count + length(s);
endfor
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", count);
suspend(0);
endif
for i in [1..length(info[2])]
count = this:count_chars(tostr(prefix, info[1], info[2][i]), count);
endfor
return count;
-------------------------------------------------------------------------------
#37 Generic Database:count any at/to this
"count [entries|chars] in <db>";
"  reports on the number of distinct string keys or the number of characters";
"  in all string keys in the db";
if (index("entries", dobjstr) == 1)
player:tell(this:count_entries("", 0), " strings in ", this.name, "(", this, ")");
elseif (index("chars", dobjstr) == 1)
player:tell(this:count_chars("", 0), " chars in ", this.name, "(", this, ")");
else
player:tell("Usage: ", verb, " entries|chars in <db>");
endif
-------------------------------------------------------------------------------
#37 Generic Database:proxy_for_core this n/a this
"Create a stand-in for the core-extraction process";
"  (rather than change the ownership on 80000 properties only to delete them).";
{core_variant, is_mcd} = args;
if (!is_mcd)
return this;
elseif (caller != #0)
raise(E_PERM);
elseif (children(this) || (length(properties(this)) < 100))
return this;
endif
proxy = $recycler:_create(parent(this), this.owner);
player:tell("Creating proxy object ", proxy, " for ", this.name, " (", this, ")");
for p in ({"name", "r", "w", "f"})
proxy.(p) = this.(p);
endfor
for p in ($object_utils:all_properties_suspended(parent(this)))
if (!is_clear_property(this, p))
$command_utils:suspend_if_needed(0, "...setting props from parent...");
proxy.(p) = this.(p);
endif
endfor
for p in (properties(this))
$command_utils:suspend_if_needed(0);
if ((p[1] == " ") && (p != " "))
continue;
endif
add_property(proxy, p, this.(p), property_info(this, p));
endfor
for v in [1..length(verbs(this))]
add_verb(proxy, verb_info(this, v), verb_args(this, v));
set_verb_code(proxy, v, verb_code(this, v));
$command_utils:suspend_if_needed(0);
endfor
proxy:clearall();
return proxy;
-------------------------------------------------------------------------------
================================#38 Everyman===============================================
#38 Everyman.queued_task_limit r = MOONumber 0
#38 Everyman:eval this n/a this
"eval(code)";
"Evaluate code with $no_one's permissions (so you won't damage anything).";
"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.";
"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.";
exp = args[1];
if (this:bad_eval(exp))
return E_PERM;
endif
set_task_perms(this);
if (exp[1] != ";")
return eval(tostr("this=", caller, "; return ", exp, ";"));
else
return eval(tostr("this=", caller, ";", exp, ";"));
endif
-------------------------------------------------------------------------------
#38 Everyman:moveto this n/a this
return 0;
-------------------------------------------------------------------------------
#38 Everyman:eval_d this n/a this
":eval_d(code)";
"exactly like :eval except that the d flag is unset";
"Evaluate code with $no_one's permissions (so you won't damage anything).";
"If code does not begin with a semicolon, set this = caller (in the code to be evaluated) and return the value of the first `line' of code.  This means that subsequent lines will not be evaluated at all.";
"If code begins with a semicolon, set this = caller and let the code decide for itself when to return a value.  This is how to do multi-line evals.";
exp = args[1];
if (this:bad_eval(exp))
return E_PERM;
endif
set_task_perms(this);
if (exp[1] != ";")
return $code_utils:eval_d(tostr("this=", caller, "; return ", exp, ";"));
else
return $code_utils:eval_d(tostr("this=", caller, ";", exp, ";"));
endif
-------------------------------------------------------------------------------
#38 Everyman:call_verb this n/a this
"call_verb(object, verb name, args)";
"Call verb with $no_one's permissions (so you won't damage anything).";
"One could do this with $no_one:eval, but ick.";
set_task_perms(this);
return args[1]:(args[2])(@args[3]);
-------------------------------------------------------------------------------
#38 Everyman:bad_eval this n/a this
":bad_eval(exp)";
"  Returns 1 if the `exp' is inappropriate for use by $no_one.  In particular, if `exp' contains calls to `eval', `fork', `suspend', or `call_function' it is bad.  Similarly, if `player' is a nonvalid object (or a child of $garbage) the expression is considered `bad' because it is likely an attempt to anonymously spoof.";
"  At present, the checks for bad builtins are overzealous.  It should check for delimited uses of the above calls, in case someone has a variable called `prevalent'.";
{exp} = args;
if (((index(exp, "eval") || index(exp, "fork")) || index(exp, "suspend")) || index(exp, "call_function"))
"Well, they had one of the evil words in here.  See if it was in a quoted string or not -- we want to permit player:tell(\"Gentlemen use forks.\")";
for bad in ({"eval", "fork", "suspend", "call_function"})
tempindex = 1;
while (l = index(exp[tempindex..$], bad, 0))
if ($code_utils:inside_quotes(exp[1..(tempindex + l) - 1]))
tempindex = tempindex + l;
else
"it's there, bad unquoted string";
return 1;
endif
endwhile
endfor
endif
if ((!$recycler:valid(player)) && (player >= #0))
return 1;
endif
return 0;
-------------------------------------------------------------------------------
#38 Everyman:set_* this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
return pass(@args);
endif
-------------------------------------------------------------------------------
================================#39 Player Database===============================================
#39 Player Database. e r = MOOList [ "", "v", [ "Editor_Owner" ], [ #96 ] ]
#39 Player Database. H r = MOOList [ "", "", [ "Hacker", "housekeeper" ], [ #36, #71 ] ]
#39 Player Database.frozen rc = MOONumber 0
#39 Player Database. n r = MOOList [ "o", "", [ "noone", "no_one" ], [ #38, #38 ] ]
#39 Player Database. Ev r = MOOList [ "ery", "", [ "everyone", "Everyman" ], [ #38, #38 ] ]
#39 Player Database.stupid_names rc = MOOList [ "with", "using", "at", "to", "in", "into", "on", "onto", "upon", "out", "from", "inside", "over", "through", "under", "underneath", "beneath", "behind", "beside", "for", "about", "is", "as", "off", "of", "me", "you", "here" ]
#39 Player Database.reserved r = MOOList [ ]
#39 Player Database:load this n/a this
":load() -- reloads the player_db with the names of all existing players.";
"This routine calls suspend() if it runs out of time.";
".frozen is set to 1 while the load is in progress so that other routines are warned and don't try to do any updates.  Sometimes, an update is unavoidable (e.g., player gets recycled) in which case the offending routine should set .frozen to 2, causing the load to start over at the beginning.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
"...N.B. clearall suspends, therefore we put the .frozen mark on FIRST...";
this.frozen = 1;
this:clearall();
for p in (players())
this:suspend_restart(p);
"... note that if a player is recycled or toaded during the suspension,...";
"... it won't be removed from the for loop iteration; thus this test:     ";
if (valid(p) && is_player(p))
if (typeof(po = this:find_exact(p.name)) == ERR)
player:tell(p.name, ":  ", po);
return;
elseif (po != p)
if (valid(po) && is_player(po))
player:tell("name `", p.name, "' for ", p, " subsumes alias for ", po.name, "(", po, ").");
endif
this:insert(p.name, p);
endif
for a in (p.aliases)
this:suspend_restart(p);
if (index(a, " ") || index(a, "	"))
"don't bother, space or tab";
elseif (typeof(ao = this:find_exact(a)) == ERR)
player:tell(a, ":  ", ao);
return;
elseif (!(valid(ao) && is_player(ao)))
this:insert(a, p);
elseif (ao != p)
player:tell("alias `", a, "' for ", p.name, "(", p, ") used by ", ao.name, "(", ao, ").");
endif
endfor
endif
endfor
this.frozen = 0;
-------------------------------------------------------------------------------
#39 Player Database:check this n/a none
":check() -- checks for recycled and toaded players that managed not to get expunged from the db.";
for p in (properties($player_db))
if ((ticks_left() < 500) || (seconds_left() < 2))
player:tell("...", p);
suspend(0);
endif
if (p[1] == " ")
nlist = this.(p)[3];
olist = this.(p)[4];
for i in [1..length(nlist)]
if (valid(olist[i]) && (is_player(olist[i]) && (nlist[i] in olist[i].aliases)))
else
player:tell(".", p[2..$], " <- ", nlist[i], " ", olist[i]);
endif
endfor
endif
endfor
player:tell("done.");
-------------------------------------------------------------------------------
#39 Player Database:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.reserved = {};
this:load();
endif
-------------------------------------------------------------------------------
#39 Player Database:available this n/a this
":available(name,who) => 1 if a name is available for use, or the object id of whoever is currently using it, or 0 if the name is otherwise forbidden.";
"If $player_db is not .frozen and :available returns 1, then $player:set_name will succeed.";
{name, ?target = valid(caller) ? caller | player} = args;
if ((name in this.stupid_names) || (name in this.reserved))
return 0;
elseif (target in $wiz_utils.rename_restricted)
return 0;
elseif (((((!name) || index(name, " ")) || index(name, "\\")) || index(name, "\"")) || index(name, "	"))
return 0;
elseif (index("*#()", name[1]))
return 0;
elseif (match(name, "(#[0-9]+)"))
return 0;
elseif (valid(who = this:find_exact(name)) && is_player(who))
return who;
elseif ($object_utils:has_callable_verb($local, "legal_name") && (!$local:legal_name(name, target)))
return 0;
else
return 1;
endif
-------------------------------------------------------------------------------
#39 Player Database:suspend_restart this n/a this
"used during :load to do the usual out-of-time check.";
"if someone makes a modification during the suspension (indicated by this.frozen being set to 2), we have to restart the entire load.";
if (caller != this)
return E_PERM;
elseif ($command_utils:running_out_of_time())
player:tell("...", args[1]);
set_task_perms($byte_quota_utils:task_perms());
suspend(0);
if (this.frozen != 1)
player:tell("...argh... restarting $player_db:load...");
fork (0)
this:load();
endfork
kill_task(task_id());
endif
endif
-------------------------------------------------------------------------------
#39 Player Database:why_bad_name this n/a this
":why_bad_name(player, namespec) => Returns a message explaining why a player name change is invalid.  Stolen from APHiD's #15411:name_okay.";
who = args[1];
name = $building_utils:parse_names(args[2])[1];
si = index(name, " ");
qi = index(name, "\"");
bi = index(name, "\\");
ti = index(name, "	");
if (((si || qi) || bi) || ti)
return tostr("You may not use a name containing ", $string_utils:english_list({@si ? {"spaces"} | {}, @qi ? {"quotation marks"} | {}, @bi ? {"backslashes"} | {}, @ti ? {"tabs"} | {}}, "ERROR", " or "), ".  Try \"", strsub(strsub(strsub(strsub(name, " ", "_"), "\"", "'"), "\\", "/"), "	", "___"), "\" instead.");
elseif (name == "")
return tostr("You may not use a blank name.");
elseif (i = index("*#()", name[1]))
return tostr("You may not begin a name with the \"", "*#()"[i], "\" character.");
elseif (match(name, "(#[0-9]+)"))
return tostr("A name can't contain a parenthesized object number.");
elseif (name in $player_db.stupid_names)
return tostr("The name \"", name, "\" would probably cause problems in command parsing or similar usage.");
elseif (name in $player_db.reserved)
return tostr("The name \"", name, "\" is reserved.");
elseif (length(name) > $login.max_player_name)
return tostr("The name \"", name, "\" is too long.  Maximum name length is ", $login.max_player_name, " characters.");
elseif ((valid(match = $player_db:find_exact(name)) && is_player(match)) && (who != match))
return tostr("The name \"", name, "\" is already being used by ", match.name, "(", match, ").");
elseif ($player_db.frozen)
return tostr("$player_db is not accepting new changes at the moment.");
elseif ($object_utils:has_callable_verb($local, "legal_name") && (!$local:legal_name(name, who)))
return "That name is reserved.";
elseif (who in $wiz_utils.rename_restricted)
return "This player is not allowed to change names.";
endif
-------------------------------------------------------------------------------
================================#40 Generic Mail Receiving Player===============================================
#40 Generic Mail Receiving Player.messages_going c = MOOList [ ]
#40 Generic Mail Receiving Player.message_keep_date rc = MOONumber 0
#40 Generic Mail Receiving Player.current_message c = MOOList [ 0, 0 ]
#40 Generic Mail Receiving Player.messages c = MOOList [ ]
#40 Generic Mail Receiving Player.mail_forward rc = MOOList [ ]
#40 Generic Mail Receiving Player.mail_options rc = MOOList [ ]
#40 Generic Mail Receiving Player.messages_kept rc = MOOList [ ]
#40 Generic Mail Receiving Player.mail_lists rc = MOOList [ ]
#40 Generic Mail Receiving Player.mail_notify r = MOOList [ [ ], [ ] ]
#40 Generic Mail Receiving Player._mail_task rc = MOONumber 0
#40 Generic Mail Receiving Player:mail_forward this n/a this
if (typeof(mf = this.(verb)) == STR)
return $string_utils:pronoun_sub(mf, @args);
else
return mf;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:receive_message this n/a this
":receive_message(msg,from)";
if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))
return E_PERM;
endif
if (this:mail_option("no_dupcc", args[1][1], args[1][2]))
"pass to :mail_option the TEXT versions of who the message is from and to";
recipients = setremove($mail_agent:parse_address_field(args[1][3]), this);
for x in (recipients)
if (this:get_current_message(x))
return 0;
endif
endfor
endif
if (this:mail_option("netmail"))
msg = args[1];
message = {"Forwarded: " + msg[4], "Original-date: " + ctime(msg[1]), "Original-From: " + msg[2], "Original-To: " + msg[3], ((("Reply-To: " + $string_utils:substitute(args[2].name, {{"@", "%"}})) + "@") + $network.moo_name) + ".moo.mud.org"};
for x in (msg[5..$])
message = {@message, @$generic_editor:fill_string(x, this:linelen())};
endfor
if (this:send_self_netmail(message, @listdelete(args, 1)) == 0)
return 0;
endif
endif
set_task_perms(this.owner);
new = this:new_message_num();
ncur = (new <= 1) ? 0 | min(this:current_message(this), new);
this:set_current_message(this, ncur);
new = max(new, ncur + 1);
this.messages = {@this.messages, {new, args[1]}};
"... new-mail notification is now done directly by $mail_agent:raw_send";
"... see :notify_mail...";
return new;
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:display_message this n/a this
":display_message(preamble,msg) --- prints msg to player.";
vb = ((this._mail_task == task_id()) || (caller == $mail_editor)) ? "notify_lines_suspended" | "tell_lines_suspended";
preamble = args[1];
player:(vb)({@(typeof(preamble) == LIST) ? preamble | {preamble}, @args[2], "--------------------------"});
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_date_gt length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string rm_message_seq undo_rmm expunge_rmm renumber keep_message_seq this n/a this
"parse_message_seq(strings,cur)         => msg_seq";
"messages_in_seq(msg_seq);              => text of messages in msg_seq";
"display_seq_headers(msg_seq[,current]) :displays summary lines of those msgs";
"rmm_message_seq(msg_seq)               => string giving msg numbers removed";
"undo_rmm()    => msg_seq of restored messages";
"expunge_rmm() => number of messages expunged";
"list_rmm()    => number of messages awaiting expunge";
"renumber(cur) => {number of messages in folder, new_cur}";
"";
"See the corresponding routines on $mail_agent.";
if ((caller == $mail_agent) || $perm_utils:controls(caller_perms(), this))
set_task_perms(this.owner);
return $mail_agent:(verb)(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:msg_summary_line this n/a this
return $mail_agent:msg_summary_line(@args);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:msg_text this n/a this
":msg_text(@msg) => list of strings.";
"msg is a mail message (in the usual transmission format) being read BY this player.";
"The default version of recipient:msg_full_text calls this to obtain the actual list of strings to display.  (this is a badly named verb).";
"returns the actual list of strings to display.";
return $mail_agent:to_text(@args);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:notify_mail this n/a this
":notify_mail(from,recipients[,msgnums])";
" used by $mail_agent:raw_send to notify this player about mail being sent";
" from <from> to <recipients>.  <msgnums> if given gives the message number(s) assigned (in the event that the corresponding recipient actually kept the mail)";
if (!$object_utils:connected(this))
return;
elseif (!((caller in {this, $mail_agent}) || $perm_utils:controls(caller_perms(), this)))
return E_PERM;
else
{from, recipients, ?msgnums = {}} = args;
from_name = $mail_agent:name(from);
"... msgnums may be shorter than recipients or may have some slots filled";
"... with 0's if msg numbers are not available for some recipients.";
if ((t = this in recipients) && ((length(msgnums) >= t) && msgnums[t]))
"... you are getting the mail and moreover your :receive_message kept it.";
namelist = $string_utils:english_list($list_utils:map_arg($mail_agent, "name", setremove(recipients, this)), "");
this:notify(tostr("You have new mail (", msgnums[t], ") from ", from_name, namelist ? " which was also sent to " + namelist | "", "."));
if (!this:mail_option("expert"))
this:notify(tostr("Type `help mail' for info on reading it."));
endif
else
"... vanilla notification; somebody got sent mail and you're finding out.";
namelist = $string_utils:english_list({@t ? {"You"} | {}, @$list_utils:map_arg($mail_agent, "name", setremove(recipients, this))}, "");
this:tell(tostr(namelist, (length(recipients) == 1) ? " has" | " have", " just been sent new mail by ", from_name, "."));
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:current_message this n/a this
":current_message([recipient])";
" => current message number for the given recipient (defaults to this).";
" => 0 if we have no record of that recipient";
"      or current message happens to be 0.";
"This verb is mostly obsolete; consider using :get_current_message()";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
elseif ((!args) || (args[1] == this))
return this.current_message[1];
elseif (a = $list_utils:assoc(args[1], this.current_message))
return a[2];
else
return 0;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:get_current_message this n/a this
":get_current_message([recipient])";
" => {msg_num, last_read_date} for the given recipient.";
" => 0 if we have no record of that recipient.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
elseif ((!args) || (args[1] == this))
if (length(this.current_message) < 2)
"Whoops, this got trashed---fix it up!";
this.current_message = {0, time(), @this.current_message};
endif
return this.current_message[1..2];
elseif (a = $list_utils:assoc(args[1], this.current_message))
return a[2..3];
else
return 0;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:set_current_message this n/a this
":set_current_message(recipient[,number[,date]])";
"Returns the new {number,last-read-date} pair for recipient.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
endif
{recip, ?number = E_NONE, ?date = 0, ?force = 0} = args;
cm = this.current_message;
if (recip == this)
this.current_message[2] = max(date, cm[2]);
if (number != E_NONE)
this.current_message[1] = number;
endif
return this.current_message[1..2];
elseif (i = $list_utils:iassoc(recip, cm))
if (force)
"`force' is assumed to come from `@unread'";
return (this.current_message[i] = {recip, number, date})[2..3];
else
return (this.current_message[i] = {recip, (number == E_NONE) ? cm[i][2] | number, max(date, cm[i][3])})[2..3];
endif
else
entry = {recip, (number != E_NONE) && number, date};
this.current_message = {@cm, entry};
return entry[2..3];
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:make_current_message this n/a this
":make_current_message(recipient[,index])";
"starts a new current_message record for recipient.";
"index, if given, indicates where recipient is to be";
"  placed (n = at or after nth entry in .current_message).";
recip = args[1];
cm = this.current_message;
if (length(args) > 1)
i = max(2, min(args[2], length(cm)));
else
i = 0;
endif
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
elseif (recip == this)
"...self...";
elseif (j = $list_utils:iassoc(recip, cm))
"...already present...";
if (i)
if (j < i)
this.current_message = {@cm[1..j - 1], @cm[j + 1..i], cm[j], @cm[i + 1..$]};
elseif (j > (i + 1))
this.current_message = {@cm[1..i], cm[j], @cm[i + 1..j - 1], @cm[j + 1..$]};
endif
endif
else
this.current_message = listappend(cm, {recip, 0, 0}, @i ? {i} | {});
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:kill_current_message this n/a this
":kill_current_message(recipient)";
"entirely forgets current message for this recipient...";
"Returns true iff successful.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
raise(E_PERM);
else
return ((recip = args[1]) != this) && ((i = $list_utils:iassoc(recip, cm = this.current_message)) && (this.current_message = listdelete(cm, i)));
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:current_folder this n/a this
":current_folder() => default folder to use, always an object, usually `this'";
set_task_perms(caller_perms());
return ((!this:mail_option("sticky")) || this.current_folder) && this;
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:set_current_folder this n/a this
set_task_perms(caller_perms());
return this.current_folder = args[1];
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:parse_folder_spec this n/a this
":parse_folder_spec(verb,args,expected_preposition[,allow_trailing_args_p])";
" => {folder, msg_seq_args, trailing_args}";
set_task_perms(caller_perms());
folder = this:current_folder();
if (!prepstr)
return {folder, args[2], {}};
endif
{verb, args, prep, ?extra = 0} = args;
p = prepstr in args;
if (prepstr != prep)
"...unexpected preposition...";
if (extra && (!index(prepstr, " ")))
return {folder, args[1..p - 1], args[p..$]};
else
player:tell("Usage:  ", verb, " [<message numbers>] [", prep, " <folder/list-name>]");
endif
elseif (!((p < length(args)) && (fname = args[p + 1])))
"...preposition but no iobj...";
player:tell(verb, " ", $string_utils:from_list(args, " "), " WHAT?");
elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname, this), fname))
"...bogus mail folder...";
else
return {folder, args[1..p - 1], args[p + 2..$]};
endif
return 0;
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:parse_mailread_cmd this n/a this
":parse_mailread_cmd(verb,args,default,prep[,trailer])";
"  handles anything of the form  `VERB message_seq [PREP folder ...]'";
"    default is the default msg-seq to use if none given";
"    prep is the expected prepstr (assumes prepstr is set), usually `on'";
"    trailer, if present and true, indicates trailing args are permitted.";
"  returns {recipient object, message_seq, current_msg,\"...\"} or 0";
set_task_perms(caller_perms());
if (!(pfs = this:parse_folder_spec(@listdelete(args, 3))))
return 0;
endif
{verb, args, default, prep, ?extra = 0} = args;
folder = pfs[1];
cur = this:get_current_message(folder) || {0};
if (typeof(pms = folder:parse_message_seq(pfs[2], @cur)) == LIST)
rest = {@listdelete(pms, 1), @pfs[3]};
if ((!extra) && rest)
"...everything should have been gobbled by :parse_message_seq...";
player:tell("I don't understand `", rest[1], "'");
return 0;
elseif (pms[1])
"...we have a nonempty message sequence...";
return {folder, pms[1], cur, rest};
elseif (used = (length(pfs[2]) + 1) - length(pms))
"...:parse_message_seq used some words, but didn't get anything out of it";
pms = ("%f %<has> no `" + $string_utils:from_list(pfs[2][1..used], " ")) + "' messages.";
elseif (typeof(pms = folder:parse_message_seq(default, @cur)) == LIST)
"...:parse_message_seq used nothing, try the default; wow it worked";
return {folder, pms[1], cur, rest};
endif
elseif (typeof(pms) == ERR)
player:tell($mail_agent:name(folder), " is not readable by you.");
if (!$object_utils:isa(folder, $mail_recipient))
player:tell("Use * to indicate a non-player mail recipient.");
endif
return 0;
endif
if (folder == this)
subst = {{"%f's", "Your"}, {"%f", "You"}, {"%<has>", "have"}};
elseif (is_player(folder))
subst = {{"%f", folder.name}, {"%<has>", $gender_utils:get_conj("has", folder)}};
else
subst = {{"%f", $mail_agent:name(folder)}, {"%<has>", "has"}};
endif
player:tell($string_utils:substitute(pms, {@subst, {"%%", "%"}}));
return 0;
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@mail any ?-2? any
"@mail <msg-sequence>                --- as in help @mail";
"@mail <msg-sequence> on <recipient> --- shows mail on mailing list or player.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (p = this:parse_mailread_cmd("@mail", args, this:mail_option("@mail") || $mail_agent.("player_default_@mail"), "on"))
this:set_current_folder(folder = p[1]);
msg_seq = p[2];
seq_size = $seq_utils:size(msg_seq);
if ((lim = player:mail_option("manymsgs")) && ((lim <= seq_size) && (!$command_utils:yes_or_no(tostr("You are about to see ", seq_size, " message headers.  Continue?")))))
player:notify(tostr("Aborted.  @mailoption manymsgs=", lim));
return;
endif
if (1 != seq_size)
player:notify(tostr(seq_size, " messages", (folder == this) ? "" | (" on " + $mail_agent:name(folder)), ":"));
endif
folder:display_seq_headers(msg_seq, @p[3]);
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@read @peek any ?-2? any
"@read <msg>...                  -- as in help @read";
"@read <msg>... on *<recipient>  -- reads messages on recipient.";
"@peek ...                       -- like @read, but don't set current message";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (p = this:parse_mailread_cmd("@read", args, "", "on"))
this:set_current_folder(folder = p[1]);
msg_seq = p[2];
if ((lim = player:mail_option("manymsgs")) && ((lim <= (seq_size = $seq_utils:size(msg_seq))) && (!$command_utils:yes_or_no(tostr("You are about to see ", seq_size, " messages.  Continue?")))))
player:notify(tostr("Aborted.  @mailoption manymsgs=", lim));
return;
endif
this._mail_task = task_id();
if (cur = folder:display_seq_full(msg_seq, tostr("Message %d", (folder == this) ? "" | (" on " + $mail_agent:name(folder)), ":")))
if (verb != "@peek")
this:set_current_message(folder, @cur);
endif
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@next @prev any ?-2? any
set_task_perms(player.owner);
if (dobjstr && (!(n = toint(dobjstr))))
player:notify(tostr("Usage:  ", verb, " [<number>] [on <recipient>]"));
elseif (dobjstr)
this:("@read")(tostr(verb[2..5], n), @listdelete(args, 1));
else
this:("@read")(verb[2..5], @args);
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@rmm*ail any ?-2? any
"@rmm <message-sequence> [from <recipient>].   Use @unrmm if you screw up.";
" Beware, though.  @unrmm can only undo the most recent @rmm.";
set_task_perms(player);
if (!(p = this:parse_mailread_cmd("@rmm", args, "cur", "from")))
"...parse failed, we've already complained...";
elseif ((!prepstr) && ((p[1] != this) && (!$command_utils:yes_or_no(("@rmmail from " + $mail_agent:name(p[1])) + ".  Continue?"))))
"...wasn't the folder player was expecting...";
player:notify("@rmmail aborted.");
else
this:set_current_folder(folder = p[1]);
e = folder:rm_message_seq(p[2]);
if (typeof(e) == ERR)
player:notify(tostr($mail_agent:name(folder), ":  ", e));
else
count = ((n = $seq_utils:size(p[2])) == 1) ? "." | tostr(" (", n, " messages).");
fname = (folder == this) ? "" | (" from " + $mail_agent:name(folder));
player:notify(tostr("Deleted ", e, fname, count));
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@renumber any n/a none
set_task_perms(player);
if (!dobjstr)
folder = this:current_folder();
elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(dobjstr), dobjstr))
return;
endif
cur = this:current_message(folder);
fname = $mail_agent:name(folder);
if (typeof(h = folder:renumber(cur)) == ERR)
player:notify(tostr(h));
else
if (!h[1])
player:notify(tostr("No messages on ", fname, "."));
else
player:notify(tostr("Messages on ", fname, " renumbered 1-", h[1], "."));
this:set_current_folder(folder);
if (h[2] && this:set_current_message(folder, h[2]))
player:notify(tostr("Current message is now ", h[2], "."));
endif
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@unrmm*ail any ?-2? any
"@unrmm [on <recipient>]  -- undoes the previous @rmm on that recipient.";
set_task_perms(player);
if (!(p = this:parse_folder_spec("@unrmm", args, "on")))
return;
endif
dobjstr = $string_utils:from_list(p[2], " ");
keep = 0;
if ((!dobjstr) || (keep = index("keep", dobjstr) == 1))
do = "undo_rmm";
elseif (index("expunge", dobjstr) == 1)
do = "expunge_rmm";
elseif (index("list", dobjstr) == 1)
do = "list_rmm";
else
player:notify(tostr("Usage:  ", verb, " [expunge|list] [on <recipient>]"));
return;
endif
this:set_current_folder(folder = p[1]);
if (msg_seq = folder:(do)(@keep ? {keep} | {}))
if (do == "undo_rmm")
player:notify(tostr($seq_utils:size(msg_seq), " messages restored to ", $mail_agent:name(folder), "."));
folder:display_seq_headers(msg_seq, 0);
else
player:notify(tostr(msg_seq, " zombie message", (msg_seq == 1) ? " " | "s ", (do == "expunge_rmm") ? "expunged from " | "on ", $mail_agent:name(folder), "."));
endif
elseif (typeof(msg_seq) == ERR)
player:notify(tostr($mail_agent:name(folder), ":  ", msg_seq));
else
player:notify(tostr("No messages to ", (do == "expunge_rmm") ? "expunge from " | "restore to ", $mail_agent:name(folder)));
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@send any ?-2? any
if (args && (args[1] == "to"))
args = listdelete(args, 1);
endif
subject = {};
for a in (args)
if (((i = index(a, "=")) > 3) && (index("subject", a[1..i - 1]) == 1))
args = setremove(args, a);
a[1..i] = "";
subject = {a};
endif
endfor
$mail_editor:invoke(args, verb, @subject);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@answer @repl*y any ?-2? any
"@answer <msg> [on *<recipient>] [<flags>...]";
set_task_perms(who = valid(caller_perms()) ? caller_perms() | player);
if (p = this:parse_mailread_cmd(verb, args, "cur", "on", 1))
if ($seq_utils:size(p[2]) != 1)
player:notify("You can only answer *one* message at a time.");
elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags(@p[4])))
player:notify_lines({tostr("Usage:  ", verb, " [message-# [on <recipient>]] [flags...]"), "where flags include any of:", "  all        reply to everyone", "  sender     reply to sender only", "  include    include the original message in your reply", "  noinclude  don't include the original in your reply"});
else
this:set_current_folder(p[1]);
$mail_editor:invoke(2, verb, p[1]:messages_in_seq(p[2])[1][2], @flags_replytos);
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@forward any ?-2? any
"@forward <msg> [on *<recipient>] to <recipient> [<recipient>...]";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (!(p = this:parse_mailread_cmd(verb, args, "", "on", 1)))
"...lose...";
return;
elseif ($seq_utils:size(sequence = p[2]) != 1)
player:notify("You can only forward *one* message at a time.");
return;
elseif ((length(p[4]) < 2) || (p[4][1] != "to"))
player:notify(tostr("Usage:  ", verb, " [<message>] [on <folder>] to <recip>..."));
return;
endif
recips = {};
for rs in (listdelete(p[4], 1))
if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))
return;
endif
recips = {@recips, r};
endfor
this:set_current_folder(folder = p[1]);
m = folder:messages_in_seq(sequence)[1];
msgnum = m[1];
msgtxt = m[2];
from = msgtxt[2];
if (msgtxt[4] != " ")
subject = tostr("[", from, ":  ", msgtxt[4], "]");
elseif ((h = "" in msgtxt) && (h < length(msgtxt)))
subject = tostr("[", from, ":  `", msgtxt[h + 1][1..min(20, $)], "']");
else
subject = tostr("[", from, "]");
endif
result = $mail_agent:send_message(player, recips, subject, $mail_agent:to_text(@msgtxt));
if (!result)
player:notify(tostr(result));
elseif (result[1])
player:notify(tostr("Message ", msgnum, @(folder == this) ? {} | {" on ", $mail_agent:name(folder)}, " @forwarded to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not sent.");
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@gripe any ?-2? any
$mail_editor:invoke($gripe_recipients, "@gripe", "@gripe: " + argstr);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@typo @bug @suggest*ion @idea @comment any ?-2? any
subject = tostr($string_utils:capitalize(verb[2..$]), ":  ", (loc = this.location).name, "(", loc, ")");
if (this != player)
return E_PERM;
elseif (argstr)
result = $mail_agent:send_message(this, {loc.owner}, subject, argstr);
if (result && result[1])
player:notify(tostr("Your ", verb, " sent to ", $mail_agent:name_list(@listdelete(result, 1)), ".  Input is appreciated, as always."));
else
player:notify(tostr("Huh?  This room's owner (", loc.owner, ") is invalid?  Tell a wizard..."));
endif
return;
elseif (!($object_utils:isa(loc, $room) && loc.free_entry))
player:notify_lines({tostr("You need to make it a one-liner, i.e., `", verb, " something or other'."), "This room may not let you back in if you go to the Mail Room."});
elseif ($object_utils:isa(loc, $generic_editor))
player:notify_lines({tostr("You need to make it a one-liner, i.e., `", verb, " something or other'."), "Sending you to the Mail Room from an editor is usually a bad idea."});
else
$mail_editor:invoke({tostr(loc.owner)}, verb, subject);
endif
if (verb == "@bug")
player:notify("For a @bug report, be sure to mention exactly what it was you typed to trigger the error...");
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@skip any ?-2? any
"@skip [*<folder/mailing_list>...]";
"  sets your last-read time for the given lists to now, indicating your";
"  disinterest in any new messages that might have appeared recently.";
set_task_perms(player);
current_folder = this:current_folder();
for a in (args || {0})
if (a ? $mail_agent:match_failed(folder = $mail_agent:match_recipient(a), a) | (folder = this:current_folder()))
"...bogus folder name, done...  No, try anyway.";
if (this:kill_current_message(this:my_match_object(a)))
player:notify("Invalid folder, but found it subscribed anyway.  Removed.");
endif
else
lseq = folder:length_all_msgs();
unread = (n = this:get_current_message(folder)) ? folder:length_date_gt(n[2]) | lseq;
this:set_current_message(folder, lseq && folder:messages_in_seq({lseq, lseq + 1})[1][1], time());
player:notify(tostr(unread ? tostr("Ignoring ", unread) | "No", " unread message", (unread != 1) ? "s" | "", " on ", $mail_agent:name(folder)));
if (current_folder == folder)
this:set_current_folder(this);
endif
endif
endfor
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@subscribe*-quick @unsubscribed*-quick any ?-2? any
"@subscribe *<folder/mailing_list> [with notification] [before|after *<folder>]";
"  causes you to be notified when new mail arrives on this list";
"@subscribe";
"  just lists available mailing lists.";
"@unsubscribed";
"  prints out available mailing lists you aren't already subscribed to.";
"@subscribe-quick and @unsubscribed-quick";
"  prints out same as above except without mail list descriptions, just names.";
set_task_perms(player);
quick = 0;
if (qi = index(verb, "-q"))
verb = verb[1..qi - 1];
quick = 1;
endif
fname = {@args, 0}[1];
if (!fname)
ml = $list_utils:slice(this.current_message[3..$]);
all_mlists = {@$mail_agent.contents, @this.mail_lists};
if ((length(all_mlists) > 50) && (!$command_utils:yes_or_no(tostr("There are ", length(all_mlists), " mailing lists.  Are you sure you want the whole list?"))))
return player:tell("OK, aborting.");
endif
for c in (all_mlists)
$command_utils:suspend_if_needed(0);
if ((c:is_usable_by(this) || c:is_readable_by(this)) && ((verb != "@unsubscribed") || (!(c in ml))))
c:look_self(quick);
endif
endfor
player:notify(tostr("-------- end of ", verb, " -------"));
return;
elseif (verb == "@unsubscribed")
player:notify("@unsubscribed does not take arguments.");
return;
elseif ($mail_agent:match_failed(folder = $mail_agent:match_recipient(fname), fname))
return;
elseif (folder == this)
player:notify("You don't need to @subscribe to yourself");
return;
elseif ($object_utils:isa(folder, $mail_recipient) ? !folder:is_readable_by(this) | (!$perm_utils:controls(this, folder)))
player:notify("That mailing list is not readable by you.");
return;
endif
notification = this in folder.mail_notify;
i = 0;
beforeafter = 0;
while (length(args) >= 2)
if (length(args) < 3)
player:notify(args[2] + " what?");
return;
elseif (args[2] in {"with", "without"})
with = args[2] == "with";
if (index("notification", args[3]) != 1)
player:notify(tostr("with ", args[3], "?"));
return;
elseif (!$object_utils:isa(folder, $mail_recipient))
player:notify(tostr("You cannot use ", verb, " to change mail notification from a non-$mail_recipient."));
elseif ((!with) == (!notification))
"... nothing to do...";
elseif (with)
if (this in folder:add_notify(this))
notification = 1;
else
player:notify("This mail recipient does not allow immediate notification.");
endif
else
folder:delete_notify(this);
notification = 0;
endif
elseif (args[2] in {"before", "after"})
if (beforeafter)
player:notify((args[2] == beforeafter) ? tostr("two `", beforeafter, "'s?") | "Only use one of `before' or `after'");
return;
elseif ($mail_agent:match_failed(other = $mail_agent:match_recipient(args[3]), args[3]))
return;
elseif (other == this)
i = 2;
elseif (!(i = $list_utils:iassoc(other, this.current_message)))
player:notify(tostr("You aren't subscribed to ", $mail_agent:name(other), "."));
return;
endif
beforeafter = args[2];
i = i - (beforeafter == "before");
if (this:mail_option("rn_order") != "fixed")
player:notify("Warning:  Do `@mail-option rn_order=fixed' if you do not want your @rn listing reordered when you next login.");
endif
endif
args[2..3] = {};
endwhile
this:make_current_message(folder, @i ? {i} | {});
len = folder:length_all_msgs();
player:notify(tostr($mail_agent:name(folder), " has ", len, " message", (len == 1) ? "" | "s", ".", notification ? "  You will be notified immediately when new messages are posted." | "  Notification of new messages will be printed when you connect."));
this:set_current_folder(folder);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:mail_catch_up this n/a this
set_task_perms((caller == this) ? this.owner | caller_perms());
this:set_current_folder(this);
dates = new_cm = head = {};
sort = this:mail_option("rn_order") || "read";
for n in (this.current_message)
$command_utils:suspend_if_needed(0);
if (typeof(n) != LIST)
head = {@head, n};
elseif ($object_utils:isa(folder = n[1], $mail_recipient) && folder:is_readable_by(this))
"...set current msg to be the last one you could possibly have read.";
if (n[3] < folder.last_msg_date)
i = folder:length_date_le(n[3]);
n[2] = i && folder:messages_in_seq(i)[1];
endif
if (sort == "fixed")
new_cm = {n, @new_cm};
elseif (sort == "send")
j = $list_utils:find_insert(dates, folder.last_msg_date - 1);
dates = listinsert(dates, folder.last_msg_date, j);
new_cm = listinsert(new_cm, n, j);
else
new_cm = listappend(new_cm, n, $list_utils:iassoc_sorted(n[3] - 1, new_cm, 3));
endif
endif
endfor
this.current_message = {@head, @$list_utils:reverse(new_cm)};
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@rn check_mail_lists @subscribed @rn-full none n/a none
set_task_perms((caller == this) ? this.owner | caller_perms());
which = {};
cm = this.current_message;
cm[1..2] = ((verb == "@rn") || (verb == "@rn-full")) ? {{this, @cm[1..2]}} | {};
all = verb == "@subscribed";
fast = this:mail_option("fast_check") && (verb != "@rn-full");
for n in (cm)
rcpt = n[1];
if (rcpt == $news)
"... $news is handled separately ...";
elseif ($mail_agent:is_recipient(rcpt))
if (fast)
if (rcpt == this)
nmsgs = ((m = this.messages) && (m[length(m)][2][1] > n[3])) ? $maxint | 0;
else
try
nmsgs = (n[1].last_msg_date > n[3]) ? $maxint | 0;
except (E_PERM, E_PROPNF)
player:notify(tostr("Bogus recipient ", rcpt, " removed from .current_message."));
this.current_message = setremove(this.current_message, n);
nmsgs = 0;
endtry
endif
else
nmsgs = n[1]:length_date_gt(n[3]);
endif
if (nmsgs || all)
which = {@which, {n[1], nmsgs}};
endif
else
player:notify(tostr("Bogus recipient ", rcpt, " removed from .current_message."));
this.current_message = setremove(this.current_message, n);
endif
$command_utils:suspend_if_needed(0);
endfor
if (which)
player:notify(tostr((verb == "@subscribed") ? "You are subscribed to the following" | "There is new activity on the following", (length(which) > 1) ? " lists:" | " list:"));
for w in (which)
name = (w[1] == this) ? " me" | $mail_agent:name(w[1]);
player:notify(tostr($string_utils:left("    " + name, 40), " ", (w[2] == $maxint) ? "has" | w[2], " new message", (w[2] == 1) ? "" | "s"));
$command_utils:suspend_if_needed(0);
endfor
if (verb != "check_mail_lists")
player:notify("-- End of listing");
endif
elseif ((verb == "@rn") || (verb == "@rn-full"))
player:notify("No new activity on any of your lists.");
elseif (verb == "@subscribed")
player:notify("You aren't subscribed to any mailing lists.");
endif
return which;
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:mail_option this n/a this
":mail_option(name)";
"Returns the value of the specified mail option";
if ((caller in {this, $mail_editor, $mail_agent}) || $perm_utils:controls(caller_perms(), this))
return $mail_options:get(this.mail_options, args[1]);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@unsub*scribe any ?-2? any
"@unsubscribe [*<folder/mailing_list> ...]";
"entirely removes the record of your current message for the named folders,";
"indicating your disinterest in anything that might appear there in the future.";
set_task_perms(player);
unsubscribed = {};
current_folder = this:current_folder();
for a in (args || {0})
if (a != 0)
folder = $mail_agent:match_recipient(a);
if (folder == $failed_match)
folder = this:my_match_object(a);
endif
else
folder = current_folder;
endif
if (!valid(folder))
"...bogus folder name...  try removing it anyway.";
if (this:kill_current_message(folder))
player:notify("Invalid folder, but found it subscribed anyway.  Removed.");
else
$mail_agent:match_failed(folder, a);
endif
elseif (folder == this)
player:notify(tostr("You can't ", verb, " yourself."));
else
if (!this:kill_current_message(folder))
player:notify(tostr("You weren't subscribed to ", $mail_agent:name(folder)));
if ($object_utils:isa(folder, $mail_recipient))
result = folder:delete_notify(this);
if ((typeof(result) == LIST) && (result[1] == this))
player:notify("Removed you from the mail notifications list.");
endif
endif
else
unsubscribed = {@unsubscribed, folder};
if ($object_utils:isa(folder, $mail_recipient))
folder:delete_notify(this);
endif
endif
endif
endfor
if (unsubscribed)
player:notify(tostr("Forgetting about ", $string_utils:english_list($list_utils:map_arg($mail_agent, "name", unsubscribed))));
if (current_folder in unsubscribed)
this:set_current_folder(this);
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:send_self_netmail this n/a this
":send_self_netmail(msg [ ,from ])";
"return 0 if successful, otherwise error.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (error = $network:invalid_email_address($wiz_utils:get_email_address(this)))
return "Invalid email address: " + error;
else
msg = args[1];
if (length(args) > 1)
from = args[2];
this:notify(tostr("Receiving mail from ", from:title(), " (", from, ") and forwarding it to your .email_address."));
endif
oplayer = player;
player = this;
error = $network:sendmail($wiz_utils:get_email_address(this), @msg);
if (error && (length(args) > 1))
this:notify(tostr("Mail sending failed: ", error));
endif
player = oplayer;
return error;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@netforw*ard any ?-2? any
"@netforward <msg>...                  -- as in help on @netforward";
"@netforward <msg>... on *<recipient>  -- netforwards messages on recipient.";
"This command forwards mail-messages to your registered email-address.";
if (player != this)
return player:tell(E_PERM);
endif
if (reason = $network:email_will_fail(email = $wiz_utils:get_email_address(player)))
return player:notify(tostr("Cannot forward mail to your email address: ", reason));
endif
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (p = player:parse_mailread_cmd(verb, args, "", "on"))
player:set_current_folder(folder = p[1]);
msg_seq = p[2];
folderstr = (folder == player) ? "" | tostr(" from ", $mail_agent:name(folder));
if ((!this:mail_option("expert_netfwd")) && (!$command_utils:yes_or_no(tostr("You are about to forward ", seq_size = $seq_utils:size(msg_seq), " message(s)", folderstr, " to your registered email-address, ", email, ".  Continue?"))))
player:notify(tostr("@Netforward cancelled."));
return;
endif
player:notify("Attempting to send network mail...");
player._mail_task = task_id();
multiple_vals = this:format_for_netforward(folder:messages_in_seq(msg_seq), folderstr);
netmail = multiple_vals[1];
header = multiple_vals[2];
reason = player:send_self_netmail({header, @netmail});
player:notify((reason == 0) ? tostr("@netforward of ", header, " completed.") | tostr("@netforward failed: ", reason, "."));
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@@sendmail any ?-2? any
"Syntax: @@sendmail";
"This is intended for use with client editors.  You probably don't want to try using this command manually.";
"Reads a formatted mail message, extracts recipients, subject line and/or reply-to header and sends message without going to the mailroom.  Example:";
"";
"@@send";
"To: Rog (#4292)";
"Subject: random";
"";
"first line";
"second line";
".";
"";
"Currently, header lines must have the same format as in an actual message.";
set_task_perms(player);
if (args)
player:notify(tostr("The ", verb, " command takes no arguments."));
$command_utils:read_lines();
return;
elseif (this != player)
player:notify(tostr("You can't use ", this.pp, " ", verb, " verb."));
$command_utils:read_lines();
return;
endif
msg = $command_utils:read_lines();
end_head = ("" in msg) || (length(msg) + 1);
from = this;
subject = "";
replyto = "";
rcpts = {};
body = msg[end_head + 1..$];
for i in [1..end_head - 1]
line = msg[i];
if (index(line, "Subject:") == 1)
subject = $string_utils:trim(line[9..$]);
elseif (index(line, "To:") == 1)
if (!(rcpts = $mail_agent:parse_address_field(line)))
player:notify("No recipients found in To: line");
return;
endif
elseif (index(line, "Reply-to:") == 1)
if ((!(replyto = $mail_agent:parse_address_field(line))) && $string_utils:trim(line[10..$]))
player:notify("No address found in Reply-to: line");
return;
endif
elseif (index(line, "From:") == 1)
"... :send_message() bombs if designated sender != player ...";
if (!(from = $mail_agent:parse_address_field(line)))
player:notify("No sender found in From: line");
return;
elseif (length(from) > 1)
player:notify("Multiple senders?");
return;
endif
from = from[1];
elseif (i = index(line, ":"))
player:notify(tostr("Unknown header \"", line[1..i], "\""));
return;
else
player:notify("Blank line must separate headers from body.");
return;
endif
endfor
if (!rcpts)
player:notify("No To: line found.");
elseif (!(subject || body))
player:notify("Blank message not sent.");
else
player:notify("Sending...");
result = $mail_agent:send_message(from, rcpts, replyto ? {subject, replyto} | subject, body);
if (e = result && result[1])
if (length(result) == 1)
player:notify("Mail actually went to no one.");
else
player:notify(tostr("Mail actually went to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
endif
else
player:notify(tostr((typeof(e) == ERR) ? e | ("Bogus recipients:  " + $string_utils:from_list(result[2]))));
player:notify("Mail not sent.");
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@keep-m*ail @keepm*ail any ?-2? any
"@keep-mail [<msg-sequence>|none] [on <recipient>]";
"marks the indicated messages as `kept'.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
if (!args)
return player:notify("Usage:  @keep-mail [<msg-sequence>|none] [on <recipient>]");
elseif (args[1] == "none")
args[1..1] = {};
if (!(pfs = this:parse_folder_spec(verb, args, "on", 0)))
return;
elseif (pfs[2])
player:notify(tostr(verb, " <message-sequence> or `none', but not both."));
return;
endif
this:set_current_folder(folder = pfs[1]);
if (e = folder:keep_message_seq({}))
player:notify(tostr("Messages on ", $mail_agent:name(folder), " are no longer marked as kept."));
else
player:notify(tostr(e));
endif
return;
elseif (p = this:parse_mailread_cmd(verb, args, "", "on"))
if ((folder = p[1]) != this)
"... maybe I'll take this clause out some day...";
player:notify(tostr(verb, " can only be used on your own mail collection."));
return;
endif
this:set_current_folder(folder);
if (e = folder:keep_message_seq(msg_seq = p[2]))
player:notify(tostr("Message", match(e, "[.,]") ? "s " | " ", e, " now marked as kept."));
elseif (typeof(e) == ERR)
player:notify(tostr(e));
else
player:notify(tostr(((seq_size = $seq_utils:size(msg_seq)) == 1) ? "That message is" | "Those messages are", " already marked as kept."));
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:my_match_recipient this n/a this
":my_match_recipient(string) => matches string against player's private mailing lists.";
if (!(string = args[1]))
return $nothing;
elseif (string[1] == "*")
string = string[2..$];
endif
return $string_utils:match(string, this.mail_lists, "aliases");
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:expire_old_messages this n/a this
set_task_perms(caller_perms());
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
else
seq = this:expirable_msg_seq();
if (seq)
this:rm_message_seq(seq);
return this:expunge_rmm();
else
return 0;
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:msg_full_text this n/a this
":msg_full_text(@msg) => list of strings.";
"msg is a mail message (in the usual transmission format).";
"display_seq_full calls this to obtain the actual list of strings to display.";
return player:msg_text(@args);
"default is to leave it up to the player how s/he wants it to be displayed.";
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@resend any ?-2? any
"@resend <msg> [on *<recipient>] to <recipient> [<recipient>...]";
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
"...";
"... parse command...";
"...";
if (!(p = this:parse_mailread_cmd(verb, args, "", "on", 1)))
"...lose...";
return;
elseif ($seq_utils:size(sequence = p[2]) != 1)
player:notify("You can only resend *one* message at a time.");
return;
elseif ((length(p[4]) < 2) || (p[4][1] != "to"))
player:notify(tostr("Usage:  ", verb, " [<message>] [on <folder>] to <recip>..."));
return;
endif
recips = {};
for rs in (listdelete(p[4], 1))
if ($mail_agent:match_failed(r = $mail_agent:match_recipient(rs), rs))
return;
endif
recips = {@recips, r};
endfor
this:set_current_folder(folder = p[1]);
"...";
"... retrieve original message...";
"...";
{msgnum, msgtxt} = folder:messages_in_seq(sequence)[1];
if (forward_style = this:mail_option("resend_forw"))
"...message will be from player...";
pmh = $mail_agent:parse_misc_headers(msgtxt, "Reply-To", "Original-Date", "Original-From");
orig_from = pmh[3][3] || msgtxt[2];
else
"...message will be from author...";
pmh = $mail_agent:parse_misc_headers(msgtxt, "Reply-To", "Original-Date", "Original-From", "Resent-By", "Resent-To");
orig_from = pmh[3][3];
from = $mail_agent:parse_address_field(msgtxt[2])[1];
to = $mail_agent:parse_address_field(msgtxt[3]);
endif
"...";
"... report bogus headers...";
"...";
if (bogus = pmh[2])
player:notify("Bogus headers stripped from original message:");
for b in (bogus)
player:notify("  " + b);
endfor
if (!$command_utils:yes_or_no("Continue?"))
player:notify("Message not resent.");
return;
endif
endif
"...";
"... subject, replyto, original-date, original-from ...";
"...";
hdrs = {msgtxt[4], pmh[3][1], {"Original-Date", pmh[3][2] || ctime(msgtxt[1])}, @orig_from ? {{"Original-From", orig_from}} | {}, @pmh[1]};
"...";
"... send it ...";
"...";
if (forward_style)
result = $mail_agent:send_message(player, recips, hdrs, pmh[4]);
else
"... resend inserts resent-to and resent-by...";
result = $mail_agent:resend_message(player, recips, from, to, hdrs, pmh[4]);
endif
"...";
"... report outcome...";
"...";
if (!result)
player:notify(tostr(result));
elseif (result[1])
player:notify(tostr("Message ", msgnum, @(folder == this) ? {} | {" on ", $mail_agent:name(folder)}, " @resent to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not resent.");
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:expirable_msg_seq this n/a this
"Return a sequence indicating the expirable messages for this player.";
set_task_perms(caller_perms());
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (!(curmsg = this:get_current_message(this)))
"No messages!  Don't even try.";
return {};
elseif (0 >= (period = this:mail_option("expire") || $mail_agent.player_expire_time))
"...no expiration allowed here...";
return {};
else
return $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(min(time() - period, curmsg[2] - 86400)));
"... the 86400 is pure fudge...";
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:format_for_netforward this n/a this
"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}";
set_task_perms(caller_perms());
{message_seq, folderstr} = args;
netmail = {};
linelen = this:linelen();
maxmsg = minmsg = 0;
for msg in (message_seq)
minmsg = minmsg ? min(msg[1], minmsg) | msg[1];
maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];
lines = {tostr("Message ", msg[1], folderstr, ":"), tostr("Date:     ", ctime(msg[2][1])), "From:     " + msg[2][2], "To:       " + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {"Subject:  " + subj} | {}};
for line in (msg[2][5..$])
if (typeof(line) != STR)
"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.";
line = tostr(line);
endif
lines = {@lines, @$generic_editor:fill_string(line, linelen)};
$command_utils:suspend_if_needed(0);
endfor
netmail = {@netmail, @lines, "", "--------------------------", "", ""};
endfor
header = tostr($network.MOO_name, " Message(s) ", minmsg, @(minmsg != maxmsg) ? {" - ", maxmsg} | {}, folderstr);
return {netmail, header};
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:format_for_netforward_debug this n/a this
"Takes a message sequence (the actual messages, not just the sequence describing it) and grovels over it filling text etc.  Returns a two valued list: {formatted message, header for same}";
set_task_perms(caller_perms());
{message_seq, folderstr} = args;
netmail = {};
linelen = this:linelen();
maxmsg = minmsg = 0;
for msg in (message_seq)
minmsg = minmsg ? min(msg[1], minmsg) | msg[1];
maxmsg = maxmsg ? max(msg[1], maxmsg) | msg[1];
lines = {tostr("Message ", msg[1], folderstr, ":"), tostr("Date:     ", ctime(msg[2][1])), "From:     " + msg[2][2], "To:       " + msg[2][3], @(length(subj = msg[2][4]) > 1) ? {"Subject:  " + subj} | {}};
for line in (msg[2][5..$])
if (typeof(line) != STR)
"I don't know how this can happen, but apparently non-strings can end up in the mail message.  So, cope.";
line = tostr(line);
endif
lines = {@lines, @$generic_editor:fill_string(line, linelen)};
$command_utils:suspend_if_needed(0);
endfor
netmail = {@netmail, @lines, "", "--------------------------", "", ""};
endfor
header = tostr($network.MOO_name, " Message(s) ", minmsg, @(minmsg != maxmsg) ? {" - ", maxmsg} | {}, folderstr);
return {netmail, header};
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@nn none n/a none
"@nn  -- reads the first new message on the first mail_recipient (in .current_message) where new mail exists.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
cm = this.current_message;
cm[1..2] = {{this, @cm[1..2]}};
for n in (cm)
if ($mail_agent:is_recipient(n[1]))
if (new = n[1]:length_date_gt(n[3]))
next = (n[1]:length_all_msgs() - new) + 1;
this:set_current_folder(folder = n[1]);
this._mail_task = task_id();
cur = folder:display_seq_full({next, next + 1}, tostr("Message %d", " on ", $mail_agent:name(folder), ":"));
this:set_current_message(folder, @cur);
return;
endif
else
player:notify(tostr("Bogus recipient ", n[1], " removed from .current_message."));
this.current_message = setremove(this.current_message, n);
endif
endfor
player:tell("No News (is good news)");
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@unread any ?-2? any
"@unread <msg> [on *<recipient>]  -- resets last-read-date for recipient to just before the first of the indicated messages.";
set_task_perms(player);
if (p = this:parse_mailread_cmd("@unread", args, "cur", "on"))
this:set_current_folder(folder = p[1]);
msg_ord = $seq_utils:first(msg_seq = p[2]);
msgdate = folder:messages_in_seq(msg_ord)[2][1] - 1;
if ((!(cm = this:get_current_message(folder))) || (cm[2] < msgdate))
player:notify("Already unread.");
else
if (folder == this)
this.current_message[2] = msgdate - 1;
else
"this:kill_current_message(folder);";
this:set_current_message(folder, cm[1], min(cm[2], msgdate), 1);
endif
folder:display_seq_headers({msg_ord, msg_ord + 1}, cm[1], msgdate);
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@refile @copym*ail any ?-2? any
"@refile/@copym*ail <msg-sequence> [on <recipient>] to <recipient>";
"@refile will delete the messages from the source folder.  @copym does not.";
"I'm not happy with this one, yet...";
set_task_perms(player);
if (!(p = this:parse_mailread_cmd("@refile", args, "cur", "on", 1)))
"...lose...";
elseif ((length(p[4]) != 2) || (p[4][1] != "to"))
player:notify(tostr("Usage:  ", verb, " [<message numbers>] [on <folder>] to <folder>"));
elseif ($mail_agent:match_failed(dest = $mail_agent:match_recipient(p[4][2]), p[4][2]))
"...bogus destination folder...";
else
source = p[1];
msg_seq = p[2];
for m in (source:messages_in_seq(msg_seq))
if (!(e = dest:receive_message(m[2], source)))
player:notify(tostr("Copying msg. ", m[1], ":  ", e));
return;
endif
$command_utils:suspend_if_needed(0);
endfor
if (refile = verb == "@refile")
if (typeof(e = source:rm_message_seq(msg_seq)) == ERR)
player:notify(tostr("Deleting from ", source, ":  ", e));
endif
endif
count = tostr(n = $seq_utils:size(msg_seq), " message", (n == 1) ? "" | "s");
fname = (source == this) ? "" | tostr(is_player(source) ? " from " | " from *", source.name, "(", source, ")");
suffix = tostr(is_player(dest) ? " to " | " to *", dest.name, "(", dest, ").");
player:notify(tostr(refile ? "Refiled " | "Copied ", count, fname, suffix));
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@quickr*eply @qreply any ?-2? any
"@qreply <msg> [on *<recipient>] [<flags>...]";
"like @reply only, as in @qsend, we prompt for the message text using ";
"$command_utils:read_lines() rather than invoking the $mail_editor.";
set_task_perms(who = valid(cp = caller_perms()) ? cp | player);
if (!(p = this:parse_mailread_cmd(verb, args, "cur", "on", 1)))
"...garbled...";
elseif ($seq_utils:size(p[2]) != 1)
player:notify("You can only answer *one* message at a time.");
elseif (LIST != typeof(flags_replytos = $mail_editor:check_answer_flags("noinclude", @p[4])))
player:notify_lines({tostr("Usage:  ", verb, " [message-# [on <recipient>]] [flags...]"), "where flags include any of:", "  all        reply to everyone", "  sender     reply to sender only", tostr("  include    include the original message in reply (can't do this for ", verb, ")"), "  noinclude  don't include the original in your reply"});
elseif ("include" in flags_replytos[1])
player:notify(tostr("Can't include message on a ", verb));
else
this:set_current_folder(p[1]);
if (to_subj = $mail_editor:parse_msg_headers(p[1]:messages_in_seq(p[2])[1][2], flags_replytos[1]))
player:notify(tostr("To:       ", $mail_agent:name_list(@to_subj[1])));
if (to_subj[2])
player:notify(tostr("Subject:  ", to_subj[2]));
endif
if (replytos = flags_replytos[2])
player:notify(tostr("Reply-to: ", $mail_agent:name_list(@replytos)));
endif
hdrs = {to_subj[2], replytos || {}};
player:notify("Enter lines of message:");
message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {"@edit"}, {tostr("You are composing mail to ", $mail_agent:name_list(@to_subj[1]), "."), @active ? {} | {"Type `@edit' to take this into the mail editor."}});
if (typeof(message) == ERR)
player:notify(tostr(message));
elseif (message[1] == "@edit")
$mail_editor:invoke(1, verb, to_subj[1], @hdrs, message[2]);
elseif (!message[2])
player:notify("Blank message not sent.");
else
result = $mail_agent:send_message(this, to_subj[1], hdrs, message[2]);
if (result && result[1])
player:notify(tostr("Message sent to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not sent.");
endif
endif
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@mail-all-new*-mail none n/a none
"@mail-all-new-mail";
" Prints headers for all new mail on every mail-recipient mentioned in .current_message.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
cm = this.current_message;
cm[1..2] = {{this, @cm[1..2]}};
this._mail_task = task_id();
nomail = 1;
new_cms = {};
for f in (cm)
if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))
player:notify(tostr(folder, " is neither a $player nor a $mail_recipient"));
elseif (typeof(flen = folder:length_all_msgs()) == ERR)
player:notify(tostr($mail_agent:name(folder), " ", flen));
elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))
nomail = 0;
player:notify("===== " + $string_utils:left(tostr($mail_agent:name(folder), " (", s = $seq_utils:size(msg_seq), " message", (s == 1) ? ") " | "s) "), 40, "="));
folder:display_seq_headers(msg_seq, @f[2..3]);
player:notify("");
$command_utils:suspend_if_needed(2);
endif
endfor
if (nomail)
player:notify("You don't have any new mail anywhere.");
else
player:notify("===== " + $string_utils:left("End of new mail ", 40, "="));
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@read-all-new*-mail @ranm any n/a none
"@read-all-new-mail [yes]";
" Prints all new mail on every mail-recipient mentioned in .current_message";
" Generally this will spam you into next Tuesday.";
" You will be queried for whether you want your last-read dates updated";
"   but you can specify \"yes\" on the command line to suppress this.";
"   If you do so, last-read dates will be updated after each folder read.";
set_task_perms(valid(cp = caller_perms()) ? cp | player);
noconfirm = args && args[1];
if ((noconfirm && (noconfirm != "yes")) && (noconfirm != "no"))
player:notify("Unexpected argument(s): " + argstr);
return;
endif
cm = this.current_message;
cm[1..2] = {{this, @cm[1..2]}};
this._mail_task = task_id();
nomail = 1;
new_cms = {};
for f in (cm)
if (!($object_utils:isa(folder = f[1], $player) || $object_utils:isa(folder, $mail_recipient)))
player:notify(tostr(folder, " is neither a $player nor a $mail_recipient"));
elseif (typeof(flen = folder:length_all_msgs()) == ERR)
player:notify(tostr($mail_agent:name(folder), " ", flen));
elseif (msg_seq = $seq_utils:range(folder:length_date_le(f[3]) + 1, flen))
nomail = 0;
player:notify("===== " + $string_utils:left(tostr($mail_agent:name(folder), " (", s = $seq_utils:size(msg_seq), " message", (s == 1) ? ") " | "s) "), 40, "="));
player:notify("");
if (cur = folder:display_seq_full(msg_seq, tostr("Message %d", (folder == this) ? "" | (" on " + $mail_agent:name(folder)), ":")))
if (noconfirm == "yes")
this:set_current_message(folder, @cur);
this:set_current_folder(folder);
else
new_cms = {@new_cms, {folder, @cur}};
endif
player:notify("");
endif
endif
$command_utils:suspend_if_needed(1);
this._mail_task = task_id();
endfor
if (nomail)
player:notify("You don't have any new mail anywhere.");
elseif (player:notify("===== " + $string_utils:left("End of new mail ", 40, "=")) || (noconfirm ? noconfirm == "yes" | $command_utils:yes_or_no("Did you get all of that?")))
for n in (new_cms)
this:set_current_message(@n);
this:set_current_folder(n[1]);
endfor
player:notify("Last-read-dates updated");
else
player:notify("Last-read-dates not updated");
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@quick*send @qsend any ?-2? any
"Syntax: @quicksend <recipients(s)> [subj=<text>] [<message>]";
"Sends the recipients(s) a quick message, wit{out having to go to the mailroom. If there is more than one recipients, place them all in quotes. If the subj contains spaces, place it in quotes.";
"To put line breaks in the message, use a caret (^).";
"If no message is given, prompt for lines of message.";
"Examples:";
"@quicksend Alice subj=\"Wonderland is neat!\" Have you checked out the Wonderland scenario yet? I think you'd like it!";
"@quicksend \"Ethel Fred\" Have you seen Lucy around?^--Ricky";
set_task_perms($object_utils:isa(player, $guest) ? player.owner | player);
if (!args)
player:notify(tostr("Usage: ", verb, " <recipients(s)> [subj=<text>] [<message>]"));
return E_INVARG;
elseif (this != player)
player:notify(tostr("You can't use ", this.pp, " @quicksend verb."));
return E_PERM;
elseif (!(recipients = $mail_editor:parse_recipients({}, $string_utils:explode(args[1]))))
return;
else
if ((length(args) > 1) && ((eq = index(args[2], "=")) && (index("subject", args[2][1..eq - 1]) == 1)))
subject = $string_utils:trim(args[2][eq + 1..$]);
ws = $string_utils:word_start(argstr);
argstr = argstr[1..ws[1][2]] + argstr[ws[2][2] + 1..$];
args = listdelete(args, 2);
else
subject = "";
endif
if (length(args) > 1)
unbroken = argstr[(argstr[1] == "\"") ? length(args[1]) + 4 | (length(args[1]) + 2)..$] + "^";
message = {};
while (unbroken)
if (i = index(unbroken, "^"))
message = {@message, unbroken[1..i - 1]};
endif
unbroken = unbroken[i + 1..$];
endwhile
else
if (!(subject || player:mail_option("nosubject")))
player:notify("Subject:");
subject = $command_utils:read();
endif
player:notify("Enter lines of message:");
message = $command_utils:read_lines_escape((active = player in $mail_editor.active) ? {} | {"@edit"}, {tostr("You are composing mail to ", $mail_agent:name_list(@recipients), "."), @active ? {} | {"Type `@edit' to take this into the mail editor."}});
if (typeof(message) == ERR)
player:notify(tostr(message));
return;
elseif (message[1] == "@edit")
$mail_editor:invoke(1, verb, recipients, subject, {}, message[2]);
return;
elseif (!(message[2] || subject))
player:notify("Blank message not sent.");
return;
endif
message = message[2];
endif
result = $mail_agent:send_message(this, recipients, subject, message);
if (result && result[1])
player:notify(tostr("Message sent to ", $mail_agent:name_list(@listdelete(result, 1)), "."));
else
player:notify("Message not sent.");
endif
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.mail_options = {};
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:confunc this n/a this
if (((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this))) && (caller != #0))
return E_PERM;
endif
this:check_mail();
this:mail_catch_up();
this:check_mail_lists();
pass(@args);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@add-notify any any any
"Ideally, in order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.";
"Usage:  @add-notify me to player";
"    Sends mail to player saying that I want to be added to their mail notification property.";
"Usage:  @add-notify player to me";
"    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.  (Deletes from temporary record.)";
if (this == dobj)
target = $string_utils:match_player(iobjstr);
if ($command_utils:player_match_failed(target, iobjstr))
return;
elseif (this in target.mail_notify[1])
player:tell("You already receive notifications when ", target.name, " receives mail.");
elseif (this in target.mail_notify[2])
player:tell("You already asked to be notified when ", target.name, " receives mail.");
else
$mail_agent:send_message(player, {target}, "mail notification request", {tostr($string_utils:nn(this), " would like to receive mail notifications when you get mail."), "Please type:", tostr("  @add-notify ", this.name, " to me"), "if you wish to allow this action."});
player:tell("Notifying ", $string_utils:nn(target), " that you would like to be notified when ", target.ps, " receives mail.");
target.mail_notify[2] = setadd(target.mail_notify[2], this);
endif
elseif (this == iobj)
target = $string_utils:match_player(dobjstr);
if ($command_utils:player_match_failed(target, dobjstr))
return;
elseif (target in this.mail_notify[2])
this.mail_notify[1] = setadd(this.mail_notify[1], target);
this.mail_notify[2] = setremove(this.mail_notify[2], target);
player:tell(target.name, " will be notified when you receive mail.");
else
player:tell("It doesn't look like ", target.name, " wants to be notified when you receive mail.");
endif
else
player:tell("Usage:  @add-notify me to player");
player:tell("        @add-notify player to me");
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:mail_notify this n/a this
if ((length(this.mail_notify) > 0) && (typeof(this.mail_notify[1]) == LIST))
return this.mail_notify[1];
else
return this.mail_notify;
endif
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@unsend any in/inside/into any
"USAGE: @unsend [message-sequence] from <player>";
"Attempts to unsend messages you sent to <player>. Per *B:Unsend, messages may not be unsent if they have been read, have been netforwarded to the player (@mail-option +netmail), or if the player has set emself so that mail may not be unsent from em (@mail-option +no_unsend). In addition, mail sent to multiple players may not be unsent unless it can be unsent from each recipient.";
"";
"The following message sequences are the only ones allowed:";
"";
"  before:<date>    - Strictly before the given date.";
"  after:<date>     - Strictly after the given date.";
"  since:<date>     - On or after the given date.";
"  until:<date>     - On or before the given date.";
"  subject:<string> - The subject contains the given string.";
"  body:<string>    - The message body contains the given string.";
"  last:<number>    - The last <number> messages you sent.";
"";
"If you do not specify a sequence, the default sequence stored in @mail-option @unsend will be used.";
base = (dobjstr || this:mail_option(verb)) || $mail_agent.("player_default_@unsend");
if (player != this)
return player:tell(E_PERM);
elseif (typeof(base) == STR)
seq = $string_utils:words(base);
else
seq = base;
endif
who = $string_utils:match_player(iobjstr);
fail_msg = "Message(s) were not removed as expected. As per *B:Unsend, I cannot elaborate on why.";
if ($command_utils:player_match_failed(who, iobjstr))
return;
elseif (typeof(res = $mail_options:parse({verb, @seq})) == STR)
return player:notify(res);
elseif (who:mail_option("no_unsend") || ($object_utils:has_callable_verb(who, "do_unsend") != {$mail_recipient_class}))
"Author's note: I'm not checking for +netmail. The player could have turned it on (or off) later. Netmailed messages are not saved on the player, so they can't be removed, anyway.";
return player:notify(fail_msg);
endif
"The following loop weeds out `last:#' references, which need to be proccessed in a specific way.";
newseq = otherpeople = {};
last = 0;
for x in (seq)
if (`x[1..5] == "last:" ! ANY')
last = toint(x[6..$]);
else
newseq = {@newseq, x};
endif
endfor
seq = {"new", "unkept:", tostr("from:", player), @newseq};
if (last > 0)
seq = {@seq, tostr("last:", last)};
endif
ok = who:parse_message_seq(seq, who:current_message());
if (typeof(ok) != LIST)
return player:notify(fail_msg);
endif
allmsgs = length($seq_utils:tolist(@ok));
count = missed = 0;
for position in ($list_utils:reverse($list_utils:range(allmsgs)))
time = time() + 60;
ok = (position == allmsgs) ? ok | who:parse_message_seq(seq, who:current_message());
if ((typeof(ok) == STR) || (!ok[1]))
break;
elseif (time() > time)
player:notify("Due to a mysterious time delay (probably incredible lag), your @unsend command has been aborted. Try again later.");
count && player:notify(tostr(count, "message", (count == 1) ? "" | "s", " were unsent before the command was aborted."));
return otherpeople && player:notify(tostr("Message(s) were also removed from ", $string_utils:nn(otherpeople), "."));
endif
x = $seq_utils:tolist(@ok)[$ - missed];
ok = {x, x + 1};
whomail = who.messages;
bad = 0;
possible = {};
"Check if a message was sent to multiple people and set them up for @unsend, too.";
if ((recips = $mail_agent:parse_address_field((msg = whomail[x][2])[3])) == {who})
who:do_unsend(ok);
"Leaving the zombie messages kinda defeats the purpose of @unsend. Since use of @unsend removes any old zombie mail, and since I can't find any nice, tidy way to save the old zombie mail, we're just going to delete the new zombie mail outright. Those who don't like this can set emselves +no_unsend.";
who.messages_going = {};
count = count + 1;
((ticks_left() < 5000) || (seconds_left() < 2)) && suspend(1);
continue;
else
if (((ticks_left() / 5000) < length(recips)) || (seconds_left() < 2))
suspend(1);
endif
"This runs on the principle that the same message text will be sent to each person. If their .messages is in a non-standard format, this will probably bomb. Such people should set themselves +no_unsend, anyway.";
for y in (setremove(recips, who))
time = time() + 60;
if (((((!is_player(y)) || y:mail_option("no_unsend")) || ($object_utils:has_callable_verb(y, "do_unsend") != {$mail_recipient_class})) || (typeof(z = y:parse_message_seq({"new", "unkept:"}, y:current_message())) == STR)) || (!z))
bad = 1;
elseif (time() > time)
player:notify("Due to a mysterious time delay (probably incredible lag), your @unsend command has been aborted. Try again later.");
count && player:notify(tostr(count, "message", (count == 1) ? "" | "s", " were unsent before the command was aborted."));
return otherpeople && player:notify(tostr("Message(s) were also removed from ", $string_utils:nn(otherpeople), "."));
else
ymail = y.messages;
numnum = 0;
for post in ($seq_utils:tolist(@z))
if (ymail[post][2] == msg)
numnum = post;
break;
endif
endfor
if (!numnum)
bad = 1;
else
z = {numnum, numnum + 1};
endif
endif
possible = bad ? {} | {@possible, {y, z}};
if (bad)
break;
endif
endfor
endif
if (bad)
missed = missed + 1;
else
for foo in ({{who, ok}, @possible})
{person, sequence} = foo;
person:do_unsend(sequence);
"Leaving the zombie messages kinda defeats the purpose of @unsend. Since use of @unsend removes any old zombie mail, and since I can't find any nice, tidy way to save the old zombie mail, we're just going to delete the new zombie mail outright. Those who don't like this can set emselves +no_unsend.";
person.messages_going = {};
if (person != who)
otherpeople = setadd(otherpeople, person);
endif
endfor
count = count + 1;
endif
endfor
if ((!count) || (count != allmsgs))
player:notify(fail_msg);
endif
count && player:notify(tostr(count, " message", (count == 1) ? "" | "s", " unsent."));
otherpeople && player:notify(tostr("Message(s) were also removed from ", $string_utils:nn(otherpeople), "."));
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:do_unsend this n/a this
":do_unsend(seq) -> Remove the specified messages. Used by @unsend. Cannot be overridden by players or player classes; @unsend won't bother to call the verb.";
if (!caller_perms().wizard)
return E_PERM;
endif
return $mail_agent:rm_message_seq(@args);
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:@annotate*mail any ?-2? any
"@annotate <msg-sequence> [on <recipient>] with \"annotation\"";
"prefix the specified messages with the given annotation.";
set_task_perms(player);
if (!(p = this:parse_mailread_cmd("@annotate", args, "cur", "on", 1)))
"...lose...";
elseif ((length(p[4]) != 2) || (p[4][1] != "with"))
player:notify(tostr("Usage:  ", verb, " [<message numbers>] [on <folder>] with <annotation>"));
else
{target, message_sequence, _, trailing_args} = p;
annotation = trailing_args[2..$];
annotation[1] = tostr("[", player.name, " (", player, "):  ", annotation[1], "]");
if (typeof(e = target:annotate_message_seq(annotation, "prepend", message_sequence)) in {ERR, STR})
player:notify(tostr("Annotation Failed:  ", e));
else
count = $seq_utils:size(message_sequence);
player:notify(tostr("Annotating ", count, " message", (count == 1) ? "" | "s", " on ", $mail_agent:name(target), " with:"));
player:notify_lines(annotation);
endif
endif
"Copied from annotatetest (#87053):@annotate [verb author Puff (#1449)] at Mon Feb 14 14:45:41 2005 PST";
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:annotate_message_seq this n/a this
return "Cannot annotate player messages.";
-------------------------------------------------------------------------------
#40 Generic Mail Receiving Player:check_mail this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
nm = this:length_all_msgs() - this:length_date_le(this:get_current_message()[2]);
if (nm)
this:notify(tostr("You have new mail (", nm, " message", (nm == 1) ? "" | "s", ").", this:mail_option("expert") ? "" | "  Type 'help mail' for info on reading it."));
endif
endif
-------------------------------------------------------------------------------
================================#41 gender utilities===============================================
#41 gender utilities.pp rc = MOOList [ "its", "his", "her", "his/her", "eir", "h*", "their", "my", "our", "your" ]
#41 gender utilities.pq rc = MOOList [ "its", "his", "hers", "his/hers", "eirs", "h*s", "theirs", "mine", "ours", "yours" ]
#41 gender utilities.psc rc = MOOList [ "It", "He", "She", "S/He", "E", "*E", "They", "I", "We", "You" ]
#41 gender utilities.pr rc = MOOList [ "itself", "himself", "herself", "(him/her)self", "emself", "h*self", "themselves", "myself", "ourselves", "yourself" ]
#41 gender utilities.be rc = MOOList [ "is", "is", "is", "is", "is", "is", "are", "am", "are", "are", "are" ]
#41 gender utilities.ps rc = MOOList [ "it", "he", "she", "s/he", "e", "*e", "they", "I", "we", "you" ]
#41 gender utilities.pqc rc = MOOList [ "Its", "His", "Hers", "His/Hers", "Eirs", "H*s", "Theirs", "Mine", "Ours", "Yours" ]
#41 gender utilities.poc rc = MOOList [ "It", "Him", "Her", "Him/Her", "Em", "H*", "Them", "Me", "Us", "You" ]
#41 gender utilities.is_plural rc = MOOList [ 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1 ]
#41 gender utilities.have rc = MOOList [ "has", "has", "has", "has", "has", "has", "have", "have", "have", "have", "have" ]
#41 gender utilities.prc rc = MOOList [ "Itself", "Himself", "Herself", "(Him/Her)self", "Emself", "H*self", "Themselves", "Myself", "Ourselves", "Yourself" ]
#41 gender utilities.ppc rc = MOOList [ "Its", "His", "Her", "His/Her", "Eir", "H*", "Their", "My", "Our", "Your" ]
#41 gender utilities.genders rc = MOOList [ "neuter", "male", "female", "either", "Spivak", "splat", "plural", "egotistical", "royal", "2nd" ]
#41 gender utilities.pronouns rc = MOOList [ "ps", "po", "pp", "pq", "pr", "psc", "poc", "ppc", "pqc", "prc" ]
#41 gender utilities.po rc = MOOList [ "it", "him", "her", "him/her", "em", "h*", "them", "me", "us", "you" ]
#41 gender utilities:set this n/a this
"$gender_utils:set(object,gender) --- sets the pronoun properties of object.";
"gender is a string: one of the strings in $gender_utils.genders, the list of rcognized genders.  If the gender change is successful, the (full) name of the gender (e.g., \"male\") is returned.  E_NONE is returned if gender does not match any recognized gender.  Any other error encountered (e.g., E_PERM, E_PROPNF) is likewise returned and the object's pronoun properties are left unaltered.";
set_task_perms(caller_perms());
{object, gender} = args;
if (this == object)
return E_DIV;
elseif (gnum = $string_utils:find_prefix(gender, this.genders))
gender = this.genders[gnum];
else
return E_NONE;
endif
save = {};
prons = this.pronouns;
for p in (prons)
save = {@save, e = `object.(p) ! ANY'};
if ((typeof(e) != STR) || (typeof(e = `object.(p) = this.(p)[gnum] ! ANY') == ERR))
for i in [1..length(save) - 1]
object.(prons[i]) = save[i];
endfor
return e;
endif
endfor
return gender;
-------------------------------------------------------------------------------
#41 gender utilities:add this n/a this
"$gender_utils:add(object[,perms[,owner]])";
"--- adds pronoun properties to object if they're not already there.";
"    perms default to \"rc\", owner defaults to the object owner.";
set_task_perms(caller_perms());
{object, ?perms = "rc", ?owner = object.owner} = args;
prons = this.pronouns;
e = 1;
for p in (prons)
if (!$object_utils:has_property(object, p))
e = `add_property(object, p, "", {owner, perms}) ! ANY';
if (typeof(e) == ERR)
player:tell("Couldn't add ", object, ".", p, ":  ", e);
return;
endif
elseif ((typeof(object.(p)) != STR) && (typeof(e = `object.(p) = "" ! ANY') == ERR))
player:tell("Couldn't reset ", object, ".", p, ":  ", e);
return;
elseif (!object.(p))
e = 0;
endif
endfor
if ((!e) && (ERR == typeof(e = this:set(object, "neuter"))))
player:tell("Couldn't initialize pronouns:  ", e);
endif
-------------------------------------------------------------------------------
#41 gender utilities:get_pronoun this n/a this
"get_pronoun(key,object) => pronoun corresponding to object.";
"key can be one of s,o,p,q,r,S,O,P,Q,R to refer to the pronoun properties relatively directly or it can be something of the form \"he/she\" or \"He/She\".";
"Next the object is checked for the desired pronoun property.  If that doesn't exist, we look at object.gender and infer the pronoun from the corresponding $gender_utils property.  If .gender doesn't exist or the object itself is invalid, we use the corresponding property on $player.";
{key, ?object = player} = args;
if (key[1] == ":")
key = key[2..$];
endif
if ((length(key) == 1) && (i = index("sopqrSOPQR", key, 1)))
prop = this.pronouns[i];
else
search = "$1:he$s:she$1:he/she$2:him$2:him/her$3:his/her$4:hers$4:his/hers$5:himself$5:herself$5:himself/herself";
i = index(search, (":" + key) + "$");
if (!i)
return "";
endif
cap = strcmp("a", key) > 0;
prop = this.pronouns[toint(search[i - 1]) + (5 * cap)];
endif
if (!valid(object))
return $player.(prop);
elseif (STR == typeof(p = `object.(prop) ! ANY'))
return p;
elseif ((STR == typeof(g = `object.gender ! ANY')) && (i = g in this.genders))
return this.(prop)[i];
else
return $player.(prop);
endif
-------------------------------------------------------------------------------
#41 gender utilities:get_conj*ugation this n/a this
"get_conj(verbspec,object) => verb conjugated according to object.";
"verbspec can be one of \"singular/plural\", \"singular\", \"singular/\", or \"/plural\", e.g., \"is/are\", \"is\", \"is/\", or \"/are\".";
"The object is checked to see whether it is singular or plural.  This is inferred from its .gender property.  If .gender doesn't exist or the object itself is invalid, we assume singular.";
{spec, ?object = player} = args;
i = index(spec + "/", "/");
sing = spec[1..i - 1];
if (i < length(spec))
plur = spec[i + 1..$];
else
plur = "";
endif
cap = strcmp("a", (i == 1) ? spec[2] | spec) > 0;
if (((valid(object) && (STR == typeof(g = `object.gender ! ANY'))) && (i = g in this.genders)) && this.is_plural[i])
vb = plur || this:_verb_plural(sing, i);
else
vb = sing || this:_verb_singular(plur, i);
endif
if (cap)
return $string_utils:capitalize(vb);
else
return vb;
endif
-------------------------------------------------------------------------------
#41 gender utilities:_verb_plural this n/a this
{st, idx} = args;
if (typeof(st) != STR)
return E_INVARG;
endif
len = length(st);
if ((len >= 3) && (rindex(st, "n't") == (len - 2)))
return this:_verb_plural(st[1..len - 3], idx) + "n't";
elseif (i = st in {"has", "is"})
return this.({"have", "be"}[i])[idx];
elseif (st == "was")
return (idx > 6) ? "were" | st;
elseif ((len <= 3) || (st[len] != "s"))
return st;
elseif (st[len - 1] != "e")
return st[1..len - 1];
"elseif ((r = (rindex(st, \"sses\") || rindex(st, \"zzes\"))) && (r == (len - 3)))";
elseif ((r = rindex(st, "zzes")) && (r == (len - 3)))
return st[1..len - 3];
elseif ((((st[len - 2] == "h") && index("cs", st[len - 3])) || index("ox", st[len - 2])) || (st[len - 3..len - 2] == "ss"))
return st[1..len - 2];
"washes => wash, belches => belch, boxes => box";
"used to have || ((st[len - 2] == \"s\") && (!index(\"aeiouy\", st[len - 3])))";
"so that <consonant>ses => <consonant>s";
"known examples: none";
"counterexample: browses => browse";
"update of sorts--put in code to handle passes => pass";
elseif (st[len - 2] == "i")
return st[1..len - 3] + "y";
else
return st[1..len - 1];
endif
-------------------------------------------------------------------------------
#41 gender utilities:_verb_singular this n/a this
{st, ?idx = 1} = args;
if (typeof(st) != STR)
return E_INVARG;
endif
len = length(st);
if ((len >= 3) && (rindex(st, "n't") == (len - 2)))
return this:_verb_singular(st[1..len - 3], idx) + "n't";
elseif (i = st in {"have", "are"})
return this.({"have", "be"}[i])[idx];
elseif ((st[len] == "y") && (!index("aeiou", st[len - 1])))
return st[1..len - 1] + "ies";
elseif (index("sz", st[len]) && index("aeiou", st[len - 1]))
return (st + st[len]) + "es";
elseif (index("osx", st[len]) || ((len > 1) && (index("chsh", st[len - 1..len]) % 2)))
return st + "es";
else
return st + "s";
endif
-------------------------------------------------------------------------------
#41 gender utilities:_do this n/a this
"_do(cap,object,modifiers...)";
{cap, object, modifiers} = args;
if (!modifiers)
if (typeof(object) != OBJ)
return tostr(object);
elseif (!valid(object))
return (cap ? "N" | "n") + "othing";
else
return cap ? object:titlec() | object:title();
endif
elseif (modifiers[1] == ".")
if (i = index(modifiers[2..$], "."))
i = i + 1;
elseif (!(i = (index(modifiers, ":") || index(modifiers, "#")) || index(modifiers, "!")))
i = length(modifiers) + 1;
endif
if (typeof(o = `object.(modifiers[2..i - 1]) ! ANY') == ERR)
return tostr("%(", o, ")");
else
return this:_do(cap || (strcmp("a", modifiers[2]) > 0), o, modifiers[i..$]);
endif
elseif (modifiers[1] == ":")
if (typeof(object) != OBJ)
return tostr("%(", E_TYPE, ")");
elseif (p = this:get_pronoun(modifiers, object))
return p;
else
return tostr("%(", modifiers, "??)");
endif
elseif (modifiers[1] == "#")
return tostr(object);
elseif (modifiers[1] == "!")
return this:get_conj(modifiers[2..$], object);
else
i = (((index(modifiers, ".") || index(modifiers, ":")) || index(modifiers, "#")) || index(modifiers, "!")) || (length(modifiers) + 1);
s = modifiers[1..i - 1];
if (j = s in {"dobj", "iobj", "this"})
return this:_do(cap, {dobj, iobj, callers()[2][1]}[j], modifiers[i..$]);
else
return tostr("%(", s, "??)");
endif
endif
-------------------------------------------------------------------------------
#41 gender utilities:pronoun_sub this n/a this
"Experimental pronoun substitution. The official version is on $string_utils.";
"syntax:  :pronoun_sub(text[,who])";
"experimental version that accomodates Aladdin's style...";
set_task_perms($no_one);
{old, ?who = player} = args;
if (typeof(old) == LIST)
plines = {};
for line in (old)
plines = {@plines, this:pronoun_sub(line, who)};
endfor
return plines;
endif
new = "";
here = valid(who) ? who.location | $nothing;
objspec = "nditl";
objects = {who, dobj, iobj, caller, here};
prnspec = "sopqrSOPQR";
prprops = {"ps", "po", "pp", "pq", "pr", "Ps", "Po", "Pp", "Pq", "Pr"};
oldlen = length(old);
while ((prcnt = index(old, "%")) && (prcnt < oldlen))
cp_args = {};
s = old[k = prcnt + 1];
if (brace = index("([{", s))
if (!(w = index(old[k + 1..oldlen], ")]}"[brace])))
return new + old;
elseif (brace == 3)
s = this:_do(0, who, old[prcnt + 2..(k = k + w) - 1]);
else
p = old[prcnt + 2..(k = k + w) - 1];
if (brace == 1)
cp_args = {who, p};
elseif (p[1] == "#")
s = (o = index(objspec, p[2])) ? tostr(objects[o]) | (("[" + p) + "]");
elseif (!(o = index(objspec, p[1])))
s = ("[" + p) + "]";
else
cp_args = {objects[o], p[2..w - 1], strcmp(p[1], "a") < 0};
endif
endif
elseif (o = index(objspec, s))
cp_args = {objects[o], "", strcmp(s, "a") < 0};
elseif (w = index(prnspec, s, 1))
cp_args = {who, prprops[w]};
elseif (s == "#")
s = tostr(who);
elseif (s != "%")
s = "%" + s;
endif
new = (new + old[1..prcnt - 1]) + ((!cp_args) ? s | ((typeof(sub = $string_utils:_cap_property(@cp_args)) != ERR) ? sub | (("%(" + tostr(sub)) + ")")));
old = old[k + 1..oldlen];
oldlen = oldlen - k;
endwhile
return new + old;
-------------------------------------------------------------------------------
================================#42 permissions utilities===============================================
#42 permissions utilities:controls this n/a this
"$perm_utils:controls(who, what)";
"Is WHO allowed to hack on WHAT?";
{who, what} = args;
return (valid(who) && valid(what)) && (who.wizard || (who == what.owner));
-------------------------------------------------------------------------------
#42 permissions utilities:apply this n/a this
":apply(permstring,mods) => new permstring.";
"permstring is a permissions string, mods is a concatenation of strings of the form +<letters>, !<letters>, or -<letters>, where <letters> is a string of letters as might appear in a permissions string (`+' adds the specified permissions, `-' or `!' removes them; `-' and `!' are entirely equivalent).";
{perms, mods} = args;
if ((!mods) || (!index("!-+", mods[1])))
return mods;
endif
i = 1;
while (i <= length(mods))
if (mods[i] == "+")
while (((i = i + 1) <= length(mods)) && (!index("!-+", mods[i])))
if (!index(perms, mods[i]))
perms = perms + mods[i];
endif
endwhile
else
"mods[i] must be ! or -";
while (((i = i + 1) <= length(mods)) && (!index("!-+", mods[i])))
perms = strsub(perms, mods[i], "");
endwhile
endif
endwhile
return perms;
-------------------------------------------------------------------------------
#42 permissions utilities:caller this n/a this
":caller([include line numbers])";
"  -- returns the first caller in the callers() stack distinct from `this'";
{?lineno = 0} = args;
c = callers(lineno);
{stage, lc, nono} = {1, length(c), {c[1][1], $nothing}};
while (((stage = stage + 1) <= lc) && (c[stage][1] in nono))
endwhile
return c[stage];
-------------------------------------------------------------------------------
#42 permissions utilities:controls_prop*erty controls_verb this n/a this
"Syntax:  controls_prop(OBJ who, OBJ what, STR propname)   => 0 | 1";
"         controls_verb(OBJ who, OBJ what, STR verbname)   => 0 | 1";
"";
"Is WHO allowed to hack on WHAT's PROPNAME? Or VERBNAME?";
{who, what, name} = args;
bi = (verb == "controls_verb") ? "verb_info" | "property_info";
return who.wizard || (who == call_function(bi, what, name)[1]);
-------------------------------------------------------------------------------
================================#43 time utilities===============================================
#43 time utilities.corr rc = MOONumber -122
#43 time utilities.stsd rc = MOONumber 2427
#43 time utilities.monthabbrs rc = MOOList [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
#43 time utilities.months rc = MOOList [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ]
#43 time utilities.zones rc = MOOList [ [ [ "est", "edt", "Massachusetts", "MA" ], 10800 ], [ [ "cst", "cdt" ], 7200 ], [ [ "mst", "mdt" ], 3600 ], [ [ "pst", "pdt", "California", "CA", "Lambda" ], 0 ], [ [ "gmt" ], 28800 ] ]
#43 time utilities.monthlens rc = MOOList [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ]
#43 time utilities.ct rc = MOONumber 7934
#43 time utilities.timezones rc = MOOList [ [ "AuEST", -10 ], [ "AuCST", -9 ], [ "AuWST", -8 ], [ "WET", -1 ], [ "GMT", 0 ], [ "AST", 4 ], [ "EDT", 4 ], [ "EST", 5 ], [ "CDT", 5 ], [ "CST", 6 ], [ "MDT", 6 ], [ "MST", 7 ], [ "PDT", 7 ], [ "PST", 8 ], [ "HST", 10 ] ]
#43 time utilities.time_units rc = MOOList [ [ 31536000, "year", "years", "yr", "yrs" ], [ 2628000, "month", "months", "mo", "mos" ], [ 604800, "week", "weeks", "wk", "wks" ], [ 86400, "day", "days", "dy", "dys" ], [ 3600, "hour", "hours", "hr", "hrs" ], [ 60, "minute", "minutes", "min", "mins" ], [ 1, "second", "seconds", "sec", "secs" ] ]
#43 time utilities.dayabbrs rc = MOOList [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ]
#43 time utilities.days rc = MOOList [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ]
#43 time utilities.ctcd rc = MOONumber 7276
#43 time utilities:day none n/a none
"Given a time() or ctime()-style date, this returns the full name of the day.";
if (typeof(args[1]) == INT)
time = ctime(args[1]);
elseif (typeof(args[1]) == STR)
time = args[1];
else
return E_TYPE;
endif
dayabbr = $string_utils:explode(time)[1];
return this.days[dayabbr in this.dayabbrs];
-------------------------------------------------------------------------------
#43 time utilities:month none n/a none
"Given a time() or ctime()-style date, this returns the full name";
"of the month.";
if (typeof(args[1]) == INT)
time = ctime(args[1]);
elseif (typeof(args[1]) == STR)
time = args[1];
else
return E_TYPE;
endif
monthabbr = $string_utils:explode(time)[2];
return this.months[monthabbr in this.monthabbrs];
-------------------------------------------------------------------------------
#43 time utilities:ampm none n/a none
"Return a time in the form [h]h[:mm[:ss]] {a.m.|p.m.}.  Args are";
"[1]   either a time()- or a ctime()-style date, and";
"[2]   (optional) the precision desired--1 for hours, 2 for minutes,";
"        3 for seconds.  If not given, precision defaults to minutes";
{time, ?precision = 2} = args;
if (typeof(time) == INT)
time = ctime(time);
elseif (typeof(time) != STR)
return E_TYPE;
endif
time = $string_utils:explode(time)[4];
hour = toint(time[1..2]);
if (hour == 0)
time = ("12" + time[3..(precision * 3) - 1]) + " a.m.";
elseif (hour == 12)
time = time[1..(precision * 3) - 1] + " p.m.";
elseif (hour > 12)
time = (tostr(hour - 12) + time[3..(precision * 3) - 1]) + " p.m.";
else
time = (tostr(hour) + time[3..(precision * 3) - 1]) + " a.m.";
endif
return time;
-------------------------------------------------------------------------------
#43 time utilities:to_seconds this n/a this
"Given string hh:mm:ss ($string_utils:explode(ctime(time))[4]), this returns";
"the number of seconds elapsed since 00:00:00.  I can't remember why I";
"created this verb, but I'm sure it serves some useful purpose.";
return (((60 * 60) * toint(args[1][1..2])) + (60 * toint(args[1][4..5]))) + toint(args[1][7..8]);
-------------------------------------------------------------------------------
#43 time utilities:sun this n/a this
{?time = time()} = args;
r = 10000;
h = (r * r) + (r / 2);
t = ((time + 120) % 86400) / 240;
s = (5 * ((time - 14957676) % 31556952)) / 438291;
phi = (s + t) + this.corr;
cs = $trig_utils:cos(s);
spss = ((($trig_utils:sin(phi) * $trig_utils:sin(s)) + h) / r) - r;
cpcs = ((($trig_utils:cos(phi) * cs) + h) / r) - r;
return (((((this.stsd * cs) - (this.ctcd * cpcs)) - (this.ct * spss)) + h) / r) - r;
-------------------------------------------------------------------------------
#43 time utilities:from_ctime this n/a this
"Given a string such as returned by ctime(), return the corresponding time-in-seconds-since-1970 time returned by time(), or E_DIV if the format is wrong in some essential way.";
words = $string_utils:explode(args[1]);
if (length(words) == 5)
"Arrgh!  the old ctime() didn't return a time zone, yet it arbitrarily decides whether it's standard or daylight savings time.  URK!!!!!";
words = listappend(words, "PST");
endif
if ((((length(words) != 6) || (length(hms = $string_utils:explode(words[4], ":")) != 3)) || (!(month = words[2] in this.monthabbrs))) || (!(zone = $list_utils:assoc(words[6], this.timezones))))
return E_DIV;
endif
year = toint(words[5]);
day = ({-1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + toint(words[3])) + (year * 366);
zone = zone[2];
return (((((((((((((day - ((day + 1038) / 1464)) - ((day + 672) / 1464)) - ((day + 306) / 1464)) - ((day + 109740) / 146400)) - ((day + 73140) / 146400)) - ((day + 36540) / 146400)) - 719528) * 24) + toint(hms[1])) + zone) * 60) + toint(hms[2])) * 60) + toint(hms[3]);
-------------------------------------------------------------------------------
#43 time utilities:dhms dayshoursminutesseconds this n/a this
s = args[1];
if (s < 0)
return "-" + this:(verb)(-s);
endif
m = s / 60;
s = s % 60;
if (m)
ss = tostr((s < 10) ? ":0" | ":", s);
h = m / 60;
m = m % 60;
if (h)
ss = tostr((m < 10) ? ":0" | ":", m, ss);
d = h / 24;
h = h % 24;
return tostr(@d ? {d, (h < 10) ? ":0" | ":"} | {}, h, ss);
else
return tostr(m, ss);
endif
else
return tostr(s);
endif
-------------------------------------------------------------------------------
#43 time utilities:english_time this n/a this
"english_time(time [,reference time]): returns the time as a string of";
"years, months, days, hours, minutes and seconds using the reference time as";
"the start time and incrementing forwards. it can be given in either ctime()";
"or time() format. if a reference time is not given, it is set to time().";
{_time, ?reftime = time()} = args;
if (_time < 1)
return "0 seconds";
endif
_ctime = (typeof(reftime) == INT) ? ctime(reftime) | reftime;
seclist = {60, 60, 24};
units = {"year", "month", "day", "hour", "minute", "second"};
timelist = {};
for unit in (seclist)
timelist = {_time % unit, @timelist};
_time = _time / unit;
endfor
months = 0;
month = _ctime[5..7] in $time_utils.monthabbrs;
year = toint(_ctime[21..24]);
"attribution: the algorithm used is from the eminently eminent g7.";
while (_time >= (days = this.monthlens[month] + (((month == 2) && ((year % 4) == 0)) && (!((year % 400) in {100, 200, 300})))))
_time = _time - days;
months = months + 1;
if ((month = month + 1) > 12)
year = year + 1;
month = 1;
endif
$command_utils:suspend_if_needed(0);
endwhile
timelist = {months / 12, months % 12, _time, @timelist};
for unit in (units)
i = unit in units;
if (timelist[i] > 0)
units[i] = ((tostr(timelist[i]) + " ") + units[i]) + ((timelist[i] == 1) ? "" | "s");
else
units = listdelete(units, i);
timelist = listdelete(timelist, i);
endif
endfor
return $string_utils:english_list(units);
-------------------------------------------------------------------------------
#43 time utilities:from_day this n/a this
"from_day(day_of_week,which [,reference time])";
"numeric time (seconds since 1970) corresponding to midnight (PST) of the given weekday.  Use either the name of the day or a 1..7 number (1==Sunday,...)";
"  which==-1 => use most recent such day.";
"  which==+1 => use first upcoming such day.";
"  which==0  => use closest such day.";
"larger (absolute) values for which specify a certain number of weeks into the future or past.";
{day, ?dir = 0, ?reftime = time()} = args;
if (!(toint(day) || (day = $string_utils:find_prefix(day, this.days))))
return E_DIV;
endif
delta = {288000, 374400, 460800, 547200, 28800, 115200, 201600}[toint(day)];
time = reftime - delta;
if (dir)
time = (time / 604800) + ((dir > 0) ? dir | (dir + 1));
else
time = (time + 302400) / 604800;
endif
return (time * 604800) + delta;
-------------------------------------------------------------------------------
#43 time utilities:from_month this n/a this
"from_month(month,which[,d])";
"numeric time (seconds since 1970) corresponding to midnight (PST) of the dth (first) day of the given month.  Use either the month name or a 1..12 number (1==January,...)";
"  which==-1 => use most recent such month.";
"  which==+1 => use first upcoming such month.";
"  which==0  => use closest such month.";
"larger (absolute) values for which specify a certain number of years into the future or past.";
{month, ?dir = 0, ?dth = 1} = args;
if (!(toint(month) || (month = $string_utils:find_prefix(month, this.months))))
return E_DIV;
endif
delta = ({0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}[month] + dth) - 1;
day = (time() - 28800) / 86400;
day = (day - ((day + 672) / 1461)) - delta;
if (dir)
day = ((day / 365) + dir) + (dir <= 0);
else
day = ((2 * day) + 365) / 730;
endif
day = (day * 365) + delta;
day = day + ((day + 671) / 1460);
return (day * 86400) + 28800;
-------------------------------------------------------------------------------
#43 time utilities:dst_midnight this n/a this
"Takes a time that is midnight PST and converts it to the nearest PDT midnight time if it's during that part of the year where we use PDT.";
time = args[1];
return time - (3600 * (((toint(ctime(time)[12..13]) + 12) % 24) - 12));
-------------------------------------------------------------------------------
#43 time utilities:time_sub this n/a this
"Works like pronoun substitution, but substitutes time stuff.";
"Call with time_sub(string, time). returns a string.";
"time is an optional integer in time() format.  If omitted, time() is used.";
"Macros which are unknown are ignored. $Q -> the empty string.";
"Terminal $ are ignored.";
"$H -> hour #. $M -> min #. $S -> second #. 24-hour format, fixed width.";
"$h, $m, $s same x/c have not-fixed format. 00:03:24 vs. 0:3:24";
"$O/$o -> numeric hour in 12-hour format.";
"$D -> long day name. $d -> short day name.";
"$N -> long month name. $n -> short month name.";
"$Y -> long year # (e.g. '1991'). $y -> short year # (e.g. '91')";
"$Z -> the time zone    (added in by r'm later)";
"$P/$p -> AM/PM, or am/pm.";
"$T -> date number. $t -> date number with no extra whitespace etc.";
"$1 -> Month in fixed-width numeric format (01-12)   (added by dpk)";
"$2 -> Month in nonfixed numeric format (1-12)";
"$3 -> Date in fixed-width format, 0-fill";
"$$ -> $.";
"";
"This verb stolen from Ozymandias's #4835:time_subst.";
res = "";
{thestr, ?thetime = time()} = args;
if ((typeof(thestr) != STR) || (typeof(thetime) != INT))
player:tell("Bad arguments to time_subst.");
return;
endif
itslength = length(thestr);
if (!itslength)
return "";
endif
done = 0;
cctime = ctime(thetime);
while (dollar = index(thestr, "$"))
res = res + thestr[1..dollar - 1];
if (dollar == length(thestr))
return res;
endif
thechar = thestr[dollar + 1];
thestr[1..dollar + 1] = "";
if (thechar == "$")
res = res + "$";
elseif (!strcmp(thechar, "h"))
res = res + $string_utils:trim(tostr(toint(cctime[12..13])));
elseif (thechar == "H")
res = res + cctime[12..13];
elseif (!strcmp(thechar, "m"))
res = res + $string_utils:trim(tostr(toint(cctime[15..16])));
elseif (thechar == "M")
res = res + cctime[15..16];
elseif (!strcmp(thechar, "s"))
res = res + $string_utils:trim(tostr(toint(cctime[18..19])));
elseif (thechar == "S")
res = res + cctime[18..19];
elseif (!strcmp(thechar, "D"))
res = res + $time_utils:day(thetime);
elseif (thechar == "d")
res = res + cctime[1..3];
elseif (!strcmp(thechar, "N"))
res = res + $time_utils:month(thetime);
elseif (thechar == "n")
res = res + cctime[5..7];
elseif (!strcmp(thechar, "T"))
res = res + cctime[9..10];
elseif (thechar == "t")
res = res + $string_utils:trim(cctime[9..10]);
elseif (!strcmp(thechar, "o"))
res = tostr(res, ((toint(cctime[12..13]) + 11) % 12) + 1);
elseif (thechar == "O")
res = res + $string_utils:right(tostr(((toint(cctime[12..13]) + 11) % 12) + 1), 2, "0");
elseif (!strcmp(thechar, "p"))
res = res + ((toint(cctime[12..13]) >= 12) ? "pm" | "am");
elseif (thechar == "P")
res = res + ((toint(cctime[12..13]) >= 12) ? "PM" | "AM");
elseif (!strcmp(thechar, "y"))
res = res + cctime[23..24];
elseif (thechar == "Y")
res = res + cctime[21..24];
elseif (thechar == "Z")
res = res + cctime[26..$];
elseif (thechar == "1")
res = res + $string_utils:right(tostr($string_utils:explode(cctime)[2] in this.monthabbrs), 2, "0");
elseif (thechar == "2")
res = res + tostr($string_utils:explode(cctime)[2] in this.monthabbrs);
elseif (thechar == "3")
res = res + $string_utils:subst(cctime[9..10], {{" ", "0"}});
endif
endwhile
return res + thestr;
-------------------------------------------------------------------------------
#43 time utilities:mmddyy ddmmyy this n/a this
"Copied from Archer (#52775):mmddyy Tue Apr  6 17:04:26 1993 PDT";
"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YY or DD/MM/YY form of the date (depending on the verb called.)  The default seperator is '/'";
{time, ?divstr = "/"} = args;
if (typeof(time) == INT)
time = ctime(time);
elseif (typeof(time) != STR)
return E_TYPE;
endif
date = $string_utils:explode(time);
day = toint(date[3]);
month = date[2] in $time_utils.monthabbrs;
year = date[5];
daystr = (day < 10) ? "0" + tostr(day) | tostr(day);
monthstr = (month < 10) ? "0" + tostr(month) | tostr(month);
yearstr = tostr(year)[3..4];
if (verb == "mmddyy")
return tostr(monthstr, divstr, daystr, divstr, yearstr);
else
return tostr(daystr, divstr, monthstr, divstr, yearstr);
endif
-------------------------------------------------------------------------------
#43 time utilities:parse_english_time_interval this n/a this
"$time_utils:parse_english_time_interval(n1,u1,n2,u2,...)";
"or $time_utils:parse_english_time_interval(\"n1 u1[,] [and] n2[,] u2 [and] ...\")";
"There must be an even number of arguments, all of which must be strings,";
" or there must be just one argument which is the entire string to be parsed.";
"The n's are are numeric strings, and the u's are unit names.";
"The known units are in $time_utils.time_units,";
" which must be kept sorted with bigger times at the head.";
"Returns the time represented by those words.";
"For example,";
" $time_utils:parse_english_time_interval(\"30\",\"secs\",\"2\",\"minutes\",\"31\",\"seconds\") => 181";
if ((length(args) == 1) && index(args[1], " "))
return $time_utils:parse_english_time_interval(@$string_utils:words(args[1]));
endif
a = $list_utils:setremove_all(args, "and");
nargs = length(a);
if (nargs % 2)
return E_ARGS;
endif
nsec = 0;
n = 0;
for i in [1..nargs]
if ((i % 2) == 1)
if ($string_utils:is_numeric(a[i]))
n = toint(a[i]);
elseif (a[i] in {"a", "an"})
n = 1;
elseif (a[i] in {"no"})
n = 0;
else
return E_INVARG;
endif
else
unit = a[i];
if (unit[$] == ",")
unit = unit[1..$ - 1];
endif
ok = 0;
for entry in ($time_utils.time_units)
if ((!ok) && (unit in entry[2..$]))
nsec = nsec + (entry[1] * n);
ok = 1;
endif
endfor
if (!ok)
return E_INVARG;
endif
endif
endfor
return nsec;
-------------------------------------------------------------------------------
#43 time utilities:seconds_until_date this n/a this
"Copied from Ballroom Complex (#29992):from_date by Keelah! (#30246) Tue Jul 13 19:42:32 1993 PDT";
":seconds_until_date(month,day,time,which)";
"month is a string or the numeric representation of the month, day is a number, time is a string in the following format, hh:mm:ss.";
"which==-1 => use most recent such month.";
"which==+1 => use first upcoming such month.";
"which==0 => use closest such month.";
"This will return the number of seconds until the month, day and time given to it.";
"Written by Keelah, on July 5, 1993.";
{month, day, time, which} = args;
converted = 0;
converted = converted + $time_utils:from_month(month, which, day);
current = this:seconds_until_time("12:00:00");
get_seconds = this:seconds_until_time(time);
if (get_seconds < 0)
get_seconds = (get_seconds + 39600) - current;
else
get_seconds = (get_seconds + 39600) - current;
endif
converted = (converted + get_seconds) - time();
return converted;
-------------------------------------------------------------------------------
#43 time utilities:seconds_until_time this n/a this
"Copied from Ballroom Complex (#29992):seconds_until by Keelah! (#30246) Tue Jul 13 19:42:37 1993 PDT";
":seconds_until_time(hh:mm:ss)";
"Given the string hh:mm:ss, this returns the number of seconds until that hh:mm:ss. If the hh:mm:ss is before the current time(), the number returned is a negative, else the number is a positive.";
"Written by Keelah, on July 4, 1993.";
current = $time_utils:to_seconds(ctime()[12..19]);
time = $time_utils:to_seconds(args[1]);
return toint(time) - toint(current);
-------------------------------------------------------------------------------
#43 time utilities:rfc822_ctime this n/a this
"Just like ctime(), but rfc-822 compliant.  I hope.";
c = $string_utils:Explode(ctime(@args));
return tostr(c[1], ", ", c[3], " ", c[2], " ", c[5], " ", c[4], " ", c[6]);
"Last modified Fri Oct 17 23:17:25 1997 EDT by neuro (#3642) on opal moo.";
-------------------------------------------------------------------------------
#43 time utilities:mmddyyyy ddmmyyyy this n/a this
"Given a time() or ctime()-style date and an optional separator, this returns the MM/DD/YYYY or DD/MM/YYYY form of the date (depending on the verb called.)  The default seperator is '/'";
{time, ?divstr = "/"} = args;
if (typeof(time) == INT)
time = ctime(time);
elseif (typeof(time) != STR)
return E_TYPE;
endif
date = $string_utils:explode(time);
day = toint(date[3]);
month = date[2] in $time_utils.monthabbrs;
year = date[5];
daystr = (day < 10) ? "0" + tostr(day) | tostr(day);
monthstr = (month < 10) ? "0" + tostr(month) | tostr(month);
yearstr = tostr(year);
if (verb == "mmddyyyy")
return tostr(monthstr, divstr, daystr, divstr, yearstr);
else
return tostr(daystr, divstr, monthstr, divstr, yearstr);
endif
-------------------------------------------------------------------------------
================================#44 Editor Help===============================================
#44 Editor Help.subject rc = MOOList [ "Syntax:  subj*ect [<text>]", "", "(MAIL ROOM)", "Specifies a Subject: line for your message.  If <text> is "", the Subject: line is removed." ]
#44 Editor Help.showlists rc = MOOList [ "Syntax:  showlists", "", "(MAIL ROOM)", "Print a list of the publically available mailing lists/archives and other non-player entities that can receive mail." ]
#44 Editor Help.prev rc = MOOList [ "Syntax:  p*rev [n] ["<text>]", "", "Moves the insertion point up n lines.  If <text> is provided, a new line is inserted as with `say'.", "Equivalent to `insert -n'.  As one might expect, n defaults to 1." ]
#44 Editor Help.moo rc = MOOList [ "*pass*", "" ]
#44 Editor Help.uncc rc = MOOList [ "*forward*", "not-to" ]
#44 Editor Help.mode rc = MOOList [ "(NOTE EDITOR)", "Syntax:  mode", "         mode string", "         mode list", "         ", "There are (currently) two modes the note editor can be in.", "One is string mode, in which if the text being edited is one line or less, ", "it will be saved as a single string (or an empty string) rather than as a list.", "The other is list mode, in which text is always saved as a list of strings.", "The mode is set when the text is first loaded (string mode if the text is a string, list mode otherwise), but can be changed using this command.", "", "The first form above (i.e., without any arguments) reports the current mode." ]
#44 Editor Help.view rc = MOOList [ "Syntax:  view <player> [<range>] [nonum]", "         view", "", "Prints some subset of the specified player's text.", "Said player must have previously made his text readable with `publish'.", "<ranges> are specified as in other commands (see `help ranges').", "References to the insertion point refer to wherever the other player has set his/her insertion point; you have no control over it.", "The default range is as in list.", "", "If no arguments are given, this lists all of the players that have published anything in this editor." ]
#44 Editor Help.compile rc = MOOList [ "Syntax:  compile [as <object>:<verb>]", "", "(VERB EDITOR)", "Installs the new program into the system if there are no syntax errors.", "If a new object:verb is specified and actually turns out to exist, that <object>:<verb> becomes the default for subsequent compilations." ]
#44 Editor Help.unsubscribe rc = MOOList [ "Syntax: unsubscribe from <list-name>", "        unsubscribe <name>... from <list-name>", "", "(MAILROOM)", "Remove yourself from the given mailing list.", "The second form removes arbitrary people from a mailing list.", "You can only do this if you own whatever is being removed or you own the list.", "", "Use the `who' command to determine if you are on a given mailing list." ]
#44 Editor Help.find rc = MOOList [ "Syntax:  f*ind  /<str>[/[c][<ins>]]", "         /<str>[/[c][<ins>]]", "", "Searches for the first line after <ins> containing <str>.  <ins> defaults to  the current insertion point (see `help insert' for how to specify other places).  With the first form, any character (not just `/') may be used as a delimiter.", "For the second form, you must use '/'.", "", "The 'c' flag, if given, indicates that case is to be ignored while searching.", "", "[Bug: With the second form, there are problems if the search string contains quotes, backslashes or a run of spaces.  The first whitespace will always be treated as a single space.  Likewise, quotes and backslashes occuring in the first word of the command (i.e., the "verb") need to be escaped with `\'.  Unfortunately it will not be possible to fix this until we get a new command parser.]" ]
#44 Editor Help.enter rc = MOOList [ "Syntax:  enter", "", "(EDITOR)", "Enters a sequence of lines at the insertion point (see `help insert').", "This is similar to .program in that every line you type after the `enter' command is inserted verbatim into the text until you type a line with a single period (`.') on it.  This command is essentially for if you don't like the idea of putting " at the beginning of each line you type.  The only exceptions, i.e., lines that are not entered verbatim (aside from the `.' line), are", "", " - If you type a line whose sole text is `@abort', ", "   that aborts this command without making any changes to the text.  ", " - Any line whose first nonblank character is `.' and has additional text", "   is entered but with its first `.' stripped off.  ", "", "Thus, to enter a line whose text is `@abort', you could enter it as `.@abort'." ]
#44 Editor Help.join rc = MOOList [ "Syntax:  join        [<range>]", "         joinliteral [<range>]", "", "combines the lines in the specified range.  Normally, spaces are inserted and double space appears after periods and colons, but 'joinliteral' (abbreviates to 'joinl') supresses this and joins the lines as is.  <range> defaults to the two lines surrounding the insertion point." ]
#44 Editor Help.perish rc = MOOList [ "*forward*", "unpublish" ]
#44 Editor Help.edit rc = MOOList [ "(VERB EDITOR)", "Syntax:  edit <object>:<verb>", "", "Changes what verb you are editing and loads the code for that verb", "into the editor. ", "Equivalent to @edit <object>:<verb>.", "", "(NOTE EDITOR)", "Syntax:  edit <note-object>", "         edit <object>.<property>", "", "Changes to a different note or a different object text property and ", "loads its text into the editor.", "These are equivalent to @notedit <note> or @notedit <object>.<property>", "respectively.", "", "For both the verb-editor and note-editor commands, <object> will match on the room you came from, though if the room you came from was another editor, then all bets are off..." ]
#44 Editor Help.subst rc = MOOList [ "Syntax:  s*ubst/<str1>/<str2>[/[g][c][r][<range>]]", "", "Substitutes <str2> for <str1>, in all of the lines of <range>.", "Any character (not just `/') may be used to delimit the strings. ", "If <str1> is blank, <str2> is inserted at the beginning of the line.  ", "(For inserting a string at the end of a line use emote/:).", "", "Normally, only one substitution is done per line in the specified range, but if the 'g' flag is given, *all* instances of <str1> are replaced.", "The 'c' flag indicates that case is not significant when searching for substitution instances.", "", "The `r' flag means that the command will be grepped and matched using regular expressions. This is how you perform a regexp subst:", "", "The <str1> field will be understood as a regular expression. If you are unfamiliar with regexp protocol, read `help regular-expressions'.", "In cases where successful matches are made, the <str2> string will be run through the substitute() builtin, with the match() info as an argument, before replacing the old string.", "So, in short. If `match(line, <str1>)' returns something, then `substitute(<str2>, match result)' is subbed in its place. The `g' and `c' arguments are still applicable.", "", "<range> defaults to the line *before* the insertion point.", "", "You do *not* need a space between the verb and the delimeter before <str1>.", "[Bug: If you omit the space and the first whitespace in <str1> is a run of more than one space, those spaces get treated as one.  Likewise, quotes and backslashes occuring in the first word of the command (i.e., the "verb") need to be escaped with `\'.  The fix on this will have to wait for a new command parser.]" ]
#44 Editor Help.list rc = MOOList [ "Syntax:  lis*t [<range>] [nonum]", "", "Prints some subset of the current verb text.", "The default range is some reasonable collection of lines around the current insertion point:  currently this is 8_-8^, ie., 8 lines above the insertion point to 8 lines below it unless this runs up against the beginning or end of file, in which case we just take the first or last 16 lines, or just 1-$ if there aren't that many.  (See `help ranges' for how to specify line numbers and ranges.)", "", "`nonum' prints without line numbers.", "", "Yes, window heights will be customizable some day." ]
#44 Editor Help.fill rc = MOOList [ "Syntax:  fill [<range>] [@ c]", "", "combines the specified lines as in join and then splits them so that no line is more than c characters (except in cases of pathological lines with very long words).  c defaults to 70.  <range> defaults to the single line preceding the insertion point." ]
#44 Editor Help.done rc = MOOList [ "*forward*", "quit" ]
#44 Editor Help.pause rc = MOOList [ "*forward*", "quit" ]
#44 Editor Help.not-to rc = MOOList [ "Syntax:  not-to [<recipients>]", "", "Synonym: uncc", "", "(MAIL ROOM)", "Removes the specified recipients from the To: line of your message." ]
#44 Editor Help.abort rc = MOOList [ "Syntax:  abort", "", "Abandons this editing session and any changes." ]
#44 Editor Help.emote rc = MOOList [ "Syntax: emote <text>", "        :<text>", "", "(EDITOR)", "Appends <text> to the end of the line before the insertion point.", "The second form is equivalent to the first except that it doesn't strip leading blanks off of <text> (just as with the normal `emote' and `:' commands).", "The insertion point is left unmoved.", "", "    >list .", "    _37_ Hello there", "    ^38^ Oh, I'm fine.", "    >:, how are you", "    Appended to line 37.", "    >:?", "    Appended to line 37.", "    >list .", "    _37_ Hello there, how are you?", "    ^38^ Oh, I'm fine.", "" ]
#44 Editor Help.send rc = MOOList [ "Syntax:  send", "", "(MAIL ROOM)", "Send the message, then exit the mail room if all of the addresses on the To: line turn out to be valid and usable (you can use the `who' command to check these in advance, though the status of recipients may change without warning).", "If the To: line turns out to contain invalid recipients or recipients that are not usable by you, the message will not be sent and you will remain in the mail room.", "It may be, however, that valid addresses on your To: line will forward to other addresses that are bogus; you'll receive warnings about these, but in this case your message will still be delivered to those addresses that are valid.", "", "Note that there may be particularly long delays when sending to recipients with large forwarding/notification lists or when sending on occasions when the MOO is heavily loaded in general.  In such a case, it is possible to continue editing the message while the send is in progress; any such edits affect only the text in the editor.  In particular, the text of the message currently being sent remains as it was when you first typed the send command.  However, any editing will mark the text as "changed" meaning that you will need to explicitly `abort' or `quit' in order to leave the mail room even if the send concludes successfully." ]
#44 Editor Help.who rc = MOOList [ "Syntax:  who ", "         who <rcpt>...", "", "(MAIL ROOM)", "Invokes $mail_agent's mail-forwarding tracer and determines who (or what) is actually going to receive your message.  The resulting list will not include destinations that will simply forward the message without :receive_message()'ing a copy for themselves.", "", "The second form expands an arbitrary list of recipients, for if e.g., you're curious about the members of particular mailing list." ]
#44 Editor Help.next rc = MOOList [ "Syntax:  n*ext [n] ["<text>]", "", "Moves the insertion point down n lines.  If <text> is provided, inserts a new line there just like `say'.", "Equivalent to `insert +n'.  As one might expect, n defaults to 1." ]
#44 Editor Help.ranges rc = MOOList [ "Most editor commands act upon a particular range of lines.", "Essentially, one needs to specify a first line and a last line.", "Line numbers may be given in any of the following forms", "  ", "  n      (i.e., the nth line of text)", "  n^     n-th line after/below  the current insertion point", "  n_     n-th line before/above the current insertion point", "  n$     n-th line before the end.", "", "In the latter three, n defaults to 1, so that `^' by itself refers to the line below the current (i.e., the line that gets `^' printed before it), and likewise for `_' while `$' refers to the last line.  Note that the usage depends on whether you are specifying a line or an insertion point (space between lines). `^5' is the space above/before line 5, while `5^' is the fifth line after/below the current insertion point.", "", "Ranges of lines may be specified in any of the", "following ways:", "", "  <line>                  just that line", "  from <line> to <line>   what it says; the following two forms are equivalent:", "  <line>-<line>            ", "  <line> <line>", "", "With the `from l to l' form, either the from or the to can be left off and it will default to whatever is usual for that command (usually a line above or below the insertion point).  Actually I was thinking of punting the `from'/`to' specifications entirely because they're so verbose.  Opinions?" ]
#44 Editor Help.save rc = MOOList [ "Syntax:  save [<note-object>]", "         save [<object>.<property>]", "", "(NOTE EDITOR)", "Installs the freshly edited text.  If <note> or <object>.<property> is specified, text is installed on that note or property instead of the original one.  In addition the new note or property becomes the default for future save commands." ]
#44 Editor Help.insert rc = MOOList [ "Syntax:  ins*ert [<ins>] ["<text>]", "         .                    (`.' == `insert' without arguments)", "", "(EDITOR)", "Many editor commands refer to an "insertion point" which is (usually) the place right below where the most recent line was inserted.  The insertion point should really be thought of as sitting *between* lines.  In listings, the line above the insertion point is marked with `_' while the one below is marked with `^'.", "", "The `insert' command, when given an argument, sets the insertion point.", "If <text> is provided, a new line will be created and inserted as with `say'.", "<ins>, both here and in other commands that require specifying an insertion point (e.g., copy/move), can be one of", "          ", "    ^n   above line n", "     n   above line n", "    _n   below line n", "     $   at the end", "    ^$   before the last line", "   n^$   n lines before the end", "     .   the current insertion point  (i.e., `insert .' is a no-op)", "    +n   n lines below the current insertion point.", "    -n   n lines above the current insertion point.", "", "For the truly perverse, there are other combinations that also work due to artifacts of the parsing process, but these might go away..." ]
#44 Editor Help.delete rc = MOOList [ "Syntax:  del*ete [<range>] ", "", "(EDITOR)", "Deletes the specified range of lines", "<range> defaults to the line *before* the current insertion point." ]
#44 Editor Help.also-to rc = MOOList [ "Syntax:  also-to [<recipients>]", "", "Synonym: cc", "", "(MAIL ROOM)", "Adds additional recipients to the To: line of your message.", "Same rules apply as for the `to' command." ]
#44 Editor Help.unpublish rc = MOOList [ "Syntax:  unpub*lish", "         depub*lish", "         perish", "", "This command reverses the effects of `publish', making your text readable only by you." ]
#44 Editor Help.copy rc = MOOList [ "Syntax:  c*opy [<range>] to <ins>", "", "Copies the specified range of lines to place given by <ins>.", "If <ins> happens to be the current insertion point, the insertion ", "point moves to the end of the inserted lines.", "", "See `help insert' for a list of possibilities for <ins>." ]
#44 Editor Help.reply-to rc = MOOList [ "Syntax:  reply-to [<recipients>]", "", "(MAIL ROOM)", "Reports the current contents of the Reply-to: field of your message.", "With arguments, adds (or changes) the Reply-to: field.", "", "When someone @answers a message, the Reply-to: field is checked first when determining to whom the reply should be sent --- see `help @answer'.", "", "To clear the Reply-to: field, do", "", "         reply-to """ ]
#44 Editor Help.summary rc = MOOList [ "You are inside an editor.  Do", "", "look          -- for list of commands", "what          -- to find out what you're editing.", "list          -- to list out some portion of the text", "say / emote   -- to add new text to whatever you're editing", "", "help edit-index -- for a full list of editor help topics", "help editors    -- for a general discussion about editors", "help moo        -- for the general MOO help summary (i.e., what you get by ", "                   typing `help' with no arguments from outside the editor)." ]
#44 Editor Help.cc rc = MOOList [ "*forward*", "also-to" ]
#44 Editor Help.move rc = MOOList [ "Syntax:  m*ove [<range>] to <ins>", "", "Moves the range of lines to place specified by <ins>.", "If <ins> happens to be the current insertion point, the insertion point is moved to the end of the freshly moved lines.  If the range of lines contains the insertion point, the insertion point is carried over to the range's new location.", "", "See `help insert' for a list of possibilities for <ins>." ]
#44 Editor Help.depublish rc = MOOList [ "*forward*", "unpublish" ]
#44 Editor Help.subscribe rc = MOOList [ "Syntax: subscribe to <list-name>", "        subscribe [<name>...] to <list-name>", "", "(MAILROOM)", "Add yourself to the given mailing list.  ", "The second form adds arbitrary people to a mailing list.", "You can only do this if you own the list or if it is listed as [Public] and you own whatever is being added.", "", "The first form of this command is probably obsolete since if <list-name> is public, you can already read it via `@mail on *<list-name>' and it's much better for the MOO if you do so.  `@mail-option +sticky' makes this even easier.", "", "Use the `who' command to determine if you are on a given mailing list." ]
#44 Editor Help.edit-index rc = MOOList [ "*index*", "Editor Help Topics" ]
#44 Editor Help.say rc = MOOList [ "Syntax: say <text>", "        "<text>", "", "(EDITOR)", "Adds <text> to whatever you are editing.", "The second form is equivalent to the first except in that it doesn't strip leading blanks off of <text> (just as with the normal `say' and `"' commands).", "", "The added text appears as a new line at the insertion point.  The insertion point, in turn, gets moved so as to be after the added text.  For example:", "", "    >"first line", "    Line 1 added.", "    >"  second line"", "    Line 2 added.", "    >list", "      1: first line", "    __2_   second line"", "    ^^^^" ]
#44 Editor Help.print rc = MOOList [ "Syntax:  pri*nt", "", "Display your text without line numbers.", "", "(MAIL ROOM)", "Display your message including headers." ]
#44 Editor Help.what rc = MOOList [ "Syntax:  w*hat", "", "Prints information about the editing session." ]
#44 Editor Help.publish rc = MOOList [ "Syntax:  pub*lish", "", "By default, only you (and wizards) can read the text you are editing.", "This command makes your text readable by the entire world (see `help view').", "This is useful if you need help from someone or if you just want to show off your programming acumen.", "Use `unpublish' to make your text private again." ]
#44 Editor Help.quit rc = MOOList [ "Syntax:  q*uit", "         done", "         pause  ", "", "(EDITOR)", "Leaves the editor.  If you have unsaved text it will be there when you return (and in fact you will not be able to do anything else with this editor until you 'abort' or save the text).", "" ]
#44 Editor Help.to rc = MOOList [ "Syntax:  to [<recipients>]", "", "(MAIL ROOM)", "Specifies a new set of recipients (the To: line) for your message.", "Recipient names not beginning with * are matched against the list of players.", "Recipient names beginning with * are interpreted as mailing-lists/archives/other types of non-person addresses and are matched against all such publically available objects (see `help showlists').  If the list you want to use isn't in the database (i.e., isn't located in the database ($mail_agent)) you need to refer to it by object id." ]
================================#45 Generic Mail Recipient===============================================
#45 Generic Mail Recipient.mail_forward r = MOOString "%t (%[#t]) is a generic recipient."
#45 Generic Mail Recipient.messages_going  = MOOList [ ]
#45 Generic Mail Recipient.moderated rc = MOOList [ ]
#45 Generic Mail Recipient.moderator_notify rc = MOOList [ ]
#45 Generic Mail Recipient.rmm_own_msgs rc = MOONumber 1
#45 Generic Mail Recipient.last_msg_date r = MOONumber 0
#45 Generic Mail Recipient.validation_password  = MOOString ""
#45 Generic Mail Recipient.messages_kept r = MOOList [ ]
#45 Generic Mail Recipient.guests_can_send_here rc = MOONumber 0
#45 Generic Mail Recipient.last_used_time r = MOONumber 0
#45 Generic Mail Recipient.registered_email  = MOOString ""
#45 Generic Mail Recipient.moderator_forward rc = MOOString "%n (%#) can't send to moderated list %t (%[#t]) directly."
#45 Generic Mail Recipient.expire_period r = MOONumber 2592000
#45 Generic Mail Recipient.writers rc = MOOList [ ]
#45 Generic Mail Recipient.mail_notify r = MOOList [ ]
#45 Generic Mail Recipient.email_validated  = MOONumber 1
#45 Generic Mail Recipient.readers rc = MOOList [ ]
#45 Generic Mail Recipient.messages  = MOOList [ ]
#45 Generic Mail Recipient:set_aliases this n/a this
"For changing mailing list aliases, we check to make sure that none of the aliases match existing mailing list aliases.  Aliases containing spaces are not used in addresses and so are not subject to this restriction ($mail_agent:match will not match on them, however, so they only match if used in the immediate room, e.g., with match_object() or somesuch).";
"  => E_PERM   if you don't own this";
{newaliases} = args;
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (this.location != $mail_agent)
"... we don't care...";
return pass(@args);
elseif (length(newaliases) > $mail_agent.max_list_aliases)
return E_QUOTA;
else
for a in (aliases = newaliases)
if (index(a, " "))
"... we don't care...";
elseif (rp = $mail_agent:reserved_pattern(a))
player:tell("Mailing list name \"", a, "\" uses a reserved pattern: ", rp[1]);
aliases = setremove(aliases, a);
elseif (valid(p = $mail_agent:match(a, #-1)) && ((p != this) && (a in p.aliases)))
player:tell("Mailing list name \"", a, "\" in use on ", p.name, "(", p, ")");
aliases = setremove(aliases, a);
endif
endfor
return pass(aliases) && (newaliases == aliases);
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:look_self this n/a this
"Returns full name and mail aliases for this list, read and write status by the player, and a short description. Calling :look_self(1) will omit the description.";
{?brief = 0} = args;
namelist = "*" + ((names = this:mail_names()) ? $string_utils:from_list(names, ", *") | tostr(this));
if (typeof(fwd = this:mail_forward()) != LIST)
fwd = {};
endif
if (this:is_writable_by(player))
if (player in fwd)
read = " [Writable/Subscribed]";
else
read = " [Writable]";
endif
elseif (this.readers == 1)
read = tostr(" [Public", (player in fwd) ? "/Subscribed]" | "]");
elseif (player in fwd)
read = " [Subscribed]";
elseif (this:is_readable_by(player))
read = " [Readable]";
else
read = "";
endif
if (this:is_usable_by($no_one))
mod = "";
elseif (this:is_usable_by(player))
mod = " [Approved]";
else
mod = " [Moderated]";
endif
player:tell(namelist, "  (", this, ")", read, mod);
if (!brief)
d = this:description();
if (typeof(d) == STR)
d = {d};
endif
for l in (d)
if (length(l) <= 75)
ls = {l};
else
ls = $generic_editor:fill_string(l, 76);
endif
for line in (ls)
player:tell("    ", line);
$command_utils:suspend_if_needed(0);
endfor
endfor
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:is_writable_by is_annotatable_by this n/a this
return $perm_utils:controls(who = args[1], this) || `who in this.writers ! E_TYPE';
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:is_readable_by this n/a this
return (typeof(this.readers) != LIST) || (((who = args[1]) in this.readers) || (this:is_writable_by(who) || $mail_agent:sends_to(1, this, who)));
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:is_usable_by this n/a this
who = args[1];
if (this.moderated)
return `who in this.moderated ! E_TYPE' || (this:is_writable_by(who) || who.wizard);
else
return this.guests_can_send_here || (!$object_utils:isa(who, $guest));
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:mail_notify this n/a this
if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))
return this:moderator_notify(@args);
else
return this.(verb);
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:mail_forward this n/a this
if ((args && (!this:is_usable_by(args[1]))) && (!args[1].wizard))
return this:moderator_forward(@args);
elseif (typeof(mf = this.(verb)) == STR)
return $string_utils:pronoun_sub(mf, @args);
else
return mf;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:moderator_forward this n/a this
if (typeof(mf = this.(verb)) == STR)
return $string_utils:pronoun_sub(mf, args ? args[1] | $player);
else
return mf;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:add_forward this n/a this
":add_forward(recip[,recip...]) adds new recipients to this list.  Returns a string error message or a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient, string => other kind of failure)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
forward_self = (!this.mail_forward) || (this in this.mail_forward);
for recip in (args)
if ((!valid(recip)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))
r = E_INVARG;
elseif ($perm_utils:controls(perms, this) || ((typeof(this.readers) != LIST) && $perm_utils:controls(perms, recip)))
this.mail_forward = setadd(this.mail_forward, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
if ((length(this.mail_forward) > 1) && ($nothing in this.mail_forward))
this.mail_forward = setremove(this.mail_forward, $nothing);
endif
if (forward_self)
this.mail_forward = setadd(this.mail_forward, this);
endif
return result;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:delete_forward this n/a this
":delete_forward(recip[,recip...]) removes recipients to this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
forward_self = (!this.mail_forward) || (this in this.mail_forward);
for recip in (args)
if (!(recip in this.mail_forward))
r = E_INVARG;
elseif (((!valid(recip)) || $perm_utils:controls(perms, recip)) || $perm_utils:controls(perms, this))
if (recip == this)
forward_self = 0;
endif
this.mail_forward = setremove(this.mail_forward, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
if (!(forward_self || this.mail_forward))
this.mail_forward = {$nothing};
elseif (this.mail_forward == {this})
this.mail_forward = {};
endif
return result;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:add_notify this n/a this
":add_notify(recip[,recip...]) adds new notifiees to this list.  Returns a list of results (recip => success, E_PERM => not allowed, E_INVARG => not a valid recipient)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
for recip in (args)
if ((!valid(recip)) || (recip == this))
r = E_INVARG;
elseif ($perm_utils:controls(perms, this) || (this:is_readable_by(perms) && $perm_utils:controls(perms, recip)))
this.mail_notify = setadd(this.mail_notify, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
return result;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:delete_notify this n/a this
":delete_notify(recip[,recip...]) removes notifiees from this list.  Returns a list of results (E_PERM => not allowed, E_INVARG => not on list)";
if (caller == $mail_editor)
perms = player;
else
perms = caller_perms();
endif
result = {};
rmthis = 0;
for recip in (args)
if (!(recip in this.mail_notify))
r = E_INVARG;
elseif ((!valid(recip)) || ($perm_utils:controls(perms, recip) || $perm_utils:controls(perms, this)))
if (recip == this)
rmthis = 1;
endif
this.mail_notify = setremove(this.mail_notify, recip);
r = recip;
else
r = E_PERM;
endif
result = listappend(result, r);
endfor
return result;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:receive_message this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
this.messages = {@this.messages, {new = this:new_message_num(), args[1]}};
this.last_msg_date = args[1][1];
this.last_used_time = time();
return new;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:ok this n/a this
":ok(caller,callerperms) => true iff caller can do read operations";
return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_readable_by(args[2]));
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:ok_write this n/a this
":ok_write(caller,callerperms) => true iff caller can do write operations";
return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_writable_by(args[2]));
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:parse_message_seq from_msg_seq %from_msg_seq to_msg_seq %to_msg_seq subject_msg_seq body_msg_seq kept_msg_seq unkept_msg_seq display_seq_headers display_seq_full messages_in_seq list_rmm new_message_num length_num_le length_date_le length_all_msgs exists_num_eq msg_seq_to_msg_num_list msg_seq_to_msg_num_string this n/a this
":parse_message_seq(strings,cur) => {msg_seq,@unused_strings} or string error";
"";
":from_msg_seq(olist)     => msg_seq of messages from those people";
":%from_msg_seq(strings)  => msg_seq of messages with strings in the From: line";
":to_msg_seq(olist)       => msg_seq of messages to those people";
":%to_msg_seq(strings)    => msg_seq of messages with strings in the To: line";
":subject_msg_seq(target) => msg_seq of messages with target in the Subject:";
":body_msg_seq(target)    => msg_seq of messages with target in the body";
":new_message_num()    => number that the next incoming message will receive.";
":length_num_le(num)   => number of messages in folder numbered <= num";
":length_date_le(date) => number of messages in folder dated <= date";
":length_all_msgs()    => number of messages in folder";
":exists_num_eq(num)   => index of message in folder numbered == num, or 0";
"";
":display_seq_headers(msg_seq[,cur])   display message summary lines";
":display_seq_full(msg_seq[,preamble]) display entire messages";
"            => number of final message displayed";
":list_rmm() displays contents of .messages_going.";
"            => the number of messages in .messages_going.";
"";
":messages_in_seq(msg_seq) => list of messages in msg_seq on folder";
"";
"See the corresponding routines on $mail_agent for more detail.";
return this:ok(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:length_date_gt this n/a this
":length_date_le(date) => number of messages in folder dated > date";
"";
if (this:ok(caller, caller_perms()))
date = args[1];
return (this.last_msg_date <= date) ? 0 | $mail_agent:(verb)(date);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:rm_message_seq this n/a this
":rm_message_seq(msg_seq) removes the given sequence of from folder";
"               => string giving msg numbers removed";
"See the corresponding routine on $mail_agent.";
if (this:ok_write(caller, caller_perms()))
return $mail_agent:(verb)(@args);
elseif (this:ok(caller, caller_perms()) && (seq = this:own_messages_filter(caller_perms(), @args)))
return $mail_agent:(verb)(@listset(args, seq, 1));
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:undo_rmm expunge_rmm renumber keep_message_seq set_message_body_by_index this n/a this
":rm_message_seq(msg_seq) removes the given sequence of from folder";
"               => string giving msg numbers removed";
":list_rmm()    displays contents of .messages_going.";
"               => number of messages in .messages_going.";
":undo_rmm()    restores previously deleted messages from .messages_going.";
"               => msg_seq of restored messages";
":expunge_rmm() destroys contents of .messages_going once and for all.";
"               => number of messages in .messages_going.";
":renumber([cur])  renumbers all messages";
"               => {number of messages,new cur}.";
":set_message_body_by_index(i,newbody)";
"               changes the body of the i-th message.";
"";
"See the corresponding routines on $mail_agent.";
return this:ok_write(caller, caller_perms()) ? $mail_agent:(verb)(@args) | E_PERM;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:own_messages_filter this n/a this
":own_messages_filter(who,msg_seq) => subsequence of msg_seq consisting of those messages that <who> is actually allowed to remove (on the assumption that <who> is not one of the allowed writers of this folder.";
if (!this.rmm_own_msgs)
return E_PERM;
elseif ((typeof(seq = this:from_msg_seq({args[1]}, args[2])) != LIST) || (seq != args[2]))
return {};
else
return seq;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:messages this n/a this
"NOTE:  this routine is obsolete, use :messages_in_seq()";
":messages(num) => returns the message numbered num.";
":messages()    => returns the entire list of messages (can be SLOW).";
if (!this:ok(caller, caller_perms()))
return E_PERM;
elseif (!args)
return this:messages_in_seq({1, this:length_all_msgs() + 1});
elseif (!(n = this:exists_num_eq(args[1])))
return E_RANGE;
else
return this:messages_in_seq(n)[2];
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:date_sort this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
date_seq = {};
for msg in (this.messages)
date_seq = {@date_seq, msg[2][1]};
endfor
msg_order = $list_utils:sort($list_utils:range(n = length(msgs = this.messages)), date_seq);
newmsgs = {};
for i in [1..n]
if ($command_utils:suspend_if_needed(0))
player:tell("...", i);
endif
newmsgs = {@newmsgs, {i, msgs[msg_order[i]][2]}};
endfor
if (length(this.messages) != n)
"...shit, new mail received,... start again...";
fork (0)
this:date_sort();
endfork
else
this.messages = newmsgs;
this.last_used_time = newmsgs[$][2][1];
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:_fix_last_msg_date this n/a this
mlen = this:length_all_msgs();
this.last_msg_date = mlen && this:messages_in_seq(mlen)[2][1];
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:moderator_notify this n/a this
return this.(verb);
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:msg_summary_line this n/a this
return $mail_agent:msg_summary_line(@args);
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:__check this n/a this
for m in (this.messages)
$mail_agent:__convert_new(@m[2]);
$command_utils:suspend_if_needed(0);
endfor
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:__fix this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
msgs = {};
i = 1;
for m in (oldmsgs = this.messages)
msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};
if ($command_utils:running_out_of_time())
player:notify(tostr("...", i, " ", this));
suspend(0);
if (oldmsgs != this.messages)
return 0;
endif
endif
i = i + 1;
endfor
this.messages = msgs;
return 1;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
if (!(this in {$mail_recipient, $big_mail_recipient}))
"...generic mail recipients stay in #-1...";
move(this, $mail_agent);
this:rm_message_seq($seq_utils:range(1, this:length_all_msgs()));
this:expunge_rmm();
this:_fix_last_msg_date();
this.mail_forward = {};
for p in ({"mail_notify", "moderator_forward", "moderator_notify", "writers", "readers", "expire_period", "last_used_time"})
this.(p) = $mail_recipient.(p);
endfor
endif
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:initialize this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
this.mail_forward = {};
return pass(@args);
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:mail_name_old mail_name short_mail_name this n/a this
return "*" + this.aliases[1];
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:mail_names this n/a this
names = {};
for a in (this.aliases)
if (!index(a, " "))
names = setadd(names, strsub(a, "_", "-"));
endif
endfor
return names;
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:expire_old_messages this n/a this
if (this:ok_write(caller, caller_perms()))
if ($network.active)
"Passed security check...";
set_task_perms($wiz_utils:random_wizard());
for x in (this.mail_notify)
if (!$object_utils:has_verb(x, "notify_mail"))
"In theory I should call this:delete_notify but it's ugly and ticky as sin and I'm lazy.";
this.mail_notify = setremove(this.mail_notify, x);
endif
endfor
if (this.expire_period && (rmseq = $seq_utils:remove(this:unkept_msg_seq(), 1 + this:length_date_le(time() - this.expire_period))))
"... i.e., everything not marked kept that is older than expire_period";
if (this.registered_email && this.email_validated)
format = this.owner:format_for_netforward(this:messages_in_seq(rmseq), " expired from " + $mail_agent:name(this));
$network:sendmail(this.registered_email, @{format[2], @format[1]});
"Do nothing if it bounces, etc.";
endif
this:rm_message_seq(rmseq);
return this:expunge_rmm();
else
return 0;
endif
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:moveto this n/a this
if (this:is_writable_by(caller_perms()) || this:is_writable_by(caller))
pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:msg_full_text this n/a this
":msg_full_text(@msg) => list of strings.";
"msg is a mail message (in the usual transmission format).";
"display_seq_full calls this to obtain the actual list of strings to display.";
return player:msg_text(@args);
"default is to leave it up to the player how s/he wants it to be displayed.";
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:@set_expire this any any
"Syntax:  @set_expire <recipient> to <time>";
"         @set_expire <recipient> to";
"";
"Allows the list owner to set the expiration period of this mail recipient. This is the time messages will remain before they are removed from the list. The <time> given can be in english terms (e.g., 2 months, 45 days, etc.).";
"Non-wizard mailing list owners are limited to a maximum expire period of 180 days. They are also prohibited from setting the list to non-expiring.";
"Wizards may set the expire period to 0 for no expiration.";
"The second form, leaving off the time specification, will tell you what the recipient's expire period is currently set to.";
if ((caller_perms() != #-1) && (caller_perms() != player))
return player:tell(E_PERM);
elseif (!this:is_writable_by(player))
return player:tell(E_PERM);
elseif (!iobjstr)
return player:tell(this.expire_period ? tostr("Messages will automatically expire from ", this:mail_name(), " after ", $time_utils:english_time(this.expire_period), ".") | tostr("Messages will not expire from ", this:mail_name()));
elseif (typeof(time = $time_utils:parse_english_time_interval(iobjstr)) == ERR)
return player:tell(time);
elseif ((time == 0) && (!player.wizard))
return player:tell("Only wizards may set a mailing list to not expire.");
elseif ((time > (180 * 86400)) && (!player.wizard))
return player:tell("Only a wizard may set the expiration period on a mailing list to greater than 180 days.");
endif
this.expire_period = time;
player:tell("Messages will ", (time != 0) ? tostr("automatically expire from ", this:mail_name(), " after ", $time_utils:english_time(time)) | tostr("not expire from ", this:mail_name()), ".");
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:@register @netregister this any any
"Syntax:   @register <recipient> to <email-address>";
"alias     @netregister <recipient> to <email-address>";
"          @register <recipient> to";
"";
"The list owner may use this command to set a registered email address for the mail recipient. When set, mail messages that expire off of the mail recipient will be mailed to that address.";
"If you leave the email address off of the command, it will return the current registration and expiration information for that recipient if you own it.";
"The owner may register a mail recipient to any email address. However, if the address does not match his registered email address, then a password will be generated and sent to the address specified when this command is used. Then, the owner may retrieve that password and verify the address with the command:";
"";
"  @validate <recipient> with <password>";
"";
"See *B:MailingListReform #98087 for full details.";
if ((caller_perms() != #-1) && (caller_perms() != player))
return player:tell(E_PERM);
elseif (!$perm_utils:controls(player, this))
return player:tell(E_PERM);
elseif (!iobjstr)
if (this.registered_email)
player:tell(this:mail_name(), " is registered to ", this.registered_email, ". Messages will be sent there when they expire after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), ".");
else
player:tell(this:mail_name(), " is not registered to any address. Messages will be deleted when they expire after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), ".");
player:tell("Usage:  @register <recipient> to <email-address>");
endif
return;
elseif (iobjstr == $wiz_utils:get_email_address(player))
this.registered_email = $wiz_utils:get_email_address(player);
this.email_validated = 1;
player:tell("Messages expired from ", this:mail_name(), " after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), " will be emailed to ", this.registered_email, " (which is your registered email address).");
elseif (reason = $network:invalid_email_address(iobjstr))
return player:tell(reason, ".");
elseif (!$network.active)
return player:tell("The network is not up at the moment. Please try again later or contact a wizard for help.");
else
password = $wiz_utils:random_password(5);
result = $network:sendmail(iobjstr, tostr($network.MOO_Name, " mailing list verification"), @$generic_editor:fill_string(tostr("The mailing list ", this:mail_name(), " on ", $network.MOO_Name, " has had this address designated as the recipient of expired mail messages. If this is not correct, then you need do nothing but ignore this message. If this is correct, you must log into the MOO and type:  `@validate ", this:mail_name(), " with ", password, "' to start receiving expired mail messages."), 75));
if (result != 0)
return player:tell("Mail sending did not work: ", result, ". Address not set.");
endif
this.registered_email = iobjstr;
this.email_validated = 0;
this.validation_password = password;
player:tell("Registration complete. Password sent to the address you specified. When you receive the email, log back in to validate it with the command:  @validate <recipient> with <password>. If you do not receive the password email, try again or notify a wizard if this is a recurring problem.");
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:@validate this none any
"Syntax:  @validate <recipient> with <password>";
"";
"This command is used to validate an email address set to receive expired messages that did not match the list owner's registered email address. When using the @register command, a password was sent via email to the address specified. This command is to verify that the password was received properly.";
if ((caller_perms() != #-1) && (caller_perms() != player))
return player:tell(E_PERM);
elseif (!$perm_utils:controls(player, this))
return player:tell(E_PERM);
elseif (!this.registered_email)
return player:tell("No email address has even been set for ", this:mail_name(), ".");
elseif (this.email_validated)
return player:tell("The email address for ", this:mail_name(), " has already been validated.");
elseif (!iobjstr)
return player:tell("Usage:  @validate <recipient> with <password>");
elseif (iobjstr != this.validation_password)
return player:tell("That is not the correct password.");
else
this.email_validated = 1;
player:tell("Password validated. Messages that expire after ", (this.expire_period == 0) ? "never" | $time_utils:english_time(this.expire_period), " from ", this:mail_name(), " will be emailed to ", this.registered_email, ".");
endif
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:set_name this n/a this
{name} = args;
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (this.location != $mail_agent)
"... we don't care...";
return pass(@args);
elseif (index(name, " "))
"... we don't care...";
elseif (rp = $mail_agent:reserved_pattern(name))
player:tell("Mailing list name \"", a, "\" uses a reserved pattern: ", rp[1]);
return 0;
elseif (valid(p = $mail_agent:match(name, #-1)) && ((p != this) && (name in p.aliases)))
player:tell("Mailing list name \"", name, "\" in use on ", p.name, "(", p, ")");
return 0;
endif
return pass(name);
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:ok_annotate this n/a this
":ok_annotate(caller,callerperms) => true iff caller can do annotations";
return (args[1] in {this, $mail_agent}) || (args[2].wizard || this:is_annotatable_by(args[2]));
-------------------------------------------------------------------------------
#45 Generic Mail Recipient:annotate_message_seq this n/a this
"annotate_message_seq(note, \"append\"|\"prepend\", message_seq) ;";
"";
"Prepend or append (default is prepend) note (a list of strings) to each message in message_seq";
"Recipient must be annotatable (:is_annotatable_by() returns 1) by the caller for this to work.";
{note, appendprepend, message_seq} = args;
if (!this:ok_annotate(caller, caller_perms()))
return E_PERM;
endif
for i in ($seq_utils:tolist(message_seq))
body = this:message_body_by_index(i);
if (appendprepend == "append")
body = {@body, "", @note};
else
body = {@note, "", @body};
endif
this:set_message_body_by_index(i, body);
endfor
return 1;
"Copied from annotatetest (#87053):annotate_message_seq [verb author Puff (#1449)] at Mon Feb 14 14:04:56 2005 PST";
-------------------------------------------------------------------------------
================================#46 Mail Distribution Center===============================================
#46 Mail Distribution Center.reserved_patterns r = MOOList [ ]
#46 Mail Distribution Center.last_mail_time r = MOONumber 0
#46 Mail Distribution Center.player_expire_time rc = MOONumber 2592000
#46 Mail Distribution Center.player_default_@mail rc = MOOString "last:15"
#46 Mail Distribution Center.time_collisions r = MOOList [ 0, 0 ]
#46 Mail Distribution Center.options rc = MOOList [ "include", "noinclude", "all", "sender", "nosubject", "expert", "enter", "sticky", "@mail", "manymsgs", "replyto" ]
#46 Mail Distribution Center.max_list_aliases rc = MOONumber 8
#46 Mail Distribution Center.player_default_@unsend r = MOOString "last:1"
#46 Mail Distribution Center.max_mail_notify rc = MOONumber 15
#46 Mail Distribution Center:resolve_addr this n/a this
"resolve(name,from,seen,prevrcpts,prevnotifs) => {rcpts,notifs} or E_INVARG";
"resolve(list,from,seen,prevrcpts,prevnotifs) => {bogus,rcpts,notifs}";
"Given either an address (i.e., objectid) or a list of such, traces down all .mail_forward lists and .mail_notify to determine where a message should actually go and who should be told about it.  Both forms take previous lists of recipients/notifications and add only those addresses that weren't there before.  `seen' is the stack of addresses we are currently resolving (for detecting loops).  The first form returns E_INVARG if `name' is invalid.  The second form returns all invalid addresses in the `bogus' list but still does the appropriate search on the remaining addresses.";
{recip, from, ?seen = {}, ?prevrcpts = {}, ?prevnotifs = {}} = args;
sofar = {prevrcpts, prevnotifs};
if (typeof(recip) == LIST)
bogus = {};
for r in (recip)
result = this:resolve_addr(r, from, seen, @sofar);
if (result)
sofar = result;
else
bogus = setadd(bogus, r);
endif
endfor
return {bogus, @sofar};
else
fwd = include_recip = 0;
if ((recip == $nothing) || (recip in seen))
return sofar;
elseif ((!valid(recip)) || ((!(is_player(recip) || $object_utils:isa(recip, $mail_recipient))) || (typeof(fwd = recip:mail_forward(from)) != LIST)))
"recip is a non-player non-mailing-list/folder or forwarding is screwed.";
if (typeof(fwd) == STR)
player:tell(fwd);
endif
return E_INVARG;
elseif (is_player(recip) && `recip:refuses_action(from, "mail") ! E_VERBNF')
player:tell(recip:mail_refused_msg());
return E_INVARG;
elseif (fwd)
if (r = recip in fwd)
include_recip = 1;
fwd = listdelete(fwd, r);
endif
result = this:resolve_addr(fwd, recip, setadd(seen, recip), @sofar);
if (bogus = result[1])
player:tell(recip.name, "(", recip, ")'s .mail_forward list includes the following bogus entr", (length(bogus) > 1) ? "ies:  " | "y:  ", $string_utils:english_list(bogus));
endif
sofar = result[2..3];
else
include_recip = 1;
endif
if ((ticks_left() < 1000) || (seconds_left() < 2))
suspend(0);
endif
biffs = sofar[2];
for n in (this:mail_notify(recip, from))
if (valid(n))
if (i = $list_utils:iassoc_suspended(n, biffs))
biffs[i] = setadd(biffs[i], recip);
else
biffs = {{n, recip}, @biffs};
endif
endif
if ((ticks_left() < 1000) || (seconds_left() < 2))
suspend(0);
endif
endfor
return {include_recip ? setadd(sofar[1], recip) | sofar[1], biffs};
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:sends_to this n/a this
"sends_to(from,addr,rcpt[,seen]) ==> true iff mail sent to addr passes through rcpt.";
{from, addr, rcpt, ?seen = {}} = args;
if (addr == rcpt)
return 1;
elseif (!(addr in seen))
seen = {@seen, addr};
for a in ((typeof(fwd = this:mail_forward(addr, @from ? {} | {from})) == LIST) ? fwd | {})
if (this:sends_to(addr, a, rcpt, seen))
return 1;
endif
$command_utils:suspend_if_needed(0);
endfor
endif
return 0;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:send_message this n/a this
"send_message(from,rcpt-list,hdrs,msg) -- formats and sends a mail message.  hders is either the text of the subject line, or a {subject,{reply-to,...}} list.";
"Return E_PERM if from isn't owned by the caller.";
"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{from, to, orig_hdrs, msg} = args;
"...";
"... remove bogus Resent-To/Resent-By headers...";
"...";
if ((typeof(orig_hdrs) == LIST) && (length(orig_hdrs) > 2))
hdrs = orig_hdrs[1..2];
orig_hdrs[1..2] = {};
strip = {"Resent-To", "Resent-By"};
for h in (orig_hdrs)
(h[1] in strip) || (hdrs = {@hdrs, h});
endfor
else
hdrs = orig_hdrs;
endif
"...";
"... send it...";
"...";
if ($perm_utils:controls(caller_perms(), from))
text = $mail_agent:make_message(from, to, hdrs, msg);
return this:raw_send(text, to, from);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:raw_send this n/a this
"Copied from Mail Distribution Center (#6418):raw_send by Nosredna (#2487) Mon Feb 24 10:46:26 1997 PST";
"WIZARDLY";
"raw_send(text,rcpts,sender) -- does the actual sending of a message.  Assumes that text has already been formatted correctly.  Decides who to send it to and who wants to be notified about it and does so.";
"Return {E_PERM} if the caller is not entitled to use this verb.";
"Return {0, @invalid_rcpts} if rcpts contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{text, rcpts, from} = args;
if (typeof(rcpts) != LIST)
rcpts = {rcpts};
endif
if (!(caller in {$mail_agent, $mail_editor}))
return {E_PERM};
elseif (bogus = (resolve = this:resolve_addr(rcpts, from))[1])
return {0, bogus};
else
set_task_perms($wiz_utils:random_wizard());
this:touch(rcpts);
actual_rcpts = resolve[2];
biffs = resolve[3];
results = {};
for recip in (actual_rcpts)
if ((ticks_left() < 10000) || (seconds_left() < 2))
player:notify(tostr("...", recip));
suspend(1);
endif
if (typeof(e = recip:receive_message(text, from)) in {ERR, STR})
"...receive_message bombed...";
player:notify(tostr(recip, ":receive_message:  ", e));
e = 0;
elseif ((!is_player(recip)) || (!e))
"...not a player or receive_message isn't giving out the message number";
"...no need to force a notification...";
elseif (i = $list_utils:iassoc(recip, biffs))
"...player-recipient was already getting a notification...";
"...make sure notification includes a mention of him/her/itself.";
if (!(recip in listdelete(biffs[i], 1)))
biffs[i][2..1] = {recip};
endif
else
"...player-recipient wasn't originally being notified at all...";
biffs = {{recip, recip}, @biffs};
endif
results = {@results, e};
endfor
"The following is because the scheduler can BITE ME. --Nosredna";
fork (0)
for b in (biffs)
if ((ticks_left() < 10000) || (seconds_left() < 2))
suspend(1);
endif
if ($object_utils:has_callable_verb(b[1], "notify_mail"))
mnums = {};
for r in (listdelete(b, 1))
mnums = {@mnums, (rn = r in actual_rcpts) && results[rn]};
endfor
b[1]:notify_mail(from, listdelete(b, 1), mnums);
endif
endfor
endfork
return {1, @actual_rcpts};
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:mail_forward mail_notify this n/a this
who = args[1];
if ($object_utils:has_verb(who, verb))
return who:(verb)(@listdelete(args, 1));
else
return {};
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:touch this n/a this
"touch(name or list,seen) => does .last_used_time = time() if we haven't already touched this in the last hour";
{recip, ?seen = {}} = args;
if (typeof(recip) == LIST)
for r in (recip)
result = this:touch(r, seen);
$command_utils:suspend_if_needed(0);
endfor
else
if (((!valid(recip)) || (recip in seen)) || ((!is_player(recip)) && (!($mail_recipient in $object_utils:ancestors(recip)))))
"recip is neither a player nor a mailing list/folder";
else
if (fwd = this:mail_forward(recip))
this:touch(fwd, {@seen, recip});
endif
if (!is_player(recip))
recip.last_used_time = time();
endif
endif
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:look_self this n/a this
player:tell_lines(this.description);
for c in (this.contents)
$command_utils:suspend_if_needed(0);
c:look_self();
endfor
-------------------------------------------------------------------------------
#46 Mail Distribution Center:acceptable this n/a this
"Only allow mailing lists/folders in here and only if their names aren't already taken.";
what = args[1];
return ($object_utils:isa(what, $mail_recipient) && this:check_names(what, @what.aliases)) && (what:description() != parent(what):description());
-------------------------------------------------------------------------------
#46 Mail Distribution Center:check_names this n/a this
"...make sure the list has at least one usable name.";
"...make sure none of the aliases are already taken.";
{object, @aliases} = args;
if (typeof(object) == STR)
"... legacy; old version of this verb did not take on OBJ argument";
aliases = args;
endif
ok = 0;
if (length(aliases) > this.max_list_aliases)
player:tell("Mailing lists may not have more than ", this.max_list_aliases, " aliases.");
return 0;
endif
for a in (aliases)
sub1 = strsub(a, "_", "-");
sub2 = strsub(a, "-", "_");
if (sub1 == sub2)
check = 0;
else
check = 1;
endif
if (index(a, " "))
elseif (rp = $mail_agent:reserved_pattern(a))
player:tell("Mailing list name \"", a, "\" uses a reserved pattern: ", rp[1]);
return 0;
elseif (valid(p = $mail_agent:match(a, #-1)) && ((p != object) && (a in p.aliases)))
player:tell("Mailing list name \"", a, "\" in use on ", p.name, "(", p, ")");
return 0;
elseif (check && (valid(p = $mail_agent:match(sub1, #-1)) && ((p != object) && (sub1 in p.aliases))))
player:tell("Mailing list name \"", sub1, "\" in use on ", p.name, "(", p, ")");
return 0;
elseif (check && (valid(p = $mail_agent:match(sub2, #-1)) && ((p != object) && (sub2 in p.aliases))))
player:tell("Mailing list name \"", sub2, "\" in use on ", p.name, "(", p, ")");
return 0;
else
ok = 1;
endif
endfor
return ok;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:match_old match this n/a this
":match(string) => mailing list object in here that matches string.";
":match(string,player) => similar but also matches against player's private mailing lists (as kept in .mail_lists).";
if (!(string = args[1]))
return $nothing;
elseif (string[1] == "*")
string = string[2..$];
endif
if (valid(o = $string_utils:literal_object(string)) && ($mail_recipient in $object_utils:ancestors(o)))
return o;
elseif (rp = this:reserved_pattern(string))
return rp[2]:match_mail_recipient(string);
else
if (valid(who = {@args, player}[2]) && (typeof(use = `who.mail_lists ! E_PROPNF, E_PERM') == LIST))
use = {@this.contents, @use};
else
use = this.contents;
endif
partial = 1;
string = strsub(string, "_", "-");
for l in (use)
if (string in l.aliases)
return l;
endif
if (partial != $ambiguous_match)
for a in (l.aliases)
if ((index(a, string) == 1) && (!index(a, " ")))
if (partial)
partial = l;
elseif (partial != l)
partial = $ambiguous_match;
endif
endif
$command_utils:suspend_if_needed(0);
endfor
endif
endfor
return partial && $failed_match;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:match_recipient this n/a this
":match_recipient(string[,meobj]) => $player or $mail_recipient object that matches string.  Optional second argument (defaults to player) is returned in the case string==\"me\" and is also used to obtain a list of private $mail_recipients to match against.";
{string, ?me = player} = args;
if (valid(me) && ($failed_match != (o = me:my_match_recipient(string))))
return o;
elseif (!string)
return $nothing;
elseif ((string[1] == "*") && (string != "*"))
return this:match(@args);
elseif (string[1] == "`")
args[1][1..1] = "";
return $string_utils:match_player(@args);
elseif (valid(o = $string_utils:match_player(@args)) || (o == $ambiguous_match))
return o;
else
return this:match(@args);
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:match_failed this n/a this
{match_result, string, ?cmd_id = ""} = args;
cmd_id = cmd_id || "";
if (match_result == $nothing)
player:tell(cmd_id, "You must specify a valid mail recipient.");
elseif (match_result == $failed_match)
player:tell(cmd_id, "There is no mail recipient called \"", string, "\".");
elseif (match_result == $ambiguous_match)
if ((nostar = index(string, "*") != 1) && (lst = $player_db:find_all(string)))
player:tell(cmd_id, "\"", string, "\" could refer to ", (length(lst) > 20) ? tostr("any of ", length(lst), " players") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", lst), "no one", " or "), ".");
else
player:tell(cmd_id, "I don't know which \"", nostar ? "*" | "", string, "\" you mean.");
endif
elseif (!valid(match_result))
player:tell(cmd_id, match_result, " does not exist.");
else
return 0;
endif
return 1;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:make_message this n/a this
":make_message(sender,recipients,subject/replyto/additional-headers,body)";
" => message in the form as it will get sent.";
{from, recips, hdrs, body} = args;
try
fromowner = from.owner;
except (E_INVIND)
raise(E_PERM);
endtry
fromline = this:name_list(from);
if (typeof(recips) != LIST)
recips = {recips};
endif
recips = this:name_list(@recips);
others = {};
replyto = 0;
if (typeof(hdrs) != LIST)
hdrs = {hdrs};
endif
subj = hdrs[1];
if (!valid(from))
others = {"Probable-Sender:   " + this:name(fromowner)};
"  others = {'Possible-Sender:   ' + this:name(player)}";
"  if (caller_perms() != player)";
"    others = {@others, 'Possible-Sender:   ' + this:name(caller_perms())}";
"  endif";
elseif (!is_player(from))
others = {"Sender:   " + this:name(from.owner)};
endif
replyto = {@hdrs, 0}[2] && this:name_list(@hdrs[2]);
if (length(hdrs) > 2)
hdrs[1..2] = {};
for h in (hdrs)
if (match(h[1], "[a-z1-9-]+"))
others = {@others, $string_utils:left(h[1] + ": ", 15) + h[2]};
endif
endfor
endif
if (typeof(body) != LIST)
body = body ? {body} | {};
endif
return {this:time(), fromline, recips, subj || " ", @replyto ? {"Reply-to: " + replyto} | {}, @others, "", @body};
-------------------------------------------------------------------------------
#46 Mail Distribution Center:name this n/a this
what = args[1];
if (!valid(what))
name = "???";
elseif ((!is_player(what)) && $object_utils:has_callable_verb(what, "mail_name"))
name = what:mail_name();
else
name = what.name;
endif
while (m = match(name, "(#[0-9]+)"))
{s, e} = m[1..2];
name[s..e] = "";
endwhile
return tostr(name, " (", what, ")");
-------------------------------------------------------------------------------
#46 Mail Distribution Center:name_list this n/a this
return $string_utils:english_list($list_utils:map_arg(this, "name", args), "no one");
-------------------------------------------------------------------------------
#46 Mail Distribution Center:parse_address_field this n/a this
":parse_address_field(string) => list of objects";
"This is the standard routine for parsing address lists that appear in From:, To: and Reply-To: lines";
objects = {};
string = args[1];
while (m = match(string, "(#[0-9]+)"))
{s, e} = m[1..2];
if (#0 != (o = toobj(string[s + 1..e - 1])))
objects = {@objects, o};
endif
string = string[e + 1..$];
endwhile
return objects;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:display_seq_full this n/a this
":display_seq_full(msg_seq[,preamble]) => {cur, last-read-date}";
"This is the default message display routine.";
"Prints entire messages on folder (caller) to player.  msg_seq is the handle returned by :parse_message_seq(...) and indicates which messages should be printed.  preamble, if given will precede the output of the message itself, in which case the message number will be substituted for \"%d\".  Returns the number of the final message in the sequence (which can be then used as the new current message number).";
set_task_perms(caller_perms());
{msg_seq, ?preamble = ""} = args;
cur = date = 0;
for x in (msgs = caller:messages_in_seq(msg_seq))
cur = x[1];
date = x[2][1];
player:display_message(preamble ? strsub(preamble, "%d", tostr(cur)) | {}, caller:msg_full_text(@x[2]));
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
return {cur, date};
-------------------------------------------------------------------------------
#46 Mail Distribution Center:display_seq_headers this n/a this
":display_seq_headers(msg_seq[,cur[,last_read_date]])";
"This is the default header display routine.";
"Prints a list of headers of messages on caller to player.  msg_seq is the handle returned by caller:parse_message_seq(...).  cur is the player's current message.  last_read_date is the date of the last of the already-read messages.";
set_task_perms(caller_perms());
{msg_seq, ?cur = 0, ?last_old = $maxint} = args;
keep_seq = {@$seq_utils:contract(caller:kept_msg_seq(), $seq_utils:complement(msg_seq, 1, caller:length_all_msgs())), $maxint};
k = 1;
mcount = 0;
width = player:linelen() || 79;
for x in (msgs = caller:messages_in_seq(msg_seq))
if (keep_seq[k] <= (mcount = mcount + 1))
k = k + 1;
endif
annot = ((d = x[2][1]) > last_old) ? "+" | ((k % 2) ? " " | "=");
line = tostr($string_utils:right(x[1], 4, (cur == x[1]) ? ">" | " "), ":", annot, " ", caller:msg_summary_line(@x[2]));
player:tell(line[1..min(width, $)]);
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
player:tell("----+");
-------------------------------------------------------------------------------
#46 Mail Distribution Center:rm_message_seq this n/a this
":rm_message_seq(msg_seq)  removes the given sequence of from folder (caller)";
"...removed messages are saved in .messages_going for possible restoration.";
set_task_perms(caller_perms());
old = caller.messages;
new = save = nums = {};
next = 1;
for i in [1..length(seq = args[1]) / 2]
if ($command_utils:running_out_of_time())
player:tell("... rmm ", old[next][1] - 1);
suspend(0);
endif
start = seq[(2 * i) - 1];
new = {@new, @old[next..start - 1]};
save = {@save, {start - next, old[start..(next = seq[2 * i]) - 1]}};
nums = {@nums, old[start][1], old[next - 1][1] + 1};
endfor
new = {@new, @old[next..$]};
$command_utils:suspend_if_needed(0, "... rmm ...");
save_kept = $seq_utils:intersection(caller.messages_kept, seq);
$command_utils:suspend_if_needed(0, "... rmm ...");
new_kept = $seq_utils:contract(caller.messages_kept, seq);
$command_utils:suspend_if_needed(0, "... rmm ...");
caller.messages_going = save_kept ? {save_kept, save} | save;
caller.messages = new;
caller.messages_kept = new_kept;
if ($object_utils:has_callable_verb(caller, "_fix_last_msg_date"))
caller:_fix_last_msg_date();
endif
return $seq_utils:tostr(nums);
-------------------------------------------------------------------------------
#46 Mail Distribution Center:undo_rmm this n/a this
":undo_rmm()  restores previously deleted messages in .messages_going to .messages.";
set_task_perms(caller_perms());
old = caller.messages;
going = caller.messages_going;
new = seq = {};
last = 0;
next = 1;
"there are two possible formats here:";
"OLD: {{n,msgs},{n,msgs},...}";
"NEW: {kept_seq, {{n,msgs},{n,msgs},...}}";
if (going && ((!going[1]) || (typeof(going[1][2]) == INT)))
kept = going[1];
going = going[2];
else
kept = {};
endif
for s in (going)
new = {@new, @old[last + 1..last + s[1]], @s[2]};
last = last + s[1];
seq = {@seq, next + s[1], next = length(new) + 1};
endfor
caller.messages = {@new, @old[last + 1..$]};
caller.messages_going = {};
caller.messages_kept = $seq_utils:union(kept, $seq_utils:expand(caller.messages_kept, seq));
if ($object_utils:has_callable_verb(caller, "_fix_last_msg_date"))
caller:_fix_last_msg_date();
endif
return seq;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:expunge_rmm list_rmm this n/a this
":list_rmm()    displays contents of .messages_going.";
":expunge_rmm() destroys contents of .messages_going once and for all.";
"... both return the number of messages in .messages_going.";
set_task_perms(caller_perms());
cmg = caller.messages_going;
if (cmg && ((!cmg[1]) || (typeof(cmg[1][2]) == INT)))
kept = cmg[1];
cmg = cmg[2];
else
kept = {};
endif
if (verb == "expunge_rmm")
caller.messages_going = {};
count = 0;
for s in (cmg)
count = count + length(s[2]);
endfor
return count;
elseif (!cmg)
return 0;
else
msgs = seq = {};
next = 1;
for s in (cmg)
msgs = {@msgs, @s[2]};
seq = {@seq, next = next + s[1], next = next + length(s[2])};
endfor
kept = {@$seq_utils:contract(kept, $seq_utils:complement(seq, 1, $seq_utils:last(seq))), $maxint};
k = 1;
mcount = 0;
for x in (msgs)
if (kept[k] <= (mcount = mcount + 1))
k = k + 1;
endif
player:tell($string_utils:right(x[1], 4), ":", (k % 2) ? "  " | "= ", caller:msg_summary_line(@x[2]));
if ((ticks_left() < 500) || (seconds_left() < 2))
suspend(0);
endif
endfor
if (msgs)
player:tell("----+");
endif
return length(msgs);
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:renumber this n/a this
":renumber([cur]) -- assumes caller is a $mail_recipient or a $player.";
"...renumbers caller.messages, doing a suspend() if necessary.";
"...returns {number of messages,new cur}.";
set_task_perms(caller_perms());
{?cur = 0} = args;
caller.messages_going = {};
"... blow away @rmm'ed messages since there's no way to tell what their new numbers should be...";
msgs = caller.messages;
if (cur)
cur = $list_utils:iassoc_sorted(cur, msgs);
endif
while (1)
"...find first out-of-sequence message...";
l = 0;
r = (len = length(msgs)) + 1;
while ((r - 1) > l)
if (msgs[i = (r + l) / 2][1] > i)
r = i;
else
l = i;
endif
endwhile
"... r == first out-of-sequence, l == last in-sequence, l+1 == r ...";
if (l >= len)
return {l, cur};
endif
"...renumber as many messages as we have time for...";
chunk = {};
while (((r <= len) && (ticks_left() > 3000)) && (seconds_left() > 2))
for x in (msgs[r..min(r + 9, len)])
chunk = {@chunk, {r, x[2]}};
r = r + 1;
endfor
endwhile
caller.messages = {@msgs[1..l], @chunk, @msgs[r..len]};
if (chunk)
player:tell("...(renumbering ", l + 1, " -- ", r - 1, ")");
suspend(0);
else
player:tell("You lose.  This message collection is just too big.");
return;
endif
"... have to be careful since new mail may be received at this point...";
msgs = caller.messages;
endwhile
-------------------------------------------------------------------------------
#46 Mail Distribution Center:msg_summary_line this n/a this
":msg_summary_line(@msg) => date/from/subject as a single string.";
body = ("" in {@args, ""}) + 1;
if ((body > length(args)) || (!(subject = args[body])))
subject = "(None.)";
endif
if (args[1] < (time() - 31536000))
c = player:ctime(args[1]);
date = c[5..11] + c[21..25];
else
date = player:ctime(args[1])[5..16];
endif
from = args[2];
if (args[4] != " ")
subject = args[4];
endif
return tostr(date, "   ", $string_utils:left(from, 20), "   ", subject);
-------------------------------------------------------------------------------
#46 Mail Distribution Center:parse_message_seq this n/a this
"parse_message_seq(strings,cur[,last_old])";
"This is the default <message-sequence> parsing routine for those mail commands that refer to sequences of messages (@mail, @read,...) on a folder.";
"  caller (the folder) is assumed to be a $mail_recipient or a player.";
"  strings is the <message-sequence> portion of the arg list.";
"  cur is the number of the player's current message for this folder.";
"Returns a string error message if the parse fails, otherwise";
"returns a list {msg_seq, @unused_strings}, where";
"   msg_seq is a handle understood by caller:display_seq_full/headers(), and ";
"   unused_strings is the list of remaining uninterpreted strings";
set_task_perms(caller_perms());
{strings, ?cur = 0, ?last_old = 0} = args;
if (!(nummsgs = caller:length_all_msgs()))
return "%f %<has> no messages.";
elseif (typeof(strings) != LIST)
strings = {strings};
endif
seq = result = {};
mode = #0;
"... changes to 0 if we start seeing message numbers, to 1 if we see masks...";
keywords = ":from:%from:to:%to:subject:body:before:after:since:until:first:last:kept:unkept";
keyalist = {{1, "from"}, {6, "%from"}, {12, "to"}, {15, "%to"}, {19, "subject"}, {27, "body"}, {32, "before"}, {39, "after"}, {45, "since"}, {51, "until"}, {57, "first"}, {63, "last"}, {68, "kept"}, {73, "unkept"}};
strnum = 0;
for string in (strings)
strnum = strnum + 1;
$command_utils:suspend_if_needed(0);
if (string && ((c = index(string, ":")) && ((k = index(keywords, ":" + string[1..c - 1])) && (k == rindex(keywords, ":" + string[1..c - 1])))))
"...we have a mask to apply...";
keywd = $list_utils:assoc(k, keyalist)[2];
if (mode == #0)
seq = {1, nummsgs + 1};
endif
mode = 1;
if (k <= 27)
"...from, subject, to, body...";
pattern = string[c + 1..$];
if (keywd in {"subject", "body"})
elseif (keywd[1] == "%")
pattern = $string_utils:explode(pattern, "|");
else
pattern = this:((keywd == "to") ? "_parse_to" | "_parse_from")(pattern);
if (typeof(pattern) == STR)
return pattern;
endif
endif
seq = caller:(keywd + "_msg_seq")(pattern, seq);
if (typeof(seq) == STR)
if (strnum == 1)
return seq;
else
seq = {};
endif
endif
elseif (k <= 51)
"...before, since, after, until...";
if (typeof(date = this:_parse_date(string[c + 1..$])) != INT)
return tostr("Bad date `", string, "':  ", date);
endif
s = caller:length_date_le((keywd in {"before", "since"}) ? date - 1 | (date + 86399));
if (keywd in {"before", "until"})
seq = $seq_utils:remove(seq, s + 1, nummsgs);
else
seq = $seq_utils:remove(seq, 1, s);
endif
elseif (k <= 63)
"...first, last...";
if (n = toint(string[c + 1..$]))
seq = $seq_utils:(keywd + "n")(seq, n);
else
return tostr("Bad number in `", string, "'");
endif
else
"...kept, unkept...";
if (c < length(string))
return tostr("Unexpected junk after `", keywd, ":'");
elseif ((!(seq = caller:(keywd + "_msg_seq")(seq))) && (strnum == 1))
return tostr("%f %<has> no ", keywd, " messages.");
endif
endif
else
"...continue building the present sequence...";
if (mode)
seq && (result = $seq_utils:union(result, seq));
seq = {};
endif
mode = 0;
if (!string)
"...default case for @read: get the current message but skip to the next one if it's not there...";
if (cur)
i = min(caller:length_num_le(cur - 1) + 1, nummsgs);
seq = $seq_utils:add(seq, i, i);
else
return "%f %<has> no current message.";
endif
elseif ((index(string, "next") == 1) && (!index(string, "-")))
string[1..4] = "";
if ((n = string ? toint(string) | 1) <= 0)
return tostr("Bad number `", string, "'");
elseif ((i = caller:length_num_le(cur) + 1) <= nummsgs)
seq = $seq_utils:add(seq, i, min((i + n) - 1, nummsgs));
else
return "%f %<has> no next message.";
endif
elseif ((index(string, "prev") == 1) && (!index(string, "-")))
string[1..4] = "";
if ((n = string ? toint(string) | 1) <= 0)
return tostr("Bad number `", string, "'");
elseif (i = caller:length_num_le(cur - 1))
seq = $seq_utils:add(seq, max(1, (i - n) + 1), i);
else
return "%f %<has> no previous message.";
endif
elseif (string == "new")
s = last_old ? caller:length_date_le(last_old) | caller:length_num_le(cur);
if (s < nummsgs)
seq = $seq_utils:add(seq, s + 1, nummsgs);
else
return "%f %<has> no new messages.";
endif
elseif (string == "first")
seq = $seq_utils:add(seq, 1, 1);
elseif (n = toint(string) || (((string in {"last", "$"}) && -1) || ((string == "cur") && cur)))
if (n <= 0)
seq = $seq_utils:add(seq, max(0, nummsgs + n) + 1, nummsgs);
elseif (i = caller:exists_num_eq(n))
seq = $seq_utils:add(seq, i, i);
else
return (string == "cur") ? "%f's current message has been removed." | tostr("%f %<has> no message numbered `", string, "'.");
endif
elseif (((i = index(string, "..")) > 1) || ((i = index(string, "-")) > 1))
if ((start = toint(sst = string[1..i - 1])) > 0)
s = caller:length_num_le(start - 1);
elseif (sst in {"next", "prev", "cur"})
s = max(0, caller:length_num_le(cur - (sst != "next")) - (sst == "prev"));
elseif (sst in {"last", "$"})
s = nummsgs - 1;
elseif (sst == "first")
s = 0;
else
return {$seq_utils:union(result, seq), @strings[strnum..$]};
endif
j = (string[i] == ".") ? i + 2 | (i + 1);
if ((end = toint(est = string[j..$])) > 0)
e = caller:length_num_le(end);
elseif (est in {"next", "prev", "cur"})
e = min(nummsgs, caller:length_num_le(cur - (est == "prev")) + (est == "next"));
elseif (est in {"last", "$"})
e = nummsgs;
elseif (est == "first")
e = 1;
else
return {$seq_utils:union(result, seq), @strings[strnum..$]};
endif
if (s < e)
seq = $seq_utils:add(seq, s + 1, e);
else
return tostr("%f %<has> no messages in range ", string, ".");
endif
elseif (string == "cur")
return "%f %<has> no current message.";
else
return {$seq_utils:union(result, seq), @strings[strnum..$]};
endif
endif
endfor
return {$seq_utils:union(result, seq)};
-------------------------------------------------------------------------------
#46 Mail Distribution Center:_parse_from _parse_to this n/a this
":_parse_from(string with |'s in it) => object list";
":_parse_to(string with |'s in it) => object list";
"  for from:string and to:string items in :parse_message_seq";
if (verb == "_parse_to")
match_obj = fail_obj = this;
match_verb = "match_recipient";
fail_verb = "match_failed";
else
match_obj = $string_utils;
match_verb = "match_player";
fail_obj = $command_utils;
fail_verb = "player_match_failed";
endif
plist = {};
for w in ($string_utils:explode(args[1], "|"))
if (fail_obj:(fail_verb)(p = match_obj:(match_verb)(w), w))
p = $string_utils:literal_object(w);
if ((p == $failed_match) || (!$command_utils:yes_or_no("Continue? ")))
return "Bad address list:  " + args[1];
endif
endif
plist = setadd(plist, p);
endfor
return plist;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:_parse_date this n/a this
words = $string_utils:explode(args[1], "-");
if (length(words) == 1)
if (index("yesterday", words[1]) == 1)
time = $time_utils:dst_midnight((time() - (time() % 86400)) - 86400);
elseif (index("today", words[1]) == 1)
time = $time_utils:dst_midnight(time() - (time() % 86400));
elseif (typeof(time = $time_utils:from_day(words[1], -1)) == ERR)
time = "weekday, `Today', `Yesterday', or date expected.";
endif
elseif ((!words) || ((length(words) > 3) || ((!toint(words[1])) || (E_TYPE == (year = $code_utils:toint({@words, "-1"}[3]))))))
time = "Date should be of the form `5-Jan', `5-Jan-92', `Wed',`Wednesday'";
else
day = toint(words[1]);
time = $time_utils:dst_midnight($time_utils:from_month(words[2], -1, day));
if (length(words) == 3)
thisyear = toint(ctime(time)[21..24]);
if (100 > year)
year = (thisyear + 50) - (((thisyear - year) + 50) % 100);
endif
time = $time_utils:dst_midnight($time_utils:from_month(words[2], (year - thisyear) - (year <= thisyear), day));
endif
endif
return time;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:new_message_num this n/a this
":new_message_num() => number that the next incoming message will receive.";
set_task_perms(caller_perms());
new = (msgs = caller.messages) ? msgs[$][1] + 1 | 1;
if (rmsgs = caller.messages_going)
if ((!rmsgs[1]) || (typeof(rmsgs[1][2]) == INT))
rmsgs = rmsgs[2];
endif
lbrm = rmsgs[$][2];
return max(new, lbrm[$][1] + 1);
else
return new;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:length_all_msgs this n/a this
set_task_perms(caller_perms());
return length(caller.messages);
-------------------------------------------------------------------------------
#46 Mail Distribution Center:length_date_le this n/a this
set_task_perms(caller_perms());
date = args[1];
msgs = caller.messages;
if ((r = length(caller.messages)) < 25)
for l in [1..r]
if (msgs[l][2][1] > date)
return l - 1;
endif
endfor
return r;
else
l = 1;
while (l <= r)
if (date < msgs[i = (r + l) / 2][2][1])
r = i - 1;
else
l = i + 1;
endif
endwhile
return r;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:length_date_gt this n/a this
set_task_perms(caller_perms());
date = args[1];
msgs = caller.messages;
if ((len = length(caller.messages)) < 25)
for r in [0..len - 1]
if (msgs[len - r][2][1] <= date)
return r;
endif
endfor
return len;
else
l = 1;
r = len;
while (l <= r)
if (date < msgs[i = (r + l) / 2][2][1])
r = i - 1;
else
l = i + 1;
endif
endwhile
return len - r;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:length_num_le this n/a this
":length_num_le(num) => number of messages in folder numbered <= num";
set_task_perms(caller_perms());
return $list_utils:iassoc_sorted(args[1], caller.messages);
-------------------------------------------------------------------------------
#46 Mail Distribution Center:exists_num_eq this n/a this
":exists_num_eq(num) => index of message in folder numbered == num";
set_task_perms(caller_perms());
return (i = $list_utils:iassoc_sorted(args[1], caller.messages)) && ((caller.messages[i][1] == args[1]) && i);
-------------------------------------------------------------------------------
#46 Mail Distribution Center:from_msg_seq this n/a this
":from_msg_seq(object or list[,mask])";
" => msg_seq of messages from any of these senders";
set_task_perms(caller_perms());
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
fseq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
fromline = msg[2][2];
for f in ($mail_agent:parse_address_field(fromline))
if (f in plist)
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:%from_msg_seq this n/a this
":%from_msg_seq(string or list of strings[,mask])";
" => msg_seq of messages with one of these strings in the from line";
set_task_perms(caller_perms());
{nlist, ?mask = {1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
i = 1;
fseq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
fromline = " " + msg[2][2];
for n in (nlist)
if (index(fromline, n))
fseq = $seq_utils:add(fseq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return fseq || ("%f %<has> no messages from " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:to_msg_seq this n/a this
":to_msg_seq(object or list[,mask]) => msg_seq of messages to those people";
set_task_perms(caller_perms());
{plist, ?mask = {1}} = args;
if (typeof(plist) != LIST)
plist = {plist};
endif
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
toline = msg[2][3];
for r in ($mail_agent:parse_address_field(toline))
if (r in plist)
seq = $seq_utils:add(seq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", plist), "no one", " or "));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:%to_msg_seq this n/a this
":%to_msg_seq(string or list of strings[,mask])";
" => msg_seq of messages containing one of strings in the to line";
set_task_perms(caller_perms());
{nlist, ?mask = {1}} = args;
if (typeof(nlist) != LIST)
nlist = {nlist};
endif
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
toline = " " + msg[2][3];
for n in (nlist)
if (index(toline, n))
seq = $seq_utils:add(seq, i, i);
endif
endfor
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || ("%f %<has> no messages to " + $string_utils:english_list($list_utils:map_arg($string_utils, "print", nlist), "no one", " or "));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:subject_msg_seq this n/a this
":subject_msg_seq(target) => msg_seq of messages with target in the Subject:";
set_task_perms(caller_perms());
{target, ?mask = {1}} = args;
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ((length(mask) < 2) || (i < mask[2]))
subject = msg[2][4];
if (index(subject, target))
seq = $seq_utils:add(seq, i, i);
endif
else
mask = mask[3..$];
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || (("%f %<has> no messages with subjects containing `" + target) + "'");
-------------------------------------------------------------------------------
#46 Mail Distribution Center:body_msg_seq this n/a this
":body_msg_seq(target[,mask]) => msg_seq of messages with target in the body";
set_task_perms(caller_perms());
{target, ?mask = {1}} = args;
i = 1;
seq = {};
for msg in (caller.messages)
if ((!mask) || (i < mask[1]))
elseif ({@mask, $maxint}[2] <= i)
mask = mask[3..$];
"Old code follows. Lets save ticks and munge up the whole message body into one big string and index it. Don't need to know where target is in there, just that it is or isn't there";
elseif (((bstart = "" in (msg = msg[2])) && (length(msg) > bstart)) && index(tostr(@msg[bstart + 1..$]), target))
seq = $seq_utils:add(seq, i, i);
"elseif ((bstart = \"\" in (msg = msg[2])) && (l = length(msg)) > bstart)";
"while (!index(msg[l], target) && (l = l - 1) > bstart)";
"$command_utils:suspend_if_needed(0);";
"endwhile";
"if (l > bstart)";
"seq = $seq_utils:add(seq, i, i);";
"endif";
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endfor
return seq || tostr("%f %<has> no messages containing `", target, "' in the body.");
-------------------------------------------------------------------------------
#46 Mail Distribution Center:messages_in_seq this n/a this
":messages_in_seq(msg_seq) => list of messages in msg_seq on folder (caller)";
set_task_perms(caller_perms());
if (typeof(msgs = args[1]) != LIST)
return caller.messages[msgs];
elseif (length(msgs) == 2)
return caller.messages[msgs[1]..msgs[2] - 1];
else
return $seq_utils:extract(msgs, caller.messages);
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:__convert_new this n/a this
":__convert_new(@msg) => msg in new format (if it isn't already)";
"               ^ don't forget the @ here.";
"If the msg is already in the new format it passes through unchanged.";
"If the msg format is unrecognizable, warnings are printed.";
if (typeof(date = args[1]) != INT)
date = 0;
start = 1;
else
start = 2;
if (!((colon = index(args[2], ":")) && (args[2][1..colon] in {"From:", "To:", "Subject:"})))
return args;
endif
endif
from = to = 0;
subject = " ";
blank = "" in {@args, ""};
newhdr = {};
for line in (args[start..blank - 1])
if (index(line, "Date:") == 1)
if (date)
player:notify("Warning: two dates?");
endif
date = $time_utils:from_ctime(line[6..$]);
elseif (index(line, "From:") == 1)
if (from)
player:notify("Warning: two from-lines?");
endif
from = $string_utils:triml(line[6..$]);
elseif (index(line, "To:") == 1)
if (to)
player:notify("Warning: two to-lines?");
endif
to = $string_utils:triml(line[6..$]);
elseif (index(line, "Subject:") == 1)
subject = $string_utils:triml(line[9..$]);
else
newhdr = {@newhdr, line};
endif
endfor
if (!from)
player:notify("Warning: no from-line.");
endif
if (!to)
player:notify("Warning: no to-line.");
endif
return {date, from, to, subject, @newhdr, @args[blank..$]};
-------------------------------------------------------------------------------
#46 Mail Distribution Center:to_text this n/a this
":to_text(@msg) => message in text form (suitable for printing)";
return {"Date:     " + player:ctime(args[1]), "From:     " + args[2], "To:       " + args[3], @(args[4] == " ") ? {} | {"Subject:  " + args[4]}, @args[5..$]};
-------------------------------------------------------------------------------
#46 Mail Distribution Center:is_readable_by is_writable_by is_usable_by this n/a this
what = args[1];
if ($object_utils:isa(what, $mail_recipient))
return what:(verb)(@listdelete(args, 1));
else
"...it's a player:";
"...  anyone can send mail to it.";
"...  only the player itself or a wizard can read it.";
return (verb == "is_usable_by") || $perm_utils:controls(args[2], what);
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:reserved_pattern this n/a this
":reserved_pattern(string)";
"  if string matches one of the reserved patterns for mailing list names, ";
"  we return that element of .reserved_patterns.";
string = args[1];
for p in (this.reserved_patterns)
if (match(string, p[1]))
return p;
endif
endfor
return 0;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:is_recipient this n/a this
return valid(what = args[1]) && (($mail_recipient_class in (ances = $object_utils:ancestors(what))) || ($mail_recipient in ances));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:keep_message_seq this n/a this
":keep_message_seq(msg_seq)";
"...If msg_seq nonempty {}, this marks the indicated messages on this folder (caller)";
"...as immune from expiration.";
"...If msg_seq == {}, this clears all such marks.";
set_task_perms(caller_perms());
msg_seq = args[1];
if (!msg_seq)
caller.messages_kept = {};
return 1;
endif
prev_kept = caller.messages_kept;
caller.messages_kept = new_kept = $seq_utils:union(prev_kept, msg_seq);
added = $seq_utils:intersection(new_kept, $seq_utils:complement(prev_kept));
if (!added)
return "";
endif
"... urk.  now we need to get the actual numbers of the messages being kept.";
nums = {};
start = 0;
for a in (added)
nums = {@nums, (start = !start) ? caller:messages_in_seq(a)[1] | (caller:messages_in_seq(a - 1)[1] + 1)};
endfor
return $seq_utils:tostr(nums);
-------------------------------------------------------------------------------
#46 Mail Distribution Center:kept_msg_seq unkept_msg_seq this n/a this
":kept_msg_seq([mask])";
" => msg_seq of messages that are marked kept";
":unkept_msg_seq([mask])";
" => msg_seq of messages that are not marked kept";
set_task_perms(caller_perms());
{?mask = {1}} = args;
if (k = verb == "kept_msg_seq")
kseq = $seq_utils:intersection(mask, caller.messages_kept);
else
kseq = $seq_utils:intersection(mask, $seq_utils:range(1, caller:length_all_msgs()), $seq_utils:complement(caller.messages_kept));
endif
return kseq;
-------------------------------------------------------------------------------
#46 Mail Distribution Center:msg_seq_to_msg_num_string this n/a this
":msg_seq_to_msg_num_string(msg_seq) => string giving the corresponding message numbers";
set_task_perms(caller_perms());
return $seq_utils:tostr($seq_utils:from_list($list_utils:slice(caller:messages_in_seq(args[1]))));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:msg_seq_to_msg_num_list this n/a this
":msg_seq_to_msg_num_list(msg_seq) => list of corresponding message numbers";
set_task_perms(caller_perms());
return $list_utils:slice(caller:messages_in_seq(args[1]));
-------------------------------------------------------------------------------
#46 Mail Distribution Center:send_log_message this n/a this
"send_log_message(perms,from,rcpt-list,hdrs,msg) -- formats and sends a mail message. hders is either the text of the subject line, or a {subject,{reply-to,...}} list.";
"KLUDGE.  this may go away.";
"Send a message while supplying a different permission for use by :mail_forward to determine moderation action.";
"Return E_PERM unless called by a wizard.";
"Return {0, @invalid_rcpts} if rcpt-list contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{perms, from, to, hdrs, msg} = args;
if (caller_perms().wizard)
text = $mail_agent:make_message(from, to, hdrs, msg);
return this:raw_send(text, to, perms);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:parse_misc_headers this n/a this
":parse_misc_headers(msg,@extract_names)";
"Extracts the miscellaneous (i.e., not including Date: From: To: Subject:)";
"from msg (a mail message in the usual transmission format).";
"Extract_names is a list of header names";
"=> {other_headers,bogus_headers,extract_texts,body}";
"where each element of extract_texts is a string or 0";
"  according as the corresponding header in extract_names is present.";
"bogus_headers is a list of those headers that are undecipherable";
"other_headers is a list of {header_name,header_text} for the remaining";
"  miscellaneous headers.";
"headers in msg";
msgtxt = args[1];
extract_names = listdelete(args, 1);
extract_texts = $list_utils:make(length(extract_names));
heads = bogus = {};
for h in (msgtxt[5..(bstart = "" in {@msgtxt, ""}) - 1])
if (m = match(h, "%([a-z1-9-]+%): +%(.*%)"))
hname = h[m[3][1][1]..m[3][1][2]];
htext = h[m[3][2][1]..m[3][2][2]];
if (i = hname in extract_names)
extract_texts[i] = htext;
else
heads = {@heads, {hname, htext}};
endif
else
bogus = {@bogus, h};
endif
endfor
return {heads, bogus, extract_texts, msgtxt[bstart + 1..$]};
-------------------------------------------------------------------------------
#46 Mail Distribution Center:resend_message this n/a this
"resend_message(new_sender,new_rcpts,from,to,hdrs,body)";
" -- reformats and resends a previously sent message to new recipients.";
"msg is the previous message";
"Return E_PERM if new_sender isn't owned by the caller.";
"Return {0, @invalid_rcpts} if new_rcpts contains any invalid addresses.  No mail is sent in this case.";
"Return {1, @actual_rcpts} if successful.";
{new_sender, new_rcpts, from, to, hdrs, body} = args;
if (typeof(hdrs) != LIST)
hdrs = {hdrs, 0};
elseif (length(hdrs) < 2)
hdrs = {@hdrs || {""}, 0};
endif
hdrs[3..2] = {{"Resent-By", this:name_list(new_sender)}, {"Resent-To", this:name_list(@new_rcpts)}};
if ($perm_utils:controls(caller_perms(), new_sender))
text = $mail_agent:make_message(from, to, hdrs, body);
return this:raw_send(text, new_rcpts, new_sender);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:init_for_core this n/a this
if (caller_perms().wizard)
this.reserved_patterns = {};
this.last_mail_time = 0;
this.time_collisions = {0, 0};
pass(@args);
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:time this n/a this
"This was inspired by Xeric's port 4632 on *Core-DB-Issues";
now = time();
return now;
"skipping the below for now because the mail system's clock is getting very out of sync. suspect someone's playing games to run up the clock. HTC 6 Jan 2003";
if (caller == this)
if (now > this.last_mail_time)
return this.last_mail_time = now;
else
this.time_collisions[2] = this.time_collisions[2] + 1;
return this.last_mail_time = this.last_mail_time + 1;
endif
else
return now;
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:set_message_body_by_index this n/a this
":set_message_body_by_index(i,newbody)";
"Replaces the body of the i-th message on the (caller) recipient.";
"i must be a message index (not a message number) in the range 1 .. number of messages,";
"newbody must be a list of strings.";
set_task_perms(caller_perms());
{i, body} = args;
bstart = "" in caller.messages[i][2];
if (bstart)
caller.messages[i][2][bstart + 1..$] = body;
else
caller.messages[i][2][$ + 1..$] = {"", @body};
endif
-------------------------------------------------------------------------------
#46 Mail Distribution Center:get_message_body_by_index this n/a this
#46 Mail Distribution Center:message_body_by_index this n/a this
":message_body_by_index(i)";
"Return the body of the i-th message on the (caller) recipient.";
"i must be a message index (not a message number) in the range 1 .. number of messages,";
set_task_perms(caller_perms());
{i} = args;
msg = caller:messages_in_seq({i, i + 1})[1][2];
bstart = "" in msg;
return msg[bstart ? bstart + 1 | ($ + 1)..$];
-------------------------------------------------------------------------------
================================#47 Mail Room===============================================
#47 Mail Room.recipients  = MOOList [ ]
#47 Mail Room.replytos  = MOOList [ ]
#47 Mail Room.sending  = MOOList [ ]
#47 Mail Room.subjects  = MOOList [ ]
#47 Mail Room:working_on this n/a this
return this:ok(who = args[1]) && tostr("a letter ", this:sending(who) ? "(in transit) " | "", "to ", this:recipient_names(who), (subject = `this.subjects[who] ! ANY') && tostr(" entitled \"", subject, "\""));
-------------------------------------------------------------------------------
#47 Mail Room:parse_invoke this n/a this
"invoke(rcptstrings,verb[,subject]) for a @send";
"invoke(1,verb,rcpts,subject,replyto,body) if no parsing is needed";
"invoke(2,verb,msg,flags,replytos) for an @answer";
if (!(which = args[1]))
player:tell_lines({tostr("Usage:  ", args[2], " <list-of-recipients>"), tostr("        ", args[2], "                      to continue with a previous draft")});
elseif (typeof(which) == LIST)
"...@send...";
if (rcpts = this:parse_recipients({}, which))
if (replyto = player:mail_option("replyto"))
replyto = this:parse_recipients({}, replyto, ".mail_options: ");
endif
if (0 == (subject = {@args, 0}[3]))
if (player:mail_option("nosubject"))
subject = "";
else
player:tell("Subject:");
subject = $command_utils:read();
endif
endif
return {rcpts, subject, replyto, {}};
endif
elseif (which == 1)
return args[3..6];
elseif (!(to_subj = this:parse_msg_headers(msg = args[3], flags = args[4])))
else
include = {};
if ("include" in flags)
prefix = ">            ";
for line in ($mail_agent:to_text(@msg))
if (!line)
prefix = ">  ";
include = {@include, prefix};
else
include = {@include, @this:fill_string(">  " + line, 70, prefix)};
endif
endfor
endif
return {@to_subj, args[5], include};
endif
return 0;
-------------------------------------------------------------------------------
#47 Mail Room:init_session this n/a this
{who, recip, subj, replyto, msg} = args;
if (this:ok(who))
this.sending[who] = 0;
this.recipients[who] = recip;
this.subjects[who] = subj;
this.replytos[who] = replyto || {};
this:load(who, msg);
this.active[who]:tell("Composing ", this:working_on(who));
p = this.active[who];
"if (p:mail_option(\"enter\") && !args[5])";
"Changed from above so that @reply can take advantage of @mailoption +enter. Ho_Yan 11/9/94";
if (p:mail_option("enter"))
if (typeof(lines = $command_utils:read_lines()) == ERR)
p:tell(lines);
else
this:insert_line(p in this.active, lines, 0);
endif
endif
endif
-------------------------------------------------------------------------------
#47 Mail Room:pri*nt any n/a none
if (!dobjstr)
plyr = player;
elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
endif
if ((plyr != player) && (!this:readable(plyr in this.active)))
player:tell(plyr.name, "(", plyr, ") has not published anything here.");
elseif (typeof(msg = this:message_with_headers(plyr in this.active)) != LIST)
player:tell(msg);
else
player:display_message({((plyr == player) ? "Your" | tostr(plyr.name, "(", plyr, ")'s")) + " message so far:", ""}, player:msg_text(@msg));
endif
-------------------------------------------------------------------------------
#47 Mail Room:message_with_headers this n/a this
return (this:readable(who = args[1]) || this:ok(who)) && $mail_agent:make_message(this.active[who], this.recipients[who], {this.subjects[who], this.replytos[who]}, this:text(who));
-------------------------------------------------------------------------------
#47 Mail Room:subj*ect: any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (!argstr)
player:tell(this.subjects[who]);
elseif (ERR == typeof(subj = this:set_subject(who, argstr)))
player:tell(subj);
else
player:tell(subj ? ("Setting the subject line for your message to \"" + subj) + "\"." | "Deleting the subject line for your message.");
endif
-------------------------------------------------------------------------------
#47 Mail Room:set_subject this n/a this
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
this.subjects[who] = subj = args[2];
this:set_changed(who, 1);
return subj;
endif
-------------------------------------------------------------------------------
#47 Mail Room:sending this n/a this
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
elseif ((!(task = this.sending[who])) || $code_utils:task_valid(task))
return task;
else
"... uh oh... sending task crashed...";
this:set_changed(who, 1);
return this.sending[who] = 0;
endif
-------------------------------------------------------------------------------
#47 Mail Room:to*: any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (!args)
player:tell("Your message is currently to ", this:recipient_names(who), ".");
else
this.recipients[who] = this:parse_recipients({}, args);
this:set_changed(who, 1);
player:tell("Your message is now to ", this:recipient_names(who), ".");
endif
-------------------------------------------------------------------------------
#47 Mail Room:also*-to: cc*: any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
this.recipients[who] = this:parse_recipients(this.recipients[who], args);
this:set_changed(who, 1);
player:tell("Your message is now to ", this:recipient_names(who), ".");
endif
-------------------------------------------------------------------------------
#47 Mail Room:not-to*: uncc*: any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
recips = this.recipients[who];
nonmrs = {};
mrs = {};
for o in (recips)
if ($object_utils:isa(o, $mail_recipient))
mrs = {@mrs, o};
else
nonmrs = {@nonmrs, o};
endif
endfor
for a in (args)
if (!a)
player:tell("\"\"?");
return;
elseif (valid(aobj = $mail_agent:match_recipient(a)) && (aobj in recips))
elseif ($failed_match != (aobj = $string_utils:literal_object(a)))
if (!(aobj in recips))
player:tell(aobj, " was not a recipient.");
return;
endif
elseif ((a[1] == "*") && valid(aobj = $string_utils:match(a[2..$], mrs, "aliases")))
elseif ((a[1] != "*") && valid(aobj = $string_utils:match(a, nonmrs, "aliases")))
elseif (valid(aobj = $string_utils:match(a, recips, "aliases")))
else
player:tell("couldn't find \"", a, "\" in To: list.");
return;
endif
recips = setremove(recips, aobj);
endfor
this.recipients[who] = recips;
this:set_changed(who, 1);
player:tell("Your message is now to ", this:recipient_names(who), ".");
endif
-------------------------------------------------------------------------------
#47 Mail Room:parse_recipients this n/a this
"parse_recipients(prev_list,list_of_strings) -- parses list of strings and adds any resulting player objects to prev_list.  Optional 3rd arg is prefixed to any mismatch error messages";
{recips, l, ?cmd_id = ""} = args;
cmd_id = cmd_id || "";
for s in ((typeof(l) == LIST) ? l | {l})
if (typeof(s) != STR)
if ($mail_agent:is_recipient(s))
recips = setadd(recips, s);
else
player:tell(cmd_id, s, " is not a valid mail recipient.");
endif
elseif (!$mail_agent:match_failed(md = $mail_agent:match_recipient(s), s, cmd_id))
recips = setadd(recips, md);
endif
endfor
return recips;
-------------------------------------------------------------------------------
#47 Mail Room:recipient_names this n/a this
return this:ok(who = args[1]) && $mail_agent:name_list(@this.recipients[who]);
-------------------------------------------------------------------------------
#47 Mail Room:make_message this n/a this
return $mail_agent:make_message(@args);
-------------------------------------------------------------------------------
#47 Mail Room:name_list this n/a this
"(obsolete verb... see $mail_agent:name_list)";
return $mail_agent:(verb)(@args[1]);
-------------------------------------------------------------------------------
#47 Mail Room:parse_msg_headers this n/a this
"parse_msg_headers(msg,flags)";
"  parses msg to extract reply recipients and construct a subject line";
"  if the \"all\" flag is present, reply goes to all of the original recipients";
"  returns a list {recipients, subjectline} or 0 in case of error.";
{msg, flags} = args;
replyall = "all" in flags;
objects = {};
if ("followup" in flags)
"...look for first non-player recipient in To: line...";
for o in ($mail_agent:parse_address_field(msg[3]))
if (objects)
break o;
elseif ($object_utils:isa(o, $mail_recipient))
objects = {o};
endif
endfor
endif
objects = objects || $mail_agent:parse_address_field(msg[2] + (replyall ? msg[3] | ""));
for line in (msg[5..("" in {@msg, ""}) - 1])
if (rt = index(line, "Reply-to:") == 1)
objects = $mail_agent:parse_address_field(line);
endif
endfor
recips = {};
for o in (objects)
if (o == #0)
player:tell("Sorry, but I can't parse the header of that message.");
return 0;
elseif ((!valid(o)) || (!(is_player(o) || ($mail_recipient in $object_utils:ancestors(o)))))
player:tell(o, " is no longer a valid player or maildrop; ignoring that recipient.");
elseif (o != player)
recips = setadd(recips, o);
endif
endfor
subject = msg[4];
if (subject == " ")
subject = "";
elseif (subject && (index(subject, "Re: ") != 1))
subject = "Re: " + subject;
endif
return {recips, subject};
-------------------------------------------------------------------------------
#47 Mail Room:check_answer_flags this n/a this
flags = {};
for o in ({"all", "include", "followup"})
if (player:mail_option(o))
flags = {@flags, o};
endif
endfor
reply_to = player:mail_option("replyto") || {};
flaglist = "+1#include -1#noinclude +2#all -2#sender 0#replyto +3#followup ";
for a in (args)
if (i = index(a, "="))
value = a[i + 1..$];
a = a[1..i - 1];
else
value = "";
endif
if ((typeof(a) != STR) || ((i = index(flaglist, "#" + a)) < 3))
player:tell("Unrecognized answer/reply option:  ", a);
return 0;
elseif (i != rindex(flaglist, "#" + a))
player:tell("Ambiguous answer/reply option:  ", a);
return 0;
elseif (j = index("0123456789", flaglist[i - 1]) - 1)
if (value)
player:tell("Flag does not take a value:  ", a);
return 0;
endif
f = {"include", "all", "followup"}[j];
flags = (flaglist[i - 2] == "+") ? setadd(flags, f) | setremove(flags, f);
if (f == "all")
flags = setremove(flags, "followup");
endif
elseif ((!value) || (value = this:parse_recipients({}, $string_utils:explode(value), "replyto flag:  ")))
reply_to = value || {};
endif
endfor
return {flags, reply_to};
-------------------------------------------------------------------------------
#47 Mail Room:reply-to*: replyto*: any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
if (args)
this.replytos[who] = rt = this:parse_recipients({}, args);
this:set_changed(who, 1);
else
rt = this.replytos[who];
endif
player:tell(rt ? ("Replies will go to " + $mail_agent:name_list(@this.replytos[who])) + "." | "Reply-to field is empty.");
endif
-------------------------------------------------------------------------------
#47 Mail Room:send none n/a none
"WIZARDLY";
if (!(who = this:loaded(player)))
player:notify(this:nothing_loaded_msg());
elseif (!(recips = this.recipients[who]))
player:notify("Umm... your message isn't addressed to anyone.");
elseif (this:sending(who))
player:notify("Again? ... relax... it'll get there eventually.");
else
msg = this:message_with_headers(who);
this.sending[who] = old_sending = task_id();
this:set_changed(who, 0);
player:notify("Sending...");
"... this sucker can suspend BIG TIME...";
result = $mail_agent:raw_send(msg, recips, player);
"... the world changes...";
who = player in this.active;
if (who && (this.sending[who] == old_sending))
"... same editing session; no problemo...";
previous = "";
this.sending[who] = 0;
else
"... uh oh, different session... tiptoe quietly out...";
"... Don't mess with the session.";
previous = "(prior send) ";
endif
if (!(e = result[1]))
player:notify(tostr(previous, (typeof(e) == ERR) ? e | ("Bogus recipients:  " + $string_utils:from_list(result[2]))));
player:notify(tostr(previous, "Mail not sent."));
previous || this:set_changed(who, 1);
elseif (length(result) == 1)
player:notify(tostr(previous, "Mail not actually sent to anyone."));
previous || this:set_changed(who, 1);
else
player:notify(tostr(previous, "Mail actually sent to ", $mail_agent:name_list(@listdelete(result, 1))));
if (previous)
"...don't even think about it...";
elseif (player.location == this)
if (ticks_left() < 10000)
suspend(0);
endif
this:done();
elseif (!this:changed(who))
"... player is gone, no further edits...";
this:kill_session(who);
endif
endif
endif
-------------------------------------------------------------------------------
#47 Mail Room:who any n/a none
if (dobjstr)
if (!(recips = this:parse_recipients({}, args)))
"parse_recipients has already complained about anything it doesn't like";
return;
endif
elseif (caller != player)
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
else
recips = this.recipients[who];
endif
resolve = $mail_agent:resolve_addr(recips, player);
if (resolve[1])
player:tell("Bogus addresses:  ", $string_utils:english_list(resolve[1]));
else
player:tell(dobjstr ? ("Mail to " + $mail_agent:name_list(@recips)) + " actually goes to " | "Your mail will actually go to ", $mail_agent:name_list(@resolve[2]));
endif
-------------------------------------------------------------------------------
#47 Mail Room:showlists any n/a none
player:tell_lines({"Available aliases:", ""});
for c in ((dobjstr == "all") ? $object_utils:descendants($mail_recipient) | $mail_agent.contents)
if (c:is_usable_by(player) || c:is_readable_by(player))
c:look_self();
endif
endfor
-------------------------------------------------------------------------------
#47 Mail Room:subsc*ribe any any any
player:tell("This command is obsolete.  Use @subscribe instead.  See `help @subscribe'");
return;
if (!iobjstr)
player:tell("Usage:  ", verb, " [<list-of-people/lists>] to <list>");
return;
elseif ($mail_agent:match_failed(iobj = $mail_agent:match(iobjstr), iobjstr))
return;
endif
rstrs = dobjstr ? $string_utils:explode(dobjstr) | {"me"};
recips = this:parse_recipients({}, rstrs);
outcomes = iobj:add_forward(@recips);
if (typeof(outcomes) != LIST)
player:tell(outcomes);
return;
endif
added = {};
for r in [1..length(recips)]
if ((t = typeof(e = outcomes[r])) == OBJ)
added = setadd(added, recips[r]);
else
player:tell(verb, " ", recips[r].name, " to ", iobj.name, ":  ", e);
endif
endfor
if (added)
player:tell($string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%(name) (%#)", added)), " added to ", iobj.name, " (", iobj, ")");
endif
-------------------------------------------------------------------------------
#47 Mail Room:unsubsc*ribe any in/inside/into any
if (!iobjstr)
player:tell("Usage:  ", verb, " [<list-of-people/lists>] from <list>");
return;
elseif ($mail_agent:match_failed(iobj = $mail_agent:match(iobjstr), iobjstr))
return;
endif
rstrs = dobjstr ? $string_utils:explode(dobjstr) | {"me"};
recips = this:parse_recipients({}, rstrs);
outcomes = iobj:delete_forward(@recips);
if (typeof(outcomes) != LIST)
player:tell(outcomes);
return;
endif
removed = {};
for r in [1..length(recips)]
if (typeof(e = outcomes[r]) == ERR)
player:tell(verb, " ", recips[r].name, " from ", iobj.name, ":  ", (e == E_INVARG) ? "Not on list." | e);
else
removed = setadd(removed, recips[r]);
endif
endfor
if (removed)
player:tell($string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%(name) (%#)", removed)), " removed from ", iobj.name, " (", iobj, ")");
endif
-------------------------------------------------------------------------------
#47 Mail Room:retain_session_on_exit this n/a this
return this:ok(who = args[1]) && (this:sending(who) || pass(@args));
-------------------------------------------------------------------------------
#47 Mail Room:no_littering_msg this n/a this
"recall that this only gets called if :retain_session_on_exit returns true";
return (this:ok(who = player in this.active) && (!this:changed(who))) ? {"Your message is in transit."} | this.(verb);
-------------------------------------------------------------------------------
#47 Mail Room:local_editing_info this n/a this
lines = {"To:       " + (toline = $mail_agent:name_list(@args[1])), "Subject:  " + $string_utils:trim(subject = args[2])};
if (args[3])
lines = {@lines, "Reply-to: " + $mail_agent:name_list(@args[3])};
endif
lines = {@lines, "", @args[4]};
return {tostr("MOOMail", subject ? ("(" + subject) + ")" | (("-to(" + toline) + ")")), lines, "@@sendmail"};
-------------------------------------------------------------------------------
================================#48 Note Editor===============================================
#48 Note Editor.objects rc = MOOList [ ]
#48 Note Editor.strmode r = MOOList [ ]
#48 Note Editor:e*dit any n/a none
if (this:changed(who = player in this.active))
player:tell("You are still editing ", this:working_on(who), ".  Please type ABORT or SAVE first.");
elseif (spec = this:parse_invoke(dobjstr, verb))
this:init_session(who, @spec);
endif
-------------------------------------------------------------------------------
#48 Note Editor:save any n/a none
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (!dobjstr)
note = this.objects[who];
elseif (1 == (note = this:note_match_failed(dobjstr)))
return;
else
this.objects[who] = note;
endif
text = this:text(who);
strmode = (length(text) <= 1) && this.strmode[who];
if (strmode)
text = text ? text[1] | "";
endif
if (ERR == typeof(result = this:set_note_text(note, text)))
player:tell("Text not saved to ", this:working_on(who), ":  ", result);
if ((result == E_TYPE) && (typeof(note) == OBJ))
player:tell("Do `mode list' and try saving again.");
elseif (!dobjstr)
player:tell("Use `save' with an argument to save the text elsewhere.");
endif
else
player:tell("Text written to ", this:working_on(who), strmode ? " as a single string." | ".");
this:set_changed(who, 0);
endif
-------------------------------------------------------------------------------
#48 Note Editor:init_session this n/a this
if (this:ok(who = args[1]))
this.strmode[who] = strmode = typeof(text = args[3]) == STR;
this:load(who, strmode ? text ? {text} | {} | text);
this.objects[who] = args[2];
player:tell("Now editing ", this:working_on(who), ".", strmode ? "  [string mode]" | "");
endif
-------------------------------------------------------------------------------
#48 Note Editor:working_on this n/a this
if (!(who = args[1]))
return "????";
endif
spec = this.objects[who];
if (typeof(spec) == LIST)
object = spec[1];
prop = spec[2];
else
object = spec;
prop = 0;
endif
return valid(object) ? tostr("\"", object.name, "\"(", object, ")", prop ? "." + prop | "") | tostr(prop ? ("." + prop) + " on " | "", "invalid object (", object, ")");
-------------------------------------------------------------------------------
#48 Note Editor:parse_invoke this n/a this
":parse_invoke(string,verb)";
" string is the actual commandline string indicating what we are to edit";
" verb is the command verb that is attempting to invoke the editor";
if (caller != this)
raise(E_PERM);
elseif (!(string = args[1]))
player:tell_lines({("Usage:  " + args[2]) + " <note>   (where <note> is some note object)", ("        " + args[2]) + "          (continues editing an unsaved note)"});
elseif (1 == (note = this:note_match_failed(string)))
elseif (ERR == typeof(text = this:note_text(note)))
player:tell("Couldn't retrieve text:  ", text);
else
return {note, text};
endif
return 0;
-------------------------------------------------------------------------------
#48 Note Editor:note_text this n/a this
"WIZARDLY";
if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))
return E_PERM;
endif
set_task_perms(player);
if (typeof(spec = args[1]) == OBJ)
text = spec:text();
else
text = `spec[1].(spec[2]) ! ANY';
endif
if (((tt = typeof(text)) in {ERR, STR}) || ((tt == LIST) && ((!text) || (typeof(text[1]) == STR))))
return text;
else
return E_TYPE;
endif
-------------------------------------------------------------------------------
#48 Note Editor:set_note_text this n/a this
"WIZARDLY";
if ((caller != $note_editor) || (caller_perms() != $note_editor.owner))
return E_PERM;
endif
set_task_perms(player);
attempt = E_NONE;
if (typeof(spec = args[1]) == OBJ)
return spec:set_text(args[2]);
elseif ($object_utils:has_callable_verb(spec[1], "set_" + spec[2]))
attempt = spec[1]:("set_" + spec[2])(args[2]);
endif
if (typeof(attempt) == ERR)
return `spec[1].(spec[2]) = args[2] ! ANY';
else
return attempt;
endif
-------------------------------------------------------------------------------
#48 Note Editor:note_match_failed this n/a this
if (pp = $code_utils:parse_propref(string = args[1]))
object = pp[1];
prop = pp[2];
else
object = string;
prop = 0;
endif
if ($command_utils:object_match_failed(note = player:my_match_object(object, this:get_room(player)), object))
elseif (prop)
if (!$object_utils:has_property(note, prop))
player:tell(object, " has no \".", prop, "\" property.");
else
return {note, prop};
endif
elseif ((!$object_utils:has_callable_verb(note, "text")) || (!$object_utils:has_callable_verb(note, "set_text")))
return {note, "description"};
"... what we used to do.  but why barf?   that's no fun...";
player:tell(object, "(", note, ") doesn't look like a note.");
else
return note;
endif
return 1;
-------------------------------------------------------------------------------
#48 Note Editor:w*hat none n/a none
pass(@args);
if ((who = this:loaded(player)) && this.strmode[who])
player:tell("Text will be stored as a single string instead of a list when possible.");
endif
-------------------------------------------------------------------------------
#48 Note Editor:mode any n/a none
"mode [string|list]";
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (dobjstr && (index("string", dobjstr) == 1))
this.strmode[who] = mode = 1;
player:tell("Now in string mode:");
elseif (dobjstr && (index("list", dobjstr) == 1))
this.strmode[who] = mode = 0;
player:tell("Now in list mode:");
elseif (dobjstr)
player:tell("Unrecognized mode:  ", dobjstr);
player:tell("Should be one of `string' or `list'");
return;
else
player:tell("Currently in ", (mode = this.strmode[who]) ? "string " | "list ", "mode:");
endif
if (mode)
player:tell("  store text as a single string instead of a list when possible.");
else
player:tell("  always store text as a list of strings.");
endif
-------------------------------------------------------------------------------
#48 Note Editor:local_editing_info this n/a this
{what, text} = args;
cmd = (typeof(text) == STR) ? "@set-note-string" | "@set-note-text";
name = (typeof(what) == OBJ) ? what.name | tostr(what[1].name, ".", what[2]);
note = (typeof(what) == OBJ) ? what | tostr(what[1], ".", what[2]);
return {name, text, tostr(cmd, " ", note)};
-------------------------------------------------------------------------------
#48 Note Editor:set_* this n/a this
if ($perm_utils:controls(caller_perms(), this))
return pass(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
================================#49 Verb Editor===============================================
#49 Verb Editor.objects  = MOOList [ ]
#49 Verb Editor.verbnames  = MOOList [ ]
#49 Verb Editor:e*dit any n/a none
if (!args)
player:tell("edit what?");
else
this:invoke(argstr, verb);
endif
-------------------------------------------------------------------------------
#49 Verb Editor:com*pile save none ?-2? any
pas = {{}, {}};
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
elseif (!args)
object = this.objects[who];
vname = this.verbnames[who];
if (typeof(vname) == LIST)
vargs = listdelete(vname, 1);
vname = vname[1];
else
vargs = {};
endif
changeverb = 0;
elseif ((args[1] != "as") || ((length(args) < 2) || ((!(spec = $code_utils:parse_verbref(args[2]))) || ((typeof(pas = $code_utils:parse_argspec(@args[3..$])) != LIST) || pas[2]))))
if (typeof(pas) != LIST)
player:tell(pas);
elseif (pas[2])
player:tell("I don't understand \"", $string_utils:from_list(pas[2], " "), "\"");
endif
player:tell("Usage: ", verb, " [as <object>:<verb>]");
return;
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1], this:get_room(player)), spec[1]))
return;
else
vname = spec[2];
vargs = pas[1] && {@pas[1], "none", "none"}[1..3];
if (vargs)
vargs[2] = $code_utils:full_prep(vargs[2]) || vargs[2];
endif
changeverb = 1;
endif
if (vargs)
vnum = $code_utils:find_verb_named(object, vname);
while (vnum && (this:fetch_verb_args(object, vnum) != vargs))
vnum = $code_utils:find_verb_named(object, vname, vnum + 1);
endwhile
if (!vnum)
player:tell("There is no ", object, ":", vname, " verb with args (", $string_utils:from_list(vargs, " "), ").");
if (!changeverb)
player:tell("Use 'compile as ...' to write your code to another verb.");
endif
return;
endif
objverbname = tostr(object, ":", vname, " (", $string_utils:from_list(vargs, " "), ")");
else
vnum = 0;
objverbname = tostr(object, ":", ($code_utils:toint(vname) == E_TYPE) ? vname | this:verb_name(object, vname));
endif
"...";
"...perform eval_subs on verb code if necessary...";
"...";
if (player.eval_subs && player:edit_option("eval_subs"))
verbcode = {};
for x in (this:text(who))
verbcode = {@verbcode, $code_utils:substitute(x, player.eval_subs)};
endfor
else
verbcode = this:text(who);
endif
"...";
"...write it out...";
"...";
if (result = this:set_verb_code(object, vnum ? vnum | vname, verbcode))
player:tell(objverbname, " not compiled because:");
for x in (result)
player:tell("  ", x);
endfor
elseif (typeof(result) == ERR)
player:tell({result, ("You do not have write permission on " + objverbname) + ".", ("The verb " + objverbname) + " does not exist (!?!)", ("The object " + tostr(object)) + " does not exist (!?!)"}[1 + (result in {E_PERM, E_VERBNF, E_INVARG})]);
if (!changeverb)
player:tell("Do 'compile as <object>:<verb>' to write your code to another verb.");
endif
changeverb = 0;
else
player:tell(objverbname, verbcode ? " successfully compiled." | " verbcode removed.");
this:set_changed(who, 0);
endif
if (changeverb)
this.objects[who] = object;
this.verbnames[who] = vargs ? {vname, @vargs} | vname;
endif
-------------------------------------------------------------------------------
#49 Verb Editor:working_on this n/a this
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
object = this.objects[who];
verbname = this.verbnames[who];
if (typeof(verbname) == LIST)
return tostr(object, ":", verbname[1], " (", $string_utils:from_list(listdelete(verbname, 1), " "), ")");
else
return tostr(object, ":", this:verb_name(object, verbname), " (", this:verb_args(object, verbname), ")");
endif
endif
"return this:ok(who = args[1]) && tostr(this.objects[who]) + \":\" + this.verbnames[who];";
-------------------------------------------------------------------------------
#49 Verb Editor:init_session this n/a this
{who, object, vname, vcode} = args;
if (this:ok(who))
this:load(who, vcode);
this.verbnames[who] = vname;
this.objects[who] = object;
this.active[who]:tell("Now editing ", this:working_on(who), ".");
"this.active[who]:tell(\"Now editing \", object, \":\", vname, \".\");";
endif
-------------------------------------------------------------------------------
#49 Verb Editor:parse_invoke this n/a this
":parse_invoke(string,v,?code)";
"  string is the commandline string to parse to obtain the obj:verb to edit";
"  v is the actual command verb used to invoke the editor";
" => {object, verbname, verb_code} or error";
if (caller != this)
raise(E_PERM);
endif
vref = $string_utils:words(args[1]);
if ((!vref) || (!(spec = $code_utils:parse_verbref(vref[1]))))
player:tell("Usage: ", args[2], " object:verb");
return;
endif
if (argspec = listdelete(vref, 1))
if (typeof(pas = $code_utils:parse_argspec(@argspec)) == LIST)
if (pas[2])
player:tell("I don't understand \"", $string_utils:from_list(pas[2], " "), "\"");
return;
endif
argspec = {@pas[1], "none", "none"}[1..3];
argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];
else
player:tell(pas);
return;
endif
endif
if (!$command_utils:object_match_failed(object = player:my_match_object(spec[1], this:get_room(player)), spec[1]))
vnum = $code_utils:find_verb_named(object, vname = spec[2]);
if (argspec)
while (vnum && (this:fetch_verb_args(object, vnum) != argspec))
vnum = $code_utils:find_verb_named(object, vname, vnum + 1);
endwhile
endif
if (length(args) > 2)
code = args[3];
elseif (vnum)
code = this:fetch_verb_code(object, vnum);
else
code = E_VERBNF;
endif
if (typeof(code) == ERR)
player:tell((code != E_VERBNF) ? code | "That object does not define that verb", argspec ? " with those args." | ".");
return code;
else
return {object, argspec ? {vname, @argspec} | vname, code};
endif
endif
return 0;
-------------------------------------------------------------------------------
#49 Verb Editor:fetch_verb_code this n/a this
"WIZARDLY";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
return `verb_code(args[1], args[2], !player:edit_option("no_parens")) ! ANY';
endif
-------------------------------------------------------------------------------
#49 Verb Editor:set_verb_code this n/a this
"WIZARDLY";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
return `set_verb_code(args[1], args[2], args[3]) ! ANY';
endif
-------------------------------------------------------------------------------
#49 Verb Editor:local_editing_info this n/a this
if (caller == $verb_editor)
set_task_perms(player);
endif
{object, vname, code} = args;
if (typeof(vname) == LIST)
if (vname[3] != "none")
vname[3] = $code_utils:short_prep(vname[3]);
endif
vargs = tostr(" ", vname[2], " ", vname[3], " ", vname[4]);
vname = vname[1];
else
vargs = "";
endif
name = tostr(object.name, ":", vname);
"... so the next 2 lines are actually wrong, since verb_info won't";
"... necessarily retrieve the correct verb if we have more than one";
"... matching the given same name; anyway, if parse_invoke understood vname,";
"... so will @program.  I suspect these were put here because in the";
"... old scheme of things, vname was always a number.";
"vname = strsub($string_utils:explode(verb_info(object, vname)[3])[1], \"*\", \"\")";
"vargs = verb_args(object, vname)";
"";
return {name, code, tostr("@program ", object, ":", vname, vargs)};
-------------------------------------------------------------------------------
#49 Verb Editor:verb_name this n/a this
"verb_name(object, vname)";
"Find vname on object and return its full name (quoted).";
"This is useful for when we're working with verb numbers.";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
given = args[2];
if (typeof(info = `verb_info(args[1], given) ! ANY') == ERR)
return tostr(given, "[", info, "]");
elseif (info[3] == given)
return given;
else
return tostr(given, "/\"", info[3], "\"");
endif
endif
-------------------------------------------------------------------------------
#49 Verb Editor:verb_args this n/a this
"verb_name(object, vname)";
"Find vname on object and return its full name (quoted).";
"This is useful for when we're working with verb numbers.";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
return E_PERM;
else
set_task_perms(player);
return $string_utils:from_list(`verb_args(args[1], args[2]) ! ANY', " ");
endif
-------------------------------------------------------------------------------
#49 Verb Editor:comment any ?-2? any
"Syntax: comment [<range>]";
"";
"Turns the specified range of lines, into comments.";
if ((caller != player) && (caller_perms() != player))
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"."}, @args)) != LIST)
player:tell(tostr(range));
elseif (range[3])
player:tell_lines($code_utils:verb_documentation());
else
text = this.texts[who];
{from, to, crap} = range;
cut = $maxint;
for line in [from..to]
cut = min(cut, `match(text[line], "[^ ]")[1] ! E_RANGE => 1');
endfor
for line in [from..to]
text[line] = toliteral(text[line][cut..$]) + ";";
endfor
this.texts[who] = text;
player:tell((to == from) ? "Line" | "Lines", " changed.");
this.changes[who] = 1;
this.times[who] = time();
endif
-------------------------------------------------------------------------------
#49 Verb Editor:uncomment any ?-2? any
"Syntax: uncomment [<range>]";
"";
"Turns the specified range of lines from comments to, uh, not comments.";
if ((caller != player) && (caller_perms() != player))
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"."}, @args)) != LIST)
player:tell(tostr(range));
elseif (range[3])
player:tell_lines($code_utils:verb_documentation());
else
text = this.texts[who];
{from, to, crap} = range;
bogus = {};
for line in [from..to]
if (match(text[line], "^ *\"%([^\\\"]%|\\.%)*\";$"))
"check from $code_utils:verb_documentation";
if (!bogus)
text[line] = $no_one:eval(text[line])[2];
endif
else
bogus = setadd(bogus, line);
endif
endfor
if (bogus)
player:tell((length(bogus) == 1) ? "Line" | "Lines", " ", $string_utils:english_list(bogus), " ", (length(bogus) == 1) ? "is" | "are", " not comments.");
player:tell("No changes.");
return;
endif
this.texts[who] = text;
player:tell((to == from) ? "Line" | "Lines", " changed.");
this.changes[who] = 1;
this.times[who] = time();
endif
-------------------------------------------------------------------------------
#49 Verb Editor:fetch_verb_args this n/a this
"WIZARDLY";
if ((caller != $verb_editor) || (caller_perms() != $verb_editor.owner))
raise(E_PERM);
else
set_task_perms(player);
return `verb_args(args[1], args[2]) ! ANY';
endif
-------------------------------------------------------------------------------
================================#50 Generic Editor===============================================
#50 Generic Editor.change_msg rc = MOOString "Text has been altered since the last save."
#50 Generic Editor.commands2 rc = MOOList [ [ "say", "emote", "lis*t", "ins*ert", "n*ext,p*rev", "del*ete", "f*ind", "s*ubst", "m*ove,c*opy", "join*l", "fill" ], [ "y*ank", "w*hat", "abort", "q*uit,done,pause" ] ]
#50 Generic Editor.previous_session_msg rc = MOOString ""
#50 Generic Editor.changes  = MOOList [ ]
#50 Generic Editor.return_msg rc = MOOString "%N comes back from the Generic Editing Room."
#50 Generic Editor.times r = MOOList [ ]
#50 Generic Editor.no_change_msg rc = MOOString "There have been no changes since the last save."
#50 Generic Editor.no_littering_msg rc = MOOString "Keeping your [whatever] for later work.  Since this the Generic Editor, you have to do your own :set_changed(0) so that we'll know to get rid of whatever it you're working on when you leave.  Please don't litter... especially in the Generic Editor."
#50 Generic Editor.no_text_msg rc = MOOString "There are no lines of text."
#50 Generic Editor.inserting  = MOOList [ ]
#50 Generic Editor.commands rc = MOOList [ [ "say", "<text>" ], [ "emote", "<text>" ], [ "lis*t", "[<range>] [nonum]" ], [ "ins*ert", "[<ins>] ["<text>]" ], [ "n*ext,p*rev", "[n] ["<text>]" ], [ "del*ete", "[<range>]" ], [ "f*ind", "/<str>[/[c][<range>]]" ], [ "s*ubst", "/<str1>/<str2>[/[g][c][r][<range>]]" ], [ "m*ove,c*opy", "[<range>] to <ins>" ], [ "join*l", "[<range>]" ], [ "fill", "[<range>] [@<col>]" ], [ "w*hat", "" ], [ "abort", "" ], [ "q*uit,done,pause", "" ], [ "enter", "" ], [ "y*ank", "from <text-source>" ] ]
#50 Generic Editor.readable r = MOOList [ ]
#50 Generic Editor.stateprops r = MOOList [ [ "texts", 0 ], [ "changes", 0 ], [ "inserting", 1 ], [ "readable", 0 ] ]
#50 Generic Editor.invoke_task r = MOONumber 0
#50 Generic Editor.original r = MOOList [ ]
#50 Generic Editor.nothing_loaded_msg rc = MOOString "You're not currently editing anything."
#50 Generic Editor.active r = MOOList [ ]
#50 Generic Editor.help rc = MOOObjRef #44
#50 Generic Editor.exit_on_abort rc = MOONumber 0
#50 Generic Editor.texts  = MOOList [ ]
#50 Generic Editor.depart_msg rc = MOOString "%N heads off to the Generic Editing Room."
#50 Generic Editor:say any ?-2? any
if ((caller != player) && (caller_perms() != player))
return E_PERM;
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
this:insert_line(who, argstr);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:emote any ?-2? any
if ((caller != player) && (caller_perms() != player))
return E_PERM;
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
else
this:append_line(who, argstr);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:enter any n/a none
if (!this:loaded(player))
player:tell(this:nothing_loaded_msg());
else
lines = $command_utils:read_lines();
if (typeof(lines) == ERR)
player:notify(tostr(lines));
return;
endif
this:insert_line(this:loaded(player), lines, 0);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:lis*t view any ?-2? any
nonum = 0;
if (verb == "view")
if (!args)
l = {};
for i in [1..length(this.active)]
if (this.readable[i])
l = {@l, this.active[i]};
endif
endfor
if (l)
player:tell("Players having readable texts in this editor:  ", $string_utils:names_of(l));
else
player:tell("No one has published anything in this editor.");
endif
return;
elseif ($command_utils:player_match_result(plyr = $string_utils:match_player(args[1]), args[1])[1])
"...no such player";
return;
elseif ((!(who = this:loaded(plyr))) || (!this:readable(who)))
player:tell(plyr.name, "(", plyr, ") has not published anything in this editor.");
return;
endif
args = listdelete(args, 1);
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
len = length(this.texts[who]);
ins = this.inserting[who];
window = 8;
if (len < (2 * window))
default = {"1-$"};
elseif (ins <= window)
default = {tostr("1-", 2 * window)};
else
default = {tostr(window, "_-", window, "^"), tostr(2 * window, "$-$")};
endif
if (typeof(range = this:parse_range(who, default, @args)) != LIST)
player:tell(tostr(range));
elseif (range[3] && (!(nonum = "nonum" == $string_utils:trim(range[3]))))
player:tell("Don't understand this:  ", range[3]);
elseif (nonum)
player:tell_lines(this.texts[who][range[1]..range[2]]);
else
for line in [range[1]..range[2]]
this:list_line(who, line);
if ($command_utils:running_out_of_time())
suspend(0);
if (!(who = this:loaded(player)))
player:tell("ack!  something bad happened during a suspend...");
return;
endif
endif
endfor
if ((ins > len) && (len == range[2]))
player:tell("^^^^");
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:ins*ert n*ext p*revious . any n/a none
if (i = index(argstr, "\""))
text = argstr[i + 1..$];
argstr = argstr[1..i - 1];
else
text = 0;
endif
spec = $string_utils:trim(argstr);
if (index("next", verb) == 1)
verb = "next";
spec = "+" + (spec || "1");
elseif (index("prev", verb) == 1)
verb = "prev";
spec = "-" + (spec || "1");
else
spec = spec || ".";
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (ERR == typeof(number = this:parse_insert(who, spec)))
if (verb in {"next", "prev"})
player:tell("Argument must be a number.");
else
player:tell("You must specify an integer or `$' for the last line.");
endif
elseif ((number > (max = length(this.texts[who]) + 1)) || (number < 1))
player:tell("That would take you out of range (to line ", number, "?).");
else
this.inserting[who] = number;
if (typeof(text) == STR)
this:insert_line(who, text);
else
if (verb != "next")
(number > 1) ? this:list_line(who, number - 1) | player:tell("____");
endif
if (verb != "prev")
(number < max) ? this:list_line(who, number) | player:tell("^^^^");
endif
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:del*ete any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @args)) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
else
player:tell_lines((text = this.texts[who])[from = range[1]..to = range[2]]);
player:tell("---Line", (to > from) ? "s" | "", " deleted.  Insertion point is before line ", from, ".");
this.texts[who] = {@text[1..from - 1], @text[to + 1..$]};
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
this.inserting[who] = from;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:f*ind any ?-2? any
if (callers() && (caller != this))
return E_PERM;
endif
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(subst = this:parse_subst(argstr && (argstr[1] + argstr), "c", "Empty search string?")) != LIST)
player:tell(tostr(subst));
elseif (typeof(start = subst[4] ? this:parse_insert(who, subst[4]) | this.inserting[who]) == ERR)
player:tell("Starting from where?", subst[4] ? ("  (can't parse " + subst[4]) + ")" | "");
else
search = subst[2];
case = !index(subst[3], "c", 1);
text = this.texts[who];
tlen = length(text);
while ((start <= tlen) && (!index(text[start], search, case)))
start = start + 1;
endwhile
if (start > tlen)
player:tell("`", search, "' not found.");
else
this.inserting[who] = start + 1;
this:list_line(who, start);
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:m*ove c*opy any ?-2? any
verb = (is_move = verb[1] == "m") ? "move" | "copy";
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
wargs = args;
t = to_pos = 0;
while (t = "to" in (wargs = wargs[t + 1..$]))
to_pos = to_pos + t;
endwhile
range_args = args[1..to_pos - 1];
if ((!to_pos) || (ERR == typeof(dest = this:parse_insert(who, $string_utils:from_list(wargs, " ")))))
player:tell(verb, " to where? ");
elseif ((dest < 1) || (dest > ((last = length(this.texts[who])) + 1)))
player:tell("Destination (", dest, ") out of range.");
elseif (("from" in range_args) || ("to" in range_args))
player:tell("Don't use that kind of range specification with this command.");
elseif (typeof(range = this:parse_range(who, {"_", "^"}, @args[1..to_pos - 1])) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk before `to':  ", range[3]);
elseif ((is_move && (dest >= range[1])) && (dest <= (range[2] + 1)))
player:tell("Destination lies inside range of lines to be moved.");
else
from = range[1];
to = range[2];
ins = this.inserting[who];
text = this.texts[who];
if (!is_move)
this.texts[who] = {@text[1..dest - 1], @text[from..to], @text[dest..last]};
if (ins >= dest)
this.inserting[who] = ((ins + to) - from) + 1;
endif
else
"oh shit... it's a move";
if (dest < from)
newtext = {@text[1..dest - 1], @text[from..to], @text[dest..from - 1], @text[to + 1..last]};
if ((ins >= dest) && (ins <= to))
ins = (ins > from) ? (ins - from) + dest | (((ins + to) - from) + 1);
endif
else
newtext = {@text[1..from - 1], @text[to + 1..dest - 1], @text[from..to], @text[dest..last]};
if ((ins > from) && (ins < dest))
ins = (ins <= to) ? ((ins + dest) - to) - 1 | (((ins - to) + from) - 1);
endif
endif
this.texts[who] = newtext;
this.inserting[who] = ins;
endif
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
player:tell("Lines ", is_move ? "moved." | "copied.");
endif
-------------------------------------------------------------------------------
#50 Generic Editor:join*literal any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_-^", "_", "^"}, @args)) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
elseif (!(result = this:join_lines(who, @range[1..2], length(verb) <= 4)))
player:tell((result == 0) ? "Need at least two lines to join." | result);
else
this:list_line(who, range[1]);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:fill any ?-2? any
fill_column = 70;
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @args)) != LIST)
player:tell(range);
elseif (range[3] && ((range[3][1] != "@") || ((fill_column = toint(range[3][2..$])) < 10)))
player:tell("Usage:  fill [<range>] [@ column]   (where column >= 10).");
else
join = this:join_lines(who, @range[1..2], 1);
newlines = this:fill_string((text = this.texts[who])[from = range[1]], fill_column);
if (fill = ((nlen = length(newlines)) > 1) || (newlines[1] != text[from]))
this.texts[who] = {@text[1..from - 1], @newlines, @text[from + 1..$]};
if (((insert = this.inserting[who]) > from) && (nlen > 1))
this.inserting[who] = (insert + nlen) - 1;
endif
endif
if (fill || join)
for line in [from..(from + nlen) - 1]
this:list_line(who, line);
endfor
else
player:tell("No changes.");
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:pub*lish perish unpub*lish depub*lish none n/a none
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (typeof(e = this:set_readable(who, index("publish", verb) == 1)) == ERR)
player:tell(e);
elseif (e)
player:tell("Your text is now globally readable.");
else
player:tell("Your text is read protected.");
endif
-------------------------------------------------------------------------------
#50 Generic Editor:w*hat none n/a none
if (!(this:ok(who = player in this.active) && (typeof(this.texts[who]) == LIST)))
player:tell(this:nothing_loaded_msg());
else
player:tell("You are editing ", this:working_on(who), ".");
player:tell("Your insertion point is ", (this.inserting[who] > length(this.texts[who])) ? "after the last line: next line will be #" | "before line ", this.inserting[who], ".");
player:tell(this.changes[who] ? this:change_msg() | this:no_change_msg());
if (this.readable[who])
player:tell("Your text is globally readable.");
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:abort none n/a none
if (!this.changes[who = player in this.active])
player:tell("No changes to throw away.  Editor cleared.");
else
player:tell("Throwing away session for ", this:working_on(who), ".");
endif
this:reset_session(who);
if (this.exit_on_abort)
this:done();
endif
-------------------------------------------------------------------------------
#50 Generic Editor:done q*uit pause none n/a none
if (!(caller in {this, player}))
return E_PERM;
elseif (!(who = player in this.active))
player:tell("You are not actually in ", this.name, ".");
return;
elseif (!valid(origin = this.original[who]))
player:tell("I don't know where you came here from.");
else
player:moveto(origin);
if (player.location == this)
player:tell("Hmmm... the place you came from doesn't want you back.");
else
if (msg = this:return_msg())
player.location:announce($string_utils:pronoun_sub(msg));
endif
return;
endif
endif
player:tell("You'll have to use 'home' or a teleporter.");
-------------------------------------------------------------------------------
#50 Generic Editor:huh2 this n/a this
"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.";
set_task_perms(caller_perms());
if ((c = callers()) && ((c[1][1] != this) || (length(c) > 1)))
return pass(@args);
endif
verb = args[1];
v = 1;
vmax = min(length(verb), 5);
while ((v <= vmax) && (verb[v] == "subst"[v]))
v = v + 1;
endwhile
argstr = $code_utils:argstr(verb, args[2]);
if (((v > 1) && (v <= length(verb))) && (((vl = verb[v]) < "A") || (vl > "Z")))
argstr = (verb[v..$] + (argstr && " ")) + argstr;
return this:subst();
elseif ("/" == verb[1])
argstr = (verb + (argstr && " ")) + argstr;
return this:find();
else
pass(@args);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:insertion this n/a this
return this:ok(who = args[1]) && this.inserting[who];
-------------------------------------------------------------------------------
#50 Generic Editor:set_insertion this n/a this
return this:ok(who = args[1]) && ((((ins = toint(args[2])) < 1) ? E_INVARG | ((ins <= (max = length(this.texts[who]) + 1)) || (ins = max))) && (this.inserting[who] = ins));
-------------------------------------------------------------------------------
#50 Generic Editor:changed retain_session_on_exit this n/a this
return this:ok(who = args[1]) && this.changes[who];
-------------------------------------------------------------------------------
#50 Generic Editor:set_changed this n/a this
return this:ok(who = args[1]) && (((unchanged = !args[2]) || (this.times[who] = time())) && (this.changes[who] = !unchanged));
-------------------------------------------------------------------------------
#50 Generic Editor:origin this n/a this
return this:ok(who = args[1]) && this.original[who];
-------------------------------------------------------------------------------
#50 Generic Editor:set_origin this n/a this
return this:ok(who = args[1]) && (((valid(origin = args[2]) && (origin != this)) || ((origin == $nothing) || E_INVARG)) && (this.original[who] = origin));
-------------------------------------------------------------------------------
#50 Generic Editor:readable this n/a this
return (((who = args[1]) < 1) || (who > length(this.active))) ? E_RANGE | this.readable[who];
-------------------------------------------------------------------------------
#50 Generic Editor:set_readable this n/a this
return this:ok(who = args[1]) && (this.readable[who] = !(!args[2]));
-------------------------------------------------------------------------------
#50 Generic Editor:text this n/a this
{?who = player in this.active} = args;
return (this:readable(who) || this:ok(who)) && this.texts[who];
-------------------------------------------------------------------------------
#50 Generic Editor:load this n/a this
texts = args[2];
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
elseif (typeof(texts) == STR)
texts = {texts};
elseif ((typeof(texts) != LIST) || (length(texts) && (typeof(texts[1]) != STR)))
return E_TYPE;
endif
this.texts[who] = texts;
this.inserting[who] = length(texts) + 1;
this.changes[who] = 0;
this.readable[who] = 0;
this.times[who] = time();
-------------------------------------------------------------------------------
#50 Generic Editor:working_on this n/a this
"Dummy routine.  The child editor should provide something informative";
return this:ok(who = args[1]) && (("something [in " + this.name) + "]");
-------------------------------------------------------------------------------
#50 Generic Editor:ok this n/a this
who = args[1];
if ((who < 1) || (who > length(this.active)))
return E_RANGE;
elseif ((length(c = callers()) < 2) ? player == this.active[who] | ((c[2][1] == this) || ($perm_utils:controls(c[2][3], this.active[who]) || (c[2][3] == $generic_editor.owner))))
return 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:loaded this n/a this
return ((who = args[1] in this.active) && (typeof(this.texts[who]) == LIST)) && who;
-------------------------------------------------------------------------------
#50 Generic Editor:list_line this n/a this
if (this:ok(who = args[1]))
f = 1 + ((line = args[2]) in {(ins = this.inserting[who]) - 1, ins});
player:tell($string_utils:right(line, 3, " _^"[f]), ":_^"[f], " ", this.texts[who][line]);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:insert_line this n/a this
":insert_line([who,] line or list of lines [,quiet])";
"  inserts the given text at the insertion point.";
"  returns E_NONE if the session has no text loaded yet.";
if (typeof(args[1]) != INT)
args = {player in this.active, @args};
endif
{who, lines, ?quiet = this.active[who]:edit_option("quiet_insert")} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
elseif (typeof(text = this.texts[who]) != LIST)
return E_NONE;
else
if (typeof(lines) != LIST)
lines = {lines};
endif
p = this.active[who];
insert = this.inserting[who];
this.texts[who] = {@text[1..insert - 1], @lines, @text[insert..$]};
this.inserting[who] = insert + length(lines);
if (lines)
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
if (!quiet)
if (length(lines) != 1)
p:tell("Lines ", insert, "-", (insert + length(lines)) - 1, " added.");
else
p:tell("Line ", insert, " added.");
endif
endif
else
p:tell("No lines added.");
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:append_line this n/a this
":append_line([who,] string)";
"  appends the given string to the line before the insertion point.";
"  returns E_NONE if the session has no text loaded yet.";
if (typeof(args[1]) != INT)
args = {player in this.active, @args};
endif
{who, string} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
elseif ((append = this.inserting[who] - 1) < 1)
return this:insert_line(who, {string});
elseif (typeof(text = this.texts[who]) != LIST)
return E_NONE;
else
this.texts[who][append] = text[append] + string;
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
p = this.active[who];
if (!p:edit_option("quiet_insert"))
p:tell("Appended to line ", append, ".");
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:join_lines this n/a this
{who, from, to, english} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
elseif (from >= to)
return 0;
else
nline = "";
for line in ((text = this.texts[who])[from..to])
if (!english)
nline = nline + line;
else
len = length(line) + 1;
while ((len = len - 1) && (line[len] == " "))
endwhile
if (len > 0)
nline = (nline + line) + (index(".:", line[len]) ? "  " | " ");
endif
endif
endfor
this.texts[who] = {@text[1..from - 1], nline, @text[to + 1..$]};
if ((insert = this.inserting[who]) > from)
this.inserting[who] = (insert <= to) ? from + 1 | ((insert - to) + from);
endif
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
return to - from;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:parse_number this n/a this
"parse_number(who,string,before)   interprets string as a line number.  In the event that string is `.', `before' tells us which line to use.  Return 0 if string is bogus.";
{who, string, before} = args;
if (!(fuckup = this:ok(who)))
return fuckup;
endif
last = length(this.texts[who]);
ins = this.inserting[who] - 1;
after = !before;
if (!string)
return 0;
elseif ("." == string)
return ins + after;
elseif (!(i = index("_^$", string[slen = length(string)])))
return toint(string);
else
start = {ins + 1, ins, last + 1}[i];
n = 1;
if ((slen > 1) && (!(n = toint(string[1..slen - 1]))))
return 0;
elseif (i % 2)
return start - n;
else
return start + n;
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:parse_range this n/a this
"parse_range(who,default,@args) => {from to rest}";
numargs = length(args);
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
elseif (!(last = length(this.texts[who])))
return this:no_text_msg();
endif
default = args[2];
r = 0;
while (default && (LIST != typeof(r = this:parse_range(who, {}, default[1]))))
default = listdelete(default, 1);
endwhile
if (typeof(r) == LIST)
from = r[1];
to = r[2];
else
from = to = 0;
endif
saw_from_to = 0;
not_done = 1;
a = 2;
while (((a = a + 1) <= numargs) && not_done)
if (args[a] == "from")
if ((a == numargs) || (!(from = this:parse_number(who, args[a = a + 1], 0))))
return "from ?";
endif
saw_from_to = 1;
elseif (args[a] == "to")
if ((a == numargs) || (!(to = this:parse_number(who, args[a = a + 1], 1))))
return "to ?";
endif
saw_from_to = 1;
elseif (saw_from_to)
a = a - 1;
not_done = 0;
elseif (i = index(args[a], "-"))
from = this:parse_number(who, args[a][1..i - 1], 0);
to = this:parse_number(who, args[a][i + 1..$], 1);
not_done = 0;
elseif (f = this:parse_number(who, args[a], 0))
from = f;
if ((a == numargs) || (!(to = this:parse_number(who, args[a + 1], 1))))
to = from;
else
a = a + 1;
endif
not_done = 0;
else
a = a - 1;
not_done = 0;
endif
endwhile
if (from < 1)
return tostr("from ", from, "?  (out of range)");
elseif (to > last)
return tostr("to ", to, "?  (out of range)");
elseif (from > to)
return tostr("from ", from, " to ", to, "?  (backwards range)");
else
return {from, to, $string_utils:from_list(args[a..numargs], " ")};
endif
-------------------------------------------------------------------------------
#50 Generic Editor:parse_insert this n/a this
"parse_ins(who,string)  interprets string as an insertion point, i.e., a position between lines and returns the number of the following line or 0 if bogus.";
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
endif
{who, string} = args;
if (length(string) == 0)
return E_INVARG;
endif
last = length(this.texts[who]) + 1;
ins = this.inserting[who];
if (i = index("-+", string[1]))
rest = string[2..$];
return ((n = toint(rest)) || (rest == "0")) ? {ins - n, ins + n}[i] | E_INVARG;
else
if (!(j = index(string, "^") || index(string, "_")))
offset = 0;
else
offset = (j == 1) || toint(string[1..j - 1]);
if (!offset)
return E_INVARG;
elseif (string[j] == "^")
offset = -offset;
endif
endif
rest = string[j + 1..$];
if (i = rest in {".", "$"})
return offset + {ins, last}[i];
elseif (!(n = toint(rest)))
return E_INVARG;
else
return (offset + (j && (string[j] == "^"))) + n;
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:parse_subst this n/a this
{cmd, ?recognized_flags = "gcr", ?null_subst_msg = "Null substitution?"} = args;
if (!cmd)
return "s*ubst/<str1>/<str2>[/[g][c][r][<range>]] expected...";
endif
bchar = cmd[1];
cmd = cmd[2..$];
fromstr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];
cmd = cmd[b2 + 1..$];
tostr = cmd[1..(b2 = index(cmd + bchar, bchar, 1)) - 1];
cmd = cmd[b2 + 1..$];
cmdlen = length(cmd);
b2 = 0;
while (((b2 = b2 + 1) <= cmdlen) && index(recognized_flags, cmd[b2]))
endwhile
return ((fromstr == "") && (tostr == "")) ? null_subst_msg | {fromstr, tostr, cmd[1..b2 - 1], cmd[b2..$]};
-------------------------------------------------------------------------------
#50 Generic Editor:invoke this n/a this
":invoke(...)";
"to find out what arguments this verb expects,";
"see this editor's parse_invoke verb.";
new = args[1];
if ((!(caller in {this, player})) && (!$perm_utils:controls(caller_perms(), player)))
"...non-editor/non-player verb trying to send someone to the editor...";
return E_PERM;
endif
if ((who = this:loaded(player)) && this:changed(who))
if (!new)
if (this:suck_in(player))
player:tell("You are working on ", this:working_on(who));
endif
return;
elseif (player.location == this)
player:tell("You are still working on ", this:working_on(who));
if (msg = this:previous_session_msg())
player:tell(msg);
endif
return;
endif
"... we're not in the editor and we're about to start something new,";
"... but there's still this pending session...";
player:tell("You were working on ", this:working_on(who));
if (!$command_utils:yes_or_no("Do you wish to delete that session?"))
if (this:suck_in(player))
player:tell("Continuing with ", this:working_on(player in this.active));
if (msg = this:previous_session_msg())
player:tell(msg);
endif
endif
return;
endif
"... note session number may have changed => don't trust `who'";
this:kill_session(player in this.active);
endif
spec = this:parse_invoke(@args);
if (typeof(spec) == LIST)
if ((player:edit_option("local") && $object_utils:has_verb(this, "local_editing_info")) && (info = this:local_editing_info(@spec)))
this:invoke_local_editor(@info);
elseif (this:suck_in(player))
this:init_session(player in this.active, @spec);
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:suck_in this n/a this
"The correct way to move someone into the editor.";
if (((loc = (who_obj = args[1]).location) != this) && (caller == this))
this.invoke_task = task_id();
who_obj:moveto(this);
if (who_obj.location == this)
try
"...forked, just in case loc:announce is broken...";
"changed to a try-endtry. Lets reduce tasks..Ho_Yan 12/20/96";
if (valid(loc) && (msg = this:depart_msg()))
loc:announce($string_utils:pronoun_sub(msg));
endif
except (ANY)
"Just drop it and move on";
endtry
else
who_obj:tell("For some reason, I can't move you.   (?)");
this:exitfunc(who_obj);
endif
this.invoke_task = 0;
endif
return who_obj.location == this;
-------------------------------------------------------------------------------
#50 Generic Editor:new_session this n/a this
"WIZARDLY";
{who_obj, from} = args;
if ($object_utils:isa(from, $generic_editor))
"... never put an editor in .original, ...";
if (w = who_obj in from.active)
from = from.original[w];
else
from = #-1;
endif
endif
if (caller != this)
return E_PERM;
elseif (who = who_obj in this.active)
"... edit in progress here...";
if (valid(from))
this.original[who] = from;
endif
return -1;
else
for p in ({{"active", who_obj}, {"original", valid(from) ? from | $nothing}, {"times", time()}, @this.stateprops})
this.(p[1]) = {@this.(p[1]), p[2]};
endfor
return length(this.active);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:kill_session this n/a this
"WIZARDLY";
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
for p in ({@this.stateprops, {"original"}, {"active"}, {"times"}})
this.(p[1]) = listdelete(this.(p[1]), who);
endfor
return who;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:reset_session this n/a this
"WIZARDLY";
if (!(fuckup = this:ok(who = args[1])))
return fuckup;
else
for p in (this.stateprops)
this.(p[1])[who] = p[2];
endfor
this.times[who] = time();
return who;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:kill_all_sessions this n/a this
"WIZARDLY";
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
for victim in (this.contents)
victim:tell("Sorry, ", this.name, " is going down.  Your editing session is hosed.");
victim:moveto(((who = victim in this.active) && valid(origin = this.original[who])) ? origin | (valid(victim.home) ? victim.home | $player_start));
endfor
for p in ({@this.stateprops, {"original"}, {"active"}, {"times"}})
this.(p[1]) = {};
endfor
return 1;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:acceptable this n/a this
return is_player(who_obj = args[1]) && (who_obj.wizard || pass(@args));
-------------------------------------------------------------------------------
#50 Generic Editor:enterfunc this n/a this
who_obj = args[1];
if (who_obj.wizard && (!(who_obj in this.active)))
this:accept(who_obj);
endif
pass(@args);
if (this.invoke_task == task_id())
"Means we're about to load something, so be quiet.";
this.invoke_task = 0;
elseif (who = this:loaded(who_obj))
who_obj:tell("You are working on ", this:working_on(who), ".");
elseif (msg = this:nothing_loaded_msg())
who_obj:tell(msg);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:exitfunc this n/a this
if (!(who = (who_obj = args[1]) in this.active))
elseif (this:retain_session_on_exit(who))
if (msg = this:no_littering_msg())
who_obj:tell_lines(msg);
endif
else
this:kill_session(who);
endif
pass(@args);
-------------------------------------------------------------------------------
#50 Generic Editor:@flush this ?-2? any
"@flush <editor>";
"@flush <editor> at <month> <day>";
"@flush <editor> at <weekday>";
"The first form removes all sessions from the editor; the other two forms remove everything older than the given date.";
if ((caller_perms() != #-1) && (caller_perms() != player))
raise(E_PERM);
elseif (!$perm_utils:controls(player, this))
player:tell("Only the owner of the editor can do a ", verb, ".");
return;
endif
if (!prepstr)
player:tell("Trashing all sessions.");
this:kill_all_sessions();
elseif (prepstr != "at")
player:tell("Usage:  ", verb, " ", dobjstr, " [at [mon day|weekday]]");
else
p = prepstr in args;
if (t = $time_utils:from_day(iobjstr, -1))
elseif (t = $time_utils:from_month(args[p + 1], -1))
if (length(args) > (p + 1))
if (!(n = toint(args[p + 2])))
player:tell(args[p + 1], " WHAT?");
return;
endif
t = t + ((n - 1) * 86400);
endif
else
player:tell("couldn't parse date");
return;
endif
this:do_flush(t, "noisy");
endif
player:tell("Done.");
-------------------------------------------------------------------------------
#50 Generic Editor:@stateprop any behind this
if (!$perm_utils:controls(player, this))
player:tell(E_PERM);
return;
endif
if (i = index(dobjstr, "="))
default = dobjstr[i + 1..$];
prop = dobjstr[1..i - 1];
if (argstr[1 + index(argstr, "=")] == "\"")
elseif (default[1] == "#")
default = toobj(default);
elseif (index("0123456789", default[1]))
default = toint(default);
elseif (default == "{}")
default = {};
endif
else
default = 0;
prop = dobjstr;
endif
if (typeof(result = this:set_stateprops(prop, default)) == ERR)
player:tell((result == E_RANGE) ? tostr(".", prop, " needs to hold a list of the same length as .active (", length(this.active), ").") | ((result != E_NACC) ? result | (prop + " is already a property on an ancestral editor.")));
else
player:tell("Property added.");
endif
-------------------------------------------------------------------------------
#50 Generic Editor:@rmstateprop any in/inside/into this
if (!$perm_utils:controls(player, this))
player:tell(E_PERM);
elseif (typeof(result = this:set_stateprops(dobjstr)) == ERR)
player:tell((result != E_NACC) ? result | (dobjstr + " is already a property on an ancestral editor."));
else
player:tell("Property removed.");
endif
-------------------------------------------------------------------------------
#50 Generic Editor:initialize this n/a this
if ($perm_utils:controls(caller_perms(), this))
pass(@args);
this:kill_all_sessions();
endif
-------------------------------------------------------------------------------
#50 Generic Editor:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this:kill_all_sessions();
if (this == $generic_editor)
this.help = $editor_help;
endif
if ($object_utils:defines_verb(this, "is_not_banned"))
delete_verb(this, "is_not_banned");
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:set_stateprops this n/a this
remove = length(args) < 2;
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
elseif (!(length(args) in {1, 2}))
return E_ARGS;
elseif (typeof(prop = args[1]) != STR)
return E_TYPE;
elseif (i = $list_utils:iassoc(prop, this.stateprops))
if (!remove)
this.stateprops[i] = {prop, args[2]};
elseif ($object_utils:has_property(parent(this), prop))
return E_NACC;
else
this.stateprops = listdelete(this.stateprops, i);
endif
elseif (remove)
elseif (prop in `properties(this) ! ANY => {}')
if (this:_stateprop_length(prop) != length(this.active))
return E_RANGE;
endif
this.stateprops = {{prop, args[2]}, @this.stateprops};
else
return $object_utils:has_property(this, prop) ? E_NACC | E_PROPNF;
endif
return 0;
-------------------------------------------------------------------------------
#50 Generic Editor:description this n/a this
is_look_self = 1;
for c in (callers())
if (is_look_self && (c[2] in {"enterfunc", "confunc"}))
return {"", "Do a 'look' to get the list of commands, or 'help' for assistance.", "", @this.description};
elseif ((c[2] != "look_self") && (c[2] != "pass"))
is_look_self = 0;
endif
endfor
d = {"Commands:", ""};
col = {{}, {}};
for c in [1..2]
for cmd in (this.commands2[c])
cmd = this:commands_info(cmd);
col[c] = {cmdargs = $string_utils:left(cmd[1] + " ", 12) + cmd[2], @col[c]};
endfor
endfor
i1 = length(col[1]);
i2 = length(col[2]);
right = 0;
while (i1 || i2)
if (!((i1 && (length(col[1][i1]) > 35)) || (i2 && (length(col[2][i2]) > 35))))
d = {@d, $string_utils:left(i1 ? col[1][i1] | "", 40) + (i2 ? col[2][i2] | "")};
i1 && (i1 = i1 - 1);
i2 && (i2 = i2 - 1);
right = 0;
elseif (right && i2)
d = {@d, (length(col[2][i2]) > 35) ? $string_utils:right(col[2][i2], 75) | ($string_utils:space(40) + col[2][i2])};
i2 = i2 - 1;
right = 0;
elseif (i1)
d = {@d, col[1][i1]};
i1 = i1 - 1;
right = 1;
else
right = 1;
endif
endwhile
return {@d, "", "----  Do `help <cmdname>' for help with a given command.  ----", "", "  <ins> ::= $ (the end) | [^]n (above line n) | _n (below line n) | . (current)", "<range> ::= <lin> | <lin>-<lin> | from <lin> | to <lin> | from <lin> to <lin>", "  <lin> ::= n | [n]$ (n from the end) | [n]_ (n before .) | [n]^ (n after .)", "`help insert' and `help ranges' describe these in detail.", @this.description};
-------------------------------------------------------------------------------
#50 Generic Editor:commands_info this n/a this
cmd = args[1];
if (pc = $list_utils:assoc(cmd, this.commands))
return pc;
elseif (this == $generic_editor)
return {cmd, "<<<<<======= Need to add this to .commands"};
else
return parent(this):commands_info(cmd);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:match_object this n/a this
{objstr, ?who = player} = args;
origin = this;
while ((where = player in origin.active) && ($recycler:valid(origin = origin.original[where]) && (origin != this)))
if (!$object_utils:isa(origin, $generic_editor))
return origin:match_object(objstr, who);
endif
endwhile
return who:my_match_object(objstr, #-1);
-------------------------------------------------------------------------------
#50 Generic Editor:who_location_msg this n/a this
who = args[1];
where = {#-1, @this.original}[1 + (who in this.active)];
wherestr = `where:who_location_msg(who) ! ANY => "An Editor"';
if (typeof(wherestr) != STR)
wherestr = "broken who_location_msg";
endif
return strsub(this.who_location_msg, "%L", wherestr);
return $string_utils:pronoun_sub(this.who_location_msg, who, this, where);
-------------------------------------------------------------------------------
#50 Generic Editor:nothing_loaded_msg no_text_msg change_msg no_change_msg no_littering_msg depart_msg return_msg previous_session_msg this n/a this
return $code_utils:verb_or_property(player, verb, this) || this.(verb);
-------------------------------------------------------------------------------
#50 Generic Editor:announce announce_all announce_all_but tell_contents this n/a this
return;
-------------------------------------------------------------------------------
#50 Generic Editor:fill_string this n/a this
"fill(string [, width [, prefix]])";
"tries to cut <string> into substrings of length < <width> along word boundaries.  Prefix, if supplied, will be prefixed to the 2nd..last substrings.";
{string, ?width = 1 + player:linelen(), ?prefix = ""} = args;
width = width + 1;
if (width < (3 + length(prefix)))
return E_INVARG;
endif
string = ("$" + string) + " $";
len = length(string);
if (len <= width)
last = len - 1;
next = len;
else
last = rindex(string[1..width], " ");
if (last < ((width + 1) / 2))
last = width + index(string[width + 1..len], " ");
endif
next = last;
while (string[next = next + 1] == " ")
endwhile
endif
while (string[last = last - 1] == " ")
endwhile
ret = {string[2..last]};
width = width - length(prefix);
minlast = (width + 1) / 2;
while (next < len)
string = "$" + string[next..len];
len = (len - next) + 2;
if (len <= width)
last = len - 1;
next = len;
else
last = rindex(string[1..width], " ");
if (last < minlast)
last = width + index(string[width + 1..len], " ");
endif
next = last;
while (string[next = next + 1] == " ")
endwhile
endif
while (string[last = last - 1] == " ")
endwhile
if (last > 1)
ret = {@ret, prefix + string[2..last]};
endif
endwhile
return ret;
-------------------------------------------------------------------------------
#50 Generic Editor:here_huh this n/a this
"This catches subst and find commands that don't fit into the usual model, e.g., s/.../.../ without the space after the s, and find commands without the verb `find'.  Still behaves in annoying ways (e.g., loses if the search string contains multiple whitespace), but better than before.";
if ((caller != this) && (caller_perms() != player))
return E_PERM;
endif
{verb, args} = args;
v = 1;
vmax = min(length(verb), 5);
while ((v <= vmax) && (verb[v] == "subst"[v]))
v = v + 1;
endwhile
argstr = $code_utils:argstr(verb, args);
if ((v > 1) && ((v <= length(verb)) && (((vl = verb[v]) < "A") || (vl > "Z"))))
argstr = (verb[v..$] + (argstr && " ")) + argstr;
this:subst();
return 1;
elseif ("/" == verb[1])
argstr = (verb + (argstr && " ")) + argstr;
this:find();
return 1;
else
return 0;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:match this n/a this
return $failed_match;
-------------------------------------------------------------------------------
#50 Generic Editor:get_room this n/a this
":get_room([player])  => correct room to match in on invocation.";
{?who = player} = args;
if (who.location != this)
return who.location;
else
origin = this;
while ((where = player in origin.active) && (valid(origin = origin.original[where]) && (origin != this)))
if (!$object_utils:isa(origin, $generic_editor))
return origin;
endif
endwhile
return this;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:invoke_local_editor this n/a this
":invoke_local_editor(name, text, upload)";
"Spits out the magic text that invokes the local editor in the player's client.";
"NAME is a good human-readable name for the local editor to use for this particular piece of text.";
"TEXT is a string or list of strings, the initial body of the text being edited.";
"UPLOAD, a string, is a MOO command that the local editor can use to save the text when the user is done editing.  The local editor is going to send that command on a line by itself, followed by the new text lines, followed by a line containing only `.'.  The UPLOAD command should therefore call $command_utils:read_lines() to get the new text as a list of strings.";
if (caller != this)
return;
endif
{name, text, upload} = args;
if (typeof(text) == STR)
text = {text};
endif
notify(player, tostr("#$# edit name: ", name, " upload: ", upload));
":dump_lines() takes care of the final `.' ...";
for line in ($command_utils:dump_lines(text))
notify(player, line);
endfor
-------------------------------------------------------------------------------
#50 Generic Editor:_stateprop_length this n/a this
"+c properties on children cannot necessarily be read, so we need this silliness...";
if (caller != this)
return E_PERM;
else
return length(this.(args[1]));
endif
-------------------------------------------------------------------------------
#50 Generic Editor:print none n/a none
txt = this:text(player in this.active);
if (typeof(txt) == LIST)
player:tell_lines(txt);
else
player:tell("Text unreadable:  ", txt);
endif
player:tell("--------------------------");
-------------------------------------------------------------------------------
#50 Generic Editor:accept this n/a this
return this:acceptable(who_obj = args[1]) && this:new_session(who_obj, who_obj.location);
-------------------------------------------------------------------------------
#50 Generic Editor:y*ank any ?-2? any
"Usage: yank from <note>";
"       yank <message-sequence> from <mail-recipient>";
"       yank from <object>:<verb>";
"       yank from <object>.<property>";
"Grabs the specified text and inserts it at the cursor.";
set_task_perms(player);
if (dobjstr)
"yank <message-sequence> from <mail-recipient>";
if (!(p = player:parse_mailread_cmd(verb, args, "", "from")))
return;
elseif ($seq_utils:size(sequence = p[2]) != 1)
player:notify(tostr("You can only ", verb, " one message at a time"));
return;
else
m = (folder = p[1]):messages_in_seq(sequence);
msg = m[1];
header = tostr("Message ", msg[1]);
if (folder != player)
header = tostr(header, " on ", $mail_agent:name(folder));
endif
header = tostr(header, ":");
lines = {header, @player:msg_full_text(@msg[2])};
this:insert_line(this:loaded(player), lines, 0);
endif
elseif (pr = $code_utils:parse_propref(iobjstr))
o = player:my_match_object(pr[1]);
if ($command_utils:object_match_failed(o, pr[1]))
return;
elseif ((lines = `o.(pr[2]) ! ANY') == E_PROPNF)
player:notify(tostr("There is no `", pr[2], "' property on ", $string_utils:nn(o), "."));
return;
elseif (lines == E_PERM)
player:notify(tostr("Error: Permission denied reading ", iobjstr));
return;
elseif (typeof(lines) == ERR)
player:notify(tostr("Error: ", lines, " reading ", iobjstr));
return;
elseif (typeof(lines) == STR)
this:insert_line(this:loaded(player), lines, 0);
return;
elseif (typeof(lines) == LIST)
for x in (lines)
if (typeof(x) != STR)
player:notify(tostr("Error: ", iobjstr, " does not contain a ", verb, "-able value."));
return;
endif
endfor
this:insert_line(this:loaded(player), lines, 0);
return;
else
player:notify(tostr("Error: ", iobjstr, " does not contain a ", verb, "-able value."));
return;
endif
elseif (pr = $code_utils:parse_verbref(iobjstr))
o = player:my_match_object(pr[1]);
if ($command_utils:object_match_failed(o, pr[1]))
return;
elseif (lines = `verb_code(o, pr[2], !player:edit_option("no_parens")) ! ANY')
this:insert_line(this:loaded(player), lines, 0);
return;
elseif (lines == E_PERM)
player:notify(tostr("Error: Permission denied reading ", iobjstr));
return;
elseif (lines == E_VERBNF)
player:notify(tostr("There is no `", pr[2], "' verb on ", $string_utils:nn(o), "."));
else
player:notify(tostr("Error: ", lines, " reading ", iobjstr));
return;
endif
elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))
return;
elseif ((lines = `iobj:text() ! ANY') == E_PERM)
player:notify(tostr("Error: Permission denied reading ", iobjstr));
return;
elseif (lines == E_VERBNF)
player:notify(tostr($string_utils:nn(iobj), " doesn't seem to be a note."));
elseif (typeof(lines) == ERR)
player:notify(tostr("Error: ", lines, " reading ", iobjstr));
return;
else
this:insert_line(this:loaded(player), lines, 0);
endif
-------------------------------------------------------------------------------
#50 Generic Editor:do_flush this n/a this
"Flushes editor sessions older than args[1].  If args[2] is true, prints status as it runs.  If args[2] is false, runs silently.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
else
{t, noisy} = args;
for i in [-length(this.active)..-1]
if (this.times[-i] < t)
if (noisy)
player:tell($string_utils:nn(this.active[-i]), ctime(this.times[-i]));
endif
this:kill_session(-i);
endif
endfor
endif
-------------------------------------------------------------------------------
#50 Generic Editor:s*ubst any ?-2? any
if (callers() && (caller != this))
return E_PERM;
elseif (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(subst = this:parse_subst(argstr)) != LIST)
player:tell(tostr(subst));
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @$string_utils:explode(subst[4]))) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
else
{fromstr, tostr, specs, dummy} = subst;
global = index(specs, "g", 1);
regexp = index(specs, "r", 1);
case = !index(specs, "c", 1);
munged = {};
text = this.texts[who];
changed = {};
{from, to} = range[1..2];
for line in [from..to]
t = t0 = text[line];
if (!fromstr)
t = tostr + t;
elseif (global)
if (regexp)
while (new = this:subst_regexp(t, fromstr, tostr, case))
t = new;
endwhile
else
t = strsub(t, fromstr, tostr, case);
endif
else
if (regexp)
(new = this:subst_regexp(t, fromstr, tostr, case)) && (t = new);
else
(i = index(t, fromstr, case)) && (t = (t[1..i - 1] + tostr) + t[i + length(fromstr)..length(t)]);
endif
endif
if (strcmp(t0, t))
changed = {@changed, line};
endif
munged = {@munged, t};
endfor
if (!changed)
player:tell("No changes in line", (from == to) ? tostr(" ", from) | tostr("s ", from, "-", to), ".");
else
this.texts[who] = {@text[1..from - 1], @munged, @text[to + 1..$]};
if (!this.changes[who])
this.changes[who] = 1;
this.times[who] = time();
endif
for line in (changed)
this:list_line(who, line);
endfor
endif
endif
-------------------------------------------------------------------------------
#50 Generic Editor:subst_regexp this n/a this
"Copied from Domain (#8111):subst_regexp by Mooshie (#106469) Mon Jan  5 19:27:26 1998 PST";
"Usage: subst_regexp(STR text, STR from string, STR to string, INT case)";
{text, from, to, case} = args;
if (m = match(text, from, case))
{start, end} = m[1..2];
text[start..end] = substitute(to, m);
return text;
else
return m;
endif
-------------------------------------------------------------------------------
#50 Generic Editor:include_for_core this n/a this
return (this == $generic_editor) ? {"owner"} | {};
-------------------------------------------------------------------------------
================================#51 matching utilities===============================================
#51 matching utilities.ordw rc = MOOList [ "1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th" ]
#51 matching utilities.matching_room r = MOOObjRef #-1
#51 matching utilities.ordn rc = MOOList [ "first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth" ]
#51 matching utilities.ordinal_regexp rc = MOOString "%<%(first%|second%|third%|fourth%|fifth%|sixth%|seventh%|eighth%|ninth%|tenth%|1st%|2nd%|3rd%|4th%|5th%|6th%|7th%|8th%|9th%|10th%)%>"
#51 matching utilities:match this n/a this
":match(string, object-list)";
"Return object in 'object-list' aliased to 'string'.";
"Matches on a wide variety of syntax, including:";
" \"5th axe\" -- The fifth object matching \"axe\" in the object list.";
" \"where's sai\" -- The only object contained in 'where' matching \"sai\" (possible $ambiguous_match).";
" \"where's second staff\" -- The second object contained in 'where' matching \"staff\".";
" \"my third dagger\" -- The third object in your inventory matching \"dagger\".";
"Ordinal matches are determined according to the match's position in 'object-list' or, if a possessive (such as \"where\" above) is given, then the ordinal is the nth match in that object's inventory.";
"In the matching room (#3879@LambdaMOO), the 'object-list' consists of first the player's contents, then the room's, and finally all exits leading from the room.";
{string, olist} = args;
if (!string)
return $nothing;
elseif (string == "me")
return player;
elseif (string == "here")
return player.location;
elseif (valid(object = $string_utils:literal_object(string)))
return object;
elseif (valid(object = $string_utils:match(string, olist, "aliases")))
return object;
elseif (parsed = this:parse_ordinal_reference(string))
return this:match_nth(parsed[2], olist, parsed[1]);
elseif (parsed = this:parse_possessive_reference(string))
{whostr, objstr} = parsed;
if (valid(whose = this:match(whostr, olist)))
return this:match(objstr, whose.contents);
else
return whose;
endif
else
return object;
endif
"Profane (#30788) - Sat Jan  3, 1998 - Changed so literals get returned ONLY if in the passed object list.";
"Profane (#30788) - Sat Jan  3, 1998 - OK, that broke lots of stuff, so changed it back.";
-------------------------------------------------------------------------------
#51 matching utilities:match_nth this n/a this
":match_nth(string, objlist, n)";
"Find the nth object in 'objlist' that matches 'string'.";
{what, where, n} = args;
for v in (where)
z = 0;
for q in (v.aliases)
z = z || (index(q, what) == 1);
endfor
if (z && (!(n = n - 1)))
return v;
endif
endfor
return $failed_match;
-------------------------------------------------------------------------------
#51 matching utilities:match_verb this n/a this
"$match_utils:match_verb(verbname, object) => Looks for a command-line style verb named <verbname> on <object> with current values of prepstr, dobjstr, dobj, iobjstr, and iobj.  If a match is made, the verb is called with @args[3] as arguments and 1 is returned.  Otherwise, 0 is returned.";
{vrb, what, rest} = args;
if (where = $object_utils:has_verb(what, vrb))
if ((vargs = verb_args(where[1], vrb)) != {"this", "none", "this"})
if (((((((vargs[2] == "any") || ((!prepstr) && (vargs[2] == "none"))) || index(("/" + vargs[2]) + "/", ("/" + prepstr) + "/")) && (((vargs[1] == "any") || ((!dobjstr) && (vargs[1] == "none"))) || ((dobj == what) && (vargs[1] == "this")))) && (((vargs[3] == "any") || ((!iobjstr) && (vargs[3] == "none"))) || ((iobj == what) && (vargs[3] == "this")))) && index(verb_info(where[1], vrb)[2], "x")) && verb_code(where[1], vrb))
set_task_perms(caller_perms());
what:(vrb)(@rest);
return 1;
endif
endif
endif
-------------------------------------------------------------------------------
#51 matching utilities:match_list this n/a this
":match_list(string, object_list) -> List of all matches.";
{what, where} = args;
if (!what)
return {};
endif
r = {};
for v in (where)
if (!(v in r))
z = 0;
for q in (v.aliases)
z = z || (q && (index(q, what) == 1));
endfor
if (z)
"r = listappend(r, v);";
r = {@r, v};
endif
endif
endfor
return r;
"Hydros (#106189) - Sun Jul 3, 2005 - Changed listappend to a splice to save ticks. Old code commented above.";
-------------------------------------------------------------------------------
#51 matching utilities:parse_ordinal_reference parse_ordref this n/a this
":parse_ordref(string)";
"Parses strings referring to an 'nth' object.";
"=> {INT n, STR object} Where 'n' is the number the ordinal represents, and 'object' is the rest of the string.";
"=> 0 If the given string is not an ordinal reference.";
"  Example:";
":parse_ordref(\"second broadsword\") => {2, \"broadsword\"}";
":parse_ordref(\"second\") => 0";
"  Note that there must be more to the string than the ordinal alone.";
if (m = match(args[1], ("^" + this.ordinal_regexp) + " +%([^ ].+%)$"))
o = substitute("%1", m);
n = (o in this.ordn) || (o in this.ordw);
return n && {n, substitute("%2", m)};
else
return 0;
endif
-------------------------------------------------------------------------------
#51 matching utilities:parse_possessive_reference this n/a this
":parse_possessive_reference(string)";
"Parses strings in a possessive format.";
"=> {STR whose, STR object}  Where 'whose' is the possessor of 'object'.";
"If the string consists only of a possessive string (ie: \"my\", or \"yduJ's\"), then 'object' will be an empty string.";
"=> 0 If the given string is not a possessive reference.";
"  Example:";
":parse_possessive_reference(\"joe's cat\") => {\"joe\", \"cat\"}";
":parse_possessive_reference(\"sis' fish\") => {\"sis\", \"fish\"}";
"  Strings are returned as a value suitable for a :match routine, thus 'my' becoming 'me'.";
":parse_possessive_reference(\"my dog\") => {\"me\", \"dog\"}";
string = args[1];
if (m = match(string, "^my$%|^my +%(.+%)?"))
return {"me", substitute("%1", m)};
elseif (m = match(string, "^%(.+s?%)'s? *%(.+%)?"))
return {substitute("%1", m), substitute("%2", m)};
else
return 0;
endif
"Profane (#30788) - Sun Jun 21, 1998 - changed first parenthetical match bit from %([^ ]+s?%) to %(.+s?%)";
-------------------------------------------------------------------------------
#51 matching utilities:object_match_failed this n/a this
"Usage: object_match_failed(object, string[, ambigs])";
"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).";
"ambigs is an optional list of the objects that were matched upon.  If given, the message printed will list the ambiguous among them as choices.";
{match_result, string, ?ambigs = 0} = args;
tell = (0 && $perm_utils:controls(caller_perms(), player)) ? "notify" | "tell";
if ((index(string, "#") == 1) && ($code_utils:toobj(string) != E_TYPE))
"...avoid the `I don't know which `#-2' you mean' message...";
if (!valid(match_result))
player:(tell)(tostr("There is no \"", string, "\" that you can see."));
endif
return !valid(match_result);
elseif (match_result == $nothing)
player:(tell)("You must give the name of some object.");
elseif (match_result == $failed_match)
player:(tell)(tostr("There is no \"", string, "\" that you can see."));
elseif (match_result == $ambiguous_match)
if (typeof(ambigs) != LIST)
player:(tell)(tostr("I don't know which \"", string, "\" you mean."));
return 1;
endif
ambigs = $match_utils:match_list(string, ambigs);
ambigs = $list_utils:map_property(ambigs, "name");
if ((length($list_utils:remove_duplicates(ambigs)) == 1) && $object_utils:isa(player.location, this.matching_room))
player:(tell)(tostr("I don't know which \"", string, "\" you mean.  Try using \"first ", string, "\", \"second ", string, "\", etc."));
else
player:(tell)(tostr("I don't know which \"", string, "\" you mean: ", $string_utils:english_list(ambigs, "nothing", " or "), "."));
endif
return 1;
elseif (!valid(match_result))
player:(tell)(tostr("The object you specified does not exist.  Seeing ghosts?"));
else
return 0;
endif
return 1;
-------------------------------------------------------------------------------
#51 matching utilities:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.matching_room = $nothing;
endif
-------------------------------------------------------------------------------
================================#52 object utilities===============================================
#52 object utilities:has_property this n/a this
"Syntax:  has_property(OBJ, STR) => INT 0|1";
"";
"Does object have the specified property? Returns true if it is defined on the object or a parent.";
{object, prop} = args;
try
object.(prop);
return 1;
except (E_PROPNF, E_INVIND)
return 0;
endtry
"Old code...Ho_Yan 10/22/96";
if (prop in $code_utils.builtin_props)
return valid(object);
else
return !(!property_info(object, prop));
endif
-------------------------------------------------------------------------------
#52 object utilities:all_properties all_verbs this n/a this
"Syntax:  all_properties (OBJ what)";
"         all_verbs      (OBJ what)";
"";
"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms.";
what = args[1];
if (what.owner != caller_perms())
set_task_perms(caller_perms());
endif
bif = (verb == "all_verbs") ? "verbs" | "properties";
res = `call_function(bif, what) ! E_PERM => {}';
while (valid(what = parent(what)))
res = {@`call_function(bif, what) ! E_PERM => {}', @res};
endwhile
return res;
-------------------------------------------------------------------------------
#52 object utilities:has_verb this n/a this
":has_verb(OBJ object, STR verbname)";
"Find out if an object has a verb matching the given verbname.";
"Returns {location} if so, 0 if not, where location is the object or the ancestor on which the verb is actually defined.";
{object, verbname} = args;
while (valid(object))
try
if (verb_info(object, verbname))
return {object};
endif
except (E_VERBNF)
object = parent(object);
endtry
endwhile
return 0;
"OLD CODE BELOW:";
while (E_VERBNF == (vi = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))
object = parent(object);
endwhile
return vi ? {object} | 0;
-------------------------------------------------------------------------------
#52 object utilities:has_callable_verb this n/a this
"Usage:  has_callable_verb(object, verb)";
"See if an object has a verb that can be called by another verb (i.e., that has its x permission bit set).";
"Return {location}, where location is the object that defines the verb, or 0 if the object doesn't have the verb.";
{object, verbname} = args;
while (valid(object))
if (`index(verb_info(object, verbname)[2], "x") ! E_VERBNF => 0' && verb_code(object, verbname))
"Don't need to catch E_VERBNF in verb_code(), since it will never get there with the 0 &&";
return {object};
endif
object = parent(object);
endwhile
return 0;
-------------------------------------------------------------------------------
#52 object utilities:match_verb this n/a this
":match_verb(OBJ object, STR verb)";
"Find out if an object has a given verb, and some information about it.";
"Returns {OBJ location, STR verb} if matched, 0 if not.";
"Location is the object on which it is actually defined, verb is a name";
"for the verb which can subsequently be used in verb_info (i.e., no";
"asterisks).";
verbname = strsub(args[2], "*", "");
object = args[1];
while (E_VERBNF == (info = `verb_info(object, verbname) ! E_VERBNF, E_INVARG'))
object = parent(object);
endwhile
return info ? {object, verbname} | 0;
-------------------------------------------------------------------------------
#52 object utilities:isa this n/a this
":isa(x,y) == valid(x) && (y==x || y in :ancestors(x))";
{what, targ} = args;
while (valid(what))
if (what == targ)
return 1;
endif
what = parent(what);
endwhile
return 0;
-------------------------------------------------------------------------------
#52 object utilities:ancestors this n/a this
"Usage:  ancestors(object[, object...])";
"Return a list of all ancestors of the object(s) in args, with no duplicates.";
"If called with a single object, the result will be in order ascending up the inheritance hierarchy.  If called with multiple objects, it probably won't.";
ret = {};
for o in (args)
what = o;
while (valid(what = parent(what)))
ret = setadd(ret, what);
endwhile
endfor
return ret;
-------------------------------------------------------------------------------
#52 object utilities:ordered_descendants this n/a this
r = {what = args[1]};
for k in (children(what))
if (children(k))
r = {@r, @this:(verb)(k)};
else
r = {@r, k};
endif
endfor
return r;
-------------------------------------------------------------------------------
#52 object utilities:contains this n/a this
"$object_utils:contains(obj1, obj2) -- does obj1 contain obj2?";
"";
"Return true iff obj2 is under obj1 in the containment hierarchy; that is, if obj1 is obj2's location, or its location's location, or ...";
{loc, what} = args;
while (valid(what))
what = what.location;
if (what == loc)
return valid(loc);
endif
endwhile
return 0;
-------------------------------------------------------------------------------
#52 object utilities:all_contents this n/a this
"all_contents(object)";
"Return a list of all objects contained (at some level) by object.";
for y in (res = args[1].contents)
y.contents && (res = {@res, @this:all_contents(y)});
endfor
return res;
-------------------------------------------------------------------------------
#52 object utilities:findable_properties this n/a this
"findable_properties(object)";
"Return a list of properties on those members of object's ancestor list that are readable or are owned by the caller (or all properties if the caller is a wizard).";
what = args[1];
props = {};
who = caller_perms();
while (what != $nothing)
if ((what.r || (who == what.owner)) || who.wizard)
props = {@properties(what), @props};
endif
what = parent(what);
endwhile
return props;
-------------------------------------------------------------------------------
#52 object utilities:owned_properties this n/a this
"owned_properties(what[, who])";
"Return a list of all properties on WHAT owned by WHO.";
"Only wizardly verbs can specify WHO; mortal verbs can only search for properties owned by their own owners.  For more information, talk to Gary_Severn.";
what = anc = args[1];
who = ((c = caller_perms()).wizard && (length(args) > 1)) ? args[2] | c;
props = {};
while (anc != $nothing)
for k in (properties(anc))
if (property_info(what, k)[1] == who)
props = listappend(props, k);
endif
endfor
anc = parent(anc);
endwhile
return props;
-------------------------------------------------------------------------------
#52 object utilities:property_conflicts this n/a this
":property_conflicts(object,newparent)";
"Looks for propertyname conflicts that would keep chparent(object,newparent)";
"  from working.";
"Returns a list of elements of the form {<propname>, @<objectlist>}";
"where <objectlist> is list of descendents of object defining <propname>.";
if (!valid(object = args[1]))
return E_INVARG;
elseif (!valid(newparent = args[2]))
return (newparent == #-1) ? {} | E_INVARG;
elseif (!($perm_utils:controls(caller_perms(), object) && (newparent.f || $perm_utils:controls(caller_perms(), newparent))))
"... if you couldn't chparent anyway, you don't need to know...";
return E_PERM;
endif
"... properties existing on newparent";
"... cannot be present on object or any descendent...";
props = conflicts = {};
for o in ({object, @$object_utils:descendents_suspended(object)})
for p in (properties(o))
if (`property_info(newparent, p) ! E_PROPNF => 0')
if (i = p in props)
conflicts[i] = {@conflicts[i], o};
else
props = {@props, p};
conflicts = {@conflicts, {p, o}};
endif
endif
$command_utils:suspend_if_needed(0);
endfor
$command_utils:suspend_if_needed(0);
endfor
return conflicts;
-------------------------------------------------------------------------------
#52 object utilities:descendants_with_property_suspended this n/a this
":descendants_with_property_suspended(object,property)";
" => list of descendants of object on which property is defined.";
"calls suspend(0) as needed";
{object, prop} = args;
if ((caller == this) || (object.w || $perm_utils:controls(caller_perms(), object)))
$command_utils:suspend_if_needed(0);
if (`property_info(object, prop) ! E_PROPNF => 0')
return {object};
endif
r = {};
for c in (children(object))
r = {@r, @this:descendants_with_property_suspended(c, prop)};
endfor
return r;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#52 object utilities:locations this n/a this
"Usage:  locations(object)";
"Return a listing of the location hierarchy above object.";
ret = {};
what = args[1];
while (valid(what = what.location))
ret = {@ret, what};
endwhile
return ret;
-------------------------------------------------------------------------------
#52 object utilities:all_properties_suspended all_verbs_suspended this n/a this
"Syntax:  all_properties_suspended (OBJ what)";
"         all_verbs_suspended      (OBJ what)";
"";
"Returns all properties or verbs defined on `what' and all of its ancestors. Uses wizperms to get properties or verbs if the caller of this verb owns what, otherwise, uses caller's perms. Suspends as necessary";
what = args[1];
if (what.owner != caller_perms())
set_task_perms(caller_perms());
endif
bif = (verb == "all_verbs_suspended") ? "verbs" | "properties";
res = `call_function(bif, what) ! E_PERM => {}';
while (valid(what = parent(what)))
res = {@`call_function(bif, what) ! E_PERM => {}', @res};
$command_utils:suspend_if_needed(0);
endwhile
return res;
-------------------------------------------------------------------------------
#52 object utilities:connected this n/a this
":connected(object) => true if object is a connected player.";
"equivalent to (object in connected_players()) for valid players, perhaps with less server overhead.";
"use object:is_listening() if you want to allow for puppets and other non-player objects that still 'care' about what's said.";
return typeof(`connected_seconds(@args) ! E_INVARG') == INT;
-------------------------------------------------------------------------------
#52 object utilities:isoneof this n/a this
":isoneof(x,y) = x isa z, for some z in list y";
{what, targ} = args;
while (valid(what))
if (what in targ)
return 1;
endif
what = parent(what);
endwhile
return 0;
-------------------------------------------------------------------------------
#52 object utilities:defines_verb this n/a this
"Returns 1 if the verb is actually *defined* on this object, 0 else.";
"Use this instead of :has_verb if your aim is to manipulate that verb code or whatever.";
return `verb_info(@args) ! ANY => 0' && 1;
"Old code below...Ho_Yan 10/22/96";
info = verb_info(@args);
return typeof(info) != ERR;
-------------------------------------------------------------------------------
#52 object utilities:defines_property this n/a this
":defines_property(OBJ object, STR property name) => Returns 1 if the property is actually *defined* on the object given";
if (!valid(o = args[1]))
return 0;
elseif (!valid(p = parent(o)))
return this:has_property(o, args[2]);
else
return (!this:has_property(p, args[2])) && this:has_property(o, args[2]);
endif
-------------------------------------------------------------------------------
#52 object utilities:has_any_verb has_any_property this n/a this
":has_any_verb(object) / :has_any_property(object)";
" -- does `object' have any verbs/properties?";
return !(!`(verb == "has_any_verb") ? verbs(args[1]) | properties(args[1]) ! E_INVARG => 0');
-------------------------------------------------------------------------------
#52 object utilities:has_readable_prop*erty hrp this n/a this
":has_readable_property(OBJ object, STR property name) => 1 if property exists and is publically readable (has the r flag set true).";
{object, prop} = args;
try
pinfo = property_info(object, prop);
return index(pinfo[2], "r") != 0;
except (E_PROPNF)
return (prop in $code_utils.builtin_props) > 0;
endtry
-------------------------------------------------------------------------------
#52 object utilities:descendants descendents this n/a this
":descendants (OBJ object) => {OBJs} all nested children of <object>";
r = children(args[1]);
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r = {@r, @kids};
endif
i = i + 1;
endwhile
return r;
-------------------------------------------------------------------------------
#52 object utilities:leaves this n/a this
":leaves (OBJ object) => {OBJs} descendants of <object> that have no children";
r = {args[1]};
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i..i] = kids;
else
i = i + 1;
endif
endwhile
return r;
-------------------------------------------------------------------------------
#52 object utilities:branches this n/a this
":branches (OBJ object) => {OBJs} descendants of <object> that have children";
r = args[1..1];
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i + 1..i] = kids;
i = i + 1;
else
r[i..i] = {};
endif
endwhile
return r;
-------------------------------------------------------------------------------
#52 object utilities:descendants_suspended descendents_suspended this n/a this
":descendants_suspended (OBJ object) => {OBJs} all nested children of <object>";
set_task_perms(caller_perms());
r = children(args[1]);
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r = {@r, @kids};
endif
i = i + 1;
$command_utils:suspend_if_needed(0);
endwhile
return r;
-------------------------------------------------------------------------------
#52 object utilities:leaves_suspended this n/a this
":leaves_suspended (OBJ object) => {OBJs} descendants of <object> that have";
"                                         no children";
set_task_perms(caller_perms());
r = {args[1]};
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i..i] = kids;
else
i = i + 1;
endif
$command_utils:suspend_if_needed(0);
endwhile
return r;
-------------------------------------------------------------------------------
#52 object utilities:branches_suspended this n/a this
":branches_suspended (OBJ object) => {OBJs} all descendants of <object> that";
"                                           have children.";
set_task_perms(caller_perms());
r = args[1..1];
i = 1;
while (i <= length(r))
if (kids = children(r[i]))
r[i + 1..i] = kids;
i = i + 1;
else
r[i..i] = {};
endif
$command_utils:suspend_if_needed(0);
endwhile
return r;
-------------------------------------------------------------------------------
#52 object utilities:disown disinherit this n/a this
":disown(object) / :disinherit(object)";
" => 1 (for a successful disinheritance)";
" raises E_PERM, E_INVARG, E_ARGS";
cp = caller_perms();
"     no set_task_perms() because we need to be able to";
"     chparent() an object we don't own";
{victim} = args;
parent = parent(victim);
if ($perm_utils:controls(cp, victim))
raise(E_INVARG, tostr(victim.name, " (", victim, ") is yours.  Use @chparent."));
elseif (!valid(parent))
raise(E_INVARG, tostr(victim.name, " (", victim, ") is already an orphan."));
elseif (!$perm_utils:controls(cp, parent))
raise(E_PERM, tostr(parent.name, " (", parent, "), the parent of ", victim.name, " (", victim, "), is not yours."));
elseif (!valid(grandparent = parent(parent)))
"... still not sure about this... do we care?  --Rog...";
raise(E_INVARG, tostr(victim.name, " (", victim, ") has no grandparent to take custody."));
else
chparent(victim, grandparent);
return 1;
endif
-------------------------------------------------------------------------------
#52 object utilities:accessible_verbs this n/a this
"  accessible_verbs(object)   => a list of verb names (or E_PERM) regardless of readability of object";
{thing} = args;
valid(thing) || raise(E_INVARG, "Invalid object argument");
{num_verbs, verbs} = {length(verbs(thing)), {}};
set_task_perms(caller_perms());
"... caching num of verbs before for loop saves us ticks ...";
for i in [1..num_verbs]
verbs = {@verbs, `verb_info(thing, i)[3] ! E_PERM'};
endfor
return verbs;
-------------------------------------------------------------------------------
#52 object utilities:accessible_prop*erties accessible_props this n/a this
" :accessible_props(object)   => a list of property names (or E_PERM), regardless of the readability of the object.";
thing = args[1];
all = properties(thing);
props = {};
set_task_perms(caller_perms());
for i in (all)
$command_utils:suspend_if_needed(0);
if ((info = `property_info(thing, i) ! ANY') != E_PROPNF)
props = {@props, info ? i | E_PERM};
endif
endfor
return props;
"Last modified Mon Nov 28 06:19:35 2005 PST, by Roebare (#109000).";
-------------------------------------------------------------------------------
================================#53 lock utilities===============================================
#53 lock utilities.input_length rc = MOONumber 0
#53 lock utilities.input_string rc = MOOString ""
#53 lock utilities.index_incremented rc = MOONumber 0
#53 lock utilities.input_index rc = MOONumber 0
#53 lock utilities.player rc = MOONumber 0
#53 lock utilities:init_scanner this n/a this
this.input_string = args[1];
this.input_length = length(args[1]);
this.input_index = 1;
this.index_incremented = 0;
-------------------------------------------------------------------------------
#53 lock utilities:scan_token this n/a this
string = this.input_string;
len = this.input_length;
i = this.input_index;
while ((i <= len) && (string[i] == " "))
i = i + 1;
endwhile
if (i > len)
this.index_incremented = 0;
return "";
elseif ((ch = string[i]) in {"(", ")", "!", "?"})
this.input_index = i + 1;
this.index_incremented = 1;
return ch;
elseif (ch in {"&", "|"})
this.input_index = i = i + 1;
this.index_incremented = 1;
if ((i <= len) && (string[i] == ch))
this.input_index = i + 1;
this.index_incremented = 2;
endif
return ch + ch;
else
start = i;
while ((i <= len) && (!((ch = string[i]) in {"(", ")", "!", "?", "&", "|"})))
i = i + 1;
endwhile
this.input_index = i;
i = i - 1;
while (string[i] == " ")
i = i - 1;
endwhile
this.index_incremented = (i - start) + 1;
return this:canonicalize_spaces(string[start..i]);
endif
-------------------------------------------------------------------------------
#53 lock utilities:canonicalize_spaces this n/a this
name = args[1];
while (index(name, "  "))
name = strsub(name, "  ", " ");
endwhile
return name;
-------------------------------------------------------------------------------
#53 lock utilities:parse_keyexp this n/a this
"parse_keyexp(STRING keyexpression, OBJ player) => returns a list containing the coded key, or a string containing an error message if the attempt failed.";
"";
"Grammar for key expressions:";
"";
"    E ::= A       ";
"       |  E || A  ";
"       |  E && A  ";
"    A ::= ( E )   ";
"       |  ! A     ";
"       |  object  ";
"       |  ? object  ";
this:init_scanner(args[1]);
this.player = args[2];
return this:parse_E();
-------------------------------------------------------------------------------
#53 lock utilities:parse_E this n/a this
exp = this:parse_A();
if (typeof(exp) != STR)
while ((token = this:scan_token()) in {"&&", "||"})
rhs = this:parse_A();
if (typeof(rhs) == STR)
return rhs;
endif
exp = {token, exp, rhs};
endwhile
"The while loop above always eats a token. Reset it back so the iteration can find it again. Always losing `)'. Ho_Yan 3/9/95";
this.input_index = this.input_index - this.index_incremented;
endif
return exp;
-------------------------------------------------------------------------------
#53 lock utilities:parse_A this n/a this
token = this:scan_token();
if (token == "(")
exp = this:parse_E();
if ((typeof(exp) != STR) && (this:scan_token() != ")"))
return "Missing ')'";
else
return exp;
endif
elseif (token == "!")
exp = this:parse_A();
if (typeof(exp) == STR)
return exp;
else
return {"!", exp};
endif
elseif (token == "?")
next = this:scan_token();
if (next in {"(", ")", "!", "&&", "||", "?"})
return ("Missing object-name before '" + token) + "'";
elseif (next == "")
return "Missing object-name at end of key expression";
else
what = this:match_object(next);
if (typeof(what) == OBJ)
return {"?", this:match_object(next)};
else
return what;
endif
endif
elseif (token in {"&&", "||"})
return ("Missing expression before '" + token) + "'";
elseif (token == "")
return "Missing expression at end of key expression";
else
return this:match_object(token);
endif
-------------------------------------------------------------------------------
#53 lock utilities:eval_key this n/a this
"eval_key(LIST|OBJ coded key, OBJ testobject) => returns true if testobject will solve the provided key.";
{key, who} = args;
type = typeof(key);
if (!(type in {LIST, OBJ}))
return 1;
elseif (typeof(key) == OBJ)
return (who == key) || $object_utils:contains(who, key);
endif
op = key[1];
if (op == "!")
return !this:eval_key(key[2], who);
elseif (op == "?")
return key[2]:is_unlocked_for(who);
elseif (op == "&&")
return this:eval_key(key[2], who) && this:eval_key(key[3], who);
elseif (op == "||")
return this:eval_key(key[2], who) || this:eval_key(key[3], who);
else
raise(E_DIV);
endif
-------------------------------------------------------------------------------
#53 lock utilities:match_object this n/a this
"used by $lock_utils to unparse a key expression so one can use `here' and `me' as well as doing the regular object matching.";
token = args[1];
if (token == "me")
return this.player;
elseif (token == "here")
if (valid(this.player.location))
return this.player.location;
else
return ("'here' has no meaning where " + this.player.name) + " is";
endif
else
what = this.player.location:match_object(token);
if (what == $failed_match)
return ("Can't find an object named '" + token) + "'";
elseif (what == $ambiguous_match)
return ("Multiple objects named '" + token) + "'";
else
return what;
endif
endif
-------------------------------------------------------------------------------
#53 lock utilities:unparse_key this n/a this
":unparse_key(LIST|OBJ coded key) => returns a string describing the key in english/moo-code terms.";
"Example:";
"$lock_utils:unparse_key({\"||\", $hacker, $housekeeper}) => \"#18105[Hacker] || #36830[housekeeper]\"";
key = args[1];
type = typeof(key);
if (!(type in {LIST, OBJ}))
return "(None.)";
elseif (type == OBJ)
if (valid(key))
return tostr(key, "[", key.name, "]");
else
return tostr(key);
endif
else
op = key[1];
arg1 = this:unparse_key(key[2]);
if (op == "?")
return "?" + arg1;
elseif (op == "!")
if (typeof(key[2]) == LIST)
return ("!(" + arg1) + ")";
else
return "!" + arg1;
endif
elseif (op in {"&&", "||"})
other = (op == "&&") ? "||" | "&&";
lhs = arg1;
rhs = this:unparse_key(key[3]);
if ((typeof(key[2]) == OBJ) || (key[2][1] != other))
exp = lhs;
else
exp = ("(" + lhs) + ")";
endif
exp = ((exp + " ") + op) + " ";
if ((typeof(key[3]) == OBJ) || (key[3][1] != other))
exp = exp + rhs;
else
exp = ((exp + "(") + rhs) + ")";
endif
return exp;
else
raise(E_DIV);
endif
endif
-------------------------------------------------------------------------------
#53 lock utilities:eval_key_new this n/a this
set_task_perms($no_one);
{key, who} = args;
type = typeof(key);
if (!(type in {LIST, OBJ}))
return 1;
elseif (typeof(key) == OBJ)
return (who == key) || $object_utils:contains(who, key);
endif
op = key[1];
if (op == "!")
return !this:eval_key(key[2], who);
elseif (op == "?")
return key[2]:is_unlocked_for(who);
elseif (op == "&&")
return this:eval_key(key[2], who) && this:eval_key(key[3], who);
elseif (op == "||")
return this:eval_key(key[2], who) || this:eval_key(key[3], who);
elseif (op == ".")
if ($object_utils:has_property(who, key[2]) && who.(key[2]))
return 1;
else
for thing in ($object_utils:all_contents(who))
if ($object_utils:has_property(thing, key[2]) && thing.(key[2]))
return 1;
endif
endfor
endif
return 0;
elseif (op == ":")
if ($object_utils:has_verb(who, key[2]) && who:(key[2])())
return 1;
else
for thing in ($object_utils:all_contents(who))
if ($object_utils:has_verb(thing, key[2]) && thing:(key[2])())
return 1;
endif
endfor
endif
return 0;
else
raise(E_DIV);
endif
-------------------------------------------------------------------------------
#53 lock utilities:parse_A_new this n/a this
token = this:scan_token();
if (token == "(")
exp = this:parse_E();
if ((typeof(exp) != STR) && (this:scan_token() != ")"))
return "Missing ')'";
else
return exp;
endif
elseif (token == "!")
exp = this:parse_A();
if (typeof(exp) == STR)
return exp;
else
return {"!", exp};
endif
elseif (token == "?")
next = this:scan_token();
if (next in {":", ".", "(", ")", "!", "&&", "||", "?"})
return ("Missing object-name before '" + token) + "'";
elseif (next == "")
return "Missing object-name at end of key expression";
else
what = this:match_object(next);
if (typeof(what) == OBJ)
return {"?", this:match_object(next)};
else
return what;
endif
endif
elseif (token in {":", "."})
next = this:scan_token();
if (next in {":", ".", "(", ")", "!", "&&", "||", "?"})
return ("Missing verb-or-property-name before '" + token) + "'";
elseif (next == "")
return "Missing verb-or-property-name at end of key expression";
elseif (typeof(next) != STR)
return "Non-string verb-or-property-name at end of key expression";
else
return {token, next};
endif
elseif (token in {"&&", "||"})
return ("Missing expression before '" + token) + "'";
elseif (token == "")
return "Missing expression at end of key expression";
else
return this:match_object(token);
endif
-------------------------------------------------------------------------------
================================#54 generic letter===============================================
#54 generic letter.burn_succeeded_msg rc = MOOString "%T burns with a smokeless flame and leaves no ash."
#54 generic letter.burn_failed_msg rc = MOOString "%T might be damp.  In any case, %[tps] won't burn."
#54 generic letter.oburn_succeeded_msg rc = MOOString "stares at %t; %[tps] bursts into flame and disappears, leaving no ash."
#54 generic letter.oburn_failed_msg rc = MOONumber 0
#54 generic letter:burn this n/a none
who = valid(caller_perms()) ? caller_perms() | player;
if ($perm_utils:controls(who, this) || this:is_readable_by(who))
result = this:do_burn();
else
result = 0;
endif
player:tell(result ? this:burn_succeeded_msg() | this:burn_failed_msg());
if (msg = result ? this:oburn_succeeded_msg() | this:oburn_failed_msg())
player.location:announce(player.name, " ", msg);
endif
-------------------------------------------------------------------------------
#54 generic letter:burn_succeeded_msg oburn_succeeded_msg burn_failed_msg oburn_failed_msg this n/a this
return (msg = this.(verb)) ? $string_utils:pronoun_sub(msg) | "";
-------------------------------------------------------------------------------
#54 generic letter:do_burn this n/a this
if ((this != $letter) && ((caller == this) || $perm_utils:controls(caller_perms(), this)))
fork (0)
$recycler:_recycle(this);
endfork
return 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
================================#55 list utilities===============================================
#55 list utilities.nonstring_tell_lines r = MOOList [ ]
#55 list utilities:make this n/a this
":make(n[,elt]) => a list of n elements, each of which == elt. elt defaults to 0.";
{n, ?elt = 0} = args;
if (n < 0)
return E_INVARG;
endif
ret = {};
build = {elt};
while (1)
if (n % 2)
ret = {@ret, @build};
endif
if (n = n / 2)
build = {@build, @build};
else
return ret;
endif
endwhile
-------------------------------------------------------------------------------
#55 list utilities:range this n/a this
":range([m,]n) => {m,m+1,...,n}";
{?m = 1, n} = args;
ret = {};
for k in [m..n]
ret = {@ret, k};
endfor
return ret;
-------------------------------------------------------------------------------
#55 list utilities:map_prop*erty this n/a this
set_task_perms(caller_perms());
{objs, prop} = args;
if (length(objs) > 50)
return {@this:map_prop(objs[1..$ / 2], prop), @this:map_prop(objs[($ / 2) + 1..$], prop)};
endif
strs = {};
for foo in (objs)
strs = {@strs, foo.(prop)};
endfor
return strs;
-------------------------------------------------------------------------------
#55 list utilities:map_verb this n/a this
set_task_perms(caller_perms());
{objs, vrb, @rest} = args;
if (length(objs) > 50)
return {@this:map_verb(@listset(args, objs[1..$ / 2], 1)), @this:map_verb(@listset(args, objs[($ / 2) + 1..$], 1))};
endif
strs = {};
for o in (objs)
strs = {@strs, o:(vrb)(@rest)};
endfor
return strs;
-------------------------------------------------------------------------------
#55 list utilities:map_arg*s this n/a this
"map_arg([n,]object,verb,@args) -- assumes the nth element of args is a list, calls object:verb(@args) with each element of the list substituted in turn, returns the list of results.  n defaults to 1.";
"map_verb_arg(o,v,{a...},a2,a3,a4,a5)={o:v(a,a2,a3,a4,a5),...}";
"map_verb_arg(4,o,v,a1,a2,a3,{a...},a5)={o:v(a1,a2,a3,a,a5),...}";
set_task_perms(caller_perms());
if (n = args[1])
{object, verb, @rest} = args[2..$];
else
object = n;
n = 1;
{verb, @rest} = args[2..$];
endif
results = {};
for a in (rest[n])
results = listappend(results, object:(verb)(@listset(rest, a, n)));
endfor
return results;
-------------------------------------------------------------------------------
#55 list utilities:map_builtin this n/a this
":map_builtin(objectlist,func) applies func to each of the objects in turn and returns the corresponding list of results.  This function is mainly here for completeness -- in the vast majority of situations, a simple for loop is better.";
set_task_perms(caller_perms());
{objs, builtin} = args;
if (!`function_info(builtin) ! E_INVARG => 0')
return E_INVARG;
endif
if (length(objs) > 100)
return {@this:map_builtin(objs[1..$ / 2], builtin), @this:map_builtin(objs[($ / 2) + 1..$], builtin)};
endif
strs = {};
for foo in (objs)
strs = {@strs, call_function(builtin, foo)};
endfor
return strs;
-------------------------------------------------------------------------------
#55 list utilities:find_insert this n/a this
"find_insert(sortedlist,key) => index of first element in sortedlist > key";
"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 1 to length(sortedlist)+1, inclusive.";
{lst, key} = args;
if ((r = length(lst)) < 25)
for l in [1..r]
if (lst[l] > key)
return l;
endif
endfor
return r + 1;
else
l = 1;
while (r >= l)
if (key < lst[i = (r + l) / 2])
r = i - 1;
else
l = i + 1;
endif
endwhile
return l;
endif
-------------------------------------------------------------------------------
#55 list utilities:remove_duplicates this n/a this
"remove_duplicates(list) => list as a set, i.e., all repeated elements removed.";
out = {};
for x in (args[1])
out = setadd(out, x);
endfor
return out;
-------------------------------------------------------------------------------
#55 list utilities:arrayset this n/a this
"arrayset(list,value,pos1,...,posn) -- returns list modified such that";
"  list[pos1][pos2][...][posn] == value";
if (length(args) > 3)
return listset(@listset(args[1..3], this:arrayset(@listset(listdelete(args, 3), args[1][args[3]], 1)), 2));
"... Rog's entry in the Obfuscated MOO-Code Contest...";
else
return listset(@args);
endif
-------------------------------------------------------------------------------
#55 list utilities:setremove_all this n/a this
":setremove_all(set,elt) => set with *all* occurences of elt removed";
{set, what} = args;
while (w = what in set)
set[w..w] = {};
endwhile
return set;
-------------------------------------------------------------------------------
#55 list utilities:append this n/a this
"append({a,b,c},{d,e},{},{f,g,h},...) =>  {a,b,c,d,e,f,g,h}";
if (length(args) > 50)
return {@this:append(@args[1..$ / 2]), @this:append(@args[($ / 2) + 1..$])};
endif
l = {};
for a in (args)
l = {@l, @a};
endfor
return l;
-------------------------------------------------------------------------------
#55 list utilities:reverse this n/a this
"reverse(list) => reversed list";
return this:_reverse(@args[1]);
-------------------------------------------------------------------------------
#55 list utilities:_reverse this n/a this
":_reverse(@list) => reversed list";
if (length(args) > 50)
return {@this:_reverse(@args[($ / 2) + 1..$]), @this:_reverse(@args[1..$ / 2])};
endif
l = {};
for a in (args)
l = listinsert(l, a);
endfor
return l;
-------------------------------------------------------------------------------
#55 list utilities:compress this n/a this
"compress(list) => list with consecutive repeated elements removed, e.g.,";
"compress({a,b,b,c,b,b,b,d,d,e}) => {a,b,c,b,d,e}";
if (l = args[1])
out = {last = l[1]};
for x in (listdelete(l, 1))
if (x != last)
out = listappend(out, x);
last = x;
endif
endfor
return out;
else
return l;
endif
-------------------------------------------------------------------------------
#55 list utilities:sort this n/a this
"sort(list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.";
"sort({x1,x3,x2},{1,3,2}) => {x1,x2,x3}";
lst = args[1];
unsorted_keys = (use_sorted_lst = length(args) >= 2) ? args[2] | lst;
sorted_lst = sorted_keys = {};
for e in (unsorted_keys)
l = this:find_insert(sorted_keys, e);
sorted_keys = listinsert(sorted_keys, e, l);
if (use_sorted_lst)
sorted_lst = listinsert(sorted_lst, lst[length(sorted_keys)], l);
endif
endfor
return sorted_lst || sorted_keys;
-------------------------------------------------------------------------------
#55 list utilities:sort_suspended this n/a this
":sort_suspended(interval,list[,keys]) => sorts keys (assumed to be all numbers or strings) and returns list with the corresponding permutation applied to it.  keys defaults to the list itself.";
"does suspend(interval) as needed.";
set_task_perms(caller_perms());
interval = args[1];
if (typeof(interval) != INT)
return E_ARGS;
endif
lst = args[2];
unsorted_keys = (use_sorted_lst = length(args) >= 3) ? args[3] | lst;
sorted_lst = sorted_keys = {};
for e in (unsorted_keys)
l = this:find_insert(sorted_keys, e);
sorted_keys[l..l - 1] = {e};
if (use_sorted_lst)
sorted_lst[l..l - 1] = {lst[length(sorted_keys)]};
endif
$command_utils:suspend_if_needed(interval);
endfor
return sorted_lst || sorted_keys;
-------------------------------------------------------------------------------
#55 list utilities:slice this n/a this
"slice(alist[,index]) returns a list of the index-th elements of the elements of alist, e.g., ";
"    slice({{\"z\",1},{\"y\",2},{\"x\",5}},2) => {1,2,5}.";
"index defaults to 1 and may also be a nonempty list, e.g., ";
"    slice({{\"z\",1,3},{\"y\",2,4}},{2,1}) => {{1,\"z\"},{2,\"y\"}}";
{thelist, ?ind = 1} = args;
slice = {};
if (typeof(ind) == LIST)
for elt in (thelist)
s = {elt[ind[1]]};
for i in (listdelete(ind, 1))
s = {@s, elt[i]};
endfor
slice = {@slice, s};
endfor
else
for elt in (thelist)
slice = {@slice, elt[ind]};
endfor
endif
return slice;
-------------------------------------------------------------------------------
#55 list utilities:assoc this n/a this
"assoc(target,list[,index]) returns the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"returns {} if no such element is found";
{target, thelist, ?indx = 1} = args;
for t in (thelist)
if ((typeof(t) == LIST) && `t[indx] == target ! E_RANGE => 0')
return t;
endif
endfor
return {};
-------------------------------------------------------------------------------
#55 list utilities:iassoc this n/a this
"Copied from Moo_tilities (#332):iassoc by Mooshie (#106469) Wed Mar 18 19:27:51 1998 PST";
"Usage: iassoc(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"Returns 0 if no such element is found.";
{target, thelist, ?indx = 1} = args;
for element in (thelist)
if (`element[indx] == target ! E_RANGE, E_TYPE => 0')
if (typeof(element) == LIST)
return element in thelist;
endif
endif
endfor
return 0;
-------------------------------------------------------------------------------
#55 list utilities:iassoc_suspended this n/a this
"Copied from Moo_tilities (#332):iassoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:53 1998 PST";
"Usage: iassoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ]]) => Returns the index of the first element of `list' whose own index-th element is target. Index defaults to 1.";
"Returns 0 if no such element is found.";
"Suspends as needed. Suspend length defaults to 0.";
set_task_perms(caller_perms());
{target, thelist, ?indx = 1, ?suspend_for = 0} = args;
cu = $command_utils;
for element in (thelist)
if (`element[indx] == target ! E_RANGE, E_TYPE => 0' && (typeof(element) == LIST))
return element in thelist;
endif
cu:suspend_if_needed(suspend_for);
endfor
return 0;
"Mooshie (#106469) - Tue Feb 10, PST - :assoc_suspended does a set_task_perms, why shouldn't this?";
-------------------------------------------------------------------------------
#55 list utilities:assoc_prefix this n/a this
"assoc_prefix(target,list[,index]) returns the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.";
{target, thelist, ?indx = 1} = args;
for t in (thelist)
if ((typeof(t) == LIST) && ((length(t) >= indx) && (index(t[indx], target) == 1)))
return t;
endif
endfor
return {};
-------------------------------------------------------------------------------
#55 list utilities:iassoc_prefix this n/a this
"iassoc_prefix(target,list[,index]) returns the index of the first element of `list' whose own index-th element has target as a prefix.  Index defaults to 1.";
{target, lst, ?indx = 1} = args;
for i in [1..length(lst)]
if ((typeof(lsti = lst[i]) == LIST) && ((length(lsti) >= indx) && (index(lsti[indx], target) == 1)))
return i;
endif
endfor
return 0;
-------------------------------------------------------------------------------
#55 list utilities:iassoc_sorted this n/a this
"iassoc_sorted(target,sortedlist[,i]) => index of last element in sortedlist whose own i-th element is <= target.  i defaults to 1.";
"  sortedlist is assumed to be sorted in increasing order and the number returned is anywhere from 0 to length(sortedlist), inclusive.";
{target, lst, ?indx = 1} = args;
if ((r = length(lst)) < 25)
for l in [1..r]
if (target < lst[l][indx])
return l - 1;
endif
endfor
return r;
else
l = 0;
r = r + 1;
while ((r - 1) > l)
if (target < lst[i = (r + l) / 2][indx])
r = i;
else
l = i;
endif
endwhile
return l;
endif
-------------------------------------------------------------------------------
#55 list utilities:sort_alist this n/a this
":sort_alist(alist[,n]) sorts a list of tuples by n-th (1st) element.";
{alist, ?sort_on = 1} = args;
if ((alist_length = length(alist)) < 25)
"use insertion sort on short lists";
return this:sort(alist, this:slice(@args));
endif
left_index = alist_length / 2;
right_index = (alist_length + 1) / 2;
left_sublist = this:sort_alist(alist[1..left_index], sort_on);
right_sublist = this:sort_alist(alist[left_index + 1..alist_length], sort_on);
"...";
"... merge ...";
"...";
left_key = left_sublist[left_index][sort_on];
right_key = right_sublist[right_index][sort_on];
if (left_key > right_key)
merged_list = {};
else
"... alist_length >= 25 implies right_index >= 2...";
"... move right_index downward until left_key > right_key...";
r = right_index - 1;
while (left_key <= (right_key = right_sublist[r][sort_on]))
if (r = r - 1)
else
return {@left_sublist, @right_sublist};
endif
endwhile
merged_list = right_sublist[r + 1..right_index];
right_index = r;
endif
while (l = left_index - 1)
"... left_key > right_key ...";
"... move left_index downward until left_key <= right_key...";
while ((left_key = left_sublist[l][sort_on]) > right_key)
if (l = l - 1)
else
return {@right_sublist[1..right_index], @left_sublist[1..left_index], @merged_list};
endif
endwhile
merged_list[1..0] = left_sublist[l + 1..left_index];
left_index = l;
"... left_key <= right_key ...";
if (r = right_index - 1)
"... move right_index downward until left_key > right_key...";
while (left_key <= (right_key = right_sublist[r][sort_on]))
if (r = r - 1)
else
return {@left_sublist[1..left_index], @right_sublist[1..right_index], @merged_list};
endif
endwhile
merged_list[1..0] = right_sublist[r + 1..right_index];
right_index = r;
else
return {@left_sublist[1..left_index], right_sublist[1], @merged_list};
endif
endwhile
return {@right_sublist[1..right_index], left_sublist[1], @merged_list};
-------------------------------------------------------------------------------
#55 list utilities:sort_alist_suspended this n/a this
"sort_alist_suspended(interval,alist[,n]) sorts a list of tuples by n-th element.  n defaults to 1.  Calls suspend(interval) as necessary.";
set_task_perms(caller_perms());
"... so it can be killed...";
{interval, alist, ?sort_on = 1} = args;
if ((alist_length = length(alist)) < 10)
"insertion sort on short lists";
$command_utils:suspend_if_needed(interval);
return this:sort(alist, this:slice(@listdelete(args, 1)));
endif
"variables specially expanded for the anal-retentive";
left_index = alist_length / 2;
right_index = (alist_length + 1) / 2;
left_sublist = this:sort_alist_suspended(interval, alist[1..left_index], sort_on);
right_sublist = this:sort_alist_suspended(interval, alist[left_index + 1..alist_length], sort_on);
left_element = left_sublist[left_index];
right_element = right_sublist[right_index];
merged_list = {};
while (1)
$command_utils:suspend_if_needed(interval);
if (left_element[sort_on] > right_element[sort_on])
merged_list = {left_element, @merged_list};
if (left_index = left_index - 1)
left_element = left_sublist[left_index];
else
return {@right_sublist[1..right_index], @merged_list};
endif
else
merged_list = {right_element, @merged_list};
if (right_index = right_index - 1)
right_element = right_sublist[right_index];
else
return {@left_sublist[1..left_index], @merged_list};
endif
endif
endwhile
-------------------------------------------------------------------------------
#55 list utilities:randomly_permute this n/a this
":randomly_permute(list) => list with its elements randomly permuted";
"  each of the length(list)! possible permutations is equally likely";
plist = {};
for i in [1..length(ulist = args[1])]
plist = listinsert(plist, ulist[i], random(i));
endfor
return plist;
-------------------------------------------------------------------------------
#55 list utilities:count this n/a this
"$list_utils:count(item, list)";
"Returns the number of occurrences of item in list.";
{x, xlist} = args;
if (typeof(xlist) != LIST)
return E_INVARG;
endif
counter = 0;
while (loc = x in xlist)
counter = counter + 1;
xlist = xlist[loc + 1..$];
endwhile
return counter;
-------------------------------------------------------------------------------
#55 list utilities:flatten this n/a this
"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST";
":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'";
newlist = {};
for elm in (args[1])
if (typeof(elm) == LIST)
newlist = {@newlist, @this:flatten(elm)};
else
newlist = {@newlist, elm};
endif
endfor
return newlist;
-------------------------------------------------------------------------------
#55 list utilities:longest shortest this n/a this
"Copied from APHiD (#33119):longest Sun May  9 21:00:18 1993 PDT";
"$list_utils:longest(<list>)";
"$list_utils:shortest(<list>)";
"             - Returns the shortest or longest element in the list.  Elements may be either strings or lists.  Returns E_TYPE if passed a non-list or a list containing non-string/list elements.  Returns E_RANGE if passed an empty list.";
if (typeof(all = args[1]) != LIST)
return E_TYPE;
elseif (all == {})
return E_RANGE;
else
result = all[1];
for things in (all)
if ((typeof(things) != LIST) && (typeof(things) != STR))
return E_TYPE;
else
result = (((verb == "longest") && (length(result) < length(things))) || ((verb == "shortest") && (length(result) > length(things)))) ? things | result;
endif
endfor
endif
return result;
-------------------------------------------------------------------------------
#55 list utilities:check_nonstring_tell_lines this n/a this
"check_nonstring_tell_lines(lines)";
if (caller_perms().wizard)
"don't let a nonwizard mess up our stats";
for line in (args[1])
if (typeof(line) != STR)
this.nonstring_tell_lines = listappend(this.nonstring_tell_lines, callers());
return;
endif
endfor
endif
-------------------------------------------------------------------------------
#55 list utilities:reverse_suspended this n/a this
"reverse(list) => reversed list.  Does suspend(0) as necessary.";
set_task_perms(caller_perms());
"^^^For suspend task.";
return this:_reverse_suspended(@args[1]);
-------------------------------------------------------------------------------
#55 list utilities:_reverse_suspended this n/a this
":_reverse(@list) => reversed list";
set_task_perms(caller_perms());
$command_utils:suspend_if_needed(0);
if (length(args) > 50)
return {@this:_reverse_suspended(@args[($ / 2) + 1..$]), @this:_reverse_suspended(@args[1..$ / 2])};
endif
l = {};
for a in (args)
l = listinsert(l, a);
endfor
return l;
-------------------------------------------------------------------------------
#55 list utilities:randomly_permute_suspended this n/a this
":randomly_permute_suspended(list) => list with its elements randomly permuted";
"  each of the length(list)! possible permutations is equally likely";
set_task_perms(caller_perms());
plist = {};
for i in [1..length(ulist = args[1])]
plist = listinsert(plist, ulist[i], random(i));
$command_utils:suspend_if_needed(0);
endfor
return plist;
-------------------------------------------------------------------------------
#55 list utilities:swap_elements this n/a this
"swap_elements -- exchange two elements in a list";
"Usage:  $list_utils:swap_elements(<list/LIST>,<index/INT>,<index/INT>)";
"        $list_utils:swap_elements({\"a\",\"b\"},1,2);";
{l, i, j} = args;
if (((typeof(l) == LIST) && (typeof(i) == INT)) && (typeof(j) == INT))
ll = length(l);
if (((i > 0) && (i <= ll)) && ((j > 0) && (j <= ll)))
t = l[i];
l[i] = l[j];
l[j] = t;
return l;
else
return E_RANGE;
endif
else
return E_TYPE;
endif
-------------------------------------------------------------------------------
#55 list utilities:random_item random_element this n/a this
"random_item -- returns a random element of the input list.";
if (length(args) == 1)
if (typeof(l = args[1]) == LIST)
if (length(l) > 0)
return l[random($)];
else
return E_RANGE;
endif
else
return E_TYPE;
endif
else
return E_ARGS;
endif
-------------------------------------------------------------------------------
#55 list utilities:assoc_suspended this n/a this
"Copied from Moo_tilities (#332):assoc_suspended by Mooshie (#106469) Wed Mar 18 19:27:54 1998 PST";
"Usage: assoc_suspended(ANY target, LIST list [, INT index [, INT suspend-for ])) => Returns the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"Returns {} if no such element is found.";
"Suspends as necessary. Suspend length defaults to 0.";
set_task_perms(caller_perms());
{target, thelist, ?indx = 1, ?suspend_for = 0} = args;
cu = $command_utils;
for t in (thelist)
if (`t[indx] == target ! E_TYPE => 0')
if ((typeof(t) == LIST) && (length(t) >= indx))
return t;
endif
endif
cu:suspend_if_needed(suspend_for);
endfor
return {};
-------------------------------------------------------------------------------
#55 list utilities:amerge this n/a this
"Copied from Uther's_Ghost (#93141):amerge Tue May 27 20:28:18 1997 PDT";
"amerge(list[,tindex[,dindex]]) returns an associated list such that all the tuples in the original list with the same tindex-th element are merged. Useful for merging alists ( amerge({@alist1, @alist2, ...}) ) and for ensuring that each tuple has a unique index. Tindex defaults to 1. Dindex defaults to 1 and refers to the position in the tuple where the tindex-th element will land in the new tuple.";
{alist, ?tidx = 1, ?didx = 1} = args;
if (alist)
alist = this:sort_alist(alist, tidx);
i = 1;
res = {{cur = alist[1][tidx]}};
for tuple in (alist)
if (tuple[tidx] == cur)
res[i] = {@res[i], @listdelete(tuple, tidx)};
else
if (didx != 1)
res[i] = this:swap_elements(res[i], 1, min(didx, length(res[i])));
endif
i = i + 1;
res = {@res, {cur = tuple[tidx], @listdelete(tuple, tidx)}};
endif
endfor
return res;
endif
return alist;
-------------------------------------------------------------------------------
#55 list utilities:passoc this n/a this
"passoc -- essentially a hashtable lookup for parallel lists.  Parallel lists are an efficient way to store and access key/value pairs.";
"Usage:  $list_utils:passoc(<key>,<key-list>,<value-list>)";
"        avalue=$list_utils:passoc(\"akey\",keys,values)";
return args[3][args[1] in args[2]];
-------------------------------------------------------------------------------
#55 list utilities:setmove this n/a this
"Copied from Moo_tilities (#332):setmove by Mooshie (#106469) Mon Sep 22 21:07:25 1997 PDT";
"Usage: setmove(LIST elements, INT from, INT to)";
"Moves element in list from one position in list to another.";
"";
"Example: setmove({x, y, z}, 1, 3) => {y, z, x}";
"         setmove({x, y, z}, 2, 1} => {y, x, z}";
{start, from, to} = args;
what = start[from];
return listinsert(listdelete(start, from), what, to);
"  Written by Mooshie (#106469) @ Lambda - Mon Sep 22 21:03:26 1997 PDT -  ";
-------------------------------------------------------------------------------
#55 list utilities:iassoc_new this n/a this
"Copied from Moo_tilities (#332):iassoc_new by Mooshie (#106469) Wed Mar 18 19:27:52 1998 PST";
"Usage: iassoc_new(ANY target, LIST list [, INT index ]) => Returns the index of the first element of `list' whose own index-th element is target.  Index defaults to 1.";
"Returns 0 if no such element is found.";
"NOTE: expects that each index in the given list will be a list with at least as many elements as the indicated `index' argument. Otherwise will return E_RANGE";
{target, thelist, ?indx = 1} = args;
try
for element in (thelist)
if (element[indx] == target)
if (typeof(element) == LIST)
return element in thelist;
endif
endif
endfor
except e (ANY)
return e[1];
endtry
return 0;
-------------------------------------------------------------------------------
#55 list utilities:build_alist this n/a this
"Syntax:  build_alist(list, N) =>";
"{list[1..N], list[N+1..N*2], list[N*2+1..N*3], ..., list[N*(N-1)+1..N*N]}";
"";
"Creates an associated list from a flat list at every Nth interval. If the list doesn't have a multiple of N elements, E_RANGE is returned.";
"Example:  build_alist({a,b,c,d,e,f,g,h,i},3)=>{{a,b,c},{d,e,f},{g,h,i}}";
{olist, interval} = args;
if ((tot = length(olist)) % interval)
return E_RANGE;
endif
nlist = {};
d = 1;
while (d <= tot)
nlist = {@nlist, olist[1..interval]};
olist[1..interval] = {};
d = d + interval;
endwhile
return nlist;
-------------------------------------------------------------------------------
#55 list utilities:flatten_suspended this n/a this
"Copied from list utilities (#372):flatten [verb author Hacker (#18105)] at Sun Jul  3 07:46:47 2011 PDT";
"Copied from $quinn_utils (#34283):unroll by Quinn (#19845) Mon Mar  8 09:29:03 1993 PST";
":flatten(LIST list_of_lists) => LIST of all lists in given list `flattened'";
newlist = {};
for elm in (args[1])
if (typeof(elm) == LIST)
$command_utils:suspend_if_needed(0);
newlist = {@newlist, @this:flatten_suspended(elm)};
else
$command_utils:suspend_if_needed(0);
newlist = {@newlist, elm};
endif
endfor
return newlist;
-------------------------------------------------------------------------------
================================#56 command utilities===============================================
#56 command utilities.lag_samples r = MOOList [ ]
#56 command utilities.feature_task  = MOOList [ 388912170, "@abort", [ ], "", #-1, "", "", #-1, "" ]
#56 command utilities:object_match_failed this n/a this
"Usage: object_match_failed(object, string)";
"Prints a message if string does not match object.  Generally used after object is derived from a :match_object(string).";
{match_result, string} = args;
tell = $perm_utils:controls(caller_perms(), player) ? "notify" | "tell";
if ((index(string, "#") == 1) && ($code_utils:toobj(string) != E_TYPE))
"...avoid the `I don't know which `#-2' you mean' message...";
if (!valid(match_result))
player:(tell)(tostr(string, " does not exist."));
endif
return !valid(match_result);
elseif (match_result == $nothing)
player:(tell)("You must give the name of some object.");
elseif (match_result == $failed_match)
player:(tell)(tostr("I see no \"", string, "\" here."));
elseif (match_result == $ambiguous_match)
player:(tell)(tostr("I don't know which \"", string, "\" you mean."));
elseif (!valid(match_result))
player:(tell)(tostr(match_result, " does not exist."));
else
return 0;
endif
return 1;
-------------------------------------------------------------------------------
#56 command utilities:player_match_result player_match_failed this n/a this
":player_match_failed(result,string)";
"  is exactly like :object_match_failed(result,string)";
"  except that its messages are more suitable for player searches.";
":player_match_result(results,strings)";
"  handles a list of results, also presumably from $string_utils:match_player(strings), printing messages to player for *each* of the nonmatching strings.  It returns a list, an overall result (true if some string didn't match --- just like player_match_failed), followed by the list players that matched.";
"";
"An optional 3rd arg gives an identifying string to prefix to each of the nasty messages.";
if (valid(player))
tell = $perm_utils:controls(caller_perms(), player) ? "notify" | "tell";
plyr = player;
else
tell = "notify";
plyr = $login;
endif
"...";
{match_results, strings, ?cmdid = ""} = args;
pmf = verb == "player_match_failed";
if (typeof(match_results) == OBJ)
match_results = {match_results};
strings = {strings};
endif
pset = {};
bombed = 0;
for i in [1..length(match_results)]
if (valid(result = match_results[i]))
pset = setadd(pset, match_results[i]);
elseif (result == $nothing)
"... player_match_result quietly skips over blank strings";
if (pmf)
plyr:(tell)("You must give the name of some player.");
bombed = 1;
endif
elseif (result == $failed_match)
plyr:(tell)(tostr(cmdid, "\"", strings[i], "\" is not the name of any player."));
bombed = 1;
elseif (result == $ambiguous_match)
lst = $player_db:find_all(strings[i]);
plyr:(tell)(tostr(cmdid, "\"", strings[i], "\" could refer to ", (length(lst) > 20) ? tostr("any of ", length(lst), " players") | $string_utils:english_list($list_utils:map_arg(2, $string_utils, "pronoun_sub", "%n (%#)", lst), "no one", " or "), "."));
bombed = 1;
else
plyr:(tell)(tostr(result, " does not exist."));
bombed = 1;
endif
endfor
if ((!bombed) && (!pset))
"If there were NO valid results, but not any actual 'error', fail anyway.";
plyr:(tell)("You must give the name of some player.");
bombed = 1;
endif
return pmf ? bombed | {bombed, @pset};
-------------------------------------------------------------------------------
#56 command utilities:read this n/a this
"$command_utils:read() -- read a line of input from the player and return it";
"Optional argument is a prompt portion to replace `a line of input' in the prompt.";
"";
"Returns E_PERM if the current task is not the most recent task spawned by a command from player.";
{?prompt = "a line of input"} = args;
c = callers();
p = c[$][5];
p:notify(tostr("[Type ", prompt, " or `@abort' to abort the command.]"));
try
ans = read();
if ($string_utils:trim(ans) == "@abort")
p:notify(">> Command Aborted <<");
kill_task(task_id());
endif
return ans;
except error (ANY)
return error[1];
endtry
-------------------------------------------------------------------------------
#56 command utilities:read_lines this n/a this
"$command_utils:read_lines([max]) -- read zero or more lines of input";
"";
"Returns a list of strings, the (up to MAX, if given) lines typed by the player.  Returns E_PERM if the current task is not a command task that has never called suspend().";
"In order that one may enter arbitrary lines, including \"@abort\" or \".\", if the first character in an input line is `.' and there is some nonwhitespace afterwords, the `.' is dropped and the rest of the line is taken verbatim, so that, e.g., \".@abort\" enters as \"@abort\" and \"..\" enters as \".\".";
{?max = 0} = args;
c = callers();
p = c[$][5];
p:notify(tostr("[Type", max ? tostr(" up to ", max) | "", " lines of input; use `.' to end or `@abort' to abort the command.]"));
ans = {};
while (1)
try
line = read();
if ((line[1..min(6, $)] == "@abort") && ((tail = line[7..$]) == $string_utils:space(tail)))
p:notify(">> Command Aborted <<");
kill_task(task_id());
elseif ((!line) || (line[1] != "."))
ans = {@ans, line};
elseif ((tail = line[2..$]) == $string_utils:space(tail))
return ans;
else
ans = {@ans, tail};
endif
if (max && (length(ans) >= max))
return ans;
endif
except error (ANY)
return error[1];
endtry
endwhile
-------------------------------------------------------------------------------
#56 command utilities:yes_or_no this n/a this
":yes-or-no([prompt]) -- prompts the player for a yes or no answer and returns a true value iff the player enters a line of input that is some prefix of \"yes\"";
"";
"Returns E_NONE if the player enters a blank line, E_INVARG, if the player enters something that isn't a prefix of \"yes\" or \"no\", and E_PERM if the current task is not a command task that has never called suspend().";
c = callers();
p = c[$][5];
p:notify(tostr(args ? args[1] + " " | "", "[Enter `yes' or `no']"));
try
ans = read(@((caller == p) || $perm_utils:controls(caller_perms(), p)) ? {p} | {});
if (ans = $string_utils:trim(ans))
if (ans == "@abort")
p:notify(">> Command Aborted <<");
kill_task(task_id());
endif
return (index("yes", ans) == 1) || ((index("no", ans) != 1) && E_INVARG);
else
return E_NONE;
endif
except error (ANY)
return error[1];
endtry
-------------------------------------------------------------------------------
#56 command utilities:read_lines_escape this n/a this
"$command_utils:read_lines_escape(escapes[,help]) -- read zero or more lines of input";
"";
"Similar to :read_lines() except that help is available and one may specify other escape sequences to terminate the read.";
"  escapes should be either a string or list of strings; this specifies which inputs other from `.' or `@abort' should terminate the read (... don't use anything beginning with a `.').";
"  help should be a string or list of strings to be printed in response to the player typing `?'; the first line of the help text should be a general comment about what the input text should be used for.  Successive lines should describe the effects of the alternative escapes.";
"Returns {end,list-of-strings-input} where end is the particular line that terminated this input or 0 if input terminated normally with `.'.  Returns E_PERM if the current task is not a command task that has never called suspend().  ";
"@abort and lines beginning with `.' are treated exactly as with :read_lines()";
{escapes, ?help = "You are currently in a read loop."} = args;
c = callers();
p = c[$][5];
escapes = {".", "@abort", @(typeof(escapes) == LIST) ? escapes | {escapes}};
p:notify(tostr("[Type lines of input; `?' for help; end with `", $string_utils:english_list(escapes, "", "' or `", "', `", ""), "'.]"));
ans = {};
escapes[1..0] = {"?"};
"... set up the help text...";
if (typeof(help) != LIST)
help = {help};
endif
help[2..1] = {"Type `.' on a line by itself to finish.", "Anything else with a leading period is entered with the period removed.", "Type `@abort' to abort the command completely."};
while (1)
try
line = read();
if ((trimline = $string_utils:trimr(line)) in escapes)
if (trimline == ".")
return {0, ans};
elseif (trimline == "@abort")
p:notify(">> Command Aborted <<");
kill_task(task_id());
elseif (trimline == "?")
p:notify_lines(help);
else
return {trimline, ans};
endif
else
if (line && (line[1] == "."))
line[1..1] = "";
endif
ans = {@ans, line};
endif
except error (ANY)
return error[1];
endtry
endwhile
-------------------------------------------------------------------------------
#56 command utilities:suspend this n/a this
"Suspend, using output_delimiters() in case a client needs to keep track";
"of the output of the current command.";
"Args are TIME, amount of time to suspend, and optional (misnamed) OUTPUT.";
"If given no OUTPUT, just do a suspend.";
"If OUTPUT is neither list nor string, suspend and return output_delimiters";
"If OUTPUT is a list, it should be in the output_delimiters() format:";
"  {PREFIX, SUFFIX}.  Use these to handle that client stuff.";
"If OUTPUT is a string, it should be SUFFIX (output_delimiters[2])";
"";
"Proper usage:";
"The first time you want to suspend, use";
"  output_delimiters = $command_utils:suspend(time, x);";
"where x is some non-zero number.";
"Following, use";
"  $command_utils:suspend(time, output_delimiters);";
"To wrap things up, use";
"  $command_utils:suspend(time, output_delimiters[2]);";
"You'll probably want time == 0 most of the time.";
"Note: Using this from verbs called by other verbs could get pretty weird.";
{time, ?output = 0} = args;
set_task_perms(caller_perms());
value = 0;
if (!output)
suspend(time);
else
if (typeof(output) == LIST)
PREFIX = output[1];
SUFFIX = output[2];
if (PREFIX)
player:tell(output[2]);
endif
suspend(time);
if (SUFFIX)
player:tell(output[1]);
endif
elseif (typeof(output) == STR)
if (output)
player:tell(output);
endif
else
output = output_delimiters(player);
suspend(time);
if (output != {"", ""})
player:tell(output[1]);
endif
value = output;
endif
endif
return output;
-------------------------------------------------------------------------------
#56 command utilities:running_out_of_time this n/a this
"Return true if we're running out of ticks or seconds.";
return (ticks_left() < 4000) || (seconds_left() < 2);
"If this verb is changed make sure to change :suspend_if_needed as well.";
-------------------------------------------------------------------------------
#56 command utilities:suspend_if_needed this n/a this
"Usage:  $command_utils:suspend_if_needed(<time>[, @<announcement>])";
"See if we're running out of ticks or seconds, and if so suspend(<time>) and return true.  If more than one arg is given, print the remainder with player:tell.";
if ((ticks_left() < 4000) || (seconds_left() < 2))
"Note: above computation should be the same as :running_out_of_time.";
{?time = 10, @ann} = args;
if (ann && valid(player))
player:tell(tostr(@ann));
endif
amount = max(time, min($login:current_lag(), 10));
set_task_perms(caller_perms());
"this is trying to back off according to lag...";
suspend(amount);
return 1;
endif
-------------------------------------------------------------------------------
#56 command utilities:dump_lines this n/a this
":dump_lines(text) => text `.'-quoted for :read_lines()";
"  text is assumed to be a list of strings";
"Returns a corresponding list of strings which, when read via :read_lines, ";
"produces the original list of strings (essentially, any strings beginning ";
"with a period \".\" have the period doubled).";
"The list returned includes a final \".\"";
text = args[1];
newtext = {};
i = lasti = 0;
for line in (text)
if (match(line, "^%(%.%| *@abort *$%)"))
newtext = {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, "." + line};
lasti = i = i + 1;
else
i = i + 1;
endif
endfor
return {@newtext, @(i > lasti) ? text[lasti + 1..i] | {}, "."};
-------------------------------------------------------------------------------
#56 command utilities:explain_syntax this n/a this
":explain_syntax(here,verb,args)";
verb = args[2];
for x in ({player, args[1], @valid(dobj) ? {dobj} | {}, @valid(iobj) ? {iobj} | {}})
what = x;
while (hv = $object_utils:has_verb(what, verb))
what = hv[1];
i = 1;
while (i = $code_utils:find_verb_named(what, verb, i))
if (evs = $code_utils:explain_verb_syntax(x, verb, @verb_args(what, i)))
player:tell("Try this instead:  ", evs);
return 1;
endif
i = i + 1;
endwhile
what = parent(what);
endwhile
endfor
return 0;
-------------------------------------------------------------------------------
#56 command utilities:do_huh this n/a this
":do_huh(verb,args)  what :huh should do by default.";
{verb, args} = args;
if ($perm_utils:controls(caller_perms(), player) || (caller_perms() == player))
this.feature_task = {task_id(), verb, args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr};
endif
set_task_perms(cp = caller_perms());
notify = $perm_utils:controls(cp, player) ? "notify" | "tell";
if (verb == "")
"should only happen if a player types backslash";
player:(notify)("I don't understand that.");
return;
endif
if (player:my_huh(verb, args))
"... the player found something funky to do ...";
elseif (caller:here_huh(verb, args))
"... the room found something funky to do ...";
elseif (player:last_huh(verb, args))
"... player's second round found something to do ...";
elseif (dobj == $ambiguous_match)
if (iobj == $ambiguous_match)
player:(notify)(tostr("I don't understand that (\"", dobjstr, "\" and \"", iobjstr, "\" are both ambiguous names)."));
else
player:(notify)(tostr("I don't understand that (\"", dobjstr, "\" is an ambiguous name)."));
endif
elseif (iobj == $ambiguous_match)
player:(notify)(tostr("I don't understand that (\"", iobjstr, "\" is an ambiguous name)."));
else
player:(notify)("I don't understand that.");
player:my_explain_syntax(caller, verb, args) || (caller:here_explain_syntax(caller, verb, args) || this:explain_syntax(caller, verb, args));
endif
-------------------------------------------------------------------------------
#56 command utilities:task_info this n/a this
"task_info(task id)";
"Return info (the same info supplied by queued_tasks()) about a given task id, or E_INVARG if there's no such task queued.";
"WIZARDLY";
set_task_perms(caller_perms());
tasks = queued_tasks();
task_id = args[1];
for task in (tasks)
if (task[1] == task_id)
return task;
endif
endfor
return E_INVARG;
-------------------------------------------------------------------------------
#56 command utilities:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.lag_samples = {};
this.feature_task = "hey, neat, no feature verbs have been run yet!";
endif
-------------------------------------------------------------------------------
#56 command utilities:kill_if_laggy this n/a this
"Kills this task if the current lag is greater than args[1].  Args[2..n] will be passed to player:tell.";
cutoff = args[1];
if ($login:current_lag() > cutoff)
player:tell(@listdelete(args, 1));
kill_task(task_id());
endif
-------------------------------------------------------------------------------
#56 command utilities:validate_feature this n/a this
":validate_feature(verb, args)";
"  (where `verb' and `args' are the arguments passed to :my_huh)";
"  returns true or false based on whether this is the same command typed by the user (comparing it against $command_utils.feature_task, set by $command_utils:do_huh).";
"  assumes that the :my_huh parsing has not suspended";
return {task_id(), @args, argstr, dobj, dobjstr, prepstr, iobj, iobjstr} == this.feature_task;
-------------------------------------------------------------------------------
================================#57 generic wizard===============================================
#57 generic wizard.public_identity rc = MOOObjRef #-1
#57 generic wizard.newt_victim_msg rc = MOOString ""
#57 generic wizard.advertised rc = MOONumber 1
#57 generic wizard.programmer_msg rc = MOOString "%d is now a programmer."
#57 generic wizard.toad_victim_msg rc = MOOString "Have a nice life..."
#57 generic wizard.mail_identity c = MOOObjRef #-1
#57 generic wizard.newt_msg rc = MOOString "%n @newts %d (%[#d])"
#57 generic wizard.toad_msg rc = MOOString "%n @toads %d (%[#d])"
#57 generic wizard.programmer_victim_msg rc = MOOString "You are now a programmer."
#57 generic wizard:@chown*# any ?-2? any
if ((!player.wizard) || (player != this))
player:notify("Sorry.");
return;
endif
set_task_perms(player);
args = setremove(args, "to");
if ((length(args) != 2) || (!args[2]))
player:notify(tostr("Usage:  ", verb, " <object-or-property-or-verb> <owner>"));
return;
endif
what = args[1];
owner = $string_utils:match_player(args[2]);
bynumber = verb == "@chown#";
if ($command_utils:player_match_result(owner, args[2])[1])
elseif (spec = $code_utils:parse_verbref(what))
object = this:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
vname = spec[2];
if (bynumber)
vname = $code_utils:toint(vname);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || (vname > length(verbs(object))))
return player:notify("Verb number out of range.");
endif
endif
info = `verb_info(object, vname) ! ANY';
if (info == E_VERBNF)
player:notify("That object does not define that verb.");
elseif (typeof(info) == ERR)
player:notify(tostr(info));
else
try
result = set_verb_info(object, vname, listset(info, owner, 1));
player:notify("Verb owner set.");
except e (ANY)
player:notify(e[2]);
endtry
endif
endif
elseif (bynumber)
player:notify("@chown# can only be used with verbs.");
elseif (index(what, ".") && (spec = $code_utils:parse_propref(what)))
object = this:my_match_object(spec[1]);
if (!$command_utils:object_match_failed(object, spec[1]))
pname = spec[2];
e = $wiz_utils:set_property_owner(object, pname, owner);
if (e == E_NONE)
player:notify("+c Property owner set.  Did you really want to do that?");
else
player:notify(tostr(e && "Property owner set."));
endif
endif
else
object = this:my_match_object(what);
if (!$command_utils:object_match_failed(object, what))
player:notify(tostr($wiz_utils:set_owner(object, owner) && "Object ownership changed."));
endif
endif
-------------------------------------------------------------------------------
#57 generic wizard:@shout any ?-2? any
if (caller != this)
raise(E_PERM);
endif
set_task_perms(player);
if ((length(args) == 1) && (argstr[1] == "\""))
argstr = args[1];
endif
shout = $gender_utils:get_conj("shouts", player);
for person in (connected_players())
if (person != player)
person:notify(tostr(player.name, " ", shout, ", \"", argstr, "\""));
endif
endfor
player:notify(tostr("You shout, \"", argstr, "\""));
-------------------------------------------------------------------------------
#57 generic wizard:@grant @grants* @transfer any any any
"@grant <object> to <player>";
"@grants <object> to <player>   --- same as @grant but may suspend.";
"@transfer <expression> to <player> -- like 'grant', but evalutes a possible list of objects to transfer, and modifies quota.";
"Ownership of the object changes as in @chown and :set_owner (i.e., .owner and all c properties change).  In addition all verbs and !c properties owned by the original owner change ownership as well.  Finally, for !c properties, instances on descendant objects change ownership (as in :set_property_owner).";
if ((!player.wizard) || (player != this))
player:notify("Sorry.");
return;
endif
set_task_perms(player);
if ((!iobjstr) || (!dobjstr))
return player:notify(tostr("Usage:  ", verb, " <object> to <player>"));
endif
if ($command_utils:player_match_failed(newowner = $string_utils:match_player(iobjstr), iobjstr))
"...newowner is bogus...";
return;
endif
if (verb == "@transfer")
objlist = player:eval_cmd_string(dobjstr, 0);
if (!objlist[1])
player:notify(tostr("Had trouble reading `", dobjstr, "': "));
player:notify_lines(@objlist[2]);
return;
elseif (typeof(objlist[2]) == OBJ)
objlist = objlist[2..2];
elseif (typeof(objlist[2]) != LIST)
player:notify(tostr("Value of `", dobjstr, "' is not an object or list:  ", toliteral(objlist[2])));
return;
else
objlist = objlist[2];
endif
elseif ($command_utils:object_match_failed(object = this:my_match_object(dobjstr), dobjstr))
"...object is bogus...";
return;
else
objlist = {object};
endif
"Used to check for quota of newowner, but doesn't anymore, cuz the quota check doesn't work";
suspendok = verb != "@grant";
player:tell("Transferring ", toliteral(objlist), " to ", $string_utils:nn(newowner));
for object in (objlist)
$command_utils:suspend_if_needed(0);
same = object.owner == newowner;
for vnum in [1..length(verbs(object))]
info = verb_info(object, vnum);
if (!((info[1] != object.owner) && (valid(info[1]) && is_player(info[1]))))
same = same && (info[1] == newowner);
set_verb_info(object, vnum, listset(info, newowner, 1));
endif
endfor
for prop in (properties(object))
if (suspendok && ((ticks_left() < 5000) || (seconds_left() < 2)))
suspend(0);
endif
info = property_info(object, prop);
if (!(index(info[2], "c") || (((info[1] != object.owner) && valid(info[1])) && is_player(info[1]))))
same = same && (info[1] == newowner);
$wiz_utils:set_property_owner(object, prop, newowner, suspendok);
endif
endfor
if (suspendok)
suspend(0);
endif
$wiz_utils:set_owner(object, newowner, suspendok);
if (same)
player:notify(tostr(newowner.name, " already owns everything ", newowner.ps, " is entitled to on ", object.name, "."));
else
player:notify(tostr("Ownership changed on ", $string_utils:nn(object), ", verb, properties and descendants' properties."));
endif
endfor
player:notify(tostr(verb, " complete."));
-------------------------------------------------------------------------------
#57 generic wizard:@programmer any n/a none
set_task_perms(player);
dobj = $string_utils:match_player(dobjstr);
if (dobj == $nothing)
player:notify(tostr("Usage:  ", verb, " <playername>"));
elseif ($command_utils:player_match_result(dobj, dobjstr)[1])
elseif ($wiz_utils:check_prog_restricted(dobj))
return player:notify(tostr("Sorry, ", dobj.name, " is not allowed to be a programmer."));
elseif ((dobj.description == $player.description) && (!$command_utils:yes_or_no($string_utils:pronoun_sub("@Programmer %d despite %[dpp] lack of description?"))))
player:notify(tostr("Okay, leaving ", dobj.name, " !programmer."));
return;
elseif (result = $wiz_utils:set_programmer(dobj))
player:notify(tostr(dobj.name, " (", dobj, ") is now a programmer.  ", dobj.ppc, " quota is currently ", $quota_utils:get_quota(dobj), "."));
player:notify(tostr(dobj.name, " and the other wizards have been notified."));
if (msg = this:programmer_victim_msg())
dobj:notify(msg);
endif
if ($object_utils:isa(dobj.location, $room) && (msg = this:programmer_msg()))
dobj.location:announce_all_but({dobj}, msg);
endif
elseif (result == E_NONE)
player:notify(tostr(dobj.name, " (", dobj, ") is already a programmer..."));
else
player:notify(tostr(result));
endif
-------------------------------------------------------------------------------
#57 generic wizard:make-core-database any n/a none
{?core_variant_name = ""} = args;
if (!player.wizard)
player:notify("Nice try, but permission denied.");
return;
elseif (length(connected_players()) > 1)
player:notify("You need to @boot everybody else before I'll believe this isn't the real MOO.");
abort = 1;
elseif (`boot_player(open_network_connection("localhost", 666)) ! ANY' != E_PERM)
player:notify("Why are outbound connections enabled?  I bet this is the real MOO.");
abort = 1;
else
abort = (!$command_utils:yes_or_no("Continuing with this command will destroy all but the central core of the database.  Are you sure you want to do this?  ")) || (!$command_utils:yes_or_no("Really sure? "));
endif
if (abort)
player:notify("Core database extraction aborted.");
return;
endif
"----------------------------------------";
player:notify("Messing with server options...");
spi = {};
for p in ({"protect_recycle", "protect_set_property_info", "protect_add_property", "protect_chparent", "bg_ticks"})
spi = {@spi, {p, $server_options.(p)}};
$server_options.(p) = 0;
endfor
$server_options.bg_ticks = 1000000;
add_property($server_options, "bg_seconds", 7, {player, "r"});
`load_server_options() ! ANY';
add_property($server_options, "__mcd__savesopt", spi, {player, "r"});
"----------------------------------------";
player:notify("Killing all queued tasks ...");
for t in (queued_tasks())
kill_task(t[1]);
endfor
suspend(0);
"----------------------------------------";
player:notify(tostr("Identifying objects to be saved", @core_variant_name ? {" for core variant '", core_variant_name, "'"} | {}, " ..."));
"... TODO --- core variant name lookup?";
core_variant = {{"name", core_variant_name}};
{saved, saved_props, skipped_parents, proxy_original, proxy_incore} = $core_object_info(core_variant, 1);
if (!(player in saved))
player:notify("Sorry, but this won't work unless you yourself are on the list of objects to be saved.");
player:notify("Core database extraction aborted.");
return;
endif
for ops in (saved_props)
{o, o_props} = ops;
for p in (o_props)
if (i = o.(p) in proxy_original)
o.(p) = proxy_incore[i];
endif
endfor
endfor
"... TODO --- why isn't this on #0:init_for_core ? --Rog";
$player_class = $mail_recipient_class;
"----------------------------------------";
player:notify("Stripping you of any personal verbs and/or properties ...");
for i in [1..length(verbs(player))]
delete_verb(player, 1);
endfor
for p in (properties(player))
delete_property(player, p);
endfor
chparent(player, $wiz);
for p in ($object_utils:all_properties(player))
clear_property(player, p);
endfor
player:set_name("Wizard");
player:set_aliases({"Wizard"});
player.description = "";
player.key = 0;
player.ownership_quota = 100;
player.password = 0;
player.last_password_time = 0;
$gender_utils:set(player, "neuter");
"----------------------------------------";
suspend(0);
owners_original = owners_incore = {};
for i in [1..length(proxy_original)]
o = proxy_original[i];
if (is_player(o) && (o != $no_one))
owners_original = {@owners_original, o};
owners_incore = {@owners_incore, proxy_incore[i]};
endif
endfor
for o in (saved)
if (is_player(o) && (o != $no_one))
owners_original = {@owners_original, o};
owners_incore = {@owners_incore, o};
endif
endfor
player:notify(tostr("Chowning every saved object, verb and property to one of ", $string_utils:nn(owners_incore), "..."));
for o in (saved)
$command_utils:suspend_if_needed(0, "... ", length(saved) - (o in saved), " to go");
if (i = o.owner in owners_original)
o.owner = owners_incore[i];
elseif (valid(o.owner) && o.owner.wizard)
o.owner = player;
else
o.owner = $hacker;
endif
old_verbs = {};
for j in [1..length(verbs(o))]
$command_utils:suspend_if_needed(0, "... ", length(saved) - (o in saved), " to go");
info = verb_info(o, j);
if (i = info[1] in owners_original)
info[1] = owners_incore[i];
elseif (valid(info[1]) && info[1].wizard)
info[1] = player;
else
info[1] = $hacker;
endif
set_verb_info(o, j, info);
if (index(info[3], "(old)"))
old_verbs = {j, @old_verbs};
endif
endfor
for vname in (old_verbs)
delete_verb(o, vname);
endfor
for p in ($object_utils:all_properties(o))
$command_utils:suspend_if_needed(0, "... ", length(saved) - (o in saved), " to go");
info = property_info(o, p);
if (i = info[1] in owners_original)
info[1] = owners_incore[i];
elseif (valid(info[1]) && info[1].wizard)
info[1] = player;
else
info[1] = $hacker;
endif
set_property_info(o, p, info);
endfor
endfor
"----------------------------------------";
player:notify("Removing all unsaved :recycle and :exitfunc verbs ...");
for o in [#0..max_object()]
$command_utils:suspend_if_needed(0, "... ", o);
if (valid(o) && (!(o in saved)))
for v in ({"recycle", "exitfunc"})
while ($object_utils:defines_verb(o, v))
delete_verb(o, v);
endwhile
endfor
endif
endfor
"----------------------------------------";
player:notify("Recycling unsaved objects ...");
add_property(this, "__mcd__pos", toint(max_object()), {player, "r"});
add_property(this, "__mcd__save", {core_variant, saved, saved_props, skipped_parents}, {player, "r"});
suspend(0);
try
this:mcd_2(core_variant, saved, saved_props, skipped_parents);
finally
if ((!queued_tasks()) && `this.__mcd__save ! E_PROPNF => 0')
"...use raw notify since we have no idea what will be b0rken";
notify(player, "Core database extraction failed.");
endif
endtry
-------------------------------------------------------------------------------
#57 generic wizard:@shutdown any ?-2? any
if (!player.wizard)
player:notify("Sorry.");
return;
elseif ($code_utils:task_valid($shutdown_task))
player:notify(tostr("Shutdown already in progress.  The MOO will be shut down in ", $time_utils:english_time($shutdown_time - time()), ", by ", $shutdown_message));
return;
endif
if (s = match(argstr, "^in +%([0-9]+%)%( +%|$%)"))
bounds = s[3][1];
delay = toint(argstr[bounds[1]..bounds[2]]);
argstr = argstr[s[2] + 1..$];
else
delay = 2;
endif
if (!$command_utils:yes_or_no(tostr("Do you really want to shut down the server in ", delay, " minutes?")))
player:notify("Aborted.");
return;
endif
announce_times = {};
if (delay > 0)
while (delay > 0)
announce_times = {@announce_times, delay * 60};
delay = delay / 2;
endwhile
announce_times = {@announce_times, 30, 10};
$shutdown_time = time() + announce_times[1];
endif
$shutdown_message = tostr(player.name, " (", player, "): ", argstr);
$shutdown_task = task_id();
for i in [1..length(announce_times)]
base_msg = tostr("*** The server will be shut down by ", player.name, " (", player, ") in ", $time_utils:english_time(announce_times[i]), ":");
msg = {base_msg, @$generic_editor:fill_string("*** " + argstr, length(base_msg) - 4, "*** ")};
"...use raw notify() since :notify() verb could be broken...";
for p in (connected_players())
for line in (msg)
notify(p, line);
endfor
$command_utils:suspend_if_needed(0);
endfor
suspend(announce_times[i] - {@announce_times, 0}[i + 1]);
endfor
for p in (connected_players())
notify(p, tostr("*** Server shutdown by ", $shutdown_message, " ***"));
boot_player(p);
endfor
suspend(0);
$shutdown_task = E_NONE;
set_task_perms(player);
shutdown(argstr);
-------------------------------------------------------------------------------
#57 generic wizard:@dump-d*atabase none n/a none
set_task_perms(player);
dump_database();
player:notify("Dumping...");
-------------------------------------------------------------------------------
#57 generic wizard:@who-calls any ?-2? any
set_task_perms(player);
if (argstr[1] != ":")
argstr = ":" + argstr;
endif
player:notify(tostr("Searching for verbs that appear to call ", argstr, " ..."));
player:notify("");
$code_utils:find_verbs_containing(argstr + "(");
-------------------------------------------------------------------------------
#57 generic wizard:mcd_2 none n/a none
if (!caller_perms().wizard)
return;
elseif (length(connected_players()) > 1)
return;
elseif (`boot_player(open_network_connection("localhost", 666)) ! ANY' != E_PERM)
return;
elseif (!("__mcd__pos" in properties(this)))
return;
endif
end = this.__mcd__pos;
{core_variant, saved, saved_props, skipped_parents} = args;
player:notify(tostr("*** Recycling from #", end, " ..."));
suspend(0);
fork (0)
try
this:mcd_2(core_variant, saved, saved_props, skipped_parents);
finally
if ((!queued_tasks()) && `this.__mcd__save ! E_PROPNF => 0')
"...use raw notify since we have no idea what will be b0rken";
notify(player, "Core database extraction failed.");
endif
endtry
endfork
for i in [0..end]
this.__mcd__pos = end - i;
o = toobj(end - i);
if ($command_utils:running_out_of_time())
return;
endif
if (valid(o) && (!(o in saved)))
for x in (o.contents)
move(x, #-1);
endfor
if (is_player(o))
"o.features = {}";
set_player_flag(o, 0);
endif
if (!(o in skipped_parents))
chparent(o, #-1);
endif
recycle(o);
endif
endfor
delete_property(this, "__mcd__pos");
spi = $server_options.__mcd__savesopt;
delete_property($server_options, "__mcd__savesopt");
delete_property($server_options, "bg_seconds");
for pv in (spi)
$server_options.(pv[1]) = pv[2];
endfor
load_server_options();
"----------------------------------------";
suspend(0);
player:notify("Killing queued tasks ...");
for t in (queued_tasks())
kill_task(t[1]);
endfor
"----------------------------------------";
player:notify("Compacting object numbers ...");
old_oids = new_oids = {player};
for o_ps in (saved_props)
$command_utils:suspend_if_needed(0);
{o, o_props} = o_ps;
for p in (o_props)
if ((p == "owner") || (p == "location"))
"...renumber() takes care of these";
elseif (i = (old = o.(p)) in old_oids)
o.(p) = new_oids[i];
elseif (valid(old))
new_oids[1..0] = {o.(p) = renumber(old)};
old_oids[1..0] = {old};
endif
endfor
endfor
for o in (saved)
if (valid(o) && (o != player))
renumber(o);
endif
endfor
reset_max_object();
"...rebuild saved list so that parents come before children...";
saved = {};
for o in [#0..max_object()]
os = {};
while (valid(o) && (!(o in saved)))
os = {o, @os};
o = parent(o);
endwhile
saved = {@saved, @os};
endfor
"----------------------------------------";
player:notify("Performing miscellaneous cleanups ...");
succeeded = 1;
for o in [#0..max_object()]
$command_utils:suspend_if_needed(0);
try
move(o, #-1);
except e (ANY)
player:notify(tostr("Couldn't move ", o, " => ", e[2]));
player:notify(toliteral(e[4]));
succeeded = 0;
endtry
endfor
for o in (saved)
$command_utils:suspend_if_needed(0);
if ($object_utils:has_callable_verb(o, "init_for_core"))
try
o:init_for_core(core_variant);
except e (ANY)
player:notify(tostr("Error from ", o, ":init_for_core => ", e[2]));
player:notify(toliteral(e[4]));
succeeded = 0;
endtry
endif
endfor
player:notify("Re-measuring everything ...");
for o in [#0..max_object()]
$command_utils:suspend_if_needed(0);
if (valid(o))
$byte_quota_utils:object_bytes(o);
endif
endfor
$wiz_utils:initialize_owned();
$byte_quota_utils:summarize_one_user(player);
delete_property(this, "__mcd__save");
player:notify("Core database extraction " + (succeeded ? "is complete." | "failed."));
if (succeeded)
boot_player(player);
shutdown();
endif
-------------------------------------------------------------------------------
#57 generic wizard:@toad @toad! @toad!! any ?-2? any
"@toad[!][!] <player> [blacklist|redlist|graylist] [commentary]";
whostr = args[1];
comment = $string_utils:first_word(argstr)[2];
if (verb == "@toad!!")
listname = "redlist";
elseif (verb == "@toad!")
listname = "blacklist";
elseif ((ln = {@args, ""}[2]) && (index(listname = $login:listname(ln), ln) == 1))
"...first word of coment is one of the magic words...";
comment = $string_utils:first_word(comment)[2];
else
listname = "";
endif
if ((!player.wizard) || (player != this))
player:notify("Yeah, right... you wish.");
return;
elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))
return;
elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))
player:notify(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
return;
elseif (who == player)
player:notify("If you want to toad yourself, you have to do it by hand.");
return;
endif
dobj = who;
if (msg = player:toad_victim_msg())
notify(who, msg);
endif
if ($wiz_utils:rename_all_instances(who, "disfunc", "toad_disfunc"))
player:notify(tostr(who, ":disfunc renamed."));
endif
if ($wiz_utils:rename_all_instances(who, "recycle", "toad_recycle"))
player:notify(tostr(who, ":recycle renamed."));
endif
"MOO-specific cleanup while still a player object.";
this:toad_cleanup(who);
e = $wiz_utils:unset_player(who, $hacker);
player:notify(e ? tostr(who.name, "(", who, ") is now a toad.") | tostr(e));
if (e && ($object_utils:isa(who.location, $room) && (msg = player:toad_msg())))
who.location:announce_all_but({who}, msg);
endif
if (listname && (!$login:(listname + "ed")(cname = $string_utils:connection_hostname(who.last_connect_place))))
$login:(listname + "_add")(cname);
player:notify(tostr("Site ", cname, " ", listname, "ed."));
else
cname = "";
endif
if (!comment)
player:notify("So why is this person being toaded?");
comment = $command_utils:read();
endif
$mail_agent:send_message(player, $toad_log, tostr("@toad ", who.name, " (", who, ")"), {$string_utils:from_list(who.all_connect_places, " "), @cname ? {$string_utils:capitalize(listname + "ed:  ") + cname} | {}, @comment ? {comment} | {}});
player:notify(tostr("Mail sent to ", $mail_agent:name($toad_log), "."));
`$local.waitlist:note_reapee(who, tostr("@toaded by ", player.name)) ! ANY';
-------------------------------------------------------------------------------
#57 generic wizard:@untoad @detoad any ?-2? any
"@untoad <object> [as namespec]";
"Turns object into a player.  Anything that isn't a guest is chowned to itself.";
if (!player.wizard)
player:notify("Yeah, right... you wish.");
elseif (prepstr && (prepstr != "as"))
player:notify(tostr("Usage:  ", verb, " <object> [as name,alias,alias...]"));
elseif ($command_utils:object_match_failed(dobj, dobjstr))
elseif (prepstr && (!(e = $building_utils:set_names(dobj, iobjstr))))
player:notify(tostr("Initial rename failed:  ", e));
elseif (e = $wiz_utils:set_player(dobj, g = $object_utils:isa(dobj, $guest)))
player:notify(tostr(dobj.name, "(", dobj, ") is now a ", g ? "usable guest." | "player."));
elseif (e == E_INVARG)
player:notify(tostr(dobj.name, "(", dobj, ") is not of an appropriate player class."));
player:notify("@chparent it to $player or some descendant.");
elseif (e == E_NONE)
player:notify(tostr(dobj.name, "(", dobj, ") is already a player."));
elseif (e == E_NACC)
player:notify("Wait until $player_db is finished updating...");
elseif (e == E_RECMOVE)
player:notify(tostr("The name `", dobj.name, "' is currently unavailable."));
player:notify(tostr("Try again with   ", verb, " ", dobj, " as <newname>"));
else
player:notify(tostr(e));
endif
-------------------------------------------------------------------------------
#57 generic wizard:@quota any beside any
"@quota <player> is [public] <number> [<reason>]";
"  changes a player's quota.  sends mail to the wizards.";
if (player != this)
return player:notify("Permission denied.");
endif
set_task_perms(player);
dobj = $string_utils:match_player(dobjstr);
if ($command_utils:player_match_result(dobj, dobjstr)[1])
return;
elseif (!valid(dobj))
player:notify("Set whose quota?");
return;
endif
if (iobjstr[1..min(7, $)] == "public ")
iobjstr[1..7] = "";
if ($object_utils:has_property($local, "public_quota_log"))
recipients = {$quota_log, $local.public_quota_log};
else
player:tell("No public quota log.");
return E_INVARG;
endif
else
recipients = {$quota_log};
endif
old = $quota_utils:get_quota(dobj);
qstr = iobjstr[1..(n = index(iobjstr + " ", " ")) - 1];
new = $code_utils:toint((qstr[1] == "+") ? qstr[2..$] | qstr);
reason = iobjstr[n + 1..$] || "(none)";
if (typeof(new) != INT)
player:notify(tostr("Set ", dobj.name, "'s quota to what?"));
return;
elseif (qstr[1] == "+")
new = old + new;
endif
result = $quota_utils:set_quota(dobj, new);
if (typeof(result) == ERR)
player:notify(tostr(result));
else
player:notify(tostr(dobj.name, "'s quota set to ", new, "."));
endif
$mail_agent:send_message(player, recipients, tostr("@quota ", dobj.name, " (", dobj, ") ", new, " (from ", old, ")"), tostr("Reason for quota ", ((new - old) < 0) ? "decrease: " | "increase: ", reason, index("?.!", reason[$]) ? "" | "."));
-------------------------------------------------------------------------------
#57 generic wizard:@players any ?-2? any
set_task_perms(player);
"The time below is Oct. 1, 1990, roughly the birthdate of the LambdaMOO server.";
start = 654768000;
now = time();
day = (24 * 60) * 60;
week = 7 * day;
month = 30 * day;
days_objects = days_players = {0, 0, 0, 0, 0, 0, 0};
weeks_objects = weeks_players = {0, 0, 0, 0};
months_objects = months_players = {};
nonplayer_objects = invalid_objects = 0;
always_objects = always_players = 0;
never_objects = never_players = 0;
numo = 0;
if (argstr)
if (((!dobjstr) && (prepstr == "with")) && (index("objects", iobjstr) == 1))
with_objects = 1;
else
player:notify(tostr("Usage:  ", verb, " [with objects]"));
return;
endif
else
with_objects = 0;
players = players();
endif
for i in [1..with_objects ? toint(max_object()) + 1 | length(players)]
if (with_objects)
o = toobj(i - 1);
else
o = players[i];
endif
if ($command_utils:running_out_of_time())
player:notify(tostr("... ", o));
suspend(0);
endif
if (valid(o))
numo = numo + 1;
p = is_player(o) ? o | o.owner;
if (!valid(p))
invalid_objects = invalid_objects + 1;
elseif (!$object_utils:isa(p, $player))
nonplayer_objects = nonplayer_objects + 1;
else
seconds = now - p.last_connect_time;
days = seconds / day;
weeks = seconds / week;
months = seconds / month;
if (seconds < 0)
if (is_player(o))
always_players = always_players + 1;
else
always_objects = always_objects + 1;
endif
elseif (seconds > (now - start))
if (is_player(o))
never_players = never_players + 1;
else
never_objects = never_objects + 1;
endif
elseif (months > 0)
while (months > length(months_players))
months_players = {@months_players, 0};
months_objects = {@months_objects, 0};
endwhile
if (is_player(o))
months_players[months] = months_players[months] + 1;
endif
months_objects[months] = months_objects[months] + 1;
elseif (weeks > 0)
if (is_player(o))
weeks_players[weeks] = weeks_players[weeks] + 1;
endif
weeks_objects[weeks] = weeks_objects[weeks] + 1;
else
if (is_player(o))
days_players[days + 1] = days_players[days + 1] + 1;
endif
days_objects[days + 1] = days_objects[days + 1] + 1;
endif
endif
endif
endfor
player:notify("");
player:notify(tostr("Last connected"));
player:notify(tostr("at least this     Num.     Cumul.   Cumul. %", with_objects ? "     Num.     Cumul.   Cumul. %" | ""));
player:notify(tostr("long ago        players   players   players ", with_objects ? "   objects   objects   objects" | ""));
player:notify(tostr("---------------------------------------------", with_objects ? "--------------------------------" | ""));
su = $string_utils;
col1 = 14;
col2 = 7;
col3 = 10;
col4 = 9;
col5 = 11;
col6 = 11;
col7 = 10;
nump = length(players());
totalp = totalo = 0;
for x in ({{days_players, days_objects, "day", 1}, {weeks_players, weeks_objects, "week", 0}, {months_players, months_objects, "month", 0}})
pcounts = x[1];
ocounts = x[2];
unit = x[3];
offset = x[4];
for i in [1..length(pcounts)]
$command_utils:suspend_if_needed(0);
j = i - offset;
player:notify(tostr(su:left(tostr(j, " ", unit, (j == 1) ? ":" | "s:"), col1), su:right(pcounts[i], col2), su:right(totalp = totalp + pcounts[i], col3), su:right((totalp * 100) / nump, col4), "%", with_objects ? tostr(su:right(ocounts[i], col5), su:right(totalo = totalo + ocounts[i], col6), su:right((totalo * 100) / numo, col7), "%") | ""));
endfor
player:notify("");
endfor
player:notify(tostr(su:left("Never:", col1), su:right(never_players, col2), su:right(totalp = totalp + never_players, col3), su:right((totalp * 100) / nump, col4), "%", with_objects ? tostr(su:right(never_objects, col5), su:right(totalo = totalo + never_objects, col6), su:right((totalo * 100) / numo, col7), "%") | ""));
player:notify(tostr(su:left("Always:", col1), su:right(always_players, col2), su:right(totalp = totalp + always_players, col3), su:right((totalp * 100) / nump, col4), "%", with_objects ? tostr(su:right(always_objects, col5), su:right(totalo = totalo + always_objects, col6), su:right((totalo * 100) / numo, col7), "%") | ""));
with_objects && player:notify(tostr(su:left("Non-player owner:", (((col1 + col2) + col3) + col4) + 1), su:right(nonplayer_objects, col5), su:right(totalo = totalo + nonplayer_objects, col6), su:right((totalo * 100) / numo, col7), "%"));
with_objects && player:notify(tostr(su:left("Invalid owner:", (((col1 + col2) + col3) + col4) + 1), su:right(invalid_objects, col5), su:right(totalo = totalo + invalid_objects, col6), su:right((totalo * 100) / numo, col7), "%"));
player:notify("");
-------------------------------------------------------------------------------
#57 generic wizard:kill_aux_wizard_parse this n/a this
"Auxiliary verb for parsing @kill soon [#-of-seconds] [player | everyone]";
"Args[1] is either # of seconds or player/everyone.";
"Args[2], if it exists, is player/everyone, and forces args[1] to have been # of seconds.";
"Return value: {# of seconds [default 60] , 1 for all, object for player.}";
set_task_perms(caller_perms());
nargs = length(args);
soon = toint(args[1]);
if (nargs > 1)
everyone = args[2];
elseif (soon <= 0)
everyone = args[1];
else
everyone = 0;
endif
if (everyone == "everyone")
everyone = 1;
elseif (typeof(everyone) == STR)
result = $string_utils:match_player(everyone);
if ($command_utils:player_match_failed(result, everyone))
player:notify(tostr("Usage:  ", callers()[1][2], " soon [number of seconds] [\"everyone\" | player name]"));
return {-1, -1};
else
return {soon ? soon | 60, result};
endif
endif
return {soon ? soon | 60, everyone ? everyone | player};
-------------------------------------------------------------------------------
#57 generic wizard:@grepcore @egrepcore any ?-2? any
set_task_perms(player);
if (!args)
player:notify(tostr("Usage:  ", verb, " <pattern>"));
return;
endif
pattern = argstr;
regexp = verb == "@egrepcore";
player:notify(tostr("Searching for core verbs ", regexp ? "matching the regular expression " | "containing the string ", toliteral(pattern), " ..."));
player:notify("");
$code_utils:(regexp ? "find_verbs_matching" | "find_verbs_containing")(pattern, $core_objects());
-------------------------------------------------------------------------------
#57 generic wizard:@net-who @@who any ?-2? any
"@net-who prints all connected users and hosts.";
"@net-who player player player prints specified users and current or most recent connected host.";
"@net-who from hoststring prints all players who have connected from that host or host substring.  Substring can include *'s, e.g. @net-who from *.foo.edu.";
set_task_perms(player);
su = $string_utils;
if ((prepstr == "from") && dobjstr)
player:notify(tostr("Usage:  ", verb, " from <host string>"));
elseif (((prepstr != "from") || dobjstr) || (!iobjstr))
"Not parsing 'from' here...  Instead printing connected/recent users.";
if (!(pstrs = args))
unsorted = connected_players();
else
unsorted = listdelete($command_utils:player_match_result(su:match_player(pstrs), pstrs), 1);
endif
if (!unsorted)
return;
endif
$wiz_utils:show_netwho_listing(player, unsorted);
else
$wiz_utils:show_netwho_from_listing(player, iobjstr);
endif
-------------------------------------------------------------------------------
#57 generic wizard:@make-player any ?-2? any
"Creates a player.";
"Syntax:  @make-player name email-address comments....";
"Generates a random password for the player.";
if ((!player.wizard) || callers())
return E_PERM;
elseif (length(args) < 2)
player:tell("Syntax:  @make-player name email-address comments....");
return;
elseif (args[2] == "for")
"common mistake: @make-player <name> for <email-address> ...";
args = listdelete(args, 2);
endif
return $wiz_utils:do_make_player(@args);
-------------------------------------------------------------------------------
#57 generic wizard:@abort-sh*utdown any ?-2? any
if (!player.wizard)
player:notify("Sorry.");
elseif (!$code_utils:task_valid($shutdown_task))
player:notify("No server shutdown in progress.");
$shutdown_task = E_NONE;
else
"... Reset time so that $login:check_for_shutdown shuts up...";
kill_task($shutdown_task);
$shutdown_task = E_NONE;
$shutdown_time = time() - 1;
for p in (connected_players())
notify(p, tostr("*** Server shutdown ABORTED by ", player.name, " (", player, ")", argstr && (":  " + argstr), " ***"));
endfor
endif
-------------------------------------------------------------------------------
#57 generic wizard:toad_msg toad_victim_msg programmer_msg programmer_victim_msg newt_msg newt_victim_msg this n/a this
"This is the canonical doing-something-to-somebody message.";
"The corresponding property can either be";
"   string             msg for all occasions";
"   list of 2 strings  {we-are-there-msg,we-are-elsewhere-msg}";
m = this.(verb);
if (typeof(m) != LIST)
return $string_utils:pronoun_sub(m);
elseif ((this.location == dobj.location) || (length(m) < 2))
return $string_utils:pronoun_sub(m[1]);
else
return $string_utils:pronoun_sub(m[2]);
endif
-------------------------------------------------------------------------------
#57 generic wizard:moveto this n/a this
set_task_perms((caller in {this, $generic_editor, $verb_editor, $mail_editor, $note_editor}) ? this.owner | caller_perms());
return `move(this, args[1]) ! ANY';
-------------------------------------------------------------------------------
#57 generic wizard:@newt any ?-2? any
"@newt <player> [commentary]";
"turns a player into a newt.  It can get better...";
"adds player to $login.newted, they will not be allowed to log in.";
"Sends mail to $newt_log giving .all_connect_places and commentary.";
whostr = args[1];
comment = $string_utils:first_word(argstr)[2];
if (!player.wizard)
player:notify("Yeah, right.");
elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))
return;
elseif (((whostr != who.name) && (!(whostr in who.aliases))) && (whostr != tostr(who)))
player:notify(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
return;
elseif (who == player)
player:notify("If you want to newt yourself, you have to do it by hand.");
return;
elseif (who in $login.newted)
player:notify(tostr(who.name, " appears to already be a newt."));
return;
else
$wiz_utils:newt_player(who, comment);
endif
-------------------------------------------------------------------------------
#57 generic wizard:@unnewt @denewt @get-better any ?-2? any
"@denewt <player> [commentary]";
"Remove the player from $Login.newted";
"Sends mail to $newt_log with commentary.";
whostr = args[1];
comment = $string_utils:first_word(argstr)[2];
if (!player.wizard)
player:notify("Yeah, right.");
elseif ($command_utils:player_match_failed(who = $string_utils:match_player(whostr), whostr))
return;
else
"Should parse email address and register user in some clever way.  Ick.";
if (!(who in $login.newted))
player:notify(tostr(who.name, " does not appear to be a newt."));
else
$login.newted = setremove($login.newted, who);
if (entry = $list_utils:assoc(who, $login.temporary_newts))
$login.temporary_newts = setremove($login.temporary_newts, entry);
endif
player:notify(tostr(who.name, " (", who, ") got better."));
$mail_agent:send_message(player, $newt_log, tostr("@denewt ", who.name, " (", who, ")"), comment ? {comment} | {});
endif
endif
-------------------------------------------------------------------------------
#57 generic wizard:@register any ?-2? any
"Registers a player.";
"Syntax:  @register name email-address [additional commentary]";
"Email-address is stored in $registration_db and on the player object.";
if (!player.wizard)
return player:tell(E_PERM);
endif
$wiz_utils:do_register(@args);
-------------------------------------------------------------------------------
#57 generic wizard:@new-password @newpassword any beside any
"@newpassword player is [string]";
"Set's a player's password; omit string to have one randomly generated.";
"Offer to email the password.";
if (!player.wizard)
return E_PERM;
elseif ($command_utils:player_match_failed(dobj = $string_utils:match_player(dobjstr), dobjstr))
return;
elseif (!(dobjstr in {@dobj.aliases, tostr(dobj)}))
player:notify(tostr("Must be a full name or an object number: ", dobj.name, " (", dobj, ")"));
else
$wiz_utils:do_new_password(dobj, iobjstr);
endif
-------------------------------------------------------------------------------
#57 generic wizard:@log any ?-2? any
"@log [<string>]    enters a comment in the server log.";
"If no string is given, you are prompted to enter one or more lines for an extended comment.";
set_task_perms(player);
whostr = tostr("from ", player.name, " (", player, ")");
if ((!player.wizard) || (player != caller))
player:notify("Yeah, right.");
elseif (argstr)
server_log(tostr("COMMENT: [", whostr, "]  ", argstr));
player:notify("One-line comment logged.");
elseif (lines = $command_utils:read_lines())
server_log(tostr("COMMENT: [", whostr, "]"));
for l in (lines)
server_log(l);
endfor
server_log(tostr("END_COMMENT."));
player:notify(tostr(length(lines), " lines logged as extended comment."));
endif
-------------------------------------------------------------------------------
#57 generic wizard:@guests any n/a none
set_task_perms(player);
n = (dobjstr == "all") ? 0 | $code_utils:toint(dobjstr || "20");
if (caller != this)
player:notify("You lose.");
elseif ((n == E_TYPE) && (index("now", dobjstr) != 1))
player:notify(tostr("Usage:  ", verb, " <number>  (where <number> indicates how many entries to look at in the guest log)"));
player:notify(tostr("Usage:  ", verb, " now (to see information about currently connected guests only)"));
elseif ((!dobjstr) || (index("now", dobjstr) != 1))
$guest_log:last(n);
else
"*way* too much copied code in here from @who...  Sorry.  --yduJ";
su = $string_utils;
conn = connected_players();
unsorted = {};
for g in ($object_utils:leaves($guest))
if (g in conn)
unsorted = {@unsorted, g};
endif
endfor
if (!unsorted)
player:tell("No guests found.");
return;
endif
footnotes = {};
alist = {};
nwidth = length("Player name");
for u in (unsorted)
pref = u.programmer ? "% " | "  ";
u.programmer && (footnotes = setadd(footnotes, "prog"));
u3 = {tostr(pref, u.name, " (", u, ")"), su:from_seconds(connected_seconds(u)), su:from_seconds(idle_seconds(u)), where = $string_utils:connection_hostname(connection_name(u))};
nwidth = max(length(u3[1]), nwidth);
if ($login:blacklisted(where))
where = "(*) " + where;
footnotes = setadd(footnotes, "black");
elseif ($login:graylisted(where))
where = "(+) " + where;
footnotes = setadd(footnotes, "gray");
endif
alist = {@alist, u3};
$command_utils:suspend_if_needed(0);
endfor
alist = $list_utils:sort_alist_suspended(0, alist, 3);
$command_utils:suspend_if_needed(0);
headers = {"Player name", "Connected", "Idle Time", "From Where"};
time_width = length("59 minutes") + 2;
before = {0, w1 = nwidth + 3, w2 = w1 + time_width, w3 = w2 + time_width};
tell1 = "  " + headers[1];
tell2 = "  " + su:space(headers[1], "-");
for j in [2..4]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
player:notify(tell1);
player:notify(tell2);
active = 0;
for a in (alist)
$command_utils:suspend_if_needed(0);
tell1 = a[1];
for j in [2..4]
tell1 = su:left(tell1, before[j]) + tostr(a[j]);
endfor
player:notify(tell1[1..min($, 79)]);
endfor
if (footnotes)
player:notify("");
if ("prog" in footnotes)
player:notify(" %  == programmer.");
endif
if ("black" in footnotes)
player:notify("(*) == blacklisted site.");
endif
if ("gray" in footnotes)
player:notify("(+) == graylisted site.");
endif
endif
player:tell("@guests display complete.");
endif
-------------------------------------------------------------------------------
#57 generic wizard:@rn mail_catch_up check_mail_lists current_message set_current_message get_current_message make_current_message kill_current_message @nn none n/a none
if (caller != this)
set_task_perms(valid(caller_perms()) ? caller_perms() | player);
endif
use = this.mail_identity;
if (valid(use) && (use != this))
return use:(verb)(@args);
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#57 generic wizard:@blacklist @graylist @redlist @unblacklist @ungraylist @unredlist @spooflist @unspooflist any ?-2? any
"@[un]blacklist [<site or subnet>  [for <duration>] [commentary]]";
"@[un]graylist  [<site or subnet>  [for <duration>] [commentary]]";
"@[un]redlist   [<site or subnet>  [for <duration>] [commentary]]";
"@[un]spooflist [<site of subnet>  [for <duration>] [commentary]]";
"The `for <duration>' is for temporary colorlisting a site only. The duration should be in english time units:  for 1 hour, for 1 day 2 hours 15 minutes, etc. The commentary should be after all durations. Note, if you are -not- using a duration, do not start your commentary with the word `for'.";
set_task_perms(player);
if ((player != this) || (!player.wizard))
player:notify("Ummm.  no.");
return;
endif
undo = verb[2..3] == "un";
which = $login:listname(verb[undo ? 4 | 2]);
downgrade = {"", "graylist", "blacklist"}[1 + index("br", which[1])];
if (!(fw = $string_utils:first_word(argstr)))
"... Just print the list...";
this:display_list(which);
return;
endif
target = fw[1];
if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])
if ((typeof(parse[3]) == ERR) || (!parse[3]))
player:notify(tostr("Could not parse the duration for @", which, "ing site \"", target, "\""));
return;
endif
start = parse[2];
duration = parse[3];
comment = parse[4] ? {parse[4]} | {};
comment = {tostr("for ", $time_utils:english_time(duration)), @comment};
elseif (fw[2])
comment = {fw[2]};
else
"Get the right vars set up as though parse had been called";
parse = {0, ""};
comment = {};
endif
player:tell("comment is currently ", toliteral(comment));
if (is_literal = $site_db:domain_literal(target))
if (target[$] == ".")
target = target[1..$ - 1];
endif
fullname = "subnet " + target;
else
if (target[1] == ".")
target[1..1] = "";
endif
fullname = ("domain `" + target) + "'";
endif
entrylist = $login.(which)[1 + (!is_literal)];
if ((!undo) && (target in entrylist))
player:notify(tostr(fullname, " is already ", which, "ed."));
return;
endif
entrylist = setremove(entrylist, target);
if (!(result = this:check_site_entries(undo, which, target, is_literal, entrylist))[1])
return;
endif
rm = result[2];
namelist = $string_utils:english_list(rm);
downgraded = {};
if (rm)
ntries = (length(rm) == 1) ? "ntry" | "ntries";
if ($command_utils:yes_or_no(tostr("Remove e", ntries, " for ", namelist, "?")))
dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + " them?"));
for s in (rm)
$login:(which + "_remove")(s);
dg && ($login:(downgrade + "_add")(s) && (downgraded = {@downgraded, s}));
endfor
player:notify(tostr("E", ntries, " removed", @dg ? {" and ", downgrade, "ed."} | {"."}));
else
player:notify(tostr(namelist, " will continue to be ", which, "ed."));
rm = {};
endif
endif
if (downgraded)
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(downgraded), ".")};
endif
tempentrylist = $login.("temporary_" + which)[1 + (!is_literal)];
if ((!undo) && (target in $list_utils:slice(tempentrylist)))
player:notify(tostr(fullname, " is already temporarily ", which, "ed."));
return;
endif
if (en = $list_utils:assoc(target, tempentrylist))
tempentrylist = setremove(tempentrylist, en);
endif
if (!(result = this:check_site_entries(undo, which, target, is_literal, $list_utils:slice(tempentrylist)))[1])
return;
endif
rmtemp = result[2];
tempnamelist = $string_utils:english_list(rmtemp);
tempdowngraded = {};
if (rmtemp)
ntries = (length(rmtemp) == 1) ? "ntry" | "ntries";
if ($command_utils:yes_or_no(tostr("Remove e", ntries, " for ", tempnamelist, "?")))
dg = undo && (downgrade && $command_utils:yes_or_no(downgrade + " them?"));
for s in (rmtemp)
old = $list_utils:assoc(s, tempentrylist);
$login:(which + "_remove_temp")(s);
dg && ($login:(downgrade + "_add_temp")(s, old[2], old[3]) && (tempdowngraded = {@tempdowngraded, s}));
endfor
player:notify(tostr("E", ntries, " removed", @dg ? {" and ", downgrade, "ed with durations transferred."} | {"."}));
else
player:notify(tostr(tempnamelist, " will continue to be temporarily ", which, "ed."));
rmtemp = {};
endif
endif
if (tempdowngraded)
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(tempdowngraded), ".")};
endif
if (!undo)
if (parse[1])
$login:(which + "_add_temp")(target, start, duration);
player:notify(tostr(fullname, " ", which, "ed for ", $time_utils:english_time(duration)));
else
$login:(which + "_add")(target);
player:notify(tostr(fullname, " ", which, "ed."));
endif
if (rm)
comment[1..0] = {tostr("Subsumes ", which, "ing for ", namelist, ".")};
endif
if (rmtemp)
comment[1..0] = {tostr("Subsumes temporary ", which, "ing for ", tempnamelist, ".")};
endif
elseif ($login:(which + "_remove")(target))
player:notify(tostr(fullname, " un", which, "ed."));
if (!downgrade)
elseif ($command_utils:yes_or_no(downgrade + " it?"))
$login:(downgrade + "_add")(target) && (downgraded = {target, @downgraded});
player:notify(tostr(fullname, " ", downgrade, "ed."));
else
player:notify(tostr(fullname, " not ", downgrade, "ed."));
endif
if (downgraded)
player:tell("Comment currently: ", toliteral(comment), " ; downgrade = ", toliteral(downgrade), " ; downgraded = ", toliteral(downgraded));
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(downgraded), ".")};
endif
if (rm)
comment[1..0] = {tostr("Also removed ", namelist, ".")};
endif
elseif ((old = $list_utils:assoc(target, $login.("temporary_" + which)[1 + (!is_literal)])) && $login:(which + "_remove_temp")(target))
player:notify(tostr(fullname, " un", which, "ed."));
if (!downgrade)
elseif ($command_utils:yes_or_no(downgrade + " it?"))
$login:(downgrade + "_add_temp")(target, old[2], old[3]) && (tempdowngraded = {target, @tempdowngraded});
player:notify(tostr(fullname, " ", downgrade, "ed, currently for ", $time_utils:english_time(old[3]), " from ", $time_utils:time_sub("$1/$3", old[2])));
else
player:notify(tostr(fullname, " not ", downgrade, "ed."));
endif
if (tempdowngraded)
comment[1..0] = {tostr(downgrade, "ed ", $string_utils:english_list(tempdowngraded), "with durations transferred.")};
endif
if (rmtemp)
comment[1..0] = {tostr("Also removed ", tempnamelist, ".")};
endif
elseif (rm || rmtemp)
player:notify(tostr(fullname, " itself was never actually ", which, "ed."));
comment[1..0] = {tostr("Removed ", namelist, " from regular and ", tempnamelist, " from temporary.")};
else
player:notify(tostr(fullname, " was not ", which, "ed before."));
return;
endif
subject = tostr(undo ? "@un" | "@", which, " ", fullname);
$mail_agent:send_message(player, $site_log, subject, comment);
"...";
"... make sure we haven't screwed ourselves...";
uhoh = {};
for site in (player.all_connect_places)
if (index(site, target) && $login:(which + "ed")(site))
uhoh = {@uhoh, site};
endif
endfor
if (uhoh)
player:notify(tostr("WARNING:  ", $string_utils:english_list(uhoh), " are now ", which, "ed!"));
endif
-------------------------------------------------------------------------------
#57 generic wizard:@corify any for/abount any
"Usage:  @corify <object> as <propname>";
"Adds <object> to the core, as $<propname>";
"Reminds the wizard to write an :init_for_core verb, if there isn't one already.";
if (!player.wizard)
player:tell("Sorry, the core is wizardly territory.");
return;
endif
if (dobj == $failed_match)
dobj = player:my_match_object(dobjstr);
endif
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
if (!iobjstr)
player:tell("Usage:  @corify <object> as <propname>");
return;
elseif (iobjstr[1] == "$")
iobjstr = iobjstr[2..$];
endif
try
add_property(#0, iobjstr, dobj, {player, "r"});
except e (ANY)
return player:tell(e[1], ":", e[2]);
endtry
if (!("init_for_core" in verbs(dobj)))
player:tell(dobj:titlec(), " has no :init_for_core verb.  Strongly consider adding one before doing anything else.");
else
player:tell("Corified ", $string_utils:nn(dobj), " as $", iobjstr, ".");
endif
-------------------------------------------------------------------------------
#57 generic wizard:@make-guest any n/a none
"Usage:  @make-guest <guestname>";
"Creates a player called <guestname>_Guest owned by $hacker and a child of $guest. Or, if $local.guest exists, make a child of that, assuming that all other guests are children of it too.";
if (!player.wizard)
player:tell("If you think this MOO needs more guests, you should contact a wizard.");
return E_PERM;
endif
if (length(args) != 1)
player:tell("Usage: ", verb, " <guest name>");
return;
endif
guest_parent = (($object_utils:has_property($local, "guest") && valid($local.guest)) && $object_utils:isa($local.guest, $guest)) ? $local.guest | $guest;
i = length(children(guest_parent));
while (!$player_db:available(guestnum = tostr("Guest", i = i + 1)))
endwhile
guestname = args[1] + "_Guest";
guestaliases = {guestname, adj = args[1], guestnum};
if (!player.wizard)
return;
elseif ($player_db.frozen)
player:tell("Sorry, the player db is frozen, so no players can be made right now.  Please try again in a few minutes.");
return;
elseif (!$player_db:available(guestname))
player:tell("\"", guestname, "\" is not an available name.");
return;
elseif (!$player_db:available(adj))
player:Tell("\"", adj, "\" is not an available name.");
return;
else
new = $quota_utils:bi_create(guest_parent, $hacker);
new:set_name(guestname);
new:set_aliases(guestaliases);
if (!(e = $wiz_utils:set_player(new, 1)))
player:Tell("Unable to make ", new.name, " (", new, ") a player.");
player:Tell(tostr(e));
else
player:Tell("Guest: ", new.name, " (", new, ") made.");
new.default_description = {"By definition, guests appear nondescript."};
new.description = new.default_description;
new.last_connect_time = $maxint;
new.last_disconnect_time = time();
new.password = 0;
new.size_quota = new.size_quota;
new:set_gender(new.default_gender);
move(new, $player_start);
player:tell("Now don't forget to @describe ", new, " as something.");
endif
endif
-------------------------------------------------------------------------------
#57 generic wizard:@temp-newt any behind any
if (!player.wizard)
return player:tell("Permission denied.");
elseif (!valid(who = $string_utils:match_player(dobjstr)))
return $command_utils:player_match_failed(who, dobjstr);
elseif (((dobjstr != who.name) && (!(dobjstr in who.aliases))) && (dobjstr != tostr(who)))
return player:tell(tostr("Must be a full name or an object number:  ", who.name, "(", who, ")"));
elseif (who == player)
player:notify("If you want to newt yourself, you have to do it by hand.");
return;
elseif (!(howlong = $time_utils:parse_english_time_interval(iobjstr)))
return player:tell("Can't parse time: ", howlong);
else
if (who in $login.newted)
player:notify(tostr(who.name, " appears to already be a newt."));
else
$wiz_utils:newt_player(who, "", ("For " + iobjstr) + ".  ");
endif
if (index = $list_utils:iassoc(who, $login.temporary_newts))
$login.temporary_newts[index][2] = time();
$login.temporary_newts[index][3] = howlong;
else
$login.temporary_newts = {@$login.temporary_newts, {who, time(), howlong}};
endif
player:tell(who.name, " (", who, ") will be a newt until ", ctime(time() + howlong));
endif
-------------------------------------------------------------------------------
#57 generic wizard:@deprog*rammer any ?-2? any
"@deprogrammer victim [for <duration>] [reason]";
"";
"Removes the prog-bit from victim.  If a duration is specified (see help $time_utils:parse_english_time_interval), then the victim is put into the temporary list. He will be automatically removed the first time he asks for a progbit after the duration expires.  Either with or without the duration you can specify a reason, or you will be prompted for one. However, if you don't have a duration, don't start the reason with the word `For'.";
set_task_perms(player);
if ((player != this) || (!player.wizard))
player:notify("No go.");
return;
endif
if (!args)
player:notify(tostr("Usage:  ", verb, " <playername> [for <duration>] [reason]"));
endif
fw = $string_utils:first_word(argstr);
if (fw[2] && (parse = this:parse_templist_duration(fw[2]))[1])
if ((typeof(parse[3]) == ERR) || (!parse[3]))
player:notify(tostr("Could not parse the duration for restricting programming for ", fw[1], "."));
return;
endif
start = parse[2];
duration = parse[3];
reason = parse[4] ? {parse[4]} | {};
else
start = duration = 0;
reason = fw[2] ? {fw[2]} | {};
endif
if (!reason)
reason = {$command_utils:read("reason for resetting programmer flag")};
endif
if (duration)
reason = {tostr("for ", $time_utils:english_time(duration)), @reason};
endif
if ($command_utils:player_match_failed(victim = $string_utils:match_player(fw[1]), fw[1]))
"...done...";
elseif (result = $wiz_utils:unset_programmer(victim, reason, @start ? {start, duration} | {}))
player:notify(tostr(victim.name, " (", victim, ") is no longer a programmer.", duration ? tostr("  This restriction will be lifted in ", $string_utils:from_seconds(duration), ".") | ""));
elseif (result == E_NONE)
player:notify(tostr(victim.name, " (", victim, ") was already a nonprogrammer..."));
else
player:notify(tostr(result));
endif
-------------------------------------------------------------------------------
#57 generic wizard:display_list this n/a this
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
endif
which = args[1];
slist = {};
if (s = $login.(which)[1])
slist = {@slist, "--- Subnets ---", @s};
endif
if (s = $login.(which)[2])
slist = {@slist, "--- Domains ---", @s};
endif
if (s = $login.("temporary_" + which)[1])
slist = {@slist, "--- Temporary Subnets ---"};
for d in (s)
slist = {@slist, tostr(d[1], " until ", $time_utils:time_sub("$1/$3 $H:$M", d[2] + d[3]))};
$command_utils:suspend_if_needed(2);
endfor
endif
if (s = $login.("temporary_" + which)[2])
slist = {@slist, "--- Temporary Domains ---"};
for d in (s)
slist = {@slist, tostr(d[1], " until ", $time_utils:time_sub("$1/$3 $H:$M", d[2] + d[3]))};
$command_utils:suspend_if_needed(2);
endfor
endif
if (slist)
player:notify_lines($string_utils:columnize(slist, 2));
else
player:notify(tostr("The ", which, " is empty."));
endif
-------------------------------------------------------------------------------
#57 generic wizard:parse_templist_duration this n/a this
"parses out the time interval at the beginning of the args[1], assumes rest is commentary.";
if ((fw = $string_utils:first_word(args[1]))[1] == "for")
words = $string_utils:words(fw[2]);
try_ = {};
ind = cont = 1;
while (cont)
word = words[ind];
cont = ind;
if (toint(word))
try_ = {@try_, word};
ind = ind + 1;
else
for set in ($time_utils.time_units)
if (word in set)
try_ = {@try_, word};
ind = ind + 1;
endif
endfor
endif
if ((cont == ind) || (ind > length(words)))
cont = 0;
endif
endwhile
dur = $time_utils:parse_english_time_interval(@try_);
rest = $string_utils:from_list(words[ind..$], " ");
return {1, time(), dur, rest};
else
return {0, argstr};
endif
-------------------------------------------------------------------------------
#57 generic wizard:check_site_entries this n/a this
"Called by @[un]<color>list to check existence of the target site.";
"=> {done okay, LIST of sites to remove}";
if (caller != this)
return E_PERM;
endif
{undo, which, target, is_literal, entrylist} = args;
rm = {};
confirm = 0;
if (is_literal)
for s in (entrylist)
if ((i = index(s, target + ".")) == 1)
"... target is a prefix of s, s should probably go...";
rm = {@rm, s};
elseif (index(target + ".", s + ".") != 1)
"... s is not a prefix of target...";
elseif (undo)
player:notify(tostr("You will need to un", which, " subnet ", s, " as well."));
elseif (confirm)
player:notify(tostr("...Subnet ", s, " already ", which, "ed..."));
else
player:notify(tostr("Subnet ", s, " already ", which, "ed."));
if (!(confirm = $command_utils:yes_or_no(tostr(which, " ", target, " anyway?"))))
return {0, {}};
endif
endif
endfor
else
for s in (entrylist)
if ((i = rindex(s, "." + target)) && (i == (length(s) - length(target))))
"... target is a suffix of s, s should probably go...";
rm = {@rm, s};
elseif ((!(i = rindex("." + target, "." + s))) || (i < ((length(target) - length(s)) + 1)))
"... s is not a suffix of target...";
elseif (undo)
player:notify(tostr("You will need to un", which, " domain `", s, "' as well."));
elseif (confirm)
player:notify(tostr("...Domain `", s, "' already ", which, "ed..."));
else
player:notify(tostr("Domain `", s, "' already ", which, "ed."));
if (!(confirm = $command_utils:yes_or_no(tostr(which, " ", target, " anyway?"))))
return {0, {}};
endif
endif
endfor
endif
return {1, rm};
-------------------------------------------------------------------------------
#57 generic wizard:@lock-login @unlock-login @lock-login! any ?-2? any
"Syntax:  @lock-login <message>";
"         @lock-login! <message>";
"         @unlock-login";
"";
"The @lock-login calls prevent all non-wizard users from logging in, displaying <message> to them when they try.  (The second syntax, with @lock-login!, additionally boots any nonwizards who are already connected.)  @unlock-login turns this off.";
if (caller != this)
raise(E_PERM);
elseif (verb[2] == "u")
$no_connect_message = 0;
player:notify("Login restrictions removed.");
elseif (!argstr)
player:notify("You must provide some message to display to users who attempt to login:  @lock-login <message>");
else
$no_connect_message = argstr;
player:notify(tostr("Logins are now blocked for non-wizard players.  Message displayed when attempted:  ", $no_connect_message));
if (verb == "@lock-login!")
wizards = $wiz_utils:all_wizards_unadvertised();
for x in (connected_players())
if (!(x in wizards))
boot_player(x);
endif
endfor
player:notify("All nonwizards have been booted.");
endif
endif
-------------------------------------------------------------------------------
#57 generic wizard:__fix this n/a this
"...was on $player, now archived here for posterity...";
"Runs the old->new format conversion on every message in this.messages.";
" => 1 if successful";
" => 0 if anything toward happened during a suspension";
"      (e.g., new message received, someone deleted stuff) ";
"      in which case this.messages is left as if this routine were never run.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
msgs = {};
i = 1;
for m in (oldmsgs = this.messages)
msgs = {@msgs, {m[1], $mail_agent:__convert_new(@m[2])}};
if ($command_utils:running_out_of_time())
player:notify(tostr("...", i, " ", this));
suspend(0);
if (oldmsgs != this.messages)
return 0;
endif
endif
i = i + 1;
endfor
this.messages = msgs;
return 1;
-------------------------------------------------------------------------------
#57 generic wizard:toad_cleanup this n/a this
if ((!player.wizard) || (caller != this))
raise(E_PERM);
endif
"Noop. Placeholder verb for MOO-specific cleanups.";
-------------------------------------------------------------------------------
================================#58 generic programmer===============================================
#58 generic programmer.eval_subs r = MOOList [ ]
#58 generic programmer.eval_env r = MOOString "here=player.location;me=player"
#58 generic programmer.eval_ticks r = MOONumber 3
#58 generic programmer.prog_options rc = MOOList [ ]
#58 generic programmer:@prop*erty any ?-2? any
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
elseif (!$quota_utils:property_addition_permitted(player))
player:tell("Property addition not permitted because quota exceeded.");
return;
endif
nargs = length(args);
usage = tostr("Usage:  ", verb, " <object>.<prop-name> [<init_value> [<perms> [<owner>]]]");
if ((nargs < 1) || (!(spec = $code_utils:parse_propref(args[1]))))
player:notify(usage);
return;
endif
object = player:my_match_object(spec[1]);
name = spec[2];
if ($command_utils:object_match_failed(object, spec[1]))
return;
endif
if (nargs < 2)
value = 0;
else
q = $string_utils:prefix_to_value(argstr[$string_utils:word_start(argstr)[2][1]..$]);
if (q[1] == 0)
player:notify(tostr("Syntax error in initial value:  ", q[2]));
return;
endif
value = q[2];
args = {args[1], value, @$string_utils:words(q[1])};
nargs = length(args);
endif
default = player:prog_option("@prop_flags");
if (!default)
default = "rc";
endif
perms = (nargs < 3) ? default | $perm_utils:apply(default, args[3]);
if (nargs < 4)
owner = player;
else
owner = $string_utils:match_player(args[4]);
if ($command_utils:player_match_result(owner, args[4])[1])
return;
endif
endif
if (nargs > 4)
player:notify(usage);
return;
endif
try
add_property(object, name, value, {owner, perms});
player:notify(tostr("Property added with value ", toliteral(object.(name)), "."));
except (E_INVARG)
if ($object_utils:has_property(object, name))
player:notify(tostr("Property ", object, ".", name, " already exists."));
else
for i in [1..length(perms)]
if (!index("rcw", perms[i]))
player:notify(tostr("Unknown permission bit:  ", perms[i]));
return;
endif
endfor
"...the only other possibility...";
player:notify("Property is already defined on one or more descendents.");
player:notify(tostr("Try @check-prop ", args[1]));
endif
except e (ANY)
player:notify(e[2]);
endtry
-------------------------------------------------------------------------------
#58 generic programmer:@chmod*# any ?-2? any
set_task_perms(player);
bynumber = verb == "@chmod#";
if (length(args) != 2)
player:notify(tostr("Usage:  ", verb, " <object-or-property-or-verb> <permissions>"));
return;
endif
{what, perms} = args;
if (spec = $code_utils:parse_verbref(what))
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
endif
if (valid(object = player:my_match_object(spec[1])))
vname = spec[2];
if (bynumber)
vname = $code_utils:toint(vname);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
endif
try
info = verb_info(object, vname);
if (!valid(owner = info[1]))
player:notify(tostr("That verb is owned by an invalid object (", owner, "); it needs to be @chowned."));
elseif (!is_player(owner))
player:notify(tostr("That verb is owned by a non-player object (", owner.name, ", ", owner, "); it needs to be @chowned."));
else
info[2] = perms = $perm_utils:apply(info[2], perms);
try
result = set_verb_info(object, vname, info);
player:notify(tostr("Verb permissions set to \"", perms, "\"."));
except (E_INVARG)
player:notify(tostr("\"", perms, "\" is not a valid permissions string for a verb."));
except e (ANY)
player:notify(e[2]);
endtry
endif
except (E_VERBNF)
player:notify("That object does not define that verb.");
except error (ANY)
player:notify(error[2]);
endtry
return;
endif
elseif (bynumber)
return player:notify("@chmod# can only be used for verbs.");
elseif (index(what, ".") && (spec = $code_utils:parse_propref(what)))
if (valid(object = player:my_match_object(spec[1])))
pname = spec[2];
try
info = property_info(object, pname);
info[2] = perms = $perm_utils:apply(info[2], perms);
try
result = set_property_info(object, pname, info);
player:notify(tostr("Property permissions set to \"", perms, "\"."));
except (E_INVARG)
player:notify(tostr("\"", perms, "\" is not a valid permissions string for a property."));
except error (ANY)
player:notify(error[2]);
endtry
except (E_PROPNF)
player:notify("That object does not have that property.");
except error (ANY)
player:notify(error[2]);
endtry
return;
endif
elseif (valid(object = player:my_match_object(what)))
perms = $perm_utils:apply(((object.r ? "r" | "") + (object.w ? "w" | "")) + (object.f ? "f" | ""), perms);
r = w = f = 0;
for i in [1..length(perms)]
if (perms[i] == "r")
r = 1;
elseif (perms[i] == "w")
w = 1;
elseif (perms[i] == "f")
f = 1;
else
player:notify(tostr("\"", perms, "\" is not a valid permissions string for an object."));
return;
endif
endfor
try
object.r = r;
object.w = w;
object.f = f;
player:notify(tostr("Object permissions set to \"", perms, "\"."));
except (E_PERM)
player:notify("Permission denied.");
endtry
return;
endif
$command_utils:object_match_failed(object, what);
-------------------------------------------------------------------------------
#58 generic programmer:@args*# any ?-2? any
if (player != caller)
return;
endif
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
endif
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr(args ? ("\"" + args[1]) + "\"?  " | "", "<object>:<verb>  expected."));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...can't find object...";
else
if (verb == "@args#")
name = $code_utils:toint(spec[2]);
if (name == E_TYPE)
return player:notify("Verb number expected.");
elseif ((name < 1) || `name > length(verbs(object)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
else
name = spec[2];
endif
try
info = verb_args(object, name);
if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
"...arg spec is bogus...";
player:notify(tostr(pas));
elseif (!(newargs = pas[1]))
player:notify($string_utils:from_list(info, " "));
elseif (pas[2])
player:notify(tostr("\"", pas[2][1], "\" unexpected."));
else
info[2] = info[2][1..index(info[2] + "/", "/") - 1];
info = {@newargs, @info[length(newargs) + 1..$]};
try
result = set_verb_args(object, name, info);
player:notify("Verb arguments changed.");
except (E_INVARG)
player:notify(tostr("\"", info[2], "\" is not a valid preposition (?)"));
except error (ANY)
player:notify(error[2]);
endtry
endif
except (E_VERBNF)
player:notify("That object does not have a verb with that name.");
except error (ANY)
player:notify(error[2]);
endtry
endif
-------------------------------------------------------------------------------
#58 generic programmer:eval*-d any ?-2? any
"A MOO-code evaluator.  Type `;CODE' or `eval CODE'.";
"Calls player:eval_cmd_string to first transform CODE in any way appropriate (e.g., prefixing .eval_env) and then do the actual evaluation.  See documentation for this:eval_cmd_string";
"If you set your .eval_time property to 1, you find out how many ticks and seconds you used.";
"If eval-d is used, the evaluation is performed as if the debug flag were unset.";
if (player != this)
player:tell("I don't understand that.");
return;
elseif (!player.programmer)
player:tell("You need to be a programmer to eval code.");
return;
endif
set_task_perms(player);
result = player:eval_cmd_string(argstr, verb != "eval-d");
if (result[1])
player:notify(this:eval_value_to_string(result[2]));
if (player:prog_option("eval_time") && (!`output_delimiters(player)[2] ! ANY'))
player:notify(tostr("[used ", result[3], " tick", (result[3] != 1) ? "s, " | ", ", result[4], " second", (result[4] != 1) ? "s" | "", ".]"));
endif
else
player:notify_lines(result[2]);
nerrors = length(result[2]);
player:notify(tostr(nerrors, " error", (nerrors == 1) ? "." | "s."));
endif
-------------------------------------------------------------------------------
#58 generic programmer:@rmprop*erty any ?-2? any
set_task_perms(player);
if ((length(args) != 1) || (!(spec = $code_utils:parse_propref(args[1]))))
player:notify(tostr("Usage:  ", verb, " <object>.<property>"));
return;
endif
object = player:my_match_object(spec[1]);
pname = spec[2];
if ($command_utils:object_match_failed(object, spec[1]))
return;
endif
try
result = delete_property(object, pname);
player:notify("Property removed.");
except (E_PROPNF)
player:notify("That object does not define that property.");
except res (ANY)
player:notify(res[2]);
endtry
-------------------------------------------------------------------------------
#58 generic programmer:@verb any ?-2? any
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
elseif (!$quota_utils:verb_addition_permitted(player))
player:tell("Verb addition not permitted because quota exceeded.");
return;
endif
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr("Usage:  ", verb, " <object>:<verb-name(s)> [<dobj> [<prep> [<iobj> [<permissions> [<owner>]]]]]"));
return;
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
return;
endif
name = spec[2];
"...Adding another verb of the same name is often a mistake...";
namelist = $string_utils:explode(name);
for n in (namelist)
if (i = index(n, "*"))
n = n[1..i - 1] + n[i + 1..$];
endif
if ((hv = $object_utils:has_verb(object, n)) && (hv[1] == object))
player:notify(tostr("Warning:  Verb `", n, "' already defined on that object."));
endif
endfor
if (typeof(pas = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
player:notify(tostr(pas));
return;
endif
verbargs = pas[1] || (player:prog_option("verb_args") || {});
verbargs = {@verbargs, "none", "none", "none"}[1..3];
rest = pas[2];
if (verbargs == {"this", "none", "this"})
perms = "rxd";
else
perms = "rd";
endif
if (rest)
perms = $perm_utils:apply(perms, rest[1]);
endif
if (length(rest) < 2)
owner = player;
elseif (length(rest) > 2)
player:notify(tostr("\"", rest[3], "\" unexpected."));
return;
elseif ($command_utils:player_match_result(owner = $string_utils:match_player(rest[2]), rest[2])[1])
return;
elseif (owner == $nothing)
player:notify("Verb can't be owned by no one!");
return;
endif
try
x = add_verb(object, {owner, perms, name}, verbargs);
player:notify(tostr("Verb added (", (x > 0) ? x | length($object_utils:accessible_verbs(object)), ")."));
except (E_INVARG)
player:notify(tostr(rest ? tostr("\"", perms, "\" is not a valid set of permissions.") | tostr("\"", verbargs[2], "\" is not a valid preposition (?)")));
except e (ANY)
player:notify(e[2]);
endtry
-------------------------------------------------------------------------------
#58 generic programmer:@rmverb*# any n/a none
set_task_perms(player);
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr("Usage:  ", verb, " <object>:<verb>"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...bogus object...";
elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
player:notify(tostr(argspec));
elseif (argspec[2])
player:notify($string_utils:from_list(argspec[2], " ") + "??");
elseif (length(argspec = argspec[1]) in {1, 2})
player:notify({"Missing preposition", "Missing iobj specification"}[length(argspec)]);
else
verbname = spec[2];
if (verb == "@rmverb#")
loc = $code_utils:toint(verbname);
if (loc == E_TYPE)
return player:notify("Verb number expected.");
elseif ((loc < 1) || (loc > `length(verbs(object)) ! E_PERM => 0'))
return player:notify("Verb number out of range.");
endif
else
if (index(verbname, "*") > 1)
verbname = strsub(verbname, "*", "");
endif
loc = $code_utils:find_last_verb_named(object, verbname);
if (argspec)
argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];
while ((loc != -1) && (`verb_args(object, loc) ! ANY' != argspec))
loc = $code_utils:find_last_verb_named(object, verbname, loc - 1);
endwhile
endif
if (loc < 0)
player:notify(tostr("That object does not define that verb", argspec ? " with those args." | "."));
return;
endif
endif
info = `verb_info(object, loc) ! ANY';
vargs = `verb_args(object, loc) ! ANY';
vcode = `verb_code(object, loc, 1, 1) ! ANY';
try
delete_verb(object, loc);
if (info)
player:notify(tostr("Verb ", object, ":", info[3], " (", loc, ") {", $string_utils:from_list(vargs, " "), "} removed."));
if (player:prog_option("rmverb_mail_backup"))
$mail_agent:send_message(player, player, tostr(object, ":", info[3], " (", loc, ") {", $string_utils:from_list(vargs, " "), "}"), vcode);
endif
else
player:notify(tostr("Unreadable verb ", object, ":", loc, " removed."));
endif
except e (ANY)
player:notify(e[2]);
endtry
endif
-------------------------------------------------------------------------------
#58 generic programmer:@forked*-verbose any n/a none
"Syntax:  @forked [player]";
"         @forked all wizards";
"";
"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. @forked-v*erbose will show the full callers() stack for each task that has suspended (not a fresh fork).";
"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.";
set_task_perms(player);
verbose = $code_utils:verbname_match("@forked-v*erbose", verb);
if (!dobjstr)
tasks = queued_tasks();
elseif ((dobjstr == "all wizards") && player.wizard)
tasks = {};
for t in (queued_tasks())
if (valid(t[5]) && t[5].wizard)
tasks = {@tasks, t};
endif
$command_utils:suspend_if_needed(1);
endfor
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)
player:notify(tostr(verb, " ", dobj.name, "(", dobj, "):  ", tasks));
return;
endif
if (tasks)
su = $string_utils;
player:notify("Queue ID    Start Time            Owner         {Size} Verb (Line) [This]");
player:notify("--------    ----------            -----         -----------------");
now = time();
for task in (tasks)
$command_utils:suspend_if_needed(0);
{q_id, start, nu, nu2, owner, vloc, vname, lineno, this, ?size = 0} = task;
time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? "Reading input ..." | tostr(now - start, " seconds ago..."), 20);
owner_name = valid(owner) ? owner.name | tostr("Dead ", owner);
player:notify(tostr(su:left(tostr(q_id), 10), "  ", time, "  ", su:left(owner_name, 12), "  {", $building_utils:size_string(size), "} ", vloc, ":", vname, " (", lineno, ")", (this != vloc) ? tostr(" [", this, "]") | ""));
if (verbose || (index(vname, "suspend") && (vloc == $command_utils)))
"Display the first (or, if verbose, every) line of the callers() list, which is gotten by taking the second through last elements of task_stack().";
stack = `task_stack(q_id, 1) ! E_INVARG => {}';
for frame in (stack[2..verbose ? $ | 2])
{sthis, svname, sprogger, svloc, splayer, slineno} = frame;
player:notify(tostr("                    Called By...  ", su:left(valid(sprogger) ? sprogger.name | tostr("Dead ", sprogger), 19), "  ", svloc, ":", svname, (sthis != svloc) ? tostr(" [", sthis, "]") | "", " (", slineno, ")"));
endfor
endif
endfor
player:notify("-----------------------------------------------------------------");
else
player:notify("No tasks.");
endif
-------------------------------------------------------------------------------
#58 generic programmer:@kill @killq*uiet any n/a none
"Kills one or more tasks.";
"Arguments:";
"   object:verb -- kills all tasks which were started from that object and verb.";
"   all -- kills all tasks owned by invoker";
"   all player-name -- wizard variant:  kills all tasks owned by player.";
"   all everyone -- wizard variant:  really kills all tasks.";
"   Integer taskid -- kills the specifically named task.";
"   soon [integer] -- kills all tasks scheduled to run in the next [integer] seconds, which defaults to 60.";
"   %integer -- kills all tasks which end in the digits contained in integer.";
"   The @killquiet alias kills tasks without the pretty printout if more than one task is being killed.";
set_task_perms(player);
quiet = index(verb, "q");
if (length(args) == 0)
player:notify_lines({tostr("Usage:  ", verb, " [object]:[verb]"), tostr("        ", verb, " task_id"), tostr("        ", verb, " soon [number-of-seconds]", player.wizard ? " [everyone|<player name>]" | ""), tostr("        ", verb, " all", player.wizard ? " [everyone|<player name>]" | "")});
return;
elseif (taskid = toint(args[1]))
elseif (all = args[1] == "all")
everyone = 0;
realplayer = player;
if (player.wizard && (length(args) > 1))
realplayer = $string_utils:match_player(args[2]);
everyone = args[2] == "everyone";
if ((!valid(realplayer)) && (!everyone))
$command_utils:player_match_result(realplayer, args[2]);
return;
elseif (!everyone)
set_task_perms(realplayer);
endif
endif
elseif (soon = args[1] == "soon")
realplayer = player;
if (length(args) > 1)
soon = toint(args[2]);
if ((soon <= 0) && (!player.wizard))
player:notify(tostr("Usage:  ", verb, " soon [positive-number-of-seconds]"));
return;
elseif (player.wizard)
result = this:kill_aux_wizard_parse(@args[2..$]);
soon = result[1];
if (result[1] < 0)
"already gave them an error message";
return;
elseif (result[2] == 1)
everyone = 1;
else
everyone = 0;
set_task_perms(result[2]);
realplayer = result[2];
endif
endif
else
soon = 60;
everyone = 0;
endif
elseif (percent = args[1][1] == "%")
l = length(args[1]);
digits = toint(args[1][2..l]);
percent = toint("1" + "0000000000"[1..l - 1]);
elseif (colon = index(argstr, ":"))
whatstr = argstr[1..colon - 1];
vrb = argstr[colon + 1..$];
if (whatstr)
what = player:my_match_object(whatstr);
endif
else
player:notify_lines({tostr("Usage:  ", verb, " [object]:[verb]"), tostr("        ", verb, " task_id"), tostr("        ", verb, " soon [number-of-seconds]", player.wizard ? " [everyone|<player name>]" | ""), tostr("        ", verb, " all", player.wizard ? " [\"everyone\"|<player name>]" | "")});
return;
endif
"OK, parsed the line, and punted them if it was bogus.  This verb could have been a bit shorter at the expense of readability.  I think it's getting towards unreadable as is.  At this point we've set_task_perms'd, and set up an enormous number of local variables.  Evaluate them in the order we set them, and we should never get var not found.";
queued_tasks = queued_tasks();
killed = 0;
if (taskid)
try
kill_task(taskid);
player:notify(tostr("Killed task ", taskid, "."));
killed = 1;
except error (ANY)
player:notify(tostr("Can't kill task ", taskid, ": ", error[2]));
endtry
elseif (all)
for task in (queued_tasks)
if (everyone || (realplayer == task[5]))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
elseif (soon)
now = time();
for task in (queued_tasks)
if (((task[2] - now) < soon) && ((!player.wizard) || (everyone || (realplayer == task[5]))))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
elseif (percent)
for task in (queued_tasks)
if (digits == (task[1] % percent))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
elseif ((colon || vrb) || whatstr)
for task in (queued_tasks)
if ((((((whatstr == "") || (valid(task[6]) && (index(task[6].name, whatstr) == 1))) || (valid(task[9]) && (index(task[9].name, whatstr) == 1))) || (task[9] == what)) || (task[6] == what)) && ((vrb == "") || (index(" " + strsub(task[7], "*", ""), " " + vrb) == 1)))
`kill_task(task[1]) ! ANY';
killed = killed + 1;
if (!quiet)
this:_kill_task_message(task);
endif
endif
$command_utils:suspend_if_needed(3, "... killing tasks");
endfor
else
player:notify("Something is funny; I didn't understand your @kill command.  You shouldn't have gotten here.  Please send yduJ mail saying you got this message from @kill, and what you had typed to @kill.");
endif
if (!killed)
player:notify("No tasks killed.");
elseif (quiet)
player:notify(tostr("Killed ", killed, " tasks."));
endif
-------------------------------------------------------------------------------
#58 generic programmer:@copy @copy-x @copy-move any any any
"Usage:  @copy source:verbname to target[:verbname]";
"  the target verbname, if not given, defaults to that of the source.  If the target verb doesn't already exist, a new verb is installed with the same args, names, code, and permission flags as the source.  Otherwise, the existing target's verb code is overwritten and no other changes are made.";
"This the poor man's version of multiple inheritance... the main problem is that someone may update the verb you're copying and you'd never know.";
"  if @copy-x is used, makes an unusable copy (!x, this none this).  If @copy-move is used, deletes the source verb as well.";
set_task_perms(player);
if (!player.programmer)
player:notify("You need to be a programmer to do this.");
player:notify("If you want to become a programmer, talk to a wizard.");
return;
elseif ((verb != "@copy-move") && (!$quota_utils:verb_addition_permitted(player)))
player:notify("Verb addition not permitted because quota exceeded.");
return;
elseif ((!(from = $code_utils:parse_verbref(dobjstr))) || (!iobjstr))
player:notify(tostr("Usage:  ", verb, " obj:verb to obj:verb"));
player:notify(tostr("        ", verb, " obj:verb to obj"));
player:notify(tostr("        ", verb, " obj:verb to :verb"));
return;
elseif ($command_utils:object_match_failed(fobj = player:my_match_object(from[1]), from[1]))
return;
elseif (iobjstr[1] == ":")
to = {fobj, iobjstr[2..$]};
elseif (!(to = $code_utils:parse_verbref(iobjstr)))
iobj = player:my_match_object(iobjstr);
if ($command_utils:object_match_failed(iobj, iobjstr))
return;
endif
to = {iobj, from[2]};
elseif ($command_utils:object_match_failed(tobj = player:my_match_object(to[1]), to[1]))
return;
else
to[1] = tobj;
endif
from[1] = fobj;
if (verb == "@copy-move")
if ((!$perm_utils:controls(player, fobj)) && (!$quota_utils:verb_addition_permitted(player)))
player:notify("Won't be able to delete old verb.  Quota exceeded, so unable to continue.  Aborted.");
return;
elseif ($perm_utils:controls(player, fobj))
"only try to move if the player controls the verb. Otherwise, skip and treat as regular @copy";
if (typeof(result = $code_utils:move_verb(@from, @to)) == ERR)
player:notify(tostr("Unable to move verb from ", from[1], ":", from[2], " to ", to[1], ":", to[2], " --> ", result));
else
player:notify(tostr("Moved verb from ", from[1], ":", from[2], " to ", result[1], ":", result[2]));
endif
return;
else
player:notify("Won't be able to delete old verb.  Treating this as regular @copy.");
endif
endif
to_firstname = strsub(to[2][1..index(to[2] + " ", " ") - 1], "*", "") || "*";
if ((!(hv = $object_utils:has_verb(to[1], to_firstname))) || (hv[1] != to[1]))
if ((!(info = `verb_info(@from) ! ANY')) || (!(vargs = `verb_args(@from) ! ANY')))
player:notify(tostr("Retrieving ", from[1], ":", from[2], " --> ", info && vargs));
return;
endif
if (!player.wizard)
info[1] = player;
endif
if (verb == "@copy-x")
"... make sure this is an unusable copy...";
info[2] = strsub(info[2], "x", "");
vargs = {"this", "none", "this"};
endif
if (from[2] != to[2])
info[3] = to[2];
endif
if (ERR == typeof(e = `add_verb(to[1], info, vargs) ! ANY'))
player:notify(tostr("Adding ", to[1], ":", to[2], " --> ", e));
return;
endif
endif
code = `verb_code(@from) ! ANY';
owner = `verb_info(@from)[1] ! ANY';
if (typeof(code) == ERR)
player:notify(tostr("Couldn't retrieve code from ", from[1].name, " (", from[1], "):", from[2], " => ", code));
return;
endif
if (owner != player)
comment = tostr("Copied from ", $string_utils:nn(from[1]), ":", from[2], (from[1] == owner) ? "" | tostr(" [verb author ", $string_utils:nn(owner), "]"), " at ", ctime());
code = {$string_utils:print(comment) + ";", @code};
if (!player:prog_option("copy_expert"))
player:notify("Use of @copy is discouraged.  Please do not use @copy if you can use inheritance or features instead.  Use @copy carefully, and only when absolutely necessary, as it is wasteful of database space.");
endif
endif
e = `set_verb_code(to[1], to_firstname, code) ! ANY';
if (ERR == typeof(e))
player:notify(tostr("Copying ", from[1], ":", from[2], " to ", to[1], ":", to[2], " --> ", e));
elseif ((typeof(e) == LIST) && e)
player:notify(tostr("Copying ", from[1], ":", from[2], " to ", to[1], ":", to[2], " -->"));
player:notify_lines(e);
else
player:notify(tostr(to[1], ":", to[2], " code set."));
endif
-------------------------------------------------------------------------------
#58 generic programmer:_kill_task_message this n/a this
set_task_perms(caller_perms());
task = args[1];
player:notify(tostr("Killed: ", $string_utils:right(tostr("task ", task[1]), 17), ", verb ", task[6], ":", task[7], ", line ", task[8], (task[9] != task[6]) ? ", this==" + tostr(task[9]) | ""));
-------------------------------------------------------------------------------
#58 generic programmer:@prog*ram @program# any ?-2? any
"This version of @program deals with multiple verbs having the same name.";
"... @program <object>:<verbname> <dobj> <prep> <iobj>  picks the right one.";
if (player != caller)
return;
endif
set_task_perms(player);
"...";
"...catch usage errors first...";
"...";
punt = "...set punt to 0 only if everything works out...";
if (!(args && (spec = $code_utils:parse_verbref(args[1]))))
player:notify(tostr("Usage: ", verb, " <object>:<verb> [<dobj> <prep> <iobj>]"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...bogus object...";
elseif (typeof(argspec = $code_utils:parse_argspec(@listdelete(args, 1))) != LIST)
player:notify(tostr(argspec));
elseif (verb == "@program#")
verbname = $code_utils:toint(spec[2]);
if (verbname == E_TYPE)
player:notify("Verb number expected.");
elseif (length(args) > 1)
player:notify("Don't give args for @program#.");
elseif ((verbname < 1) || `verbname > length(verbs(object)) ! E_PERM')
player:notify("Verb number out of range.");
else
argspec = 0;
punt = 0;
endif
elseif (argspec[2])
player:notify($string_utils:from_list(argspec[2], " ") + "??");
elseif (length(argspec = argspec[1]) in {1, 2})
player:notify({"Missing preposition", "Missing iobj specification"}[length(argspec)]);
else
punt = 0;
verbname = spec[2];
if (index(verbname, "*") > 1)
verbname = strsub(verbname, "*", "");
endif
endif
"...";
"...if we have an argspec, we'll need to reset verbname...";
"...";
if (punt)
elseif (argspec)
if (!(argspec[2] in {"none", "any"}))
argspec[2] = $code_utils:full_prep(argspec[2]);
endif
loc = $code_utils:find_verb_named(object, verbname);
while ((loc > 0) && (`verb_args(object, loc) ! ANY' != argspec))
loc = $code_utils:find_verb_named(object, verbname, loc + 1);
endwhile
if (!loc)
punt = "...can't find it....";
player:notify("That object has no verb matching that name + args.");
else
verbname = loc;
endif
else
loc = 0;
endif
"...";
"...get verb info...";
"...";
if (punt || (!(punt = "...reset punt to TRUE...")))
else
try
info = verb_info(object, verbname);
punt = 0;
aliases = info[3];
if (!loc)
loc = aliases in (verbs(object) || {});
endif
except (E_VERBNF)
player:notify("That object does not have that verb definition.");
except error (ANY)
player:notify(error[2]);
endtry
endif
"...";
"...read the code...";
"...";
if (punt)
player:notify(tostr("Now ignoring code for ", args ? args[1] | "nothing in particular", "."));
$command_utils:read_lines();
player:notify("Verb code ignored.");
else
player:notify(tostr("Now programming ", object.name, ":", aliases, "(", (!loc) ? "??" | loc, ")."));
lines = $command_utils:read_lines_escape((active = player in $verb_editor.active) ? {} | {"@edit"}, {tostr("You are editing ", $string_utils:nn(object), ":", verbname, "."), @active ? {} | {"Type `@edit' to take this into the verb editor."}});
if (lines[1] == "@edit")
$verb_editor:invoke(args[1], "@program", lines[2]);
return;
endif
try
if (result = set_verb_code(object, verbname, lines[2]))
player:notify_lines(result);
player:notify(tostr(length(result), " error(s)."));
player:notify("Verb not programmed.");
else
player:notify("0 errors.");
player:notify("Verb programmed.");
endif
except error (ANY)
player:notify(error[2]);
player:notify("Verb not programmed.");
endtry
endif
-------------------------------------------------------------------------------
#58 generic programmer:@setenv any ?-2? any
"Usage: @setenv <environment string>";
"Set your .eval_env property.";
set_task_perms(player);
if (!argstr)
player:notify(tostr("Usage:  ", verb, " <environment string>"));
return;
endif
player:notify(tostr("Current eval environment is: ", player.eval_env));
result = player:set_eval_env(argstr);
if (typeof(result) == ERR)
player:notify(tostr(result));
return;
endif
player:notify(tostr(".eval_env set to \"", player.eval_env, "\" (", player.eval_ticks, " ticks)."));
-------------------------------------------------------------------------------
#58 generic programmer:@pros*pectus pros*pectus any ?-2? any
"Usage: @prospectus <player> [from <start>] [to <end>]";
set_task_perms((caller_perms() == $nothing) ? player | caller_perms());
dobj = dobjstr ? $string_utils:match_player(dobjstr) | player;
if ($command_utils:player_match_result(dobj, dobjstr)[1])
return;
endif
dobjwords = $string_utils:words(dobjstr);
if (args[1..length(dobjwords)] == dobjwords)
args = args[length(dobjwords) + 1..$];
endif
if (!(parse_result = $code_utils:_parse_audit_args(@args)))
player:notify(tostr("Usage:  ", verb, " player [from <start>] [to <end>]"));
return;
endif
return $building_utils:do_prospectus(dobj, @parse_result);
-------------------------------------------------------------------------------
#58 generic programmer:@d*isplay any n/a none
"@display <object>[.[property]]*[,[inherited_property]]*[:[verb]]*[;[inherited_verb]]*";
if (player != this)
player:notify(tostr("Sorry, you can't use ", this:title(), "'s `", verb, "' command."));
return E_PERM;
endif
"null names for properties and verbs are interpreted as meaning all of them.";
opivu = {{}, {}, {}, {}, {}};
string = "";
punc = 1;
literal = 0;
set_task_perms(player);
for jj in [1..length(argstr)]
j = argstr[jj];
if (literal)
string = string + j;
literal = 0;
elseif (j == "\\")
literal = 1;
elseif (y = index(".,:;", j))
opivu[punc] = {@opivu[punc], string};
punc = 1 + y;
string = "";
else
string = string + j;
endif
endfor
opivu[punc] = {@opivu[punc], string};
objname = opivu[1][1];
it = this:my_match_object(objname);
if ($command_utils:object_match_failed(it, objname))
return;
endif
readable = (it.owner == this) || (it.r || this.wizard);
cant = {};
if ("" in opivu[2])
if (readable)
prop = properties(it);
else
prop = {};
cant = setadd(cant, it);
endif
if (!this:display_option("thisonly"))
what = it;
while ((!prop) && valid(what = parent(what)))
if ((what.owner == this) || (what.r || this.wizard))
prop = properties(what);
else
cant = setadd(cant, what);
endif
endwhile
endif
else
prop = opivu[2];
endif
if ("" in opivu[3])
inh = {};
for what in ({it, @$object_utils:ancestors(it)})
if (((what.owner == this) || what.r) || this.wizard)
inh = {@inh, @properties(what)};
else
cant = setadd(cant, what);
endif
endfor
else
inh = opivu[3];
endif
for q in (inh)
if (q in `properties(it) ! ANY => {}')
prop = setadd(prop, q);
inh = setremove(inh, q);
endif
endfor
vrb = {};
if ("" in opivu[4])
if (readable)
vrbs = verbs(it);
else
vrbs = $object_utils:accessible_verbs(it);
cant = setadd(cant, it);
endif
what = it;
if (!this:display_option("thisonly"))
while ((!vrbs) && valid(what = parent(what)))
if ((what.owner == this) || (what.r || this.wizard))
vrbs = verbs(what);
else
cant = setadd(cant, what);
endif
endwhile
endif
for n in [1..length(vrbs)]
vrb = setadd(vrb, {what, n});
endfor
else
for w in (opivu[4])
if (y = $object_utils:has_verb(it, w))
vrb = setadd(vrb, {y[1], w});
else
this:notify(tostr("No such verb, \"", w, "\""));
endif
endfor
endif
if ("" in opivu[5])
for z in ({it, @$object_utils:ancestors(it)})
if (((this == z.owner) || z.r) || this.wizard)
for n in [1..length(verbs(z))]
vrb = setadd(vrb, {z, n});
endfor
else
cant = setadd(cant, z);
endif
endfor
else
for w in (opivu[5])
if (typeof(y = $object_utils:has_verb(it, w)) == LIST)
vrb = setadd(vrb, {y[1], w});
else
this:notify(tostr("No such verb, \"", w, "\""));
endif
endfor
endif
if (({""} in opivu) || (opivu[2..5] == {{}, {}, {}, {}}))
this:notify(tostr(it.name, " (", it, ") [ ", it.r ? "readable " | "", it.w ? "writeable " | "", it.f ? "fertile " | "", is_player(it) ? "(player) " | "", it.programmer ? "programmer " | "", it.wizard ? "wizard " | "", "]"));
if (it.owner != (is_player(it) ? it | this))
this:notify(tostr("  Owned by ", valid(p = it.owner) ? p.name | "** extinct **", " (", p, ")."));
endif
this:notify(tostr("  Child of ", valid(p = parent(it)) ? p.name | "** none **", " (", p, ")."));
if (it.location != $nothing)
this:notify(tostr("  Location ", valid(p = it.location) ? p.name | "** unplace (tell a wizard, fast!) **", " (", p, ")."));
endif
if ($quota_utils.byte_based && $object_utils:has_property(it, "object_size"))
this:notify(tostr("  Size: ", $string_utils:group_number(it.object_size[1]), " bytes at ", this:ctime(it.object_size[2])));
endif
endif
blankargs = this:display_option("blank_tnt") ? {"this", "none", "this"} | #-1;
for b in (vrb)
$command_utils:suspend_if_needed(0);
where = b[1];
q = b[2];
short = (typeof(q) == INT) ? q | strsub(y = index(q, " ") ? q[1..y - 1] | q, "*", "");
inf = `verb_info(where, short) ! ANY';
if ((typeof(inf) == LIST) || (inf == E_PERM))
name = (typeof(inf) == LIST) ? index(inf[3], " ") ? ("\"" + inf[3]) + "\"" | inf[3] | q;
line = $string_utils:left(tostr($string_utils:right(tostr(where), 6), ":", name, " "), 32);
if (inf == E_PERM)
line = line + "   ** unreadable **";
else
line = $string_utils:left(tostr(line, inf[1].name, " (", inf[1], ") "), 53) + ((i = inf[2] in {"x", "xd", "d", "rd"}) ? {" x", " xd", "  d", "r d"}[i] | inf[2]);
vargs = `verb_args(where, short) ! ANY';
if (vargs != blankargs)
if (this:display_option("shortprep") && (!(vargs[2] in {"any", "none"})))
vargs[2] = $code_utils:short_prep(vargs[2]);
endif
line = $string_utils:left(line + " ", 60) + $string_utils:from_list(vargs, " ");
endif
endif
this:notify(line);
elseif (inf == E_VERBNF)
this:notify(tostr(inf));
this:notify(tostr("  ** no such verb, \"", short, "\" **"));
else
this:notify("This shouldn't ever happen. @display is buggy.");
endif
endfor
all = {@prop, @inh};
max = (length(all) < 4) ? 999 | (this:linelen() - 56);
depth = (length(all) < 4) ? -1 | 1;
truncate_owner_names = length(all) > 1;
for q in (all)
$command_utils:suspend_if_needed(0);
inf = `property_info(it, q) ! ANY';
if (inf == E_PROPNF)
if (q in $code_utils.builtin_props)
this:notify(tostr($string_utils:left("," + q, 25), "Built in property            ", $string_utils:abbreviated_value(it.(q), max, depth)));
else
this:notify(tostr("  ** property not found, \"", q, "\" **"));
endif
else
pname = $string_utils:left(tostr((q in `properties(it) ! ANY => {}') ? "." | (`is_clear_property(it, q) ! ANY' ? " " | ","), q, " "), 25);
if (inf == E_PERM)
this:notify(pname + "   ** unreadable **");
else
oname = inf[1].name;
truncate_owner_names && ((length(oname) > 12) && (oname = oname[1..12]));
`inf[2][1] != "r" ! E_RANGE => 1' && (inf[2][1..0] = " ");
`inf[2][2] != "w" ! E_RANGE => 1' && (inf[2][2..1] = " ");
this:notify($string_utils:left(tostr($string_utils:left(tostr(pname, oname, " (", inf[1], ") "), 47), inf[2], " "), 54) + $string_utils:abbreviated_value(it.(q), max, depth));
endif
endif
endfor
if (cant)
failed = {};
for k in (cant)
failed = listappend(failed, tostr(k.name, " (", k, ")"));
endfor
this:notify($string_utils:centre(tostr(" no permission to read ", $string_utils:english_list(failed, ", ", " or ", " or "), ". "), 75, "-"));
else
this:notify($string_utils:centre(" finished ", 75, "-"));
endif
-------------------------------------------------------------------------------
#58 generic programmer:@db*size none n/a none
set_task_perms(player);
"Let 'em @kill it.";
count = 0;
for i in [#0..max_object()]
if ($command_utils:running_out_of_time())
player:notify(tostr("Counting... [", count, "/", i, "]"));
suspend(0);
endif
if (valid(i))
count = count + 1;
endif
endfor
player:notify(tostr("There are ", count, " valid objects out of ", toint(max_object()) + 1, " allocated object numbers."));
-------------------------------------------------------------------------------
#58 generic programmer:@gethelp any ?-2? any
"@gethelp [<topic>] [from <db or dblist>]";
"  Prints the raw text of topic from the appropriate help db.";
"  With no argument, gets the blank (\"\") topic from wherever it lives";
"  Text is printed as a script for changing this help topic ";
"  (somewhat like @dump...)";
if (!prepstr)
topic = argstr;
dblist = $code_utils:help_db_list();
elseif (prepstr != "from")
player:notify("Usage:  ", verb, " [<topic>] [from <db>]");
return;
elseif (!(e = $no_one:eval_d(iobjstr = argstr[$string_utils:word_start(argstr)[(prepstr in args) + 1][1]..$])))
player:notify(tostr(e));
return;
elseif (!e[1])
player:notify_lines(e[2]);
return;
elseif (!(typeof(dblist = e[2]) in {OBJ, LIST}))
player:notify(tostr(iobjstr, " => ", dblist, " -- not an object or a list"));
return;
else
topic = dobjstr;
if (typeof(dblist) == OBJ)
dblist = {dblist};
endif
endif
search = $code_utils:help_db_search(topic, dblist);
if (!search)
player:notify("Topic not found.");
elseif (search[1] == $ambiguous_match)
player:notify(tostr("Topic `", topic, "' ambiguous:  ", $string_utils:english_list(search[2], "none", " or ")));
elseif (typeof(text = (db = search[1]):dump_topic(fulltopic = search[2])) == ERR)
"...ok...shoot me.  This is a -d verb...";
player:notify(tostr("Cannot retrieve `", fulltopic, "' on ", $code_utils:corify_object(db), ":  ", text));
else
player:notify_lines(text);
endif
-------------------------------------------------------------------------------
#58 generic programmer:@grep*all @egrep*all any ?-2? any
set_task_perms(player);
if (prepstr == "in")
pattern = dobjstr;
objlist = player:eval_cmd_string(iobjstr, 0);
if (!objlist[1])
player:notify(tostr("Had trouble reading `", iobjstr, "':  "));
player:notify_lines(@objlist[2]);
return;
elseif (typeof(objlist[2]) == OBJ)
objlist = {objlist[2..2]};
elseif (typeof(objlist[2]) != LIST)
player:notify(tostr("Value of `", iobjstr, "' is not an object or list:  ", toliteral(objlist[2])));
return;
else
objlist = objlist[2..2];
endif
elseif ((prepstr == "from") && (player.wizard && (n = toint(toobj(iobjstr)))))
pattern = dobjstr;
objlist = {n};
elseif (args && player.wizard)
pattern = argstr;
objlist = {};
else
player:notify(tostr("Usage:  ", verb, " <pattern> ", player.wizard ? "[in {<objectlist>} | from <number>]" | "in {<objectlist>}"));
return;
endif
player:notify(tostr("Searching for verbs ", @prepstr ? {prepstr, " ", iobjstr, " "} | {}, (verb == "@egrep") ? "matching the pattern " | "containing the string ", toliteral(pattern), " ..."));
player:notify("");
egrep = verb[2] == "e";
all = index(verb, "a");
$code_utils:(all ? egrep ? "find_verb_lines_matching" | "find_verb_lines_containing" | (egrep ? "find_verbs_matching" | "find_verbs_containing"))(pattern, @objlist);
-------------------------------------------------------------------------------
#58 generic programmer:@s*how any ?-2? any
set_task_perms(player);
if (dobjstr == "")
player:notify(tostr("Usage:  ", verb, " <object-or-property-or-verb>"));
return;
endif
if (index(dobjstr, ".") && (spec = $code_utils:parse_propref(dobjstr)))
if (valid(object = player:my_match_object(spec[1])))
return $code_utils:show_property(object, spec[2]);
endif
elseif (spec = $code_utils:parse_verbref(dobjstr))
if (valid(object = player:my_match_object(spec[1])))
return $code_utils:show_verbdef(object, spec[2]);
endif
elseif (((dobjstr[1] == "$") && ((pname = dobjstr[2..$]) in properties(#0))) && (typeof(#0.(pname)) == OBJ))
if (valid(object = #0.(pname)))
return $code_utils:show_object(object);
endif
elseif ((dobjstr[1] == "$") && (spec = $code_utils:parse_propref(dobjstr)))
return $code_utils:show_property(#0, spec[2]);
else
if (valid(object = player:my_match_object(dobjstr)))
return $code_utils:show_object(object);
endif
endif
$command_utils:object_match_failed(object, dobjstr);
-------------------------------------------------------------------------------
#58 generic programmer:@check-p*roperty any n/a none
"@check-prop object.property";
"  checks for descendents defining the given property.";
set_task_perms(player);
if (!(spec = $code_utils:parse_propref(dobjstr)))
player:notify(tostr("Usage:  ", verb, " <object>.<prop-name>"));
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
"...bogus object...";
elseif (!($perm_utils:controls(player, object) || object.w))
player:notify("You can't create a property on that object anyway.");
elseif ($object_utils:has_property(object, prop = spec[2]))
player:notify("That object already has that property.");
elseif (olist = $object_utils:descendants_with_property_suspended(object, prop))
player:notify("The following descendents have this property defined:");
player:notify("  " + $string_utils:from_list(olist, " "));
else
player:notify("No property name conflicts found.");
endif
-------------------------------------------------------------------------------
#58 generic programmer:set_eval_env this n/a this
"set_eval_env(string);";
"Run <string> through eval.  If it doesn't compile, return E_INVARG.  If it crashes, well, it crashes.  If it works okay, set .eval_env to it and set .eval_ticks to the amount of time it took.";
if (is_player(this) && $perm_utils:controls(caller_perms(), this))
program = args[1];
value = $no_one:eval_d((";ticks = ticks_left();" + program) + ";return ticks - ticks_left() - 2;");
if (!value[1])
return E_INVARG;
elseif (typeof(value[2]) == ERR)
return value[2];
endif
try
ok = this.eval_env = program;
this.eval_ticks = value[2];
return 1;
except error (ANY)
return error[1];
endtry
endif
-------------------------------------------------------------------------------
#58 generic programmer:@clearp*roperty @clprop*erty any n/a none
"@clearproperty <obj>.<prop>";
"Set the value of <obj>.<prop> to `clear', making it appear to be the same as the property on its parent.";
set_task_perms(player);
if (!(l = $code_utils:parse_propref(dobjstr)))
player:notify(tostr("Usage:  ", verb, " <object>.<property>"));
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(l[1]), l[1]))
"... bogus object...";
endif
try
if (is_clear_property(dobj, prop = l[2]))
player:notify(tostr("Property ", dobj, ".", prop, " is already clear!"));
return;
endif
clear_property(dobj, prop);
player:notify(tostr("Property ", dobj, ".", prop, " cleared; value is now ", toliteral(dobj.(prop)), "."));
except (E_INVARG)
player:notify(tostr("You can't clear ", dobj, ".", prop, "; none of the ancestors define that property."));
except error (ANY)
player:notify(error[2]);
endtry
-------------------------------------------------------------------------------
#58 generic programmer:@disown @disinherit any ?-2? any
"Syntax: @disown <object> [from <object>]";
"This command is used to remove unwanted children of objects you control. If you control an object, and there is a child of that object you do not want, this command will chparent() the object to its grandparent.";
set_task_perms(player);
if (prepstr)
if (prepstr != "from")
player:notify("Usage:  ", verb, " <object> [from <object>]");
return;
elseif ($command_utils:object_match_failed(iobj = player:my_match_object(iobjstr), iobjstr))
"... from WHAT?..";
return;
elseif (valid(dobj = $string_utils:literal_object(dobjstr)))
"... literal object number...";
if (parent(dobj) != iobj)
player:notify(tostr(dobj, " is not a child of ", iobj.name, " (", iobj, ")"));
return;
endif
elseif ($command_utils:object_match_failed(dobj = $string_utils:match(dobjstr, children(iobj), "name", children(iobj), "aliases"), dobjstr))
"... can't match dobjstr against any children of iobj";
return;
endif
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
"... can't match dobjstr...";
return;
endif
try
if ($object_utils:disown(dobj))
player:notify(tostr(dobj.name, " (", dobj, ")'s parent is now ", (grandparent = parent(dobj)).name, " (", grandparent, ")."));
else
"this should never happen";
endif
except e (E_PERM, E_INVARG)
{code, message, value, traceback} = e;
player:notify(message);
endtry
-------------------------------------------------------------------------------
#58 generic programmer:eval_cmd_string this n/a this
":eval_cmd_string(string[,debug])";
"Evaluates the string the way this player would normally expect to see it evaluated if it were typed on the command line.  debug (defaults to 1) indicates how the debug flag should be set during the evaluation.";
" => {@eval_result, ticks, seconds}";
"where eval_result is the result of the actual eval() call.";
"";
"For the case where string is an expression, we need to prefix `return ' and append `;' to string before passing it to eval().  However this is not appropriate for statements, where it is assumed an explicit return will be provided somewhere or that the return value is irrelevant.  The code below assumes that string is an expression unless it either begins with a semicolon `;' or one of the MOO language statement keywords.";
"Next, the substitutions described by this.eval_subs, which should be a list of pairs {string, sub}, are performed on string";
"Finally, this.eval_env is prefixed to the beginning while this.eval_ticks is subtracted from the eventual tick count.  This allows string to refer to predefined variables like `here' and `me'.";
set_task_perms(caller_perms());
{program, ?debug = 1} = args;
program = program + ";";
debug = debug ? 38 | 0;
if (!match(program, "^ *%(;%|%(if%|fork?%|return%|while%|try%)[^a-z0-9A-Z_]%)"))
program = "return " + program;
endif
program = tostr(this.eval_env, ";", $code_utils:substitute(program, this.eval_subs));
ticks = ((ticks_left() - 53) - this.eval_ticks) + debug;
seconds = seconds_left();
value = debug ? eval(program) | $code_utils:eval_d(program);
seconds = seconds - seconds_left();
ticks = ticks - ticks_left();
return {@value, ticks, seconds};
-------------------------------------------------------------------------------
#58 generic programmer:@dump any ?-2? any
"@dump something [with [id=...] [noprops] [noverbs] [create]]";
"This spills out all properties and verbs on an object, calling suspend at appropriate intervals.";
"   id=#nnn -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)";
"   noprops -- don't show properties.";
"   noverbs -- don't show verbs.";
"   create  -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it.";
set_task_perms(player);
dobj = player:my_match_object(dobjstr);
if ($command_utils:object_match_failed(dobj, dobjstr))
return;
endif
if (prepstr && (prepstr != "with"))
player:notify(tostr("Usage:  ", verb, " something [with [id=...] [noprops] [noverbs] [create]]"));
return;
endif
targname = tostr(dobj);
options = {"props", "verbs"};
create = 0;
if (iobjstr)
for o in ($string_utils:explode(iobjstr))
if (index(o, "id=") == 1)
targname = o[4..$];
elseif (o in {"noprops", "noverbs"})
options = setremove(options, o[3..$]);
elseif (o in {"create"})
create = 1;
else
player:notify(tostr("`", o, "' not understood as valid option."));
player:notify(tostr("Usage:  ", verb, " something [with [id=...] [noprops] [noverbs] [create]]"));
return;
endif
endfor
endif
if (create)
player:notify($code_utils:dump_preamble(dobj));
endif
if ("props" in options)
player:notify_lines_suspended($code_utils:dump_properties(dobj, create, targname));
endif
if (!("verbs" in options))
player:notify("\"***finished***");
return;
endif
player:notify("");
player:notify_lines_suspended($code_utils:dump_verbs(dobj, create, targname));
player:notify("\"***finished***");
-------------------------------------------------------------------------------
#58 generic programmer:#* any ?-2? any
"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):# by Geust (#24442) Sun May  9 20:19:05 1993 PDT";
"#<string>[.<property>|.parent] [exit|player|inventory] [for <code>] returns information about the object (we'll call it <thing>) named by string.  String is matched in the current room unless one of exit|player|inventory is given.";
"If neither .<property>|.parent nor <code> is specified, just return <thing>.";
"If .<property> is named, return <thing>.<property>.  .parent returns parent(<thing>).";
"If <code> is given, it is evaluated, with the value returned by the first part being substituted for %# in <code>.";
"For example, the command";
"  #JoeFeedback.parent player for toint(%#)";
"will return 26026 (unless Joe has chparented since writing this).";
set_task_perms(player);
if (!(whatstr = verb[2..dot = min(index(verb + ".", "."), index(verb + ":", ":")) - 1]))
player:notify("Usage:  #string [exit|player|inventory]");
return;
elseif (!args)
what = player:my_match_object(whatstr);
elseif (index("exits", args[1]) == 1)
what = player.location:match_exit(whatstr);
elseif (index("inventory", args[1]) == 1)
what = player:match(whatstr);
elseif (index("players", args[1]) == 1)
what = $string_utils:match_player(whatstr);
if ($command_utils:player_match_failed(what, whatstr))
return;
endif
else
what = player:my_match_object(whatstr);
endif
if ((!valid(what)) && match(whatstr, "^[0-9]+$"))
what = toobj(whatstr);
endif
if ($command_utils:object_match_failed(what, whatstr))
return;
endif
while (index(verb, ".parent") == (dot + 1))
what = parent(what);
dot = dot + 7;
endwhile
if (dot >= length(verb))
val = what;
elseif ((value = $code_utils:eval_d(tostr("return ", what, verb[dot + 1..$], ";")))[1])
val = value[2];
else
player:notify_lines(value[2]);
return;
endif
if (prepstr)
program = strsub(iobjstr + ";", "%#", toliteral(val));
end = 1;
"while (\"A\" <= (l = argstr[end]) && l <= \"Z\")";
while (("A" <= (l = program[end])) && (l <= "Z"))
end = end + 1;
endwhile
if ((program[1] == ";") || (program[1..end - 1] in {"if", "for", "fork", "return", "while", "try"}))
program = $code_utils:substitute(program, this.eval_subs);
else
program = $code_utils:substitute("return " + program, this.eval_subs);
endif
if ((value = eval(program))[1])
player:notify(this:eval_value_to_string(value[2]));
else
player:notify_lines(value[2]);
nerrors = length(value[2]);
player:notify(tostr(nerrors, " error", (nerrors == 1) ? "." | "s."));
endif
else
player:notify(this:eval_value_to_string(val));
endif
-------------------------------------------------------------------------------
#58 generic programmer:eval_value_to_string this n/a this
set_task_perms(caller_perms());
if (typeof(val = args[1]) == OBJ)
return tostr("=> ", val, "  ", valid(val) ? ("(" + val.name) + ")" | ((a = $list_utils:assoc(val, {{#-1, "<$nothing>"}, {#-2, "<$ambiguous_match>"}, {#-3, "<$failed_match>"}})) ? a[2] | "<invalid>"));
elseif (typeof(val) == ERR)
return tostr("=> ", toliteral(val), "  (", val, ")");
else
return tostr("=> ", toliteral(val));
endif
-------------------------------------------------------------------------------
#58 generic programmer:@progo*ptions @prog-o*ptions @programmero*ptions @programmer-o*ptions any ?-2? any
"@<what>-option <option> [is] <value>   sets <option> to <value>";
"@<what>-option <option>=<value>        sets <option> to <value>";
"@<what>-option +<option>     sets <option>   (usually equiv. to <option>=1";
"@<what>-option -<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option !<option>     resets <option> (equiv. to <option>=0)";
"@<what>-option <option>      displays value of <option>";
set_task_perms(player);
what = "prog";
options = what + "_options";
option_pkg = #0.(options);
set_option = ("set_" + what) + "_option";
if (!args)
player:notify_lines({("Current " + what) + " options:", "", @option_pkg:show(this.(options), option_pkg.names)});
return;
elseif (typeof(presult = option_pkg:parse(args)) == STR)
player:notify(presult);
return;
else
if (length(presult) > 1)
if (typeof(sresult = this:(set_option)(@presult)) == STR)
player:notify(sresult);
return;
elseif (!sresult)
player:notify("No change.");
return;
endif
endif
player:notify_lines(option_pkg:show(this.(options), presult[1]));
endif
-------------------------------------------------------------------------------
#58 generic programmer:prog_option this n/a this
":prog_option(name)";
"Returns the value of the specified prog option";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
return $prog_options:get(this.prog_options, args[1]);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#58 generic programmer:set_prog_option this n/a this
":set_prog_option(oname,value)";
"Changes the value of the named option.";
"Returns a string error if something goes wrong.";
if (!((caller == this) || $perm_utils:controls(caller_perms(), this)))
return tostr(E_PERM);
endif
"...this is kludgy, but it saves me from writing the same verb 3 times.";
"...there's got to be a better way to do this...";
verb[1..4] = "";
foo_options = verb + "s";
"...";
if (typeof(s = #0.(foo_options):set(this.(foo_options), @args)) == STR)
return s;
elseif (s == this.(foo_options))
return 0;
else
this.(foo_options) = s;
return 1;
endif
-------------------------------------------------------------------------------
#58 generic programmer:@list*# any ?-2? any
"@list <obj>:<verb> [<dobj> <prep> <iobj>] [with[out] paren|num] [all] [ranges]";
set_task_perms(player);
bynumber = verb == "@list#";
pflag = player:prog_option("list_all_parens");
nflag = !player:prog_option("list_no_numbers");
permflag = player:prog_option("list_show_permissions");
aflag = 0;
argspec = {};
range = {};
spec = args ? $code_utils:parse_verbref(args[1]) | E_INVARG;
args = spec ? listdelete(args, 1) | E_INVARG;
while (args)
if (args[1] && ((index("without", args[1]) == 1) || (args[1] == "wo")))
"...w,wi,wit,with => 1; wo,witho,withou,without => 0...";
fval = !index(args[1], "o");
if (`index("parentheses", args[2]) ! ANY' == 1)
pflag = fval;
args[1..2] = {};
elseif (`index("numbers", args[2]) ! ANY' == 1)
nflag = fval;
args[1..2] = {};
else
player:notify(tostr(args[1], " WHAT?"));
args = E_INVARG;
endif
elseif (index("all", args[1]) == 1)
if (bynumber)
player:notify("Don't use `all' with @list#.");
args = E_INVARG;
else
aflag = 1;
args[1..1] = {};
endif
elseif (index("0123456789", args[1][1]) || (index(args[1], "..") == 1))
if (E_INVARG == (s = $seq_utils:from_string(args[1])))
player:notify(tostr("Garbled range:  ", args[1]));
args = E_INVARG;
else
range = $seq_utils:union(range, s);
args = listdelete(args, 1);
endif
elseif (bynumber)
player:notify("Don't give args with @list#.");
args = E_INVARG;
elseif (argspec)
"... second argspec?  Not likely ...";
player:notify(tostr(args[1], " unexpected."));
args = E_INVARG;
elseif (typeof(pas = $code_utils:parse_argspec(@args)) == LIST)
argspec = pas[1];
if (length(argspec) < 2)
player:notify(tostr("Argument `", @argspec, "' malformed."));
args = E_INVARG;
else
argspec[2] = $code_utils:full_prep(argspec[2]) || argspec[2];
args = pas[2];
endif
else
"... argspec is bogus ...";
player:notify(tostr(pas));
args = E_INVARG;
endif
endwhile
if (args == E_INVARG)
if (bynumber)
player:notify(tostr("Usage:  ", verb, " <object>:<verbnumber> [with|without parentheses|numbers] [ranges]"));
else
player:notify(tostr("Usage:  ", verb, " <object>:<verb> [<dobj> <prep> <iobj>] [with|without parentheses|numbers] [all] [ranges]"));
endif
return;
elseif ($command_utils:object_match_failed(object = player:my_match_object(spec[1]), spec[1]))
return;
endif
shown_one = 0;
for what in ({object, @$object_utils:ancestors(object)})
if (bynumber)
vname = $code_utils:toint(spec[2]);
if (vname == E_TYPE)
return player:notify("Verb number expected.");
elseif ((vname < 1) || `vname > length(verbs(what)) ! E_PERM => 0')
return player:notify("Verb number out of range.");
endif
code = `verb_code(what, vname, pflag) ! ANY';
elseif (argspec)
vnum = $code_utils:find_verb_named(what, spec[2]);
while (vnum && (`verb_args(what, vnum) ! ANY' != argspec))
vnum = $code_utils:find_verb_named(what, spec[2], vnum + 1);
endwhile
vname = vnum;
code = (!vnum) ? E_VERBNF | `verb_code(what, vnum, pflag) ! ANY';
else
vname = spec[2];
code = `verb_code(what, vname, pflag) ! ANY';
endif
if (code != E_VERBNF)
if (shown_one)
player:notify("");
elseif (what != object)
player:notify(tostr("Object ", object, " does not define that verb", argspec ? " with those args" | "", ", but its ancestor ", what, " does."));
endif
if (typeof(code) == ERR)
player:notify(tostr(what, ":", vname, " -- ", code));
else
info = verb_info(what, vname);
vargs = verb_args(what, vname);
fullname = info[3];
if (index(fullname, " "))
fullname = toliteral(fullname);
endif
if (index(vargs[2], "/"))
vargs[2] = tostr("(", vargs[2], ")");
endif
player:notify(tostr(what, ":", fullname, "   ", $string_utils:from_list(vargs, " "), permflag ? " " + info[2] | ""));
if (code == {})
player:notify("(That verb has not been programmed.)");
else
lineseq = {1, length(code) + 1};
range && (lineseq = $seq_utils:intersection(range, lineseq));
if (!lineseq)
player:notify("(No lines in that range.)");
endif
for k in [1..length(lineseq) / 2]
for i in [lineseq[(2 * k) - 1]..lineseq[2 * k] - 1]
if (nflag)
player:notify(tostr(" "[1..i < 10], i, ":  ", code[i]));
else
player:notify(code[i]);
endif
$command_utils:suspend_if_needed(0);
endfor
endfor
endif
endif
shown_one = 1;
endif
if (shown_one && (!aflag))
return;
endif
endfor
if (!shown_one)
player:notify(tostr("That object does not define that verb", argspec ? " with those args." | "."));
endif
-------------------------------------------------------------------------------
#58 generic programmer:set_eval_subs none n/a none
"Copied from Player Class hacked with eval that does substitutions and assorted stuff (#8855):set_eval_subs by Geust (#24442) Fri Aug  5 13:18:59 1994 PDT";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (typeof(subs = args[1]) != LIST)
return E_TYPE;
else
for pair in (subs)
if (((length(pair) != 2) || typeof(pair[1] != STR)) || typeof(pair[2] != STR))
return E_INVARG;
endif
endfor
endif
return `this.eval_subs = subs ! ANY';
-------------------------------------------------------------------------------
#58 generic programmer:@verbs* any n/a none
set_task_perms(player);
if (!dobjstr)
try
if ((verb[7] != "(") && (verb[$] != ")"))
player:tell("Usage:  @verbs <object>");
return;
else
dobjstr = verb[8..$ - 1];
endif
except (E_RANGE)
return player:tell("Usage:  @verbs <object>");
endtry
endif
thing = player:my_match_object(dobjstr);
if (!$command_utils:object_match_failed(thing, dobjstr))
verbs = $object_utils:accessible_verbs(thing);
player:tell(";verbs(", thing, ") => ", toliteral(verbs));
endif
-------------------------------------------------------------------------------
#58 generic programmer:@old-forked-v*erbose any n/a none
"Syntax:  @forked-v*erbose [player]";
"         @forked-v*erbose all wizards";
"";
"For a normal player, shows all the tasks you have waiting in your queue, especially those forked or suspended. A wizard will see all the tasks of all the players unless the optional argument is provided. For a task which has suspended, and not a fresh fork, shows the full callers() stack.";
"The second form is only usable by wizards and provides an output of all tasks owned by characters who are .wizard=1. Useful to find a task that may get put in a random queue due to $wiz_utils:random_wizard. Or even finding verbs that run with wizard permissions that shouldn't be.";
set_task_perms(player);
if (!dobjstr)
tasks = queued_tasks();
elseif ((dobjstr == "all wizards") && player.wizard)
tasks = {};
for t in (queued_tasks())
if (valid(t[5]) && t[5].wizard)
tasks = {@tasks, t};
endif
$command_utils:suspend_if_needed(1);
endfor
elseif ($command_utils:player_match_result(dobj = $string_utils:match_player(dobjstr), dobjstr)[1])
return;
elseif (typeof(tasks = $wiz_utils:queued_tasks(dobj)) != LIST)
player:notify(tostr(verb, " ", dobj.name, "(", dobj, "):  ", tasks));
return;
endif
if (tasks)
su = $string_utils;
player:notify("Queue ID    Start Time            Owner         Verb (Line) [This]");
player:notify("--------    ----------            -----         -----------------");
now = time();
for task in (tasks)
$command_utils:suspend_if_needed(0);
{q_id, start, nu, nu2, owner, vloc, vname, lineno, this, ?size = 0} = task;
time = (start >= now) ? ctime(start)[5..24] | su:left((start == -1) ? "Reading input ..." | tostr(now - start, " seconds ago..."), 20);
owner_name = valid(owner) ? owner.name | tostr("Dead ", owner);
player:notify(tostr(su:left(tostr(q_id), 10), "  ", time, "  ", su:left(owner_name, 12), "  ", vloc, ":", vname, " (", lineno, ")", (this != vloc) ? tostr(" [", this, "]") | ""));
if (stack = `task_stack(q_id, 1) ! E_INVARG => 0')
for frame in (listdelete(stack, 1))
{sthis, svname, sprogger, svloc, splayer, slineno} = frame;
player:notify(tostr("                    Called By...  ", su:left(valid(sprogger) ? sprogger.name | tostr("Dead ", sprogger), 12), "  ", svloc, ":", svname, (sthis != svloc) ? tostr(" [", sthis, "]") | "", " (", slineno, ")"));
endfor
endif
endfor
player:notify("-----------------------------------------------------------------");
else
player:notify("No tasks.");
endif
-------------------------------------------------------------------------------
#58 generic programmer:@props @properties any ?-2? any
"Usage: @properties <object>";
"Alias: @props";
"Displays all properties defined on <object>. Properties unreadable by you display as `E_PERM'.";
if (player != this)
return player:tell(E_PERM);
endif
set_task_perms(player);
ob = this:my_match_object(argstr);
if (!$command_utils:object_match_failed(ob, argstr))
this:notify(tostr(";properties(", $code_utils:corify_object(ob), ") => ", toliteral($object_utils:accessible_props(ob))));
endif
"Last modified Mon Nov 28 06:21:21 2005 PST, by Roebare (#109000).";
-------------------------------------------------------------------------------
================================#59 code utilities===============================================
#59 code utilities._all_preps rc = MOOList [ "with", "using", "at", "to", "in front of", "in", "inside", "into", "on top of", "on", "onto", "upon", "out of", "from inside", "from", "over", "through", "under", "underneath", "beneath", "behind", "beside", "for", "about", "is", "as", "off", "off of" ]
#59 code utilities._other_preps_n rc = MOOList [ 1, 2, 4, 4, 5, 5, 5, 6, 6, 9, 9, 12, 15 ]
#59 code utilities.prepositions rc = MOOList [ "with/using", "at/to", "in front of", "in/inside/into", "on top of/on/onto/upon", "out of/from inside/from", "over", "through", "under/underneath/beneath", "behind", "beside", "for/about", "is", "as", "off/off of" ]
#59 code utilities._multi_preps rc = MOOList [ "off", "from", "out", "on", "on top", "in", "in front" ]
#59 code utilities.error_list rc = MOOList [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]
#59 code utilities.error_names rc = MOOList [ "E_NONE", "E_TYPE", "E_DIV", "E_PERM", "E_PROPNF", "E_VERBNF", "E_VARNF", "E_INVIND", "E_RECMOVE", "E_MAXREC", "E_RANGE", "E_ARGS", "E_NACC", "E_INVARG", "E_QUOTA", "E_FLOAT" ]
#59 code utilities._other_preps rc = MOOList [ "using", "at", "inside", "into", "on top of", "onto", "upon", "out of", "from inside", "underneath", "beneath", "about", "off of" ]
#59 code utilities._short_preps rc = MOOList [ "with", "to", "in front of", "in", "on", "from", "over", "through", "under", "behind", "beside", "for", "is", "as", "off" ]
#59 code utilities._version rc = MOOString "1.8.4+toastsoft.51"
#59 code utilities.builtin_props r = MOOList [ "name", "r", "w", "f", "programmer", "wizard", "owner", "location", "contents" ]
#59 code utilities:eval_d any ?-2? any
":eval_d(code...) => {compiled?,result}";
"This works exactly like the builtin eval() except that the code is evaluated ";
"as if the d flag were unset.";
code = {"set_verb_code(this,\"eval_d_util\",{\"\\\"Do not remove this verb!  This is an auxiliary verb for :eval_d().\\\";\"});", "dobj=iobj=this=#-1;", "dobjstr=iobjstr=prepstr=argstr=verb=\"\";", tostr("caller=", caller, ";"), "set_task_perms(caller_perms());", @args};
if (!caller_perms().programmer)
return E_PERM;
elseif ((caller_perms() == $no_one) && $no_one:bad_eval(tostr(@args)))
return E_PERM;
elseif (svc = set_verb_code(this, "eval_d_util", code))
lines = {};
for line in (svc)
if ((index(line, "Line ") == 1) && (n = toint(line[6..(colon = index(line + ":", ":")) - 1])))
lines = {@lines, tostr("Line ", n - 5, line[colon..$])};
else
lines = {@lines, line};
endif
endfor
return {0, lines};
else
set_task_perms(caller_perms());
return {1, this:eval_d_util()};
endif
-------------------------------------------------------------------------------
#59 code utilities:toint tonum this n/a this
":toint(STR)";
"=> toint(s) if STR is numeric";
"=> E_TYPE if it isn't";
return match(s = args[1], "^ *[-+]?[0-9]+ *$") ? toint(s) | E_TYPE;
-------------------------------------------------------------------------------
#59 code utilities:toobj this n/a this
":toobj(objectid as string) => objectid";
return match(s = args[1], "^ *#[-+]?[0-9]+ *$") ? toobj(s) | E_TYPE;
-------------------------------------------------------------------------------
#59 code utilities:toerr this n/a this
"toerr(n), toerr(\"E_FOO\"), toerr(\"FOO\") => E_FOO.";
if (typeof(s = args[1]) != STR)
n = toint(s) + 1;
if (n > length(this.error_list))
return 1;
endif
elseif (!(n = (s in this.error_names) || (("E_" + s) in this.error_names)))
return 1;
endif
return this.error_list[n];
-------------------------------------------------------------------------------
#59 code utilities:error_name this n/a this
"error_name(E_FOO) => \"E_FOO\"";
return toliteral(@args);
return this.error_names[toint(args[1]) + 1];
-------------------------------------------------------------------------------
#59 code utilities:show_object this n/a this
set_task_perms(caller_perms());
{object, ?what = {"props", "verbs"}} = args;
player:notify(tostr("Object ID:  ", object));
player:notify(tostr("Name:       ", object.name));
names = {"Parent", "Location", "Owner"};
vals = {parent(object), object.location, object.owner};
for i in [1..length(vals)]
if (!valid(vals[i]))
val = "*** NONE ***";
else
val = ((vals[i].name + " (") + tostr(vals[i])) + ")";
endif
player:notify(tostr(names[i], ":      "[1..12 - length(names[i])], val));
endfor
line = "Flags:     ";
if (is_player(object))
line = line + " player";
endif
for flag in ({"programmer", "wizard", "r", "w", "f"})
if (object.(flag))
line = (line + " ") + flag;
endif
endfor
player:notify(line);
if (player.programmer && ((player.wizard || (player == object.owner)) || object.r))
if (("verbs" in what) && (vs = verbs(object)))
player:notify("Verb definitions:");
for v in (vs)
$command_utils:suspend_if_needed(0);
player:notify(tostr("    ", v));
endfor
endif
if ("props" in what)
if (ps = properties(object))
player:notify("Property definitions:");
for p in (ps)
$command_utils:suspend_if_needed(0);
player:notify(tostr("    ", p));
endfor
endif
all_props = $object_utils:all_properties(object);
if (all_props != {})
player:notify("Properties:");
for p in (all_props)
$command_utils:suspend_if_needed(0);
strng = `toliteral(object.(p)) ! E_PERM => "(Permission denied.)"';
player:notify(tostr("    ", p, ": ", strng));
endfor
endif
endif
elseif (player.programmer)
player:notify("** Can't list properties or verbs: permission denied.");
endif
if (object.contents)
player:notify("Contents:");
for o in (object.contents)
$command_utils:suspend_if_needed(0);
player:notify(tostr("    ", o.name, " (", o, ")"));
endfor
endif
-------------------------------------------------------------------------------
#59 code utilities:show_property this n/a this
set_task_perms(caller_perms());
{object, pname} = args;
if (pname in this.builtin_props)
player:notify(tostr(object, ".", pname));
player:notify("Built-in property.");
else
try
{owner, perms} = property_info(object, pname);
except error (ANY)
player:notify(error[2]);
return;
endtry
player:notify(tostr(object, ".", pname));
player:notify(tostr("Owner:        ", valid(owner) ? tostr(owner.name, " (", owner, ")") | "*** NONE ***"));
player:notify(tostr("Permissions:  ", perms));
endif
player:notify(tostr("Value:        ", $string_utils:print(object.(pname))));
-------------------------------------------------------------------------------
#59 code utilities:show_verbdef this n/a this
set_task_perms(caller_perms());
{object, vname} = args;
if (!(hv = $object_utils:has_verb(object, vname)))
player:notify("That object does not define that verb.");
return;
elseif (hv[1] != object)
player:notify(tostr("Object ", object, " does not define that verb, but its ancestor ", hv[1], " does."));
object = hv[1];
endif
try
{owner, perms, names} = verb_info(object, vname);
except error (ANY)
player:notify(error[2]);
return;
endtry
arg_specs = verb_args(object, vname);
player:notify(tostr(object, ":", names));
player:notify(tostr("Owner:            ", valid(owner) ? tostr(owner.name, " (", owner, ")") | "*** NONE ***"));
player:notify(tostr("Permissions:      ", perms));
player:notify(tostr("Direct Object:    ", arg_specs[1]));
player:notify(tostr("Preposition:      ", arg_specs[2]));
player:notify(tostr("Indirect Object:  ", arg_specs[3]));
-------------------------------------------------------------------------------
#59 code utilities:explain_verb_syntax this n/a this
if (args[4..5] == {"none", "this"})
return 0;
endif
{thisobj, verb, adobj, aprep, aiobj} = args;
prep_part = (aprep == "any") ? "to" | this:short_prep(aprep);
".........`any' => `to' (arbitrary),... `none' => empty string...";
if ((adobj == "this") && (dobj == thisobj))
dobj_part = dobjstr;
iobj_part = ((!prep_part) || (aiobj == "none")) ? "" | ((aiobj == "this") ? dobjstr | iobjstr);
elseif ((aiobj == "this") && (iobj == thisobj))
dobj_part = (adobj == "any") ? dobjstr | ((adobj == "this") ? iobjstr | "");
iobj_part = iobjstr;
elseif (!("this" in args[3..5]))
dobj_part = (adobj == "any") ? dobjstr | "";
iobj_part = (prep_part && (aiobj == "any")) ? iobjstr | "";
else
return 0;
endif
return tostr(verb, dobj_part ? " " + dobj_part | "", prep_part ? " " + prep_part | "", iobj_part ? " " + iobj_part | "");
-------------------------------------------------------------------------------
#59 code utilities:verb_p*erms verb_permi*ssions this n/a this
"returns the permissions of the current verb (either the owner or the result of the most recent set_task_perms()).";
return caller_perms();
-------------------------------------------------------------------------------
#59 code utilities:verb_loc*ation this n/a this
"returns the object where the current verb is defined.";
return callers()[1][4];
-------------------------------------------------------------------------------
#59 code utilities:verb_documentation this n/a this
":verb_documentation([object,verbname]) => documentation at beginning of verb code, if any";
"default is the calling verb";
set_task_perms(caller_perms());
c = callers()[1];
{?object = c[4], ?vname = c[2]} = args;
try
code = verb_code(object, vname);
except error (ANY)
return error[2];
endtry
doc = {};
for line in (code)
if (match(line, "^\"%([^\\\"]%|\\.%)*\";$"))
"... now that we're sure `line' is just a string, eval() is safe...";
doc = {@doc, $no_one:eval("; return " + line)[2]};
else
return doc;
endif
endfor
return doc;
-------------------------------------------------------------------------------
#59 code utilities:set_verb_documentation this n/a this
":set_verb_documentation(object,verbname,text)";
"  changes documentation at beginning of verb code";
"  text is either a string or a list of strings";
"  returns a non-1 value if anything bad happens...";
set_task_perms(caller_perms());
{object, vname, text} = args;
if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)
return code;
elseif (typeof(vd = $code_utils:verb_documentation(object, vname)) == ERR)
return vd;
elseif (!(typeof(text) in {LIST, STR}))
return E_INVARG;
else
newdoc = {};
for l in ((typeof(text) == LIST) ? text | {text})
if (typeof(l) != STR)
return E_INVARG;
endif
newdoc = {@newdoc, $string_utils:print(l) + ";"};
endfor
if (ERR == typeof(svc = `set_verb_code(object, vname, {@newdoc, @code[length(vd) + 1..$]}) ! ANY'))
"... this shouldn't happen.  I'm not setting this code -d just yet...";
return svc;
else
return 1;
endif
endif
-------------------------------------------------------------------------------
#59 code utilities:parse_propref this n/a this
"$code_utils:parse_propref(string)";
"Parses string as a MOO-code property reference, returning {object-string, prop-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object.";
s = args[1];
if (dot = index(s, "."))
object = s[1..dot - 1];
prop = s[dot + 1..$];
if ((object == "") || (prop == ""))
return 0;
elseif (object[1] == "$")
object = `#0.(object[2..$]) ! ANY';
if (typeof(object) != OBJ)
return 0;
endif
object = tostr(object);
endif
elseif (index(s, "$") == 1)
object = "#0";
prop = s[2..$];
else
return 0;
endif
return {object, prop};
-------------------------------------------------------------------------------
#59 code utilities:parse_verbref this n/a this
"$code_utils:parse_verbref(string)";
"Parses string as a MOO-code verb reference, returning {object-string, verb-name-string} for a successful parse and false otherwise.  It always returns the right object-string to pass to, for example, this-room:match_object().";
s = args[1];
if (colon = index(s, ":"))
object = s[1..colon - 1];
verbname = s[colon + 1..$];
if (!(object && verbname))
return 0;
elseif (object[1] == "$")
pname = object[2..$];
if ((!(pname in properties(#0))) || (typeof(object = #0.(pname)) != OBJ))
return 0;
endif
object = tostr(object);
endif
return {object, verbname};
else
return 0;
endif
-------------------------------------------------------------------------------
#59 code utilities:parse_argspec this n/a this
":parse_arg_spec(@args)";
"  attempts to parse the given sequence of args into a verb_arg specification";
"returns {verb_args,remaining_args} if successful.";
"  e.g., :parse_arg_spec(\"this\",\"in\",\"front\",\"of\",\"any\",\"foo\"..)";
"           => {{\"this\",\"in front of\",\"any\"},{\"foo\"..}}";
"returns a string error message if parsing fails.";
nargs = length(args);
if (nargs < 1)
return {{}, {}};
elseif ((ds = args[1]) == "tnt")
return {{"this", "none", "this"}, listdelete(args, 1)};
elseif (!(ds in {"this", "any", "none"}))
return tostr("\"", ds, "\" is not a valid direct object specifier.");
elseif ((nargs < 2) || (args[2] in {"none", "any"}))
verbargs = args[1..min(3, nargs)];
rest = args[4..nargs];
elseif (!(gp = $code_utils:get_prep(@args[2..nargs]))[1])
return tostr("\"", args[2], "\" is not a valid preposition.");
else
verbargs = {ds, @gp[1..min(2, nargs = length(gp))]};
rest = gp[3..nargs];
endif
if ((length(verbargs) >= 3) && (!(verbargs[3] in {"this", "any", "none"})))
return tostr("\"", verbargs[3], "\" is not a valid indirect object specifier.");
endif
return {verbargs, rest};
-------------------------------------------------------------------------------
#59 code utilities:prepositions this n/a this
if (server_version() != this._version)
this:_fix_preps();
endif
return this.prepositions;
-------------------------------------------------------------------------------
#59 code utilities:short_prep this n/a this
":short_prep(p) => shortest preposition equivalent to p";
"p may be a single word or one of the strings returned by verb_args().";
if (server_version() != this._version)
this:_fix_preps();
endif
word = args[1];
word = word[1..index(word + "/", "/") - 1];
if (p = word in this._other_preps)
return this._short_preps[this._other_preps_n[p]];
elseif (word in this._short_preps)
return word;
else
return "";
endif
-------------------------------------------------------------------------------
#59 code utilities:full_prep this n/a this
if (server_version() != this._version)
this:_fix_preps();
endif
prep = args[1];
if (p = prep in this._short_preps)
return this.prepositions[p];
elseif (p = prep in this._other_preps)
return this.prepositions[this._other_preps_n[p]];
else
return "";
endif
-------------------------------------------------------------------------------
#59 code utilities:get_prep this n/a this
":get_prep(@args) extracts the prepositional phrase from the front of args, returning a list consisting of the preposition (or \"\", if none) followed by the unused args.";
":get_prep(\"in\",\"front\",\"of\",...) => {\"in front of\",...}";
":get_prep(\"inside\",...)          => {\"inside\",...}";
":get_prep(\"frabulous\",...}       => {\"\", \"frabulous\",...}";
prep = "";
allpreps = {@this._short_preps, @this._other_preps};
rest = 1;
for i in [1..length(args)]
accum = (i == 1) ? args[1] | tostr(accum, " ", args[i]);
if (accum in allpreps)
prep = accum;
rest = i + 1;
endif
if (!(accum in this._multi_preps))
return {prep, @args[rest..$]};
endif
endfor
return {prep, @args[rest..$]};
-------------------------------------------------------------------------------
#59 code utilities:_fix_preps this any this
":_fix_preps() updates the properties on this having to do with prepositions.";
"_fix_preps should be called whenever we detect that a new server version has been installed.";
orig_args = verb_args(this, verb);
multis = nothers = others = shorts = longs = {};
i = 0;
while (typeof(`set_verb_args(this, verb, {"this", tostr(i), "this"}) ! ANY') != ERR)
l = verb_args(this, verb)[2];
all = $string_utils:explode(l, "/");
s = all[1];
for p in (listdelete(all, 1))
if (length(p) <= length(s))
s = p;
endif
endfor
for p in (all)
while (j = rindex(p, " "))
multis = {p = p[1..j - 1], @multis};
endwhile
endfor
longs = {@longs, l};
shorts = {@shorts, s};
others = {@others, @setremove(all, s)};
nothers = {@nothers, @$list_utils:make(length(all) - 1, length(shorts))};
i = i + 1;
endwhile
set_verb_args(this, verb, orig_args);
this.prepositions = longs;
this._short_preps = shorts;
this._other_preps = others;
this._other_preps_n = nothers;
this._multi_preps = multis;
this._version = server_version();
return;
-------------------------------------------------------------------------------
#59 code utilities:find_verb_named this n/a this
":find_verb_named(object,name[,n])";
"  returns the *number* of the first verb on object matching the given name.";
"  optional argument n, if given, starts the search with verb n,";
"  causing the first n verbs (1..n-1) to be ignored.";
"  0 is returned if no verb is found.";
"  This routine does not find inherited verbs.";
{object, name, ?start = 1} = args;
for i in [start..length(verbs(object))]
verbinfo = verb_info(object, i);
if (this:verbname_match(verbinfo[3], name))
return i;
endif
endfor
return 0;
-------------------------------------------------------------------------------
#59 code utilities:find_last_verb_named this n/a this
":find_last_verb_named(object,name[,n])";
"  returns the *number* of the last verb on object matching the given name.";
"  optional argument n, if given, starts the search with verb n-1,";
"  causing verbs (n..length(verbs(object))) to be ignored.";
"  -1 is returned if no verb is found.";
"  This routine does not find inherited verbs.";
{object, name, ?last = -1} = args;
if (last < 0)
last = length(verbs(object));
endif
for i in [0..last - 1]
verbinfo = verb_info(object, last - i);
if (this:verbname_match(verbinfo[3], name))
return last - i;
endif
endfor
return -1;
-------------------------------------------------------------------------------
#59 code utilities:find_callable_verb_named this n/a this
":find_callable_verb_named(object,name[,n])";
"  returns the *number* of the first verb on object that matches the given";
"  name and has the x flag set.";
"  optional argument n, if given, starts the search with verb n,";
"  causing the first n verbs (0..n-1) to be ignored.";
"  0 is returned if no verb is found.";
"  This routine does not find inherited verbs.";
{object, name, ?start = 1} = args;
for i in [start..length(verbs(object))]
verbinfo = verb_info(object, i);
if (index(verbinfo[2], "x") && this:verbname_match(verbinfo[3], name))
return i;
endif
endfor
return 0;
-------------------------------------------------------------------------------
#59 code utilities:verbname_match(new) this n/a this
":verbname_match(fullverbname,name) => TRUE iff `name' is a valid name for a verb with the given `fullname'";
verblist = (" " + args[1]) + " ";
if (index(verblist, (" " + (name = args[2])) + " ") && (!match(name, "[ *]")))
"Note that if name has a * or a space in it, then it can only match one of the * verbnames";
return 1;
else
namelen = length(name);
while (m = match(verblist, "[^ *]*%(%*%)[^ ]*"))
vlast = m[2];
if ((namelen >= (m[3][1][1] - m[1])) && ((!(v = strsub(verblist[m[1]..vlast], "*", ""))) || (index(v, (verblist[vlast] == "*") ? name[1..min(namelen, length(v))] | name) == 1)))
return 1;
endif
verblist = verblist[vlast + 1..$];
endwhile
endif
return 0;
-------------------------------------------------------------------------------
#59 code utilities:find_verbs_containing find_verbs_matching find_verb_lines_containing find_verb_lines_matching this n/a this
"$code_utils:find_verbs_containing(pattern[,object|object-list[,casematters]])";
"$code_utils:find_verbs_matching(pattern[,object|object-list[,casematters]])";
"$code_utils:find_verb_lines_containing(pattern[,object|object-list[,casematters]])";
"$code_utils:find_verb_lines_matching(pattern[,object|object-list[,casematters]])";
"";
"Print (to player) the name and owner of every verb in the database whose code";
"  (find_verbs_containing) contains PATTERN as a substring ";
"  (find_verbs_matching)   has a substring matches the regular expression PATTERN .";
"Optional second argument limits the search to the specified object or objects.";
"Optional third argument if true specifies case-sensitive matching.";
":find_verbs_*() prints the first matching line in a verb while";
":find_verb_lines_*() prints all matching lines";
"";
"Because it searches the entire database, this function may suspend the task several times before returning.";
"";
set_task_perms(caller_perms());
"... puts the task in a player's own job queue and prevents someone from learning about verbs that are otherwise unreadable to him/her.";
{pattern, ?where = 0, ?casematters = 0} = args;
count = 0;
_find_verbs = "_" + verb;
if (typeof(where) == INT)
for o in [toobj(where)..max_object()]
count = count + this:(_find_verbs)(pattern, o, casematters);
endfor
elseif (typeof(where) == LIST)
for o in (where)
count = count + this:(_find_verbs)(pattern, o, casematters);
endfor
else
"...typeof(where) == OBJ...";
count = this:(_find_verbs)(pattern, where, casematters);
endif
player:notify("");
player:notify(tostr("Total: ", count, " verb", (count != 1) ? "s." | "."));
-------------------------------------------------------------------------------
#59 code utilities:_find_verbs_containing _find_verbs_matching this n/a this
":_find_verbs_containing(pattern,object[,casematters])";
":_find_verbs_matching(regexp,object[,casematters])";
"number of verbs in object with code having a line containing pattern or matching regexp";
"prints verbname and offending line to player";
set_task_perms(caller_perms());
{pattern, o, ?casematters = 0} = args;
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
if (!valid(o))
return 0;
endif
count = 0;
verbs = $object_utils:accessible_verbs(o);
_grep_verb_code = (verb == "_find_verbs_matching") ? "_egrep_verb_code" | "_grep_verb_code";
if (typeof(verbs) != LIST)
return player:notify(tostr("verbs(", o, ") => ", tostr(verbs)));
endif
for vnum in [1..length(verbs)]
if (l = this:(_grep_verb_code)(pattern, o, vnum, casematters))
owner = verb_info(o, vnum)[1];
player:notify(tostr(o, ":", verbs[vnum], " [", valid(owner) ? owner.name | "Recycled Player", " (", owner, ")]:  ", l));
count = count + 1;
endif
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
endfor
return count;
-------------------------------------------------------------------------------
#59 code utilities:_grep_verb_code this n/a this
":_grep_verb_code(pattern,object,verbname[,casematters]) => line number or 0";
"  returns line number on which pattern occurs in code for object:verbname";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
"The following gross kluge is due to Quade (#82589).  tostr is fast, and so we can check for nonexistence of a pattern very quickly this way rather than checking line by line.  MOO needs a compiler.  --Nosredna";
vc = `verb_code(object, vname) ! ANY';
if ((typeof(vc) == ERR) || (!index(tostr(@vc), pattern, casematters)))
return 0;
else
for line in (vc)
if (index(line, pattern, casematters))
return line;
endif
endfor
return 0;
endif
-------------------------------------------------------------------------------
#59 code utilities:_egrep_verb_code this n/a this
":_egrep_verb_code(regexp,object,verbname[,casematters]) => 0 or line number";
"  returns line number of first line matching regexp in object:verbname code";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
try
for line in (vc = `verb_code(object, vname) ! ANY => {}')
if (match(line, pattern, casematters))
return line;
endif
endfor
except (E_INVARG)
raise(E_INVARG, "Malformed regular expression.");
endtry
return 0;
-------------------------------------------------------------------------------
#59 code utilities:_parse_audit_args this n/a this
"Parse [from <start>] [to <end>] [for <name>].";
"Takes a series of strings, most likely @args with dobjstr removed.";
"Returns a list {INT start, INT end, STR name}, or {} if there is an error.";
fail = length(args) % 2;
start = 0;
end = toint(max_object());
match = "";
while (args && (!fail))
prep = args[1];
if (prep == "from")
if ((start = player.location:match_object(args[2])) >= #0)
start = toint(start);
else
start = toint(args[2]);
endif
elseif (prep == "to")
if ((end = player.location:match_object(args[2])) >= #0)
end = toint(end);
else
end = toint(args[2]);
endif
elseif (prep == "for")
match = args[2];
else
fail = 1;
endif
args = args[3..length(args)];
endwhile
return fail ? {} | {start, end, match};
-------------------------------------------------------------------------------
#59 code utilities:help_db_list this n/a this
":help_db_list([player]) => list of help dbs";
"in the order that they are consulted by player";
{?who = player} = args;
olist = {who, @$object_utils:ancestors(who)};
if (valid(who.location))
olist = {@olist, who.location, @$object_utils:ancestors(who.location)};
endif
dbs = {};
for o in (olist)
h = `o.help ! ANY => 0';
if (typeof(h) == OBJ)
h = {h};
endif
if (typeof(h) == LIST)
for db in (h)
if ((typeof(db) == OBJ) && (valid(db) && (!(db in dbs))))
dbs = {@dbs, db};
endif
endfor
endif
endfor
return setadd(dbs, $help);
-------------------------------------------------------------------------------
#59 code utilities:help_db_search this n/a this
":help_db_search(string,dblist)";
"  searches each of the help db's in dblist for a topic matching string.";
"  Returns  {db,topic}  or  {$ambiguous_match,{topic...}}  or {}";
{what, dblist} = args;
topics = {};
help = 1;
for db in (dblist)
$command_utils:suspend_if_needed(0);
if ({what} == (ts = `db:find_topics(what) ! ANY => 0'))
return {db, ts[1]};
elseif (ts && (typeof(ts) == LIST))
if (help)
help = db;
endif
for t in (ts)
topics = setadd(topics, t);
endfor
endif
endfor
if (length(topics) > 1)
return {$ambiguous_match, topics};
elseif (topics)
return {help, topics[1]};
else
return {};
endif
-------------------------------------------------------------------------------
#59 code utilities:corify_object this n/a this
":corify_object(object)  => string representing object";
"  usually just returns tostr(object), but in the case of objects that have";
"  corresponding #0 properties, return the appropriate $-string.";
object = args[1];
"Just in case #0 is !r on some idiot core.";
for p in (`properties(#0) ! ANY => {}')
"And if for some reason, some #0 prop is !r.";
if (`#0.(p) ! ANY' == object)
return "$" + p;
endif
endfor
return tostr(object);
-------------------------------------------------------------------------------
#59 code utilities:inside_quotes this n/a this
"See if the end of the string passed as args[1] ends 'inside' a doublequote.  Used by $code_utils:substitute.";
{string} = args;
quoted = 0;
while (i = index(string, "\""))
if ((!quoted) || ((i == 1) || (string[i - 1] != "\\")))
quoted = !quoted;
endif
string = string[i + 1..$];
endwhile
return quoted;
-------------------------------------------------------------------------------
#59 code utilities:verb_or_property this n/a this
"verb_or_property(<obj>, <name> [, @<args>])";
"Looks for a callable verb or property named <name> on <obj>.";
"If <obj> has a callable verb named <name> then return <obj>:(<name>)(@<args>).";
"If <obj> has a property named <name> then return <obj>.(<name>).";
"Otherwise return E_PROPNF, or E_PERM if you don't have permission to read the property.";
set_task_perms(caller_perms());
{object, name, @rest} = args;
return `object:(name)(@rest) ! E_VERBNF, E_INVIND => `object.(name) ! ANY'';
-------------------------------------------------------------------------------
#59 code utilities:task_valid this n/a this
"task_valid(INT id)";
"Return true iff there is currently a valid task with the given id.";
set_task_perms($no_one);
{id} = args;
t = $list_utils:slice(queued_tasks(), 1);
return ((id == task_id()) || (id in t)) || (E_PERM == `kill_task(id) ! ANY');
-------------------------------------------------------------------------------
#59 code utilities:task_owner this n/a this
":task_owner(INT task_id) => returns the owner of the task belonging to the id.";
if (a = $list_utils:assoc(args[1], queued_tasks()))
return a[5];
else
return E_INVARG;
endif
-------------------------------------------------------------------------------
#59 code utilities:argstr this n/a this
":argstr(verb,args[,argstr]) => what argstr should have been.  ";
"Recall that the command line is parsed into a sequence of words; `verb' is";
"assigned the first word, `args' is assigned the remaining words, and argstr";
"is assigned a substring of the command line, which *should* be the one";
"starting first nonblank character after the verb, but is instead (because";
"the parser is BROKEN!) the one starting with the first nonblank character";
"after the first space in the line, which is not necessarily after the verb.";
"Clearly, if the verb contains spaces --- which can happen if you use";
"backslashes and quotes --- this loses, and argstr will then erroneously";
"have extra junk at the beginning.  This verb, given verb, args, and the";
"actual argstr, returns what argstr should have been.";
verb = args[1];
argstr = {@args, argstr}[3];
n = length(args = args[2]);
if (!index(verb, " "))
return argstr;
elseif (!args)
return "";
endif
"space in verb => two possible cases:";
"(1) first space was not in a quoted string.";
"    first word of argstr == rest of verb unless verb ended on this space.";
if ((nqargs = $string_utils:words(argstr)) == args)
return argstr;
elseif (((nqn = length(nqargs)) == (n + 1)) && (nqargs[2..nqn] == args))
return argstr[$string_utils:word_start(argstr)[2][1]..length(argstr)];
else
"(2) first space was in a quoted string.";
"    argstr starts with rest of string";
qs = $string_utils:word_start("\"" + argstr);
return argstr[qs[(length(qs) - length(args)) + 1][1] - 1..length(argstr)];
endif
-------------------------------------------------------------------------------
#59 code utilities:verbname_match this n/a this
":verbname_match(fullverbname,name) => TRUE iff `name' is a valid name for a verb with the given `fullname'";
verblist = (" " + args[1]) + " ";
if (index(verblist, (" " + (name = args[2])) + " ") && (!(index(name, "*") || index(name, " "))))
"Note that if name has a * or a space in it, then it can only match one of the * verbnames";
return 1;
else
namelen = length(name);
while (star = index(verblist, "*"))
vstart = rindex(verblist[1..star], " ") + 1;
vlast = (vstart + index(verblist[vstart..$], " ")) - 2;
if ((namelen >= (star - vstart)) && ((!(v = strsub(verblist[vstart..vlast], "*", ""))) || (index(v, (verblist[vlast] == "*") ? name[1..min(namelen, length(v))] | name) == 1)))
return 1;
endif
verblist = verblist[vlast + 1..$];
endwhile
endif
return 0;
-------------------------------------------------------------------------------
#59 code utilities:substitute this n/a this
"$code_utils:substitute(string,subs) => new line";
"Subs are a list of lists, {{\"target\",\"sub\"},{...}...}";
"Substitutes targets for subs in a delimited string fashion, avoiding substituting anything inside quotes, e.g. player:tell(\"don't sub here!\")";
{s, subs} = args;
lets = "abcdefghijklmnopqrstuvwxyz0123456789";
for x in (subs)
len = length(sub = x[1]);
delimited = index(lets, sub[1]) && index(lets, sub[len]);
prefix = "";
while (i = index(s, sub))
prefix = prefix + s[1..i - 1];
if ((((prefix == "") || ((!delimited) || (!index(lets, prefix[$])))) && ((!delimited) || (((i + len) > length(s)) || (!index(lets, s[i + len]))))) && (!this:inside_quotes(prefix)))
prefix = prefix + x[2];
else
prefix = prefix + s[i..(i + len) - 1];
endif
s = s[i + len..length(s)];
endwhile
s = prefix + s;
endfor
return s;
-------------------------------------------------------------------------------
#59 code utilities:show_who_listing this n/a this
":show_who_listing(players[,more_players])";
" prints a listing of the indicated players.";
" For players in the first list, idle/connected times are shown if the player is logged in, otherwise the last_disconnect_time is shown.  For players in the second list, last_disconnect_time is shown, no matter whether the player is logged in.";
{plist, ?more_plist = {}} = args;
idles = itimes = offs = otimes = {};
argstr = dobjstr = iobjstr = prepstr = "";
for p in (more_plist)
if (!valid(p))
caller:notify(tostr(p, " <invalid>"));
elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)
if (!(p in offs))
offs = {@offs, p};
otimes = {@otimes, {-t, -t, p}};
endif
elseif (is_player(p))
caller:notify(tostr(p.name, " (", p, ") ", (t == E_PROPNF) ? "is not a $player." | "has a garbled .last_disconnect_time."));
else
caller:notify(tostr(p.name, " (", p, ") is not a player."));
endif
endfor
for p in (plist)
if (p in offs)
elseif (!valid(p))
caller:notify(tostr(p, " <invalid>"));
elseif (typeof(i = `idle_seconds(p) ! ANY') != ERR)
if (!(p in idles))
idles = {@idles, p};
itimes = {@itimes, {i, connected_seconds(p), p}};
endif
elseif (typeof(t = `p.last_disconnect_time ! E_PROPNF') == INT)
offs = {@offs, p};
otimes = {@otimes, {-t, -t, p}};
elseif (is_player(p))
caller:notify(tostr(p.name, " (", p, ") not logged in.", (t == E_PROPNF) ? "  Not a $player." | "  Garbled .last_disconnect_time."));
else
caller:notify(tostr(p.name, " (", p, ") is not a player."));
endif
endfor
if (!(idles || offs))
return 0;
endif
idles = $list_utils:sort_alist(itimes);
offs = $list_utils:sort_alist(otimes);
"...";
"... calculate widths...";
"...";
headers = {"Player name", @idles ? {"Connected", "Idle time"} | {"Last disconnect time", ""}, "Location"};
total_width = `caller:linelen() ! ANY => 0' || 79;
max_name = total_width / 4;
name_width = length(headers[1]);
names = locations = {};
for lst in ({@idles, @offs})
$command_utils:suspend_if_needed(0);
p = lst[3];
namestr = tostr(p.name[1..min(max_name, $)], " (", p, ")");
name_width = max(length(namestr), name_width);
names = {@names, namestr};
if (typeof(wlm = `p.location:who_location_msg(p) ! ANY') != STR)
wlm = valid(p.location) ? p.location.name | tostr("** Nowhere ** (", p.location, ")");
endif
locations = {@locations, wlm};
endfor
time_width = 3 + (offs ? 12 | length("59 minutes"));
before = {0, w1 = 3 + name_width, w2 = w1 + time_width, w2 + time_width};
"...";
"...print headers...";
"...";
su = $string_utils;
tell1 = headers[1];
tell2 = su:space(tell1, "-");
for j in [2..4]
tell1 = su:left(tell1, before[j]) + headers[j];
tell2 = su:left(tell2, before[j]) + su:space(headers[j], "-");
endfor
caller:notify(tell1[1..min($, total_width)]);
caller:notify(tell2[1..min($, total_width)]);
"...";
"...print lines...";
"...";
active = 0;
for i in [1..total = (ilen = length(idles)) + length(offs)]
if (i <= ilen)
lst = idles[i];
if (lst[1] < (5 * 60))
active = active + 1;
endif
l = {names[i], su:from_seconds(lst[2]), su:from_seconds(lst[1]), locations[i]};
else
lct = offs[i - ilen][3].last_connect_time;
ldt = offs[i - ilen][3].last_disconnect_time;
ctime = `caller:ctime(ldt) ! ANY => 0' || ctime(ldt);
l = {names[i], (lct <= time()) ? ctime | "Never", "", locations[i]};
if ((i == (ilen + 1)) && idles)
caller:notify(su:space(before[2]) + "------- Disconnected -------");
endif
endif
tell1 = l[1];
for j in [2..4]
tell1 = su:left(tell1, before[j]) + l[j];
endfor
caller:notify(tell1[1..min($, total_width)]);
if ($command_utils:running_out_of_time())
if ($login:is_lagging())
"Check lag two ways---global lag, but we might still fail due to individual lag of the queue this runs in, so check again later.";
caller:notify(tostr("Plus ", total - i, " other players (", total, " total; out of time and lag is high)."));
return;
endif
now = time();
suspend(0);
if ((time() - now) > 10)
caller:notify(tostr("Plus ", total - i, " other players (", total, " total; out of time and lag is high)."));
return;
endif
endif
endfor
"...";
"...epilogue...";
"...";
caller:notify("");
if (total == 1)
active_str = ", who has" + ((active == 1) ? "" | " not");
else
if (active == total)
active_str = (active == 2) ? "s, both" | "s, all";
elseif (active == 0)
active_str = "s, none";
else
active_str = tostr("s, ", active);
endif
active_str = tostr(active_str, " of whom ha", (active == 1) ? "s" | "ve");
endif
caller:notify(tostr("Total: ", total, " player", active_str, " been active recently."));
return total;
-------------------------------------------------------------------------------
#59 code utilities:_egrep_verb_code_all this n/a this
":_egrep_verb_code_all(regexp,object,verbname[,casematters]) => list of lines number";
"  returns list of all lines matching regexp in object:verbname code";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
lines = {};
for line in (vc = `verb_code(object, vname, 1, 0) ! ANY => {}')
if (match(line, pattern, casematters))
lines = {@lines, line};
endif
endfor
return lines;
-------------------------------------------------------------------------------
#59 code utilities:_grep_verb_code_all this n/a this
":_grep_verb_code_all(pattern,object,verbname[,casematters]) => list of lines";
"  returns list of lines on which pattern occurs in code for object:verbname";
set_task_perms(caller_perms());
{pattern, object, vname, ?casematters = 0} = args;
lines = {};
for line in (vc = `verb_code(object, vname) ! ANY => {}')
if (index(line, pattern, casematters))
lines = {@lines, line};
endif
endfor
return lines;
-------------------------------------------------------------------------------
#59 code utilities:verb_usage this n/a this
":verb_usage([object,verbname]) => usage string at beginning of verb code, if any";
"default is the calling verb";
set_task_perms(caller_perms());
c = callers()[1];
{?object = c[4], ?vname = c[2]} = args;
if (typeof(code = `verb_code(object, vname) ! ANY') == ERR)
return code;
else
doc = {};
indent = "^$";
for line in (code)
if (match(line, "^\"%([^\\\"]%|\\.%)*\";$"))
"... now that we're sure `line' is just a string, eval() is safe...";
e = $no_one:eval(line)[2];
if (subs = match(e, "^%(%(Usage%|Syntax%): +%)%([^ ]+%)%(.*$%)"))
"Server is broken, hence the next three lines:";
if (subs[3][4][1] > subs[3][4][2])
subs[3][4] = {0, -1};
endif
indent = ("^%(" + $string_utils:space(length(substitute("%1", subs)))) + " *%)%([^ ]+%)%(.*$%)";
docverb = substitute("%3", subs);
if (match(vname, "^[0-9]+$"))
vname = docverb;
endif
doc = {@doc, (substitute("%1", subs) + vname) + substitute("%4", subs)};
elseif (subs = match(e, indent))
if (substitute("%3", subs) == docverb)
doc = {@doc, (substitute("%1", subs) + vname) + substitute("%4", subs)};
else
doc = {@doc, e};
endif
elseif (indent)
return doc;
endif
else
return doc;
endif
endfor
return doc;
endif
-------------------------------------------------------------------------------
#59 code utilities:verb_frame this n/a this
"returns the callers() frame for the current verb.";
return callers()[1];
-------------------------------------------------------------------------------
#59 code utilities:verb_all_frames this n/a this
"returns {this:verb_frame(), @callers()}.";
return callers();
-------------------------------------------------------------------------------
#59 code utilities:move_verb this n/a this
":move_verb(OBJ from, STR verb name, OBJ to, [STR new verb name]) -> Moves the specified verb from one object to another. Returns {OBJ, Full verb name} where the verb now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the verb, unless called with wizard perms. Supplying a fourth argument moves the verb to a new name.";
"Should handle verbnames with aliases and wildcards correctly.";
who = caller_perms();
{from, origverb, to, ?destverb = origverb} = args;
if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origverb) != STR)) || (typeof(destverb) != STR))
"check this first so we can parse out long verb names next";
return E_TYPE;
endif
origverb_first = strsub(origverb[1..index(origverb + " ", " ") - 1], "*", "") || "*";
destverb_first = strsub(destverb[1..index(destverb + " ", " ") - 1], "*", "") || "*";
if ((!valid(from)) || (!valid(to)))
return E_INVARG;
elseif ((from == to) && (destverb == origverb))
"Moving same origverb onto the same object puts the verbcode in the wrong one. Just not allow";
return E_NACC;
elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))
"caller_perms() is not allowed to hack on either object in question";
return E_PERM;
elseif (!$object_utils:defines_verb(from, origverb_first))
"verb is not defined on the from object";
return E_VERBNF;
elseif ((vinfo = verb_info(from, origverb_first)) && (!$perm_utils:controls(who, vinfo[1])))
"caller_perms() is not permitted to add a verb with the existing verb owner";
return E_PERM;
elseif (!who.programmer)
return E_PERM;
else
"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective verb owner (by more traditional means)";
vcode = verb_code(from, origverb_first);
vargs = verb_args(from, origverb_first);
vinfo[3] = (destverb == origverb) ? vinfo[3] | destverb;
if (typeof(res = `add_verb(to, vinfo, vargs) ! ANY') == ERR)
return res;
else
set_verb_code(to, destverb_first, vcode);
delete_verb(from, origverb_first);
return {to, vinfo[3]};
endif
endif
-------------------------------------------------------------------------------
#59 code utilities:move_prop*erty this n/a this
":move_prop(OBJ from, STR prop name, OBJ to, [STR new prop name]) -> Moves the specified property and its contents from one object to another. Returns {OBJ, property name} where the property now resides if successful, error if not. To succeed, caller_perms() must control both objects and own the property, unless called with wizard perms. Supplying a fourth argument gives the property a new name on the new object.";
who = caller_perms();
{from, origprop, to, ?destprop = origprop} = args;
if ((((typeof(from) != OBJ) || (typeof(to) != OBJ)) || (typeof(origprop) != STR)) || (typeof(destprop) != STR))
return E_TYPE;
elseif ((!valid(from)) || (!valid(to)))
return E_INVARG;
elseif ((from == to) && (destprop == origprop))
"Moving same prop onto the same object puts the contents in the wrong one. Just not allow";
return E_NACC;
elseif (((!$perm_utils:controls(who, from)) && (!from.w)) || ((!$perm_utils:controls(who, to)) && (!to.w)))
"caller_perms() is not allowed to hack on either object in question";
return E_PERM;
elseif (!$object_utils:defines_property(from, origprop))
"property is not defined on the from object";
return E_PROPNF;
elseif ((pinfo = property_info(from, origprop)) && (!$perm_utils:controls(who, pinfo[1])))
"caller_perms() is not permitted to add a property with the existing property owner";
return E_PERM;
elseif (!who.programmer)
return E_PERM;
else
"we now know that the caller's perms control the objects or the objects are writable, and we know that the caller's perms control the prospective property owner (by more traditional means)";
pdata = from.(origprop);
pname = (destprop == origprop) ? origprop | destprop;
if (typeof(res = `add_property(to, pname, pdata, pinfo) ! ANY') == ERR)
return res;
else
delete_property(from, origprop);
return {to, pname};
endif
endif
-------------------------------------------------------------------------------
#59 code utilities:eval_d_util this n/a this
"Do not remove this verb!  This is an auxiliary verb for :eval_d().";
-------------------------------------------------------------------------------
#59 code utilities:display_callers this n/a this
":display_callers([callers() style list]) - displays the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.";
call = (caller_perms() == player) ? "notify_lines" | "tell_lines";
player:(call)(this:callers_text(@args));
-------------------------------------------------------------------------------
#59 code utilities:callers_text this n/a this
":callers_text([callers() style list]) - returns the output of the given argument, assumed to be a callers() output. See `help callers()' for details. Will use callers() explicitly if no argument is passed.";
linelen = min(player:linelen(), 200);
text = {};
su = $string_utils;
lu = $list_utils;
verbwidth = 0;
{?match = callers(1)} = args;
for verbitem in (lu:slice(match, 2))
verbwidth = max(verbwidth, length(verbitem));
endfor
verbwidth = 3 + verbwidth;
numwidth = ((linelen - verbwidth) / 4) - 1;
widths = {numwidth, verbwidth, numwidth, numwidth, numwidth};
top = l = between = "";
for x in [1..5]
top = (top + between) + su:left({"This", "Verb", "Permissions", "VerbLocation", "Player"}[x], -widths[x]);
l = (l + between) + su:space(widths[x], "-");
between = " ";
endfor
text = listappend(text, top);
text = listappend(text, l);
for line in (match)
output = {};
for bit in [1..5]
$command_utils:suspend_if_needed(3);
"bit == 2 below for verb: append line number.";
output = {@output, su:left((typeof(word = line[bit]) == STR) ? (bit == 2) ? tostr(word, "(", `line[6] ! ANY => 0', ")") | word | tostr(word, "(", valid(word) ? lu:shortest({word.name, @word.aliases}) | ((word == $nothing) ? "invalid" | ((word == $ambiguous_match) ? "ambiguous match" | "Error")), ")"), -widths[bit]), " "};
endfor
text = listappend(text, su:trimr(tostr(@output)));
endfor
text = listappend(text, l);
return text;
-------------------------------------------------------------------------------
#59 code utilities:set_property_value set_verb_or_property this n/a this
":set_property_value(object, property, value)";
" set_verb_or_property(same) -- similar to `verb_or_property'";
"  -- attempts to set <object>.<property> to <value>.  If there exists <object>:set_<property>, then it is called and its returned value is returned.  If not, we try to set the property directly; the result of this is returned.";
set_task_perms(caller_perms());
if (length(args) != 3)
return E_ARGS;
elseif (typeof(o = args[1]) != OBJ)
return E_INVARG;
elseif (!$recycler:valid(o))
return E_INVIND;
elseif (typeof(p = args[2]) != STR)
return E_INVARG;
elseif ($object_utils:has_callable_verb(o, v = "set_" + p))
return o:(v)(args[3]);
else
return o.(p) = args[3];
endif
-------------------------------------------------------------------------------
#59 code utilities:owns_task this n/a this
"$code_utils:owns_task(task_id, who)";
"The purpose of this is to be faster than $code_utils:task_owner(task_id) in those cases where you are interested in whether a certain person owns the task rather than in determining the owner of a task where you have no preconceived notion of the owner.";
return $list_utils:assoc(args[1], $wiz_utils:queued_tasks(args[2]));
-------------------------------------------------------------------------------
#59 code utilities:dflag_on this n/a this
"Syntax:  $code_utils:dflag_on()   => 0|1";
"";
"Returns true if the verb calling the verb that called this verb has the `d' flag set true. Returns false if it is !d. If there aren't that many callers, or the calling verb was a builtin such as eval, assume the debug flag is on for traceback purposes and return true.";
"This is useful for determining whether the calling verb should return or raise an error to the verb that called it.";
return (length(c = callers()) >= 2) ? `index(verb_info(c[2][4], c[2][2])[2], "d") && 1 ! E_INVARG => 1' | 1;
-------------------------------------------------------------------------------
#59 code utilities:type_str this n/a this
"type_str -- returns a string describing the type of args[1]";
x = args[1];
type_data = {1, 3.14, "", #0, E_NONE, {}};
type_strs = {"INT", "FLOAT", "STR", "OBJ", "ERR", "LIST"};
for i in [1..length(type_data)]
if (typeof(type_data[i]) == typeof(x))
return type_strs[i];
endif
endfor
return "NONE";
-------------------------------------------------------------------------------
#59 code utilities:dump_properties this n/a this
":dump_properties (object, create_flag): returns the list of strings representing the property information for this object and its ancestor objects in @dump format.";
set_task_perms(caller_perms());
{dobj, create, ?targname = tostr(dobj)} = args;
result = {};
for p in (`properties(dobj) ! ANY => {}')
pquoted = toliteral(p);
try
info = property_info(dobj, p);
value = dobj.(p);
except error (ANY)
result = {@result, tostr("\"", targname, ".(", pquoted, ") => ", toliteral(error[1]), " (", error[2], ")")};
continue p;
endtry
if (create)
uvalue = (typeof(value) == LIST) ? "{}" | 0;
result = {@result, tostr("@prop ", targname, ".", pquoted, " ", uvalue || toliteral(value), " ", info[2] || "\"\"", (info[1] == dobj.owner) ? "" | tostr(" ", info[1]))};
if (uvalue && value)
result = {@result, tostr(";;", targname, ".(", pquoted, ") = ", toliteral(value))};
endif
else
if (info[2] != "rc")
result = {@result, tostr("@chmod ", targname, ".", pquoted, " ", info[2])};
endif
if (info[1] != dobj.owner)
result = {@result, tostr("@chown ", targname, ".", pquoted, " ", info[1])};
endif
result = {@result, tostr(";;", targname, ".(", pquoted, ") = ", toliteral(value))};
endif
$command_utils:suspend_if_needed(0);
endfor
for a in ($object_utils:ancestors(dobj))
for p in (`properties(a) ! ANY => {}')
$command_utils:suspend_if_needed(1);
pquoted = toliteral(p);
try
value = dobj.(p);
except error (ANY)
result = {@result, tostr("\"", targname, ".(", pquoted, ") => ", toliteral(error[1]), " (", error[2], ")")};
continue p;
endtry
avalue = `a.(p) ! ANY';
if ((typeof(avalue) == ERR) || (value != avalue))
result = {@result, tostr(";;", targname, ".(", pquoted, ") = ", toliteral(value))};
endif
endfor
$command_utils:suspend_if_needed(1);
endfor
return result;
-------------------------------------------------------------------------------
#59 code utilities:dump_preamble this n/a this
":dump_preamble(object): produces the @create command necessary to dump this object.";
dobj = args[1];
parent = parent(dobj);
pstring = tostr(parent);
for p in (properties(#0))
if (#0.(p) == parent)
pstring = "$" + p;
endif
endfor
return tostr("@create ", pstring, " named ", dobj.name, ":", $string_utils:from_list(dobj.aliases, ","));
-------------------------------------------------------------------------------
#59 code utilities:dump_verbs this n/a this
":dump_verbs (object, create_flag): returns the list of strings representing the verb information for this object in @dump format.";
set_task_perms(caller_perms());
{dobj, create, ?targname = tostr(dobj)} = args;
result = {};
v = 1;
while ((info = `verb_info(dobj, v) ! ANY') || (info == E_PERM))
if (`index(info[3], "(old)") ! ANY' && 0)
"Thought about skipping (old) verbs...";
player:tell("Skipping ", dobj, ":\"", info[3], "\"...");
else
if (typeof(info) == ERR)
result = {@result, tostr("\"", dobj, ":", v, " --- ", info, "\";")};
else
if (i = index(vname = info[3], " "))
vname = vname[1..i - 1];
endif
if (vname[1] != "*")
vname = strsub(vname, "*", "");
endif
args = verb_args(dobj, v);
prep = (args[2] in {"any", "none"}) ? args[2] | $code_utils:short_prep(args[2]);
perms = (info[2] != ((args == {"this", "none", "this"}) ? "rxd" | "rd")) ? info[2] || "\"\"" | "";
if (create)
if (info[1] == dobj.owner)
tail = perms ? tostr(" ", perms) | "";
else
tail = tostr(" ", perms || info[2], " ", info[1]);
endif
result = {@result, tostr("@verb ", targname, ":\"", info[3], "\" ", args[1], " ", prep, " ", args[3], tail)};
else
result = {@result, tostr("@args ", targname, ":\"", info[3], "\" ", args[1], " ", prep, " ", args[3])};
if (info[1] != dobj.owner)
result = {@result, tostr("@chown ", targname, ":", vname, " ", info[1])};
endif
if (perms)
result = {@result, tostr("@chmod ", targname, ":", vname, " ", perms)};
endif
endif
if (code = verb_code(dobj, v, 1, 1))
result = {@result, tostr("@program ", targname, ":", vname), @code, ".", ""};
endif
endif
endif
if (`index(tostr(" ", info[3], " "), " * ") ! ANY')
"... we have a * verb.  may as well forget trying to list...";
"... the rest; they're invisible.  set v to something nonstring.";
v = E_TYPE;
else
v = v + 1;
endif
$command_utils:suspend_if_needed(0);
endwhile
return result;
-------------------------------------------------------------------------------
#59 code utilities:_find_verb_lines_containing _find_verb_lines_matching this n/a this
":_find_verb_lines_containing(pattern,object[,casematters])";
":_find_verb_lines_matching(regexp,object[,casematters])";
"number of verbs in object with code having a line containing pattern or matching regexp";
"prints verbname and all offending lines to player";
set_task_perms(caller_perms());
{pattern, o, ?casematters = 0} = args;
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
if (!valid(o))
return 0;
endif
count = 0;
verbs = $object_utils:accessible_verbs(o);
if (typeof(verbs) != LIST)
return player:notify(tostr("verbs(", o, ") => ", tostr(verbs)));
endif
_grep_verb_code_all = (verb == "_find_verb_lines_matching") ? "_egrep_verb_code_all" | "_grep_verb_code_all";
for vnum in [1..length(verbs)]
found = 0;
for l in (this:(_grep_verb_code_all)(pattern, o, vnum, casematters))
owner = verb_info(o, vnum)[1];
player:notify(tostr(o, ":", verbs[vnum], " [", valid(owner) ? owner.name | "Recycled Player", " (", owner, ")]:  ", l));
found = 1;
$command_utils:suspend_if_needed(0);
endfor
if (found)
count = count + 1;
endif
if ($command_utils:running_out_of_time())
player:notify(tostr("...", o));
suspend(0);
endif
endfor
return count;
-------------------------------------------------------------------------------
================================#60 Help Database===============================================
#60 Help Database. rc = MOOList [ "*forward*", "summary", "", "Type 'help <topic>' for information on a particular topic.", "" ]
#60 Help Database.@gripe rc = MOOList [ "Syntax:  @gripe <anything> ...", "", "Puts you into the MOO mail system to register a complaint (or, conceivably, a compliment) with the wizards.  The rest of the command line (the <anything> ... part) is used as the subject line for the message.  More information on using the MOO mail system is given once you're in it.", "", "You may hear back from the wizards eventually; see 'help @mail' for how to read their reply.", "", "Example:", "Munchkin types:", "  @gripe The little bird", "  "How come I can't ever see the little bird in the cuckoo clock?", "  "        -- A frustrated player", "  send", "and, somewhat later, the wizards reply with a note about being sure to look while the clock is chiming." ]
#60 Help Database.@addalias rc = MOOList [ "Syntax: @addalias <alias>[,...,<alias>] to <object>", "        @addalias <alias>[,...,<alias>] to <object>:<verb-name>", "        @addalias# <alias>[,...,<alias>] to <object>:<verb-number>", "", "The first form is used to add aliases to an object's list of aliases.  You can separate multiple aliases with commas.  The aliases will be checked against the object's current aliases and all aliases not already in the object's list of aliases will be added.", "", "Example:", "Muchkin wants to add new aliases to Rover the Wonder Dog:", "  @addalias Dog,Wonder Dog to Rover", "Since Rover the Wonder Dog already has the alias "Dog" but does not have the alias "Wonder Dog", Munchkin sees:", "  Rover the Wonder Dog(#4237) already has the alias Dog.", "  Alias Wonder Dog added to Rover the Wonder Dog(#4237).", "", "If the object is a player, spaces will also be assumed to be separations between aliases and each alias will be checked against the Player Name Database to make sure no one else is using it. Any already used aliases will be identified.  Certain other classes of objects (e.g., mail-recipients) also enforce rules about what aliases may be given them.", "", "Example:", "Munchkin wants to add his nicknames to his own list of aliases:", "  @addalias Foobar Davey to me", "@Addalias recognizes that Munchkin is trying to add an alias to a valid player and checks the aliases against the Player Name Database.  Unfortunately, DaveTheMan is already using the alias "Davey" so Munchkin sees:", "  DaveTheMan(#5432) is already using the alias Davey", "  Alias Foobar added to Munchkin(#1523).", "", "The second form of the @addalias command is for use by programmers, to add aliases to a verb they own.  All commas and spaces are assumed to be separations between aliases.", "", "The third form, @addalias#, is for unambiguously referring to a verb on an object in case there are more than one with the same name. The verb number is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list." ]
#60 Help Database.gen-index rc = MOOList [ "*index*", "General Help Topics" ]
#60 Help Database.objects r = MOOList [ "Objects are the fundamental building blocks of the MOO.  Every object has a unique number, a name, an owner, a location, and various other properties.  An object can always be referred to by its number, and sometimes by its name or one of its aliases -- if you are in the same location as the object, for example, and also in some other special cases.", "", "For help on creating an object, see 'help @create'.", "", "For help on recycling an object, see 'help @recycle'.", "", "For help on finding information about specific objects, see 'help @display', 'help @show', and 'help $object_utils'." ]
#60 Help Database.@listgag r = MOOList [ "Syntax:  @listgag [all]", "         @gaglist [all]", "", "Shows you a list of the players and objects currently on your 'gag list'.  You don't see any messages that result from actions initiated by the players or objects on this list.  In particular, you will not hear them if they try to speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.  With the optional "all" parameter it will also scan the database for players who are gagging you.  This may induce lag, so caution is advised with this option." ]
#60 Help Database.@registerme rc = MOOList [ "  @registerme as <email-address>", "This verb changes your registered email_address property. It will modify the registration, and then, to validate the email address, it will assign a new password and mail the password to the given email_address.", "If, for some reason, this is a problem for you, contact a wizard or registrar to get your email address changed.", "", "  @registerme", "Prints your registered email address." ]
#60 Help Database.put r = MOOList [ "Syntax:  put <object> into <container>", "         insert <object> in <container>", "", "Moves the named object into the named container.  Sometimes the owners of the object and/or the container will not allow you to do this." ]
#60 Help Database.@request-character rc = MOOList [ "Usage:    @request <player-name> for <email-address>", "", "Example:  @request Munchkin for msneed@baum.edu", "", "This command is available to Guest characters only.", "", "The @request command requests a new character, registered for your email address. Please use your primary address for this, as your password will be sent to the address provided." ]
#60 Help Database.@memory r = MOOList [ "Syntax:  @memory", "", "Prints out all information available on the current memory-usage behavior of the MOO server.  Probably only a wizard, if anyone, cares about this." ]
#60 Help Database.@check rc = MOOList [ "Syntax:   @check <options>", "", "where <options> is one or more of:", "-- the number of lines to be displayed", "-- a player's name, someone to be "trusted" during the assignment of responsibility for the message.", "-- a player's named prefixed by !, someone not to be "trusted".", "", "          @check-full <options>", "where <options is either ", "-- the number of lines to be displayed", "-- a search string: only lines containing that string will be displayed.", "", "Used when you are suspicious about the origin of some of the messages your character has just heard.", "", "Output from @check is in columns that contain, in order, the monitor's best guess as to:", "    what object the message came from,", "    what verb on that object that was responsible,", "    whose permissions that verb was running with, and", "    the beginning of the actual message.", "", "Output from @check-full is in columns that contains a description of all the verbs that were responsible for the noise heard, not just the best guess as to who was responsible.", "", "@check operates by examining the list of verbs that were involved in delivering the message, and assigning responsibility to the first owner it sees who is not "trusted".  By default, it trusts you and all the wizards.  It uses the records maintained by @paranoid, so you must have used that command before you received the message." ]
#60 Help Database.whereis rc = MOOList [ "Syntax:  whereis [<player> [<player>...]]", "        @whereis [<player> [<player>...]]", "", "Returns the current location of each of the specified players, or of all players if not arguments given." ]
#60 Help Database.@users rc = MOOList [ "Syntax:  @users", "", "Prints out the number of users currently connected and a list of their names, in alphabetical order." ]
#60 Help Database.@gender rc = MOOList [ "Syntax: @gender <gender>", "        @gender", "", "The first form, with an argument, defines your player to have the gender <gender>.  If <gender> is one of the standard genders (e.g., 'male', 'female', 'neuter',...), your various pronouns will also be set appropriately, making exits and certain other objects behave more pleasantly for you.", "", "The second form tells you the current definition of your player's gender, your current pronouns, and the complete list of standard genders.", "", "It should be noted that some of the "genders" on the standard gender list need verb conjugation in order to work properly and much of the MOO isn't set up for this (...yet).  For example, you should expect to see `they is' a fair amount if you @gender yourself `plural'." ]
#60 Help Database.options rc = MOOList [ "Options allow you to customize the behavior of various commands.  Options are grouped into separate option packages that each affects a given class of related commands.  Each has its own help topic:", "", "  @mail-options    --- mail commands (@mail, @read, @next, @prev, @send...)", "  @edit-options    --- editing commands (@edit and commands within the editor)", "  @build-options   --- building commands (@create, @dig, @recycle)" ]
#60 Help Database.@messages r = MOOList [ "Syntax:  @messages <object>", "", "List all of the messages that can be set on the named object and their current values.  See 'help messages' for more details." ]
#60 Help Database.write r = MOOList [ "Syntax:  write "<any text>" on <note>", "", "Adds a line of text to the named note or letter.  Only the owner of a note may do this." ]
#60 Help Database.manipulation rc = MOOList [ "Objects usually have verbs defined on them that allow players to manipulate and use them in various ways. Standard ones are:", "", "get  -- pick an object up and place it in your inventory", "drop -- remove an object from your inventory and place it in the room", "put  -- take an object from your inventory and place it in a container", "give -- hand an object to some other player", "look -- see what an object looks like", "", "You can see what objects you're carrying with the 'inventory' command; see 'help inventory' for details.", "", "Some specialized objects will have other commands. The programmer of the object will usually provide some way for you to find out what the commands are.  One way that works for most objects is the 'examine' command; see 'help examine' for details.", "", "The following specialized objects have help entries you should consult:", "", "notes -- objects that allow text to be written on them and read later", "letters -- notes that a recipient can burn after reading", "containers -- objects that may contain other objects" ]
#60 Help Database.letters r = MOOList [ "A letter is a special kind of note (see 'help notes') with the added feature that it can be recycled by anyone who can read it.  This is often useful for notes from one player to another.  You create the letter as a child of the generic letter, $letter (see 'help @create' and 'help write'), encrypt it so that only you and the other player can read it (see 'help encrypt') and then either give it to the player in question or leave it where they will find it.  Once they've read it, they can use the 'burn' command to recycle the letter; see 'help burn' for details." ]
#60 Help Database.give rc = MOOList [ "Syntax:  give <object> to <player>", "         hand <object> to <player>", "", "Move an object from your contents to that of another player.  This doesn't change the ownership of the object.  Some players may refuse to accept gifts and some objects may refuse to be given." ]
#60 Help Database." r = MOOList [ "*forward*", "say" ]
#60 Help Database. index rc = MOOList [ "*index_list*" ]
#60 Help Database.players r = MOOList [ "There are a number of commands for modifying various characteristics of the object representing you in the MOO, your 'player'.  Help on them is available in the following topics:", "", "@describe -- setting what others see when they look at you", "@gender -- changing your player's gender", "@password -- changing your player's password", "@sethome -- changing your designated home room", "@rename -- changing your name and/or aliases", "@linelength -- adding word-wrap to the lines you see" ]
#60 Help Database.@addfeature rc = MOOList [ "*forward*", "@add-feature" ]
#60 Help Database.@notedit rc = MOOList [ "Syntax:  @notedit <note-object>", "         @notedit <object>.<property>", "", "Enters the MOO Note Editor to edit the text on the named object", "For the first form, <note-object> must be a descendant of $note.  ", "For the second form, <object>.<property> can be any string-valued or text-valued (i.e., list of strings) property on any object.", "", "See 'help editors' for more detail." ]
#60 Help Database.@bug rc = MOOList [ "*forward*", "@typo" ]
#60 Help Database.@more r = MOOList [ "*subst*", "Syntax:  @more", "         @more rest", "         @more flush", "", "If you have @pagelength set (see `help @pagelength') and some combination of events or commands produces sufficiently many lines of output, you will see a message of the form", "", "%[strsub(player.more_msg,"%%n","37")]", "", "indicating (in this case) 37 more lines of text waiting to be read.  ", "At this point, you should give one of the @more commands above.  ", "", "@more without arguments prints sufficiently many lines to fill your screen,", "assuming you've set @pagelength correctly, unless there are not that many", "lines left to print.", "", "@more rest will print all of the remaining lines, regardless of your @pagelength setting.  ", "", "@more flush discards all remaining lines" ]
#60 Help Database.@quit r = MOOList [ "Syntax:  @quit", "", "Disconnect from the MOO.  This breaks your network connection and leaves your player sleeping.  Disconnecting in most parts of the MOO automatically returns your player to its designated home (see 'help home')." ]
#60 Help Database.@wrap r = MOOList [ "*forward*", "@linelength" ]
#60 Help Database.@typo rc = MOOList [ "Syntax:  @typo    [<text>]", "         @bug     [<text>]", "         @suggest [<text>]", "         @idea    [<text>]", "         @comment [<text>]", "", "If <text> is given, a one-line message is sent to the owner of the room, presumably about something that you've noticed.  If <text> is not given, we assume you have more to say than can fit comfortably on a single line; the usual mail editor is invoked.  The convention is that @typo is for typographical errors on the room or objects found therein, @bug is for anomalous or nonintuitive behaviour of some sort, @idea/@suggest for any particular brainstorms or criticisms you might happen to have, and @comment for anything else.", "", "If you're sending a bug report to someone because you got an error traceback when you used some object of theirs, please give them enough information to work on the problem.  In particular, please tell them *exactly* what you typed and *all* of the error messages that were printed to you, including the entire traceback, up to the line `(End of traceback.)'.  Without this information, it is nearly impossible for the programmer to discover, let alone fix, the problem.", "", "The usual mail editor is only invoked for this command when in rooms that allow free entry, i.e., rooms that are likely to allow you back after you are done editing your message.  Otherwise these commands will require <text> and only let you do one-line messages.  ", "Most adventuring scenario rooms fall into this latter category." ]
#60 Help Database.messages r = MOOList [ "Most objects have messages that are printed when a player succeeds or fails in manipulating the object in some way.  Of course, the kinds of messages printed are specific to the kinds of manipulations and those, in turn, are specific to the kind of object.  Regardless of the kind of object, though, there is a uniform means for listing the kinds of messages that can be set and then for setting them.", "", "The '@messages' command prints out all of the messages you can set on any object you own.  Type 'help @messages' for details.", "", "To set a particular message on one of your objects use a command with this form:", "        @<message-name> <object> is "<message>"", "where '<message-name>' is the name of the message being set, <object> is the name or number of the object on which you want to set that message, and <message> is the actual text.", "", "For example, consider the 'leave' message on an exit; it is printed to a player when they successfully use the exit to leave a room.  To set the 'leave' message on the exit 'north' from the current room, use the command", "        @leave north is "You wander in a northerly way out of the room."", "", "[Note to programmers: This class of commands automatically applies to any property whose name ends in '_msg'.  Thus, in the example above, the command is setting the 'leave_msg' property of the named exit.  You can get such a command to work on new kinds of objects simply by giving the appropriate properties names that end in '_msg'.  Additionally, in many cases the _msg property is accompanied by a _msg verb, which defaultly returns the named property, but which is available to be customized in more complex ways than allowed by simple string substitution.  You should check for the particular property you're considering whether the verb form exists (typically with @list).]", "", "The following help topics describe the uses of the various messages available on standard kinds of objects:", "", "container-messages -- the messages on objects that can contain other objects", "exit-messages -- the messages on exit objects", "thing-messages -- the messages on objects that can be taken and dropped" ]
#60 Help Database.@add-feature rc = MOOList [ "Usage:  @add-feature  <object>", " @remove-feature <object>", "", "Add or remove a feature from your list.  A feature is an object which provides additional commands you can use.  For more information, see `help features'." ]
#60 Help Database.: r = MOOList [ "*forward*", "emote" ]
#60 Help Database.? r = MOOList [ "*forward*", "help" ]
#60 Help Database.:: rc = MOOList [ "*forward*", "emote" ]
#60 Help Database.miscellaneous r = MOOList [ "Here are a few commands of occasional utility that didn't fit into any of the neat categories for the rest of the help system:", "", "@version -- printing the MOO server version number", "@lastlog -- finding out when some player last connected to the MOO" ]
#60 Help Database.examine r = MOOList [ "Syntax:  examine <object>", "         exam <object>", "", "Prints several useful pieces of information about the named object, including the following:", "        + its full name, object number, and aliases", "        + its owner's name", "        + its description", "        + its key expression (if it is locked and if you own it)", "        + its contents", "        + the 'obvious' verbs defined on it" ]
#60 Help Database.@examine rc = MOOList [ "Syntax:  @examine <object>", "         @exam <object>", "", "Prints several useful pieces of information about the named object, including the following:", "        + its full name, aliases, and object number", "        + its owner's name and object number", "        + its description", "        + its key expression (if it is locked and if you own it)", "        + its contents and their object numbers", "        + the 'obvious' verbs defined on it", "", "[Note to programmers: the 'obvious' verbs are those that are readable and that can be invoked as commands.  To keep a verb off this list, either make it unreadable (see 'help @chmod') or, if it shouldn't be used as a command, give it 'args' of 'this none this' (see 'help @args').]" ]
#60 Help Database.@paranoid rc = MOOList [ "Syntax:  @paranoid", "         @paranoid off", "         @paranoid immediate", "         @paranoid <number>", "", "In immediate mode, the monitor prepends everything you hear with the name of ", "the character it considers responsible for the message. Otherwise, it keeps ", "records of the last <number> (defaults to 10) lines you have heard. These ", "records can be accessed by the @check command." ]
#60 Help Database.encrypt r = MOOList [ "Syntax:  encrypt <note> with <key-expression>", "", "Restricts the set of players who can read the named note or letter to those for whom the given key expression is true.  See 'help keys' for information on the syntax and semantics of key expressions.  Only the owner of a note may do this." ]
#60 Help Database.get rc = MOOList [ "*forward*", "take" ]
#60 Help Database.@mode r = MOOList [ "Syntax:  @mode <brief | verbose>", "", "Sets your current mode to either brief or verbose.  In brief mode, when you enter into a room, you will not see the room's description unless you explicitly type `look'.  Verbose is the default mode." ]
#60 Help Database. name rc = MOOList [ "Every object (including players, rooms, exits) has a name and a set of aliases. The object name is commonly used to display an object in various contexts. The object aliases are used to refer to an object when players type commands.", "Help is available on the following commands:", "@rename -- change the names or aliases of an object or yourself.", "@addalias, @rmalias -- add and remove aliases." ]
#60 Help Database.@eject! rc = MOOList [ "*forward*", "@eject" ]
#60 Help Database.hand r = MOOList [ "*forward*", "give" ]
#60 Help Database.@who r = MOOList [ "*subst*", "Syntax: @who", "        @who <player> [<player> ... ]", "", "The first form lists all of the currently-connected players, along with the amount of time they've been connected, the amount of time they've been idle, and their present location in the MOO.", "", "The second form, in which a list of player names is given, shows information for just those players.  For any listed players that are not connected, we show the last login time instead of the connect/idle times.", "", "@who refers to the @who_location message (see 'help messages') on each player's location in order to determine what should be printed in the location column.  Pronoun substitutions are done on this string in the usual manner (see 'help pronouns').  The default value is "%[$room.who_location_msg]" (i.e., the room name).", "", "If the list of players to display is longer than 100, this command will not show its normal output, since it can be quite expensive to compute.  In such cases, you might want to use the @users command instead; see `help @users' for more information." ]
#60 Help Database.erase r = MOOList [ "Syntax:  erase <note>", "", "Deletes all of the text written on a note or letter.  Only the owner of a note may do this." ]
#60 Help Database.@eject rc = MOOList [ "Syntax: @eject[!] <object> [from <place>]", "", "This command is used to remove unwanted objects from places you own.  Players thus removed are unceremoniously dumped in their homes (unless that's this room, in which case they are dumped in the default player starting place).  Other kinds of objects are checked for a .home property and sent there if possible, otherwise they get thrown into #-1.  Unlike @move, @eject does *not* check to see if the object wants to be moved, and with the destination being what it is, there is no question of the destination refusing the move, either.  Generally, you should only resort to @eject if @move doesn't work.", "", "`@eject <object>' removes <object> from the current room, whereas `@eject <object> from <place>' removes the object from the specified location (in most cases, <place> will need to be specified as an object number).  In either case, this command only works if you own the room/entity from which the object is being ejected.", "", "`@eject ... from me' suffices to get rid of some unwanted object in your inventory.", "", "The verbs @eject! and @eject!! are provided for those rare situations in which @eject does not work.  @eject! does not check for .home properties, sending the offending object to #-1 immediately, but with a notification.  @eject!! is just like @eject! but provides no notification to the object.", "", "See 'help room-messages' for a list of messages one can set regarding the @eject command." ]
#60 Help Database.@add-alias rc = MOOList [ "*forward*", "@addalias" ]
#60 Help Database.gagging rc = MOOList [ "Occasionally, you may run into a situation in which you'd rather not hear from certain other players.  It might be that they're being annoying, or just that whatever they're doing makes a lot of noise.  Gagging a player will stop you from hearing the results of any task initiated by that player.  You can also gag a specific object, if you want to hear what the owner of that object says, but not the output from their noisy robot.  The commands to use gagging are listed below; detailed help is available on each of them:", "", "@gag -- add one or more players to your gag list", "@ungag -- remove a player from your gag list", "@listgag -- list the players you currently have gagged" ]
#60 Help Database.spivak rc = MOOList [ "The spivak pronouns were developed by mathematician Michael Spivak for use in his books.  They are the most simplistic of the gender neutral pronouns (others being "neuter" and "splat") and can be easily integrated into writing.  They should be used in a generic setting where the gender of the person referred to is unknown, such as "the reader."  They can also be used to describe a specific individual who has chosen not to identify emself with the traditional masculine (male) or feminine (female) gender.", "", "The spivak pronouns are", "E      - subjective", "Em     - objective", "Eir    - possessive (adjective)", "Eirs   - possessive (noun)", "Emself - reflexive" ]
#60 Help Database.@sweep rc = MOOList [ "Syntax: @sweep", "", "Used when you wish to have a private conversation, and are concerned someone may be listening in. @sweep tries to list the avenues by which information may be leaving the room. In a manner analogous to @check, it assumes that you don't want to hear about your own verbs, or those belonging to wizards, who presumably wouldn't stoop to bugging." ]
#60 Help Database.help r = MOOList [ "Syntax:  help", "         help <topic>", "         help index", "", "Print out entries from the online documentation system.  The commands `?' and `information' (usually abbreviated `info') are synonyms for `help'.", "", "The first form prints out a summary table of contents for the entire help system.  ", "", "The second form prints out the documentation available on the given topic.  Many help system entries contain references to other entries accessible in this way.  The topic name may be abbreviated; if there is no topic exactly matching the name you give, the help system checks for topics for which the name is a prefix, perhaps with the addition or omission of an initial `@', or perhaps with some confusion beween dashes (-) and underscores (_), e.g., ", "      `bui' instead of `building', ", "      `who' instead of `@who', ", "     `@wri' instead of `write',", "  `add_ent' instead of `@add-entrance',", " `unlock-'  instead of `@unlock_for_open'", "", "If the abbreviation you give is ambiguous, you will be presented with a list of the matching complete topic names.", "", "The `help index' commands prints out a list of indices for the various help databases.  Each index gives a list of topics available on that database.  It is sometimes easier to find the topics you're interested in this way, rather than tracing through the chain of cross references." ]
#60 Help Database.@edit-options rc = MOOList [ "Syntax:  @edit-option", "         @edit-option <option>", "", "Synonym:  @editoption", "", "The edit options customize the behavior of the various editors (mail editor, verb editor, etc...) to your particular taste.  The first form of this command displays all of your edit options.  The second form displays just that one option, one of the flags listed below.", "", "The remaining forms of this command are for setting your edit options:", "", "         @edit-option +<flag>", "         @edit-option -<flag>", "         @edit-option !<flag>           (equivalent to -<flag>)", "", "These respectively set and reset the specified flag", "", "-quiet_insert    insert (") and append (:) echo back the line numbers", "+quiet_insert    insert (") and append (:) produce no output", "-eval_subs       (VERB EDITOR) ignore .eval_subs when compiling verbs", "+eval_subs       (VERB EDITOR) apply .eval_subs to verbs being compiled", "-local           Use in-MOO text editors.", "+local           Ship text to client for local editing.", "-no_parens       include all parentheses in verb code.", "+no_parens       include only necessary parentheses in verb code.", "", "+parens        is a synonym for -no_parens", "+noisy_insert  is a synonym for -quiet_insert" ]
#60 Help Database.throw r = MOOList [ "*forward*", "drop" ]
#60 Help Database.full-index rc = MOOList [ "*full_index*" ]
#60 Help Database.information r = MOOList [ "*forward*", "help" ]
#60 Help Database.tinymud r = MOOList [ "This is yduJ's table of tinymud commands and their equivalents in LambdaMOO.  A longer document, with discussions of the different verbs and how they have changed, is available via FTP from ftp.lambda.moo.mud.org as pub/MOO/contrib/docs/TinyMUD-LambdaMOO-equivs.  All the commands mentioned here have help nodes on LambdaMOO.", "", "The following commands are basically the same in MOO and MUD.", "", "    drop(throw), get(take), go, help, home, inventory, look, news, say (",:)", "", "", "The following commands have no equivalent:", "", "    kill, rob, score, @force", "", "", "The following commands have the same names and do similar things, but are changed in some way (both syntactic and semantic differences, sometimes quite substantial differences):", "", "    @examine, give, page, read, whisper, @create, @dig,", "    @lock, @password, @unlock, @describe", "", "", "The following commands have rough equivalents in LambdaMOO but the name is different:", "", "    TinyMUD name            LambdaMOO name", "    ------------            --------------", "    QUIT                    @quit", "    gripe                   @gripe", "    goto/move               go", "    WHO                     @who", "    @fail                   @take_failed, @nogo, @drop_failed", "    @find                   @audit", "    @link                   @dig, @sethome, @add-exit, @add-entrance", "    @name                   @rename", "    @ofail                  @otake_failed, @onogo, @odrop_failed", "    @open                   @dig", "    @osuccess               @oleave, @oarrive, @otake_succeeded, ", "                            @odrop_succeeded", "    @success                @leave, @arrive, @take_succeeded", "                            @drop_succeeded", "    @teleport               @move", "", "", "Here are some commands for which no equivalent exists, or for which the equivalent is a complicated set of actions.", "", "    @set, @stats, @unlink", "", "", "Documentation on most of the LambdaMOO commands mentioned above can be acquired using 'help <command-name>'.  A notable exception is the commands like @oarrive and @take_failed that set textual messages on objects.  These are described under 'help messages'." ]
#60 Help Database.decrypt r = MOOList [ "Syntax:  decrypt <note>", "", "Removes any restriction on who may read the named note or letter.  Only the owner of a note may do this." ]
#60 Help Database. aliases r = MOOList [ "Every object on the MOO (players included) has a list of aliases, or names by which it can be referred.  This is useful when an object has a nice long descriptive name that you don't want to have to type every time you refer to it.", "", "Typing `exam object' will show you its aliases.  If you are a programmer, you can type `#<object>.aliases', using an object's number, or `#Munchkin.aliases p'.  (The `p' indicates that the prefix is a player's name.)", "", "See also `help #', `help @addalias', and `help @rmalias'." ]
#60 Help Database.movement r = MOOList [ "The descriptions of most rooms outline the directions in which exits exist.  Typical directions include the eight compass points ('north', 'south', 'east', 'west', 'northeast', 'southeast', 'northwest', and 'southwest'), 'up', 'down', and 'out'.", "", "To go in a particular direction, simply type the name of that direction (e.g, 'north', 'up').  The name of the direction can usually be abbreviated to one or two characters (e.g., 'n', 'sw').  You can also type 'go <direction>' to move; this is particularly useful if you know you're going to type several movement commands in a row (see 'help go').", "", "In addition to such vanilla movement, some areas may contain objects allowing teleportation and almost all areas permit the use of the 'home' command to teleport you to your designated home (see 'help home' for more details)." ]
#60 Help Database.@suggest rc = MOOList [ "*forward*", "@typo" ]
#60 Help Database.@password r = MOOList [ "Syntax: @password <old-password> <new-password>", "", "Changes your player's password (as typed in the 'connect' command when you log in to the MOO) to <new-password>.  For security reasons, you are required to type your current (soon to be old) password as the first argument.", "", "Your password is stored in an encrypted form in the MOO database; in principle, not even the wizards can tell what it is, though they can change it, of course.  It is recommended that your password not be your name or a common word; MOO passwords have been stolen or cracked in the past and characters have been made unhappy by such theft.  Your password is your security; choose a safe one.", "", "If your character does get stolen, a wizard can change it for you and tell you the new password in secret.  You may have to provide your email address for verification.", "", "Only the first 8 characters of a password are significant." ]
#60 Help Database.@idea rc = MOOList [ "*forward*", "@typo" ]
#60 Help Database.checkpoint r = MOOList [ "Checkpointing refers to process by which the MOO makes a backup copy of itself.  Because the computer that's running the MOO has to simultaneously handle two copies of itself, this results in a period of high lag for the MOO users.  So, why do we put up with this?", "", "Every successful checkpoint results in a database of what the MOO was like at that point in time.  All the MOOmail, mailing lists, objects, descriptions, properties, and verbs on all of the MOO are frozen in time and stored.  In the event that the MOO crashes (due to a power failure or the like), this checkpoint database can be used to restart the MOO with much of our recent work intact.  This is a very good thing.", "", "Checkpointing is a global backup.  Do not rely on the checkpoint database to back up your own work!  Archive your code, properties, and objects offline to ensure their safety.  Each successful checkpoint overwrites the previous day's checkpoint, so it is an unreliable means of recovering lost data.  Some of these checkpoints do get backed up quarterly, but these are not available without inconveniencing the MOO populace as a whole." ]
#60 Help Database.notes rc = MOOList [ "Notes are objects that can have text written on them to be read later.  They are useful for leaving messages to people, or for documenting your creations.", "", "The following help topics cover verbs that can be used with notes:", "", "read -- reading the text on the note", "write -- adding text to a note", "erase -- removing all the text from a note", "delete -- deleting one line of text from a note", "", "@notedit -- general editing on the text of a note", "", "encrypt -- restricting who can read a note", "decrypt -- undoing a previous encryption", "", "You can make a note by creating a child of the standard note, $note (see 'help @create').  Note that, like most objects, only the owner of a note can recycle it.  If you'd like to make it possible for a reader of your note to destroy it (this is a common desire for notes to other individual players), then you might want to look at 'help letters'." ]
#60 Help Database.descriptions r = MOOList [ "Most objects have one or more descriptive pieces of text associated with them; these texts are printed under various circumstances depending on the kind of text.  For example, every object has a 'description' text that is printed whenever a player looks at the object.  The following help topics discuss the commands for manipulating these descriptive texts on your objects:", "", "@rename -- setting the name and aliases of your objects", "@describe -- setting what others see when they look at your objects", "messages -- listing and setting the other descriptive texts on an object" ]
#60 Help Database.@ungag r = MOOList [ "Syntax:  @ungag <player or object>", "         @ungag everyone", "", "Remove the given player or object (or, in the second form, everyone) from your 'gag list'.  You will once again see any messages that result from actions initiated by the ungagged player(s) or objects.  In particular, you will once again be able to hear them if they speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.", "", "Example:", "Munchkin types:", "  @ungag Grover", "and is once again able to hear Grover's witty remarks.  Sigh..." ]
#60 Help Database.features rc = MOOList [ "Features are objects that provide you with commands not covered by the ordinary player objects.  The advantage of using features is that you can mix and match the things you like; whereas if you like a command that's defined on a player class, you have to also get all the commands it defines, and all the commands its ancestors define.", "", "You can list your features with the @features command, and add or remove features from your list with the @add-feature and @remove-feature commands." ]
#60 Help Database.@gag r = MOOList [ "Syntax:  @gag <player or object> [<player or object>...]", "", "Add the given players to your 'gag list'.  You will no longer see any messages that result from actions initiated by these players.  In particular, you will not hear them if they try to speak, emote, or whisper to you.  See 'help gagging' for an explanation of gagging in general.", "", "Example:", "Munchkin types:", "  @gag Grover", "and no longer hears anything that Grover says.  What a relief!", "", "If you specify an object, then any text originating from that object will not be printed.  Example:  Noisy Robot prints "Hi there" every 15 seconds.   In order to avoid seeing that, Munchkin types:", "  @gag Noisy", "and no longer hears that robot!  (Munchkin must be in the same room as Noisy Robot for this to work, or know its object number.)" ]
#60 Help Database.communication rc = MOOList [ "There are several commands available to allow you to communicate with your fellow MOOers.  Help is available on the following communication-related topics:", "", "say      -- talking to the other connected players in the room", "whisper  -- talking privately to someone in the same room", "page     -- yelling to someone anywhere in the MOO", "emote    -- non-verbal communication with others in the same room", "gagging  -- screening out noise generated by certain other players", "news     -- reading the wizards' most recent set of general announcements", "@gripe   -- sending complaints to the wizards", "@typo @bug @idea @suggest", "         -- sending complaints/ideas to the owner of the current room", "whereis  -- locating other players", "@who     -- finding out who is currently logged in", "mail     -- the MOO email system", "security -- the facilities for detecting forged messages and eavesdropping." ]
#60 Help Database.programming rc = MOOList [ "MOO contains a rich programming language for the creation of interesting rooms, exits, and other objects.", "", "Not every player is allowed to program in MOO, including (at the moment, anyway) you.  If you would like to be, find a wizard and convince them that you've got good ideas that the MOO needs.  Good luck!" ]
#60 Help Database.commands rc = MOOList [ "*forward*", "summary", "", "Type 'help <topic>' for information on a particular topic.", "" ]
#60 Help Database.gopher rc = MOOList [ "Gopher is an internet service for information retrieval. There are many gopher servers across the internet, providing a wide variety of information of all sorts: network news, weather, and White House press releases, campus class information, and scientific papers.", "", "The programmer interface to Gopher is contained in the object $gopher (`help $gopher')." ]
#60 Help Database.player-names rc = MOOList [ "*subst*", "A player name must be a single word, must not contain any spaces, backslashes, or quotes, nor can it begin with the characters #, *, (, or ).  Finally it cannot be one that is in use by any other player nor any of the words on the following list:", "", "%;;lns={};for l in ($string_utils:columnize({@$player_db.stupid_names,@$player_db.reserved},6)) lns={@lns,"  "+l}; endfor return lns;", "", "Note that these rules apply as well to your single-word aliases, since those can equally well be used to refer to you in commands that match on player names (@who, whereis, ...).  There are no restrictions on your multi-word aliases, however the commands that expect player names will not recognize them." ]
#60 Help Database.@age rc = MOOList [ "Syntax:  @age [player]", "", "Displays the MOO age of the player if the player specified first connected after initial connections were recorded.", "MOO age is computed from the moment the player first connected until the current time." ]
#60 Help Database.read r = MOOList [ "Syntax:  read <note>", "", "Prints the text written on the named object, usually a note or letter.  Some notes are encrypted so that only certain players may read them." ]
#60 Help Database.@rename rc = MOOList [ "Syntax: @rename <object>        to [name-and-alias],<alias>,...,<alias>", "        @rename <object>        to [name]:<alias>,...,<alias>", "        @rename <object>.<property> to <new-property-name>", "        @rename <object>:<verb-name> to <new-verb-name>", "        @rename# <object>:<verb-number> to <new-verb-name>", "", "The first two forms are used to change the name and aliases of an object. The name is what will be used in most printed descriptions of the object. The aliases are the names by which players can refer to the object in commands. Typically you want to include the name in the aliases, as the MOO parser only checks .aliases when matching, so the first syntax is generally preferred.", "", "If you leave out the "name" part of the list, @rename will leave the object's name as it is, and only change the aliases.", "", "Note that for renaming players, more stringent rules apply.  See `help player-names'.  Certain other kinds of objects (e.g., mail recipients) also enforce their own rules w.r.t what they can be named.", "", "Examples:", "Munchkin names his dog:", "  @rename #4237 to "Rover the Wonder Dog":Rover,dog", "Now we'll see 'Rover the Wonder Dog' if we're in the same room as him and we can refer to him as either 'Rover' or just 'dog' in our commands, like 'pet dog'.  Note, however, that it will be impossible to use "Rover the Wonder Dog" to rever to the dog: if you don't include the name in the aliases, confusion can result.  It might have been better to start off with", "  @rename #4237 to "Rover the Wonder Dog",Rover,dog", "", "Since he didn't, Munchkin now changes his dog's aliases:", "  @rename #4237 to ,Rover,dog,Rover the Wonder Dog", "The name remains the same--we still see 'Rover the Wonder Dog'--but now any of 'Rover', 'dog', or 'Rover the Wonder Dog' can be used to refer to him.  This can help reduce confusion.", "", "The third form of the @rename command is also for use by programmers, to change the name of a property they own to <new-property-name>.", "", "The fourth form of the @rename command is for use by programmers, to change the name of a verb they own. If the <new-verb-name> contains spaces, the verb will have multiple names, one for each space-separated word.", "", "The fifth form, @rename#, is for unambiguously referring to a verb on an object in case there is more than one with the same name. The verb number is the 1-based index of the verb as it appears in the verbs() (or @verbs) output list." ]
#60 Help Database.@sethome r = MOOList [ "Syntax: @sethome", "", "Sets your designated home (see `help home') to be the room you're in now.  If the current room wouldn't allow you to teleport in, then the `@sethome' command nicely refuses to set your home there.  This avoids later, perhaps unpleasant, surprises.  Additionally, your home must be a room that will allow you to stay there.  Rooms which you own will do this, as will rooms to which you have been added as a resident.  See the @resident command for help on adding someone as a resident to a room you own." ]
#60 Help Database.@move rc = MOOList [ "Syntax:  @move <thing> to <place>", "", "Move the specified object to the specified location.  This is not guaranteed to work; in particular, the object must agree to be moved and the destination must agree to allow the object in.  This is usually the case, however.  The special case where <thing> is 'me' is useful for teleporting yourself around.", "", "If @move doesn't work and you own the room where the object is located, try using @eject instead." ]
#60 Help Database.look rc = MOOList [ "Syntax: look", "        look <object>", "        look <object> in <container>", "", "Show a description of something.", "", "The first form, with no arguments, shows you the name and description of the room you're in, along with a list of the other objects that are there.", "", "The second form lets you look at a specific object.  Most objects have descriptions that may be read this way.  You can look at your own description using 'look me'.  You can set the description for an object or room, including yourself, with the 'describe' command (see 'help describe').", "", "The third form shows you the description of an object that is inside some other object, including objects being carried by another player." ]
#60 Help Database.spoofing r = MOOList [ "*forward*", "security" ]
#60 Help Database.take r = MOOList [ "Syntax:  take <object>", "         get <object>", "         take <object> from <container>", "         get <object> from <container>", "         remove <object> from <container>", "", "The first two forms pick up the named object and place it in your inventory.  Sometimes the owner of the object won't allow it to be picked up for some reason.", "", "The remaining forms move the named object from inside the named container (see 'help containers') into your inventory.  As before, sometimes the owner of an object will not allow you to do this." ]
#60 Help Database.@features rc = MOOList [ "Usage:  @features [<name>] [for <player>]", "", "List all of <player>'s features matching <name>, or all of <player>'s features if <name> is not supplied.  <player> defaults to you.  See `help features' for more information." ]
#60 Help Database.pronouns r = MOOList [ "Some kinds of messages are not printed directly to players; they are allowed to contain special characters marking places to include the appropriate pronoun for some player.  For example, a builder might have a doorway that's very short, so that people have to crawl to get through it.  When they do so, the builder wants a little message like this to be printed:", "", "        Balthazar crawls through the little doorway, bruising his knee.", "", "The problem is the use of 'his' in the message; what if the player in question is female?  The correct setting of the 'oleave' message on that doorway is as follows:", "", "        "crawls through the little doorway, bruising %p knee."", "", "The '%p' in the message will be replaced by either 'his', 'her', or 'its', depending upon the gender of the player.  ", "", "As it happens, you can also refer to elements of the command line (e.g., direct and indirect objects) the object issuing the message, and the location where this is all happening.  In addition one can refer to arbitrary string properties on these objects, or get the object numbers themselves.", "", "The complete set of substitutions is as follows:", "", "        %% => `%'  (just in case you actually want to talk about percentages).", "    Names:", "        %n => the player", "        %t => this object (i.e., the object issuing the message,... usually)", "        %d => the direct object from the command line", "        %i => the indirect object from the command line", "        %l => the location of the player", "    Pronouns:", "        %s => subject pronoun:          either `he',  `she', or `it'", "        %o => object pronoun:           either `him', `her', or `it'", "        %p => posessive pronoun (adj):  either `his', `her', or `its'  ", "        %q => posessive pronoun (noun): either `his', `hers', or `its'", "        %r => reflexive pronoun:  either `himself', `herself', or `itself'", "    General properties:", "        %(foo) => player.foo ", "        %[tfoo], %[dfoo], %[ifoo], %[lfoo]", "               => this.foo, dobj.foo, iobj.foo, and player.location.foo", "    Object numbers:", "        %#  => player's object number", "        %[#t], %[#d], %[#i], %[#l]", "            => object numbers for this, direct obj, indirect obj, and location.", "", "In addition there is a set of capitalized substitutions for use at the ", "beginning of sentences.  These are, respectively, ", "", "   %N, %T, %D, %I, %L for object names, ", "   %S, %O, %P, %Q, %R for pronouns, and", "   %(Foo), %[dFoo] (== %[Dfoo] == %[DFoo]),... for general properties", "", "Note: there is a special exception for player .name's which are assumed to", "already be capitalized as desired.", "", "There may be situations where the standard algorithm, i.e., upcasing the first letter, yields something incorrect, in which case a "capitalization" for a particular string property can be specified explicitly.  If your object has a ".foo" property that is like this, you need merely add a ".fooc" (in general .(propertyname+"c")) specifying the correct capitalization.  This will also work for player .name's if you want to specify a capitalization that is different from your usual .name", "", "Example:  ", "Rog makes a hand-grenade with a customizable explode message.", "Suppose someone sets grenade.explode_msg to:", "", "  "%N(%#) drops %t on %p foot.  %T explodes.  ", "   %L is engulfed in flames."", "", "If the current location happens to be #3443 ("yduJ's Hairdressing Salon"),", "the resulting substitution may produce, eg.,", "", "  "Rog(#4292) drops grenade on his foot.  Grenade explodes.  ", "   YduJ's Hairdressing Salon is engulfed in flames."", "", "which contains an incorrect capitalization.  ", "yduJ may remedy this by setting #3443.namec="yduJ's Hairdressing Salon".", "", "Note for programmers:  ", " In programs, use $string_utils:pronoun_sub().", " %n actually calls player:title() while %(name) refers to player.name directly." ]
#60 Help Database.emote r = MOOList [ "Syntax:  emote <anything> ...", "         :<anything> ...", "         ::<anything> ...", "", "Announces <anything> to everyone in the same room, prepending your name.  This is commonly used to express various non-verbal forms of communication.  In fact, it is so commonly used that there's a special abbreviation for it: any command-line beginning with ':' is treated as an 'emote' command.", "", "The alternate form, '::' (less commonly 'emote :'), does not insert the space between the player name and the text.", "", "Examples:", "Munchkin types this:", "  :wishes he were much taller...", "Everyone in the same room sees this:", "  Munchkin wishes he were much taller...", "", "Munchkin types this:", "  ::'s eyes are green.", "Everyone in the same room sees this:", "  Munchkin's eyes are green." ]
#60 Help Database.page r = MOOList [ "*subst*", "Syntax:  page <player> [[with] <text>]", "", "Sends a message to a connected player, telling them your location and, optionally, <text>.", "", "Example:", "Munchkin types:", "        page Frebble with "Where are you?"", "Frebble sees:", "        You sense that Munchkin is looking for you in the Kitchen.", "        He pages, "Where are you?"", "Munchkin sees:", "        Your message has been received.", "", "Advanced Features:", "Page refers to the following messages on the players involved (see 'help messages'):", "", "@page_origin [%[$player.page_origin_msg]]", "  Determines how the recipient is told of your location.", "", "@page_echo   [%[$player.page_echo_msg]]", "  Determines the response received by anyone who pages you.", "", "@page_absent [%[$player.page_absent_msg]]", "  Determines the response received by anyone who tries to page you when you aren't connected.", "", "All of these undergo the usual pronoun substitutions (see 'help pronouns') except that in both cases the direct object (%d) refers to the recipent of the page and the indirect object (%i) refers to the sender.  You should only change these messages if you want to add to the Virtual Reality feel of the MOO for your character." ]
#60 Help Database.@uptime rc = MOOList [ "Syntax:  @uptime", "", "   The @uptime command displays the amount of time since the last restart of the server.", "   Note to programmers:  The last restart time of the server is stored in $last_restart_time." ]
#60 Help Database.drop rc = MOOList [ "Syntax:  drop <object>", "         throw <object>", "", "Remove an object you are carrying from your inventory and put it in your current room.  Occasionally you may find that the owner of the room won't allow you to do this." ]
#60 Help Database.@remove-feature rc = MOOList [ "*forward*", "@add-feature" ]
#60 Help Database.@linelength rc = MOOList [ "Syntax:  @wrap <on|off>", "         @wrap", "", "         @linelength <number>", "         @linelength", "", "If the lines you see get cut off at the edge of your screen (you don't have", "word-wrap), you can get the MOO to split lines for you.  The @linelength", "command tells the MOO how many columns you have on your screen--you probably", "want @linelength 79--and "@wrap on" tells the MOO you want it to do word-", "wrap.", "", "It's better if you can fix this problem without the MOO's help, though,", "because the MOO's solution will be slower than a local solution, and", "because not all MUDs are willing to do word-wrap.", "", "If you don't want the MOO to split lines for you, there might still be some", "use for the @linelength command.  Certain commands, like @who and @check,", "print truncated lines so they can print in neat columns.  The default for", "these is generally about 79 columns, which looks fine if you have an", "eighty-column screen.  If your screen is a different width, though, you", "can set @linelength and some of these commands will react accordingly." ]
#60 Help Database.@describe r = MOOList [ "Syntax:  @describe <object> as <description>", "", "Sets the description string of <object> to <description>.  This is the string that is printed out whenever someone uses the 'look' command on <object>.  To describe yourself, use 'me' as the <object>.", "", "Example:", "Munchkin types this:", "  @describe me as "A very fine fellow, if a bit on the short side."", "People who type 'look Munchkin' now see this:", "  A very fine fellow, if a bit on the short side.", "", "Note for programmers:", "The description of an object is kept in its .description property.  ", "For descriptions of more than one paragraph, .description can be a list of strings." ]
#60 Help Database.privacy rc = MOOList [ "Some things you should be aware of:", "", " -*-*- OMNISCIENT WIZARDS AND SYSADMINS: -*-*-", "Wizards can look at absolutely *anything* in the MOO database.  ", "The arch-wizard and the sysadmin for the MOO-server host have complete access not only to the MOO database itself but to many other possibly-relevant things.", "The above mentioned parties (wizards et al), while they will endeavor to be discreet about anything incidental that turns up, nevertheless reserve the right to look at anything they want, if only for the sake of being able to resolve technical problems.", "", " -*-*- LOGGING: -*-*- ", "Some client programs (the "client" is the program you use to connect to the MOO, e.g., telnet, tinytalk, tinyfugue, emacs with mud.el...) are capable of logging everything that happens to the corresponding player.  In fact, with some clients this happens by default.  If a given player's client has logging enabled and said player is either in the room with you or is monitoring an object that is in the room with you, then *everything* you say and emote gets recorded.  Also, if you are in a room owned by someone else, all bets are off.  There is *no way* that the MOO server can know about what client a given player is using; thus, anyone who can hear you is a potential logger.", "", "In and of itself this would not be a problem --- indeed, logs are often useful for reference purposes.  However, there is no guarantee that the log will not end up someplace where you'd rather it didn't, e.g., posted on the rec.games.mud Usenet newsgroup.  While it is considered bad form (i.e., rude) to circulate or post a log without having the permission of at least the major participants in the activities logged, there is not a whole lot we can do on the technical side to prevent it from happening.", "", "Be aware of the problem.  The @sweep command (see `help @sweep') attempts to determine what players can be listening at any given moment.  If anything, it errs on the side of paranoia.  Even so, it doesn't cover *all* possible avenues of eavesdropping, and there's no hope for it covering the situations like the one where someone manages to convince one of the participants in your discussion who kept a log that it really doesn't need to be kept private after all.", "", "If you've got something really sensitive to discuss, you are best off doing it by encrypted email or in person." ]
#60 Help Database.insert r = MOOList [ "*forward*", "put" ]
#60 Help Database.inventory rc = MOOList [ "Syntax:  inventory", "         i", "", "Prints a list showing every object you're carrying." ]
#60 Help Database.@pagelength r = MOOList [ "Syntax:  @pagelength <number>", "         @pagelength", "", "If the lines you see scroll off the top of your screen too quickly for you to", "read and your client program is such that any lines scrolling off the top are", "gone forever, you can use the @pagelength command to invoke page buffering to", "limit the number of lines sent at a time.  E.g., if your terminal has a 24 line", "screen, you can do @pagelength 24 and output will stop every 24 lines if you", "don't type any other commands.", "", "You will need to use the @more command to continue reading output once it ", "has been stopped.  Make sure you read `help @more' before setting @pagelength.", "", "@pagelength 0 means no page buffering will be done by the MOO.", "", "By default the MOO will assume you have an infinitely wide terminal screen, so", "you may wish to set @linelength as well, and ensure wrapping is on with @wrap", "on.  (See help @linelength and help @wrap.)  As with word wrapping, you are", "best off running a client that can do its own page buffering; the MOO server's", "page buffering is inherently slower and many MUD's do not have page buffering", "at all." ]
#60 Help Database.delete r = MOOList [ "Syntax:  delete <line-number> from <note>", "", "Removes a single line of text from a note.  The first line of text is numbered 1, the second is 2, and so on.  Only the owner of a note may do this." ]
#60 Help Database.remove r = MOOList [ "*forward*", "take" ]
#60 Help Database.security rc = MOOList [ "There are several commands available to determine the origins of messages and to check that your communications with other players are secure. Help is available on the following topics:", "", "@paranoid -- keeping a record of messages your character hears.", "@check    -- looking at that record to determine responsibility for messages.", "@sweep    -- checking who is listening in on your conversation." ]
#60 Help Database.@lastlog r = MOOList [ "Syntax:  @lastlog", "         @lastlog <player>", "", "The first form prints out a list of all players, roughly sorted by how long it's been since that player last connected to the MOO.  For each player, the precise time of their last connection is printed.", "", "The second form only shows the last-connection time for the named player." ]
#60 Help Database.backspace rc = MOOList [ "Players sometimes have difficulty getting their backspace key to work.  This is an outside-MOO problem:  Whatever access software you have determines how the line you type is edited before the MOO ever sees it.  If your backspace key won't work here, you will probably need to consult with some documentation or a guru at your end.", "", "The above notwithstanding, here are a few things to try instead of backspace:", "", "   ctrl-h            (another way of typing backspace)", "   del               (delete character)", "   ctrl-backspace    (another way of typing delete character)", "   ctrl-w            (delete word left)", "   ctrl-u            (delete entire line)", "   ctrl-r            (redraw line)" ]
#60 Help Database.@version r = MOOList [ "Syntax:  @version", "", "Prints out the version number for the currently-executing MOO server." ]
#60 Help Database.alias rc = MOOList [ "*forward*", " name" ]
#60 Help Database.editors rc = MOOList [ "One can always enter an editor by teleporting to it, or you can use one of the commands provided", "", "    @edit     <object>:<verb>    invokes the Verb Editor (edits verb code)", "    @notedit  <note_object>      invokes the Note Editor (edits note text)", "    @notedit  <object>.<prop>    invokes the Note Editor (edits text property)", "    @send     <list of recipients>        invokes the Mailer (edits a mail msg)", "    @answer   [<msg_number>] [<flags>...] invokes the Mailer (edits a reply)", "", "This will transport you to one of several special rooms that have editing commands available.  These editors are admittedly not as good as EMACS, but for those with no other editing capability on their host systems, they are better than nothing.", "", "There is a generic editor that provides basic editing commands that are applicable to all editors.  Documentation for these commands can be obtained by typing `help <topic>' within the editor:", "", "    abort              emote/:            pause              send      (M) ", "    also-to (M)        fill               prev               showlists (M) ", "    compile (V)        insert             print     (M)      subject   (M) ", "    copy               join               quit               subst         ", "    delete             list               ranges             to    (M)     ", "    done               move               save      (N)      what          ", "    edit    (V,N)      next               say/"              who   (M)     ", "", "In addition, individual editors provide their own additional commands for loading text from places, saving text to places, and various other specialized functions which are denoted in the above list with (M),(N),(V) according as they apply to the mail editor, the note editor, or the verb editor, respectively.", "", "Note that a given editor only allows you one session at a time (ie. one verb, one note, or one mail message).  If you leave an editor without either aborting or compiling/saving/sending the item you're working on, that editor remembers what you are doing next time you enter it, whether you enter it by teleporting or by using the appropriate command.  Note that editors are periodically flushed so anything left there for sufficiently long will eventually go away.", "", "A player may have his own .edit_options property which is a list containing one or more (string) flags from the following list", "", "  quiet_insert", "      suppresses those annoying "Line n added." or "Appended..." messages", "      that one gets in response to 'say' or 'emote'.  This is useful if you're", "      entering a long list of lines, perhaps via some macro on your client,", "      and you don't want to see an equally long list of "Line n added..."", "      messages.  What you do want, however is some indication that this all", "      got through, which is why the "." command is an abbreviation for insert.", "", "  eval_subs", "      Enables the verb editor to process your eval_subs property when", "      compiling your verb.  See `help eval' for more information about", "      the eval_subs property.", "", "There will be more options, some day." ]
#60 Help Database.introduction r = MOOList [ "LambdaMOO is a kind of virtual reality, in which players move about from place to place manipulating their environment in what we hope are amusing, entertaining, or enlightening ways.", "", "LambdaMOO is more of a pastime than a game in the usual sense; there is no `score' kept, there are no specific goals to attain in general, and there's no competition involved.  LambdaMOO participants explore the virtual world, talk to the other participants, try out the weird gadgets that others have built, and create new places and things for others to encounter and enjoy.", "", "Most commands have the form of simple English sentences:", "    <verb>", "    <verb>  <direct object>", "    <verb>  <direct object>  <preposition>  <indirect object>", "Don't use English articles (e.g. 'a', 'an', or 'the') in your commands; the MOO won't understand them.  You can refer to yourself as 'me' and the room you're in as 'here'.", "", "The first five kinds of commands you'll want to know are listed below.  Type 'help <topic-name>' for details on any of them:", "", "look -- getting a description of the current room or any other object", "say -- speaking to the other players in the same room as you", "@who -- showing which players are currently connected to the MOO", "movement -- how to move around in the MOO, from room to room", "@quit -- disconnecting from the MOO" ]
#60 Help Database.news rc = MOOList [ "*subst*", "Syntax: news", "        news all", "        news new", "        news contents", "        news archive", "", "Read the latest edition of the %[$network.MOO_name] Newspaper, which carries articles concerning recent changes to the MOO server or to the main public classes, or other articles of interest to the MOO at large.", "", "The default behavior for the `news' command is to act like `news new' but this may be changed by setting the @mail-option news to one of `all' or `new' or `contents'.  `news all' displays all current news articles.  `news new' only displays articles you have not yet read.  `news contents' displays the authors and subjects of all current news.  `news archive' displays back issues of the newspaper which are deemed worth reading by every citizen at any time." ]
#60 Help Database.summary rc = MOOList [ "Help is available on the following general topics:", "", "introduction -- what's going on here and some basic commands", "index -- index into the help system", "", "players -- setting characteristics of yourself", "movement -- moving yourself between rooms", "communication -- communicating with other players", "manipulation -- moving or using other objects", "miscellaneous -- commands that don't fit anywhere else", "", "building -- extending the MOO", "programming -- writing code in the MOO programming language", "editors -- editing text and code in the MOO", "", "@pagelength -- what to do if lines scroll off your screen too fast", "@linelength -- what to do if lines are truncated", "tinymud -- a list of equivalences between MOO and TinyMUD concepts/commands" ]
#60 Help Database.@editoptions rc = MOOList [ "*forward*", "@edit-options" ]
#60 Help Database.burn r = MOOList [ "Syntax:  burn <letter>", "", "Destroy the named letter irretrievably.  Only players who can read the letter can do this." ]
#60 Help Database.go r = MOOList [ "Syntax: go <direction> ...", "", "Invokes the named exits in the named order, moving through many rooms in a single command.", "", "Example:", "Munchkin types:", "  go n e e u e e s e", "and moves quite rapidly from the Living Room all the way to the Bovine Illuminati Atrium, all in one command." ]
#60 Help Database.say r = MOOList [ "Syntax:  say <anything> ...", "         "<anything> ...", "", "Says <anything> out loud, so that everyone in the same room hears it.  This is so commonly used that there's a special abbreviation for it: any command-line beginning with a double-quote ('"') is treated as a 'say' command.", "", "Example:", "Munchkin types this:", "  "This is a great MOO!", "Munchkin sees this:", "  You say, "This is a great MOO!"", "Others in the same room see this:", "  Munchkin says, "This is a great MOO!"" ]
#60 Help Database.wizard-names rc = MOOList [ "*forward*", "wizard-list" ]
#60 Help Database.@comment rc = MOOList [ "*forward*", "@typo" ]
#60 Help Database.@rmalias rc = MOOList [ "Syntax: @rmalias <alias>[,...,<alias>] from <object>", "        @rmalias <alias>[,...,<alias>] from <object>:<verb-name>", "        @rmalias# <alias>[,...,<alias>] from <object>:<verb-number>", "", "The first form is used to remove aliases from an object.  If the object is a valid player, space and commas will be assumed to be separations between unwanted aliases.  Otherwise, only commas will be assumed to be separations.", "Note that @rmalias will not affect the object's name, only its aliases.", "", "The second form is for use by programmers, to remove aliases from a verb they own.  All spaces and commas are assumed to be separations between unwanted aliases.", "", "The third form, @rmalias#, is for unambiguously referring to a verb on an object that might have more than one verb with the same name. The verb-number is the 1-based index of the verb as it appears in the verb() (or @verbs) output list." ]
#60 Help Database.home r = MOOList [ "*subst*", "Syntax: home", "", "Instantly teleports you to your designated home room.", "Initially, this room is %[tostr($player_start.name," (",$player_start,")")].", "You can change your designated home; see 'help @sethome' for details." ]
#60 Help Database.@check-full rc = MOOList [ "*forward*", "@check" ]
#60 Help Database.wizard-list rc = MOOList [ "*subst*", "", "%;this:wizard_list()", "" ]
#60 Help Database.whisper r = MOOList [ "whisper "<text>" to <player>", "sends the message "<yourname> whispers, "<text>" to you " to <player>, if they are in the room." ]
#60 Help Database.@owner r = MOOList [ "Usage: @owner object", "", "Displays the specified object, its object number, and its owner (and its owner's object number)." ]
#60 Help Database.@gaglist rc = MOOList [ "*forward*", "@listgag" ]
#60 Help Database.@edit rc = MOOList [ "Syntax:  @edit <object>.<property>", "         @edit <object>:<verb-name> [<dobj> [<prep> [<iobj>]]]", "         @edit <object>", "", "Enters a MOO editor, as appropriate.", "", "Chooses the MOO Note editor for the named property, or the MOO verb editor for the named verb.  If no property or verb name is given, assumes property .text for a note object, or .description for any other object.", "", "See 'help editors' for more detail." ]
#60 Help Database:player_quota this n/a this
return $player.ownership_quota;
-------------------------------------------------------------------------------
#60 Help Database:prog_quota this n/a this
return $prog.ownership_quota;
-------------------------------------------------------------------------------
#60 Help Database:get_topic this n/a this
text = pass(@args);
object = $string_utils:match_object(what = args[1], player.location);
if ((text != E_PROPNF) || (!valid(object)))
return text;
elseif (ohelp = `object:help_msg() ! ANY' || `object.help_msg ! ANY')
return {tostr(object.name, " (", object, "):"), "----", @(typeof(ohelp) == LIST) ? ohelp | {ohelp}};
else
about = $object_utils:has_verb(object, "about");
return {tostr("Sorry, but no help is available on ", object.name, " (", object, ")."), tostr("Try `examine ", what, "'", @about ? {" or `about ", what, "'"} | {}, ".")};
endif
-------------------------------------------------------------------------------
#60 Help Database:find_topics this n/a this
topiclist = pass(@args);
if (topiclist || (!args))
return topiclist;
elseif (valid(o = $string_utils:match_object(what = args[1], player.location)))
return {what};
else
return {};
endif
-------------------------------------------------------------------------------
#60 Help Database:full_index this n/a this
text = {};
for db in ($code_utils:help_db_list())
if ($object_utils:has_callable_verb(db, "index"))
text = {@text, @db:index({tostr(db.name, " (", db, ")")})};
endif
endfor
return text;
-------------------------------------------------------------------------------
#60 Help Database:index_list this n/a this
hdr = "Available Help Indices";
text = {"", hdr, $string_utils:space(hdr, "-")};
for db in ($code_utils:help_db_list())
try
for p in (db:find_index_topics())
text = {@text, tostr($string_utils:left(p, 14), " -- ", `db.(p)[2] ! ANY' || db.name, " (", db, ")")};
endfor
except (ANY)
"generally it will be E_TYPE when :find_index_topics returns an ERR. Just skip";
continue db;
endtry
endfor
if (full = this:find_full_index_topic())
text = {@text, "", tostr($string_utils:left(full, 14), " -- ", "EVERYTHING")};
endif
return text;
-------------------------------------------------------------------------------
#60 Help Database:wizard_list this n/a this
wizzes = {};
for w in ($object_utils:leaves($wiz))
if (w.wizard && (w.advertised && is_player(w)))
wizzes = {@wizzes, w};
endif
endfor
wizzes = {#2, @$list_utils:randomly_permute(setremove(wizzes, #2))};
numwiz = length(wizzes);
hlist = {"ArchWizard:", "Wizard" + ((numwiz == 2) ? ":" | "s:"), @$list_utils:make(max(0, numwiz - 2), "")};
slist = {};
su = $string_utils;
for i in [1..numwiz]
wiz = wizzes[i];
slist = {@slist, tostr(su:left(hlist[i], 13), su:left(wiz.name, 16), (wpi = `wiz.public_identity.name ! ANY') ? (" (a.k.a. " + wpi) + ")" | "")};
endfor
return slist;
-------------------------------------------------------------------------------
#60 Help Database:dump_topic this n/a this
if (((text = pass(@args)) != E_PROPNF) || ((!valid(object = $string_utils:match_object(what = args[1], player.location))) || (!$object_utils:has_property(object, "help_msg"))))
return text;
else
return {tostr(";;", $code_utils:corify_object(object), ".help_msg = $command_utils:read_lines()"), @$command_utils:dump_lines((typeof(text = object.help_msg) == LIST) ? text | {text})};
endif
-------------------------------------------------------------------------------
#60 Help Database:find_full_index_topic this n/a this
":find_full_index_topic([search])";
"Return the *full_index* topic or 0";
"If search argument is given and true, we don't depend on cached info.";
{?search = 0} = args;
"... N.B.  There is no cached info; it turns out that";
"... full-index is near enough to the beginning of $help's property list";
"... that there's no point to doing this.  --Rog";
for p in (`properties(this) ! E_PERM => {}')
if (`this.(p)[1] ! ANY' == "*full_index*")
return p;
endif
endfor
return 0;
-------------------------------------------------------------------------------
================================#61 News===============================================
#61 News.last_news_time rc = MOONumber 1084848652
#61 News.current_news_going rc = MOOList [ ]
#61 News.current_news rc = MOOList [ 1, 2 ]
#61 News.archive_news rc = MOOList [ ]
#61 News:description this n/a this
raw = ctime(this.last_news_time);
"         111111111122222";
"123456789012345678901234";
"Fri Nov 30 14:31:21 1990";
date = (raw[1..10] + ",") + raw[20..24];
return strsub(this.description, "%d", date);
-------------------------------------------------------------------------------
#61 News:is_writable_by this n/a this
return pass(@args) || (args[1] in $list_utils:map_prop($object_utils:descendants($wiz), "mail_identity"));
-------------------------------------------------------------------------------
#61 News:rm_message_seq this n/a this
if (this:ok_write(caller, caller_perms()))
seq = args[1];
this.current_news_going = $seq_utils:intersection(this.current_news, seq);
this.current_news = $seq_utils:contract(this.current_news, seq);
return $mail_agent:(verb)(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#61 News:undo_rmm this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
seq = $mail_agent:(verb)(@args);
this.current_news = $seq_utils:union(this.current_news_going, $seq_utils:expand(this.current_news, seq));
this.current_news_going = {};
return seq;
-------------------------------------------------------------------------------
#61 News:expunge_rmm this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
endif
this.current_news_going = {};
return $mail_agent:(verb)(@args);
-------------------------------------------------------------------------------
#61 News:set_current_news this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
this.current_news = new = args[1];
if (new)
newlast = $seq_utils:last(new);
newlasttime = this:messages_in_seq(newlast)[2][1];
if (newlasttime > this.last_news_time)
"... only notify people if there exists a genuinely new item...";
this.last_news_time = newlasttime;
this:touch();
endif
else
"...flush everything...";
this.last_news_time = 0;
endif
endif
-------------------------------------------------------------------------------
#61 News:add_current_news this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
return this:set_current_news($seq_utils:union(this.current_news, args[1]));
endif
-------------------------------------------------------------------------------
#61 News:rm_current_news this n/a this
if (!this:ok_write(caller, caller_perms()))
return E_PERM;
else
return this:set_current_news($seq_utils:intersection(this.current_news, $seq_utils:complement(args[1])));
endif
-------------------------------------------------------------------------------
#61 News:news_display_seq_full this n/a this
":news_display_seq_full(msg_seq) => {cur, last-read-date}";
"Display the given msg_seq as a collection of news items";
set_task_perms(caller_perms());
desc = this:description();
player:notify((typeof(desc) == LIST) ? desc[1] | desc);
player:notify("");
msgs = this:messages_in_seq(args[1]);
for i in [-(n = length(msgs))..-1]
x = msgs[-i];
player:notify_lines(this:to_text(@x[2]));
player:notify("");
$command_utils:suspend_if_needed(0);
endfor
player:notify("(end)");
return {msgs[n][1], msgs[n][2][1]};
-------------------------------------------------------------------------------
#61 News:to_text this n/a this
":to_text(@msg) => message in text form -- formatted like a $news entry circa October, 1993";
date = args[1];
by = args[2];
"by = by[1..index(by, \"(\") - 2]";
subject = (args[4] == " ") ? "-*-NEWS FLASH-*-" | $string_utils:uppercase(args[4]);
text = args[("" in {@args, ""}) + 1..$];
ctime = $time_utils:time_sub("$D, $N $3, $Y", date);
return {ctime, subject, @text};
return {subject, tostr("  by ", by, " on ", ctime), "", @text};
-------------------------------------------------------------------------------
#61 News:check this n/a this
set_task_perms(caller_perms());
if ((player:get_current_message(this) || {0, 0})[2] < this.last_news_time)
if ((n = player:mail_option("news")) in {0, "all"})
player:tell("There is new news.  Type `news' to read all news or `news new' to read just new news.");
elseif (n == "contents")
player:tell("There is new news.  Type `news all' to read all news or `news new' to read just new news.");
elseif (n == "new")
player:tell("There is new news.  Type `news' to read new news, or `news all' to read all news.");
endif
endif
-------------------------------------------------------------------------------
#61 News:touch this n/a none
if (!this:ok_write(caller, valid(who = caller_perms()) ? who | player))
player:notify("Permission denied.");
return;
endif
fork (0)
for p in (connected_players())
$command_utils:suspend_if_needed(0);
if ((p:get_current_message(this) || {0, 0})[2] < this.last_news_time)
p:notify("There's a new edition of the newspaper.  Type 'news new' to see the new article(s).");
endif
endfor
endfork
-------------------------------------------------------------------------------
#61 News:@addnews any any this
if ((caller_perms() != #-1) && (caller_perms() != player))
raise(E_PERM);
endif
set_task_perms(player);
if (!this:is_writable_by(player))
player:notify("You can't write the news.");
elseif (typeof(result = this:add_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)
player:notify(result);
else
new = this.current_news;
if (new)
player:notify("Current newspaper set.");
this:display_seq_headers(new);
else
player:notify("Current newspaper is now empty.");
endif
endif
-------------------------------------------------------------------------------
#61 News:@rmnews any in/inside/into this
if ((caller_perms() != #-1) && (caller_perms() != player))
raise(E_PERM);
endif
set_task_perms(player);
if (!this:is_writable_by(player))
player:notify("You can't write the news.");
elseif (typeof(result = this:rm_news(args[1..(prepstr in args) - 1], player:get_current_message(this) || {0, 0})) == STR)
player:notify(result);
else
new = this.current_news;
if (new)
player:notify("Current newspaper set.");
this:display_seq_headers(new);
else
player:notify("Current newspaper is now empty.");
endif
endif
-------------------------------------------------------------------------------
#61 News:@setnews this any any
set_task_perms(player);
if (!this:is_writable_by(player))
player:notify("You can't write the news.");
elseif (typeof(seq = this:_parse(strings = args[(prepstr in args) + 1..$], @player:get_current_message(this) || {0, 0})) == STR)
player:notify(seq);
else
old = this.current_news;
if (old == seq)
player:notify("No change.");
else
this:set_current_news(seq);
if (seq)
player:notify("Current newspaper set.");
this:display_seq_headers(seq);
else
player:notify("Current newspaper is now empty.");
endif
endif
endif
-------------------------------------------------------------------------------
#61 News:_parse this n/a this
if (!(strings = args[1]))
return "You need to specify a message sequence";
elseif (typeof(pms = this:parse_message_seq(@args)) == STR)
return $string_utils:substitute(pms, {{"%f", "The news"}, {"%<has>", "has"}, {"%%", "%"}});
elseif (typeof(pms) != LIST)
return tostr(pms);
elseif (length(pms) > 1)
return tostr("I don't understand `", pms[2], "'.");
elseif (!(seq = pms[1]))
return tostr("The News (", this, ") has no `", $string_utils:from_list(strings, " "), "' messages.");
else
return seq;
endif
-------------------------------------------------------------------------------
#61 News:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.description = "It's the current issue of the News, dated %d.";
this.moderated = 1;
this.last_news_time = 0;
this.readers = 1;
this.expire_period = 0;
this.archive_news = {};
$mail_agent:send_message(#2, this, "Welcome to LambdaCore", $wiz_utils.new_core_message);
this:add_news("$");
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#61 News:add_news this n/a this
if (!this:ok_write(caller, caller_perms()))
$error:raise(E_PERM);
endif
{specs, ?cur = {0, 0}} = args;
seq = this:_parse(specs, @cur);
if (typeof(seq) == STR)
return seq;
endif
old = this.current_news;
new = $seq_utils:union(old, seq);
if (old == new)
return "Those messages are already in the news.";
endif
this:set_current_news(new);
return 1;
-------------------------------------------------------------------------------
#61 News:rm_news this n/a this
if (!this:ok_write(caller, caller_perms()))
raise(E_PERM);
endif
{specs, ?cur = {0, 0}} = args;
seq = this:_parse(specs, @cur);
if (typeof(seq) == STR)
return seq;
endif
old = this.current_news;
new = $seq_utils:intersection(old, $seq_utils:complement(seq));
if (old == new)
return "Those messages were not in the news.";
endif
this:set_current_news(new);
return 1;
-------------------------------------------------------------------------------
#61 News:@listnews none in front of this
player:notify("The following articles are currently in the newspaper:");
this:display_seq_headers(this.current_news);
-------------------------------------------------------------------------------
#61 News:@clearnews this n/a none
set_task_perms(player);
if (this:is_writable_by(player))
this:set_current_news({});
player:notify("Current newspaper is now empty.");
else
player:notify("You can't write the news.");
endif
-------------------------------------------------------------------------------
================================#62 The First Room===============================================
#62 The First Room:disfunc this n/a this
"Copied from The Coat Closet (#11):disfunc by Haakon (#2) Mon May  8 10:41:04 1995 PDT";
if ((((cp = caller_perms()) == (who = args[1])) || $perm_utils:controls(cp, who)) || (caller == this))
"need the first check since guests don't control themselves";
if (who.home == this)
move(who, $limbo);
this:announce("You hear a quiet popping sound; ", who.name, " has disconnected.");
else
pass(who);
endif
endif
-------------------------------------------------------------------------------
#62 The First Room:enterfunc this n/a this
"Copied from The Coat Closet (#11):enterfunc by Haakon (#2) Mon May  8 10:41:38 1995 PDT";
who = args[1];
if ($limbo:acceptable(who))
move(who, $limbo);
else
pass(who);
endif
-------------------------------------------------------------------------------
#62 The First Room:match this n/a this
"Copied from The Coat Closet (#11):match by Lambda (#50) Mon May  8 10:42:01 1995 PDT";
m = pass(@args);
if (m == $failed_match)
"... it might be a player off in the body bag...";
m = $string_utils:match_player(args[1]);
if (valid(m) && (!(m.location in {this, $limbo})))
return $failed_match;
endif
endif
return m;
-------------------------------------------------------------------------------
#62 The First Room:init_for_core this n/a this
"Copied from The Coat Closet (#11):init_for_core by Nosredna (#2487) Mon May  8 10:42:52 1995 PDT";
if (!caller_perms().wizard)
return E_PERM;
endif
for v in ({"announce*", "emote", "button", "knob"})
if (`verb_info($player_start, v) ! E_VERBNF => 0')
delete_verb($player_start, v);
endif
endfor
for p in ({"out", "quiet", "button"})
if (p in properties($player_start))
delete_property($player_start, p);
endif
endfor
for p in ($object_utils:all_properties($room))
clear_property($player_start, p);
endfor
$player_start.name = "The First Room";
$player_start.aliases = {};
$player_start.description = "This is all there is right now.";
$player_start.exits = $player_start.entrances = {};
"... at the end since $room:init_for_core moves stuff in";
pass(@args);
-------------------------------------------------------------------------------
#62 The First Room:keep_clean this n/a this
"Copied from The Coat Closet (#11):keep_clean by Haakon (#2) Mon May  8 10:47:08 1995 PDT";
if ($perm_utils:controls(caller_perms(), this))
junk = {};
while (1)
for x in (junk)
$command_utils:suspend_if_needed(0);
if (x in this.contents)
"This is old junk that's still around five minutes later.  Clean it up.";
if (!valid(x.owner))
move(x, $nothing);
#2:tell(">**> Cleaned up orphan object `", x.name, "' (", x, "), owned by ", x.owner, ", to #-1.");
elseif (!$object_utils:contains(x, x.owner))
move(x, x.owner);
x.owner:tell("You shouldn't leave junk in ", this.name, "; ", x.name, " (", x, ") has been moved to your inventory.");
#2:tell(">**> Cleaned up `", x.name, "' (", x, "), owned by `", x.owner.name, "' (", x.owner, "), to ", x.owner, ".");
endif
endif
endfor
junk = {};
for x in (this.contents)
if ((seconds_left() < 2) || (ticks_left() < 1000))
suspend(0);
endif
if (!is_player(x))
junk = {@junk, x};
endif
endfor
suspend(5 * 60);
endwhile
endif
-------------------------------------------------------------------------------
================================#63 Recycling Center===============================================
#63 Recycling Center.lost_souls rc = MOOList [ ]
#63 Recycling Center.announce_removal_msg rc = MOOString ""
#63 Recycling Center.orphans r = MOOList [ ]
#63 Recycling Center.history  = MOOList [ ]
#63 Recycling Center.nhist  = MOONumber 50
#63 Recycling Center:_recreate this n/a this
"Return a toad (child of #1, owned by $hacker) from this.contents.  Move it to #-1.  Recreate as a child of args[1], or of #1 if no args are given.  Chown to caller_perms() or args[2] if present.";
{?what = #1, ?who = caller_perms()} = args;
if (!(caller_perms().wizard || (who == caller_perms())))
return E_PERM;
elseif (!(valid(what) && is_player(who)))
return E_INVARG;
elseif ((((who != what.owner) && (!what.f)) && (!who.wizard)) && (!caller_perms().wizard))
return E_PERM;
endif
for potential in (this.contents)
if (((potential.owner == $hacker) && (parent(potential) == $garbage)) && (!children(potential)))
return this:setup_toad(potential, who, what);
endif
endfor
return E_NONE;
-------------------------------------------------------------------------------
#63 Recycling Center:_recycle this n/a this
"Take the object in args[1], and turn it into a child of #1 owned by $hacker.";
"If the object is a player, decline.";
item = args[1];
if (!$perm_utils:controls(caller_perms(), item))
raise(E_PERM);
elseif (is_player(item))
raise(E_INVARG);
endif
this:addhist(caller_perms(), item);
"...recreate can fail (:recycle can crash)...";
this:add_orphan(item);
this:kill_all_tasks(item);
$quota_utils:preliminary_reimburse_quota(item.owner, item);
$building_utils:recreate(item, $garbage);
this:remove_orphan(item);
"...";
$wiz_utils:set_owner(item, $hacker);
item.name = tostr("Recyclable ", item);
`move(item, this) ! ANY => 0';
-------------------------------------------------------------------------------
#63 Recycling Center:_create this n/a this
e = `set_task_perms(caller_perms()) ! ANY';
if (typeof(e) == ERR)
return e;
else
val = this:_recreate(@args);
return (val == E_NONE) ? $quota_utils:bi_create(@args) | val;
endif
-------------------------------------------------------------------------------
#63 Recycling Center:addhist this n/a this
if (caller == this)
h = this.history;
if ((len = length(h)) > this.nhist)
h = h[len - this.nhist..len];
endif
this.history = {@h, args};
endif
-------------------------------------------------------------------------------
#63 Recycling Center:show*-history this n/a none
if ($perm_utils:controls(valid(caller_perms()) ? caller_perms() | player, this))
for x in (this.history)
pname = valid(x[1]) ? x[1].name | "A recycled player";
oname = valid(x[2]) ? x[2].name | "recycled";
player:notify(tostr(pname, " (", x[1], ") recycled ", x[2], " (now ", oname, ")"));
endfor
else
player:tell("Sorry.");
endif
-------------------------------------------------------------------------------
#63 Recycling Center:request any in/inside/into this
"added check that obj is already $garbage - Bits 12/16/5";
if (!(caller_perms() in {player, #-1}))
raise(E_PERM);
endif
dobj = valid(dobj) ? dobj | $string_utils:match_object(dobjstr, player.location);
if (!valid(dobj))
dobj = (n = toint(dobjstr)) ? toobj(n) | #-1;
endif
if (!valid(dobj))
player:tell("Couldn't parse ", dobjstr, " as a valid object number.");
elseif (!(dobj in this.contents))
player:tell("Couldn't find ", dobj, " in ", this.name, ".");
elseif (!$object_utils:isa(dobj, $garbage))
player:tell("Sorry, that isn't recyclable.");
elseif ($object_utils:has_callable_verb(this, "request_refused") && (msg = this:request_refused(player, dobj)))
player:tell("Sorry, can't do that:  ", msg);
else
if (typeof(emsg = this:setup_toad(dobj, player, $root_class)) != ERR)
dobj:moveto(player);
dobj.aliases = {dobj.name = "Object " + tostr(dobj)};
player:tell("You now have ", dobj, " ready for @recreation.");
if (this.announce_removal_msg)
player.location:announce($string_utils:pronoun_sub(this.announce_removal_msg));
endif
else
player:tell(emsg);
endif
endif
-------------------------------------------------------------------------------
#63 Recycling Center:setup_toad this n/a this
"this:setup_toad(objnum,new_owner,parent)";
"Called by :_create and :request.";
if (caller != this)
return E_PERM;
endif
{potential, who, what} = args;
if (!$quota_utils:creation_permitted(who))
return E_QUOTA;
else
$wiz_utils:set_owner(potential, who);
move(potential, #-1);
set_task_perms({@callers(), {#-1, "", player}}[2][3]);
"... if :initialize crashes...";
this:add_orphan(potential);
$building_utils:recreate(potential, what);
this:remove_orphan(potential);
"... if we don't get this far, the object stays on the orphan list...";
"... orphan list should be checked periodically...";
return potential;
endif
-------------------------------------------------------------------------------
#63 Recycling Center:add_orphan this n/a this
if (caller == this)
this.orphans = setadd(this.orphans, args[1]);
endif
-------------------------------------------------------------------------------
#63 Recycling Center:remove_orphan this n/a this
if (caller == this)
this.orphans = setremove(this.orphans, args[1]);
endif
-------------------------------------------------------------------------------
#63 Recycling Center:valid this n/a this
"Usage:  valid(object)";
"True if object is valid and not $garbage.";
return valid(args[1]) && (parent(args[1]) != $garbage);
-------------------------------------------------------------------------------
#63 Recycling Center:init_for_core this n/a this
if (caller_perms().wizard)
this.orphans = {};
this.history = {};
this.lost_souls = {};
pass(@args);
endif
-------------------------------------------------------------------------------
#63 Recycling Center:resurrect this n/a this
who = caller_perms();
if (!valid(parent = {@args, $garbage}[1]))
return E_INVARG;
elseif (!who.wizard)
return E_PERM;
elseif (typeof(o = renumber($quota_utils:bi_create(parent, $hacker))) == ERR)
"..death...";
elseif (parent == $garbage)
$recycler:_recycle(o);
else
o.aliases = {o.name = tostr("Resurrectee ", o)};
$wiz_utils:set_owner(o, who);
move(o, who);
endif
reset_max_object();
return o;
-------------------------------------------------------------------------------
#63 Recycling Center:reclaim_lost_souls this n/a this
if (!caller_perms().wizard)
raise(E_PERM);
endif
fork (1800)
this:(verb)();
endfork
for x in (this.lost_souls)
this.lost_souls = setremove(this.lost_souls, x);
if ((valid(x) && (typeof(x.owner.owned_objects) == LIST)) && (!(x in x.owner.owned_objects)))
x.owner.owned_objects = setadd(x.owner.owned_objects, x);
$quota_utils:summarize_one_user(x.owner);
endif
$command_utils:suspend_if_needed(0);
endfor
-------------------------------------------------------------------------------
#63 Recycling Center:look_self this n/a this
if (prepstr in {"in", "inside", "into"})
recycler = this;
linelen = ((linelen = abs(player.linelen)) < 20) ? 78 | linelen;
intercolumn_gap = 2;
c_width = length(tostr(max_object())) + intercolumn_gap;
n_columns = (linelen + (c_width - 1)) / c_width;
things = $list_utils:sort_suspended(0, this.contents);
header = tostr(this.name, " (", this, ") contains:");
player:tell_lines({header, @$string_utils:columnize_suspended(0, things, n_columns)});
else
return pass(@args);
endif
"This code contributed by Mickey.";
-------------------------------------------------------------------------------
#63 Recycling Center:check_quota_scam this n/a this
who = args[1];
if ($quota_utils.byte_based && (is_clear_property(who, "size_quota") || is_clear_property(who, "owned_objects")))
raise(E_QUOTA);
endif
cheater = 0;
other_cheaters = {};
for x in (this.lost_souls)
if (((valid(x) && ((owner = x.owner) != $hacker)) && (typeof(owner.owned_objects) == LIST)) && (!(x in owner.owned_objects)))
if (owner == who)
who.owned_objects = setadd(who.owned_objects, x);
cheater = 1;
else
"it's someone else's quota scam we're detecting...";
other_cheaters = setadd(other_cheaters, owner);
owner.owned_objects = setadd(owner.owned_objects, x);
this.lost_souls = setremove(this.lost_souls, x);
endif
endif
this.lost_souls = setremove(this.lost_souls, x);
endfor
if ($quota_utils.byte_based)
if (cheater)
$quota_utils:summarize_one_user(who);
endif
if (other_cheaters)
fork (0)
for x in (other_cheaters)
$quota_utils:summarize_one_user(x);
endfor
endfork
endif
endif
-------------------------------------------------------------------------------
#63 Recycling Center:gc this n/a this
for x in (this.orphans)
if ((!valid(x)) || ((x.owner != $hacker) && (x in x.owner.owned_objects)))
this.orphans = setremove(this.orphans, x);
endif
endfor
-------------------------------------------------------------------------------
#63 Recycling Center:moveto this n/a this
pass(#-1);
-------------------------------------------------------------------------------
#63 Recycling Center:kill_all_tasks this n/a this
"kill_all_tasks ( object being recycled )";
" -- kill all tasks involving this now-recycled object";
((caller == this) || (caller == #0)) || raise(E_PERM);
{object} = args;
(typeof(object) == OBJ) || raise(E_INVARG);
if ((!valid(object)) || (parent(object) != $garbage))
fork (0)
for t in (queued_tasks())
for c in (`task_stack(t[1]) ! E_INVARG => {}')
if (object in c)
kill_task(t[1]);
continue t;
endif
endfor
endfor
endfork
endif
-------------------------------------------------------------------------------
================================#64 Generic Garbage Object===============================================
#64 Generic Garbage Object.aliases r = MOOList [ "garbage" ]
#64 Generic Garbage Object:description this n/a this
return ("Garbage object " + tostr(this)) + ".";
-------------------------------------------------------------------------------
#64 Generic Garbage Object:look_self this n/a this
player:tell(this:description());
-------------------------------------------------------------------------------
#64 Generic Garbage Object:title titlec this n/a this
return tostr("Recyclable ", this);
-------------------------------------------------------------------------------
#64 Generic Garbage Object:tell this n/a this
return;
-------------------------------------------------------------------------------
#64 Generic Garbage Object:do_examine none n/a none
args[1]:notify(tostr(this, " is a garbage object, ready for reuse."));
-------------------------------------------------------------------------------
================================#65 Mail Options===============================================
#65 Mail Options.show_no_dupcc r = MOOList [ "i want to read mail to me also sent to lists i read", "don't send me personal copies of mail also sent to lists i read" ]
#65 Mail Options.show_enter rc = MOOList [ "Mail editor will not start with an implicit `enter' command.", "Mail editor will start with an implicit `enter' command." ]
#65 Mail Options.show_no_unsend r = MOOList [ "People may @unsend unread messages they send to me", "No one may @unsend messages they sent to me" ]
#65 Mail Options.show_all rc = MOOList [ "Replies will go to original sender only.", "Replies will go to original sender and all previous recipients." ]
#65 Mail Options.show_include rc = MOOList [ "Original message will not be included in replies", "Original message will be included in replies" ]
#65 Mail Options.show_resend_forw rc = MOOList [ "@resend puts player in Resent-By: header", "@resend puts player in From: header (like @forward)" ]
#65 Mail Options.choices_rn_order rc = MOOList [ [ "read", [ ".current_message folders are sorted by last read date." ] ], [ "send", [ ".current_message folders are sorted by last send date." ] ], [ "fixed", [ ".current_message folders are not sorted." ] ] ]
#65 Mail Options.type_@unsend r = MOOList [ 2, [ 2 ] ]
#65 Mail Options.show_no_auto_forward rc = MOOList [ "@netforward when expiring messages", "do not @netforward messages when expiring mail" ]
#65 Mail Options.type_replyto rc = MOOList [ 1, [ 1 ] ]
#65 Mail Options.type_manymsgs rc = MOOList [ 0 ]
#65 Mail Options.show_expert_netfwd rc = MOOList [ "@netforward confirms before emailing messages", "@netforward doesn't confirm before emailing messages" ]
#65 Mail Options.show_nosubject rc = MOOList [ "Mail editor will initially require a subject line.", "Mail editor will not initially require a subject line." ]
#65 Mail Options.show_expert rc = MOOList [ "Novice mail user...", "Expert mail user..." ]
#65 Mail Options.type_expire rc = MOOList [ 0 ]
#65 Mail Options.show_followup rc = MOOList [ "No special reply action for messages with non-player recipients.", "Replies go only to first non-player recipient if any." ]
#65 Mail Options.unsend_sequences r = MOOList [ "before", "after", "since", "until", "subject", "body", "last" ]
#65 Mail Options.type_@mail rc = MOOList [ 2, [ 2 ] ]
#65 Mail Options:actual this n/a this
if (i = args[1] in {"noinclude", "sender"})
return {{{"include", "all"}[i], !args[2]}};
else
return {args};
endif
-------------------------------------------------------------------------------
#65 Mail Options:parse_@mail this n/a this
"... we'll take anything...";
raw = args[2];
if (raw == 1)
"...+@mail => @mailo=new";
return {args[1], "new"};
else
return args[1..2];
endif
-------------------------------------------------------------------------------
#65 Mail Options:parse_sticky parse_manymsgs this n/a this
{oname, raw, data} = args;
if (typeof(raw) == LIST)
if (length(raw) > 1)
return "Too many arguments.";
endif
raw = raw[1];
elseif (typeof(raw) == INT)
return {oname, raw && ((oname == "manymsgs") ? 20 | 1)};
endif
if ((value = $code_utils:toint(raw)) == E_TYPE)
return tostr("`", raw, "'?  Number expected.");
endif
return {oname, value};
-------------------------------------------------------------------------------
#65 Mail Options:parse_replyto this n/a this
{oname, raw, data} = args;
if (typeof(raw) == STR)
raw = $string_utils:explode(raw, ",");
elseif (typeof(raw) == INT)
return raw ? "You need to give one or more recipients." | {oname, 0};
endif
value = $mail_editor:parse_recipients({}, raw);
if (value)
return {oname, value};
else
return "No valid recipients in list.";
endif
-------------------------------------------------------------------------------
#65 Mail Options:show_manymsgs this n/a this
value = this:get(@args);
if (value)
return {tostr(value), {tostr("Query when asking for ", value, " or more messages.")}};
else
return {0, {"Willing to be spammed with arbitrarily many messages/headers"}};
endif
-------------------------------------------------------------------------------
#65 Mail Options:show_sticky this n/a this
value = this:get(@args);
if (value)
return {value, {"Sticky folders:  mail commands default to whatever", "mail collection the previous successful command looked at."}};
else
return {0, {"Teflon folders:  mail commands always default to `on me'."}};
endif
-------------------------------------------------------------------------------
#65 Mail Options:show_@mail this n/a this
if (value = this:get(@args))
return {"", {tostr("Default message sequence for @mail:  ", (typeof(value) == STR) ? value | $string_utils:from_list(value, " "))}};
else
default = $mail_agent.("player_default_@mail");
return {0, {tostr("Default message sequence for @mail:  ", (typeof(default) == STR) ? default | $string_utils:from_list(default, " "))}};
endif
-------------------------------------------------------------------------------
#65 Mail Options:show_replyto this n/a this
if (value = this:get(@args))
return {"", {tostr("Default Reply-to:  ", $mail_agent:name_list(@value))}};
else
return {0, {"No default Reply-to: field"}};
endif
-------------------------------------------------------------------------------
#65 Mail Options:show this n/a this
if (o = (name = args[2]) in {"sender", "noinclude"})
args[2] = {"all", "include"}[o];
return {@pass(@args), tostr("(", name, " is a synonym for -", args[2], ")")};
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#65 Mail Options:check_replyto this n/a this
"... must be object, list of objects, or false...";
value = args[1];
if (typeof(value) == OBJ)
return {{value}};
elseif (!this:istype(value, {{OBJ}}))
return $string_utils:capitalize("Object or list of objects expected.");
else
return {value};
endif
-------------------------------------------------------------------------------
#65 Mail Options:show_netmail this n/a this
if (value = this:get(@args))
return {value, {"Have MOO-mail automatically forwarded to me at", "my registered email-address."}};
else
return {value, {"Receive MOO-mail here on the MOO."}};
endif
"Last modified Tue Jun  1 02:10:08 1993 EDT by Edison@OpalMOO (#200).";
-------------------------------------------------------------------------------
#65 Mail Options:check_netmail this n/a this
":check_netmail(value) => Makes sure the email-address is one that can actually be used by $network:sendmail().";
"The actual value sent is not checked since it can only be a boolean flag.  The player's email_address property is what is checked.";
"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.";
"Returns a string error message if unusable or {value} otherwise.";
if (caller != this)
return E_PERM;
endif
if (args[1] && (reason = $network:email_will_fail($wiz_utils:get_email_address(player))))
return tostr("Invalid registered email_address: ", reason);
endif
return args;
-------------------------------------------------------------------------------
#65 Mail Options:show_expire this n/a this
value = this:get(args[1], "expire");
if (value < 0)
return {1, {"Messages will not expire."}};
else
return {value, {tostr("Unkept messages expire in ", $time_utils:english_time(value || $mail_agent.player_expire_time), value ? "" | " (default)")}};
endif
-------------------------------------------------------------------------------
#65 Mail Options:parse_expire this n/a this
{oname, value, data} = args;
if ((typeof(value) == STR) && index(value, " "))
value = $string_utils:explode(value, " ");
if (!value)
return {oname, 0};
endif
endif
if (value == 1)
return {oname, -1};
elseif (typeof(value) == LIST)
if (length(value) > 1)
nval = $time_utils:parse_english_time_interval(@value);
if (typeof(nval) == ERR)
return "Time interval should be of a form like \"30 days, 10 hours and 43 minutes\".";
else
return {oname, nval};
endif
endif
value = value[1];
endif
if ((nval = $code_utils:toint(value)) || (nval == 0))
return {oname, (nval < 0) ? -1 | nval};
elseif (value == "Never")
return {oname, -1};
else
return "Number, time interval (e.g., \"30 days\"), or \"Never\" expected";
endif
-------------------------------------------------------------------------------
#65 Mail Options:init_for_core this n/a this
if (caller_perms().wizard)
for x in ({"fast_check", "idle_check", "idle_threshold"})
this:remove_name(x);
for y in ({"show", "check", "parse"})
delete_verb(this, (y + "_") + x);
delete_property(this, (y + "_") + x);
endfor
endfor
pass(@args);
endif
-------------------------------------------------------------------------------
#65 Mail Options:check_news this n/a this
if ((what = args[1]) in {"new", "contents", "all"})
return {what};
else
return "Error: `news' option must be one of `new' or `contents' or `all'";
endif
-------------------------------------------------------------------------------
#65 Mail Options:parse_news this n/a this
if (typeof(args[2]) == INT)
return tostr(strsub(verb, "parse_", ""), " is not a boolean option.");
else
return {args[1], (typeof(args[2]) == STR) ? args[2] | $string_utils:from_list(args[2], " ")};
endif
-------------------------------------------------------------------------------
#65 Mail Options:show_news this n/a this
if ((value = this:get(@args)) == "all")
return {value, {"the `news' command will show all news"}};
elseif (value == "contents")
return {value, {"the `news' command will show the titles of all articles"}};
elseif (value == "new")
return {value, {"the `news' command will show only new news"}};
else
return {0, {"the `news' command will show all news"}};
endif
-------------------------------------------------------------------------------
#65 Mail Options:parse_@unsend this n/a this
{name, value, bleh} = args;
if (typeof(value) == INT)
return tostr(name, " is not a boolean option.");
elseif (typeof(value) == STR)
value = {value};
endif
ok = this.unsend_sequences;
for x in (value)
if ((!(pos = index(x, ":"))) || (!(x[1..pos - 1] in ok)))
return tostr("Invalid sequence - ", x);
elseif (pos != rindex(x, ":"))
return tostr("As a preventative measure, you may not use more than one : in a sequence. The following sequence is therefore invalid - ", x);
endif
endfor
return {name, value};
-------------------------------------------------------------------------------
#65 Mail Options:show_@unsend this n/a this
if (value = this:get(@args))
return {"", {tostr("Default message sequence for @unsend:  ", (typeof(value) == STR) ? value | $string_utils:from_list(value, " "))}};
else
default = $mail_agent.("player_default_@unsend");
return {0, {tostr("Default message sequence for @unsend:  ", (typeof(default) == STR) ? default | $string_utils:from_list(default, " "))}};
endif
-------------------------------------------------------------------------------
================================#66 Edit Options===============================================
#66 Edit Options.show_quiet_insert rc = MOOList [ "Report line numbers on insert or append.", "No echo on insert or append." ]
#66 Edit Options.show_eval_subs rc = MOOList [ "Ignore .eval_subs when compiling verbs.", "Use .eval_subs when compiling verbs." ]
#66 Edit Options.show_local rc = MOOList [ "Use in-MOO text editors.", "Ship text to client for local editing." ]
#66 Edit Options.show_no_parens rc = MOOList [ "include all parentheses when fetching verbs.", "includes only necessary parentheses when fetching verbs." ]
#66 Edit Options:actual this n/a this
if (i = args[1] in {"parens", "noisy_insert"})
return {{{"no_parens", "quiet_insert"}[i], !args[2]}};
else
return {args};
endif
-------------------------------------------------------------------------------
#66 Edit Options:show this n/a this
if (o = (name = args[2]) in {"parens", "noisy_insert"})
args[2] = {"no_parens", "quiet_insert"}[o];
return {@pass(@args), tostr("(", name, " is a synonym for -", args[2], ")")};
else
return pass(@args);
endif
-------------------------------------------------------------------------------
================================#67 Display Options===============================================
#67 Display Options.show_blank_tnt rc = MOOList [ "Treat `this none this' verbs like the others.", "Blank out the args on `this none this' verbs." ]
#67 Display Options.show_thisonly rc = MOOList [ "./: will show ancestor properties/verbs if none on this.", "./: will not show ancestor properties/verbs." ]
#67 Display Options.show_shortprep rc = MOOList [ "Display prepositions in full.", "Use short forms of prepositions." ]
================================#68 Generic Option Package===============================================
#68 Generic Option Package.namewidth rc = MOONumber 15
#68 Generic Option Package.extras r = MOOList [ ]
#68 Generic Option Package._namelist r = MOOString "!"
#68 Generic Option Package.names r = MOOList [ ]
#68 Generic Option Package:get this n/a this
":get(options,name) => returns the value of the option specified by name";
"i.e., if {name,value} is present in options, return value";
"      if name is present, return 1";
"      otherwise return 0";
{options, name} = args;
if (name in options)
return 1;
elseif (a = $list_utils:assoc(name, options))
return a[2];
else
return 0;
endif
-------------------------------------------------------------------------------
#68 Generic Option Package:set this n/a this
":set(optionlist,oname,value) => revised optionlist or string error message.";
"oname must be the full name of an option in .names or .extras.";
"Note that values must not be of type ERR.  ";
"FALSE (0, blank string, or empty list) is always a legal value.";
"If a verb :check_foo is defined on this, it will be used to typecheck any";
"non-false or object-type value supplied as a new value for option `foo'.";
"";
"   :check_foo(value) => string error message or {value to use}";
"";
"If instead there is a property .check_foo, that will give either the expected ";
"type or a list of allowed types.";
"Otherwise, the option is taken to be a boolean flag and all non-false, ";
"non-object values map to 1.";
"";
{options, oname, value} = args;
if (!((oname in this.names) || (oname in this.extras)))
return "Unknown option:  " + oname;
elseif (typeof(value) == ERR)
"... no option should have an error value...";
return "Error value";
elseif ((!value) && (typeof(value) != OBJ))
"... always accept FALSE (0, blankstring, emptylist)...";
elseif ($object_utils:has_callable_verb(this, check = "check_" + oname))
"... a :check_foo verb exists; use it to typecheck the value...";
if (typeof(c = this:(check)(value)) == STR)
return c;
endif
value = c[1];
elseif ($object_utils:has_property(this, tprop = "type_" + oname))
"... a .type_foo property exists...";
"... property value should be a type or list of types...";
if (!this:istype(value, t = this.(tprop)))
return $string_utils:capitalize(this:desc_type(t) + " value expected.");
endif
elseif ($object_utils:has_property(this, cprop = "choices_" + oname))
"... a .choices_foo property exists...";
"... property value should be a list of {value,docstring} pairs...";
if (!$list_utils:assoc(value, c = this.(cprop)))
return tostr("Allowed values: ", $string_utils:english_list($list_utils:slice(c, 1), "(??)", " or "));
endif
else
"... value is considered to be boolean...";
if (!value)
"... must be an object.  oops.";
return tostr("Non-object value expected.");
endif
value = 1;
endif
"... We now have oname and a value.  However, if oname is one of the extras,";
"... then we need to call :actual to see what it really means.";
if (oname in this.names)
nvlist = {{oname, value}};
elseif ((typeof(nvlist = this:actual(oname, value)) != LIST) || (!nvlist))
return nvlist || "Not implemented.";
endif
"... :actual returns a list of pairs...";
for nv in (nvlist)
{oname, value} = nv;
if (i = (oname in options) || $list_utils:iassoc(oname, options))
if ((!value) && (typeof(value) != OBJ))
"value == 0, blank string, empty list";
options[i..i] = {};
elseif (value == 1)
options[i] = oname;
else
options[i] = {oname, value};
endif
elseif (value || (typeof(value) == OBJ))
options[1..0] = {(value == 1) ? oname | {oname, value}};
endif
endfor
return options;
-------------------------------------------------------------------------------
#68 Generic Option Package:parse this n/a this
":parse(args[,...]) => {oname [,value]} or string error message";
"additional arguments are fed straight through to :parse_* routines.";
" <option> <value>     => {option, value}";
" <option>=<value>     => {option, value}";
" <option> is <value>  => {option, value}";
" +<option>            => {option, 1}";
" -<option>            => {option, 0}";
" !<option>            => {option, 0}";
" <option>             => {option}";
if (!(words = args[1]))
return "";
endif
option = words[1];
words[1..1] = {};
if (flag = option && index("-+!", option[1]))
option[1..1] = "";
endif
if (i = index(option, "="))
rawval = option[i + 1..$];
option = option[1..i - 1];
if (i == 1)
"... =bar ...";
return "Blank option name?";
elseif (flag)
"... +foo=bar";
return "Don't give a value if you use +, -, or !";
elseif (words)
"... foo=bar junk";
return $string_utils:from_list(words, " ") + "??";
endif
elseif (!option)
return "Blank option name?";
elseif (flag)
if (words)
"... +foo junk";
return "Don't give a value if you use +, -, or !";
endif
rawval = (flag - 1) % 2;
else
words && ((words[1] == "is") && (words[1..1] = {}));
rawval = words;
endif
"... do we know about this option?...";
if (!(oname = this:_name(strsub(option, "-", "_"))))
return tostr((oname == $failed_match) ? "Unknown" | "Ambiguous", " option:  ", option);
endif
"... determine new value...";
if (!rawval)
"... `@option foo is' or `@option foo=' ...";
return (rawval == {}) ? {oname} | {oname, 0};
elseif ($object_utils:has_callable_verb(this, pverb = "parse_" + oname))
return this:(pverb)(oname, rawval, args[2..$]);
elseif ($object_utils:has_property(this, cprop = "choices_" + oname))
return this:parsechoice(oname, rawval, this.(cprop));
elseif (rawval in {0, "0", {"0"}})
return {oname, 0};
elseif (rawval in {1, "1", {"1"}})
return {oname, 1};
else
return tostr("Option is a flag, use `+", option, "' or `-", option, "' (or `!", option, "')");
endif
-------------------------------------------------------------------------------
#68 Generic Option Package:_name this n/a this
":_name(string) => full option name corresponding to string ";
"               => $failed_match or $ambiguous_match as appropriate.";
if (((string = args[1]) in this.names) || (string in this.extras))
return string;
endif
char = (namestr = this._namelist)[1];
if (!(i = index(namestr, char + string)))
return $failed_match;
elseif (i != rindex(namestr, char + string))
return $ambiguous_match;
else
j = index(namestr[i + 1..$], char);
return namestr[i + 1..(i + j) - 1];
endif
-------------------------------------------------------------------------------
#68 Generic Option Package:add_name this n/a this
":add_name(name[,isextra]) adds name to the list of options recognized.";
"name must be a nonempty string and must not contain spaces, -, +, !, or =.";
"isextra true means that name isn't an actual option (recognized by :get) but merely a name that the option setting command should recognize to set a particular combination of options.  Actual options go in .names; others go in .extras";
{name, ?isextra = 0} = args;
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif ((!name) || match(name, "[-!+= ]"))
"...name is blank or contains a forbidden character";
return E_INVARG;
elseif (name in this.names)
"...name is already in option list";
if (isextra)
this.names = setremove(this.names, name);
this.extras = setadd(this.extras, name);
return 1;
else
return 0;
endif
elseif (name in this.extras)
if (isextra)
return 0;
else
this.names = setadd(this.names, name);
this.extras = setremove(this.extras, name);
return 1;
endif
else
char = this._namelist[1];
if (isextra)
this.extras = setadd(this.extras, name);
else
this.names = setadd(this.names, name);
endif
if (!index(this._namelist, (char + name) + char))
this._namelist = tostr(this._namelist, name, char);
endif
return 1;
endif
-------------------------------------------------------------------------------
#68 Generic Option Package:remove_name this n/a this
":remove_name(name) removes name from the list of options recognized.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
elseif (!(((name = args[1]) in this.names) || (name in this.extras)))
"...hmm... already gone...";
return 0;
else
char = this._namelist[1];
this._namelist = strsub(this._namelist, (char + name) + char, char);
this.names = setremove(this.names, name);
this.extras = setremove(this.extras, name);
return 1;
endif
-------------------------------------------------------------------------------
#68 Generic Option Package:show this n/a this
":show(options,name or list of names)";
" => text describing current value of option and what it means";
name = args[2];
if (typeof(name) == LIST)
text = {};
for n in (name)
text = {@text, @this:show(@listset(args, n, 2))};
endfor
return text;
elseif (!((name in this.names) || (name in this.extras)))
return {"Unknown option:  " + name};
elseif ($object_utils:has_callable_verb(this, sverb = "show_" + name))
r = this:(sverb)(@args);
value = r[1];
desc = r[2];
elseif ($object_utils:has_property(this, sverb) && ((value = this:get(args[1], name)) in {0, 1}))
desc = this.(sverb)[value + 1];
if (typeof(desc) == STR)
desc = {desc};
endif
elseif ($object_utils:has_property(this, cprop = "choices_" + name))
if (!(value = this:get(args[1], name)))
desc = this.(cprop)[1][2];
elseif (!(a = $list_utils:assoc(value, this.(cprop))))
return {(name + " has unexpected value ") + toliteral(value)};
else
desc = a[2];
endif
elseif (name in this.extras)
return {name + " not documented (complain)"};
else
value = this:get(args[1], name);
desc = {"not documented (complain)"};
if (typeof(value) in {LIST, STR})
desc[1..0] = toliteral(value);
value = "";
endif
endif
if (value in {0, 1})
which = "-+"[value + 1] + name;
elseif ((typeof(value) in {OBJ, STR, INT}) && (value != ""))
which = tostr(" ", name, "=", value);
else
which = " " + name;
endif
show = {$string_utils:left(which + "  ", this.namewidth) + desc[1]};
for i in [2..length(desc)]
show = {@show, $string_utils:space(this.namewidth) + desc[i]};
endfor
return show;
-------------------------------------------------------------------------------
#68 Generic Option Package:actual this n/a this
":actual(<name>,<value>) => list of {<name>,<value>} pairs or string errormsg";
" corresponding to what setting option <name> to <value> actually means";
" e.g., :actual(\"unfoo\",1) => {{\"foo\",0}}";
" e.g., :actual(\"g7mode\",1) => {{\"splat\",37},{\"baz\",#3}}";
return "Not implemented.";
-------------------------------------------------------------------------------
#68 Generic Option Package:istype this n/a this
":istype(value,types) => whether value is one of the given types";
if ((vtype = typeof(value = args[1])) in (types = args[2]))
return 1;
elseif (vtype != LIST)
return 0;
else
for t in (types)
if ((typeof(t) == LIST) && this:islistof(value, t))
return 1;
endif
endfor
endif
return 0;
-------------------------------------------------------------------------------
#68 Generic Option Package:islistof this n/a this
":islistof(value,types) => whether value (a list) has each element being one of the given types";
types = args[2];
for v in (value = args[1])
if (!this:istype(v, types))
return 0;
endif
endfor
return 1;
-------------------------------------------------------------------------------
#68 Generic Option Package:desc_type this n/a this
":desc_type(types) => string description of types";
nlist = {};
for t in (types = args[1])
if (typeof(t) == LIST)
if (length(t) > 1)
nlist = {@nlist, tostr("(", this:desc_type(t), ")-list")};
else
nlist = {@nlist, tostr(this:desc_type(t), "-list")};
endif
elseif (t in {INT, OBJ, STR, LIST})
nlist = {@nlist, {"number", "object", "string", "?", "list"}[t + 1]};
else
return "Bad type list";
endif
endfor
return $string_utils:english_list(nlist, "nothing", " or ");
-------------------------------------------------------------------------------
#68 Generic Option Package:parsechoice this n/a this
":parsechoice(oname,rawval,assoclist)";
which = {};
oname = args[1];
rawval = args[2];
choices = $list_utils:slice(args[3], 1);
errmsg = tostr("Allowed values for this flag: ", $string_utils:english_list(choices, "(??)", " or "));
if (typeof(rawval) == LIST)
if (length(rawval) > 1)
return errmsg;
endif
rawval = rawval[1];
elseif (typeof(rawval) != STR)
return errmsg;
endif
for c in (choices)
if (index(c, rawval) == 1)
which = {@which, c};
endif
endfor
if (!which)
return errmsg;
elseif (length(which) > 1)
return tostr(rawval, " is ambiguous.");
else
return {oname, which[1]};
endif
-------------------------------------------------------------------------------
================================#69 Error Generator===============================================
#69 Error Generator.names rc = MOOList [ "E_NONE", "E_TYPE", "E_DIV", "E_PERM", "E_PROPNF", "E_VERBNF", "E_VARNF", "E_INVIND", "E_RECMOVE", "E_MAXREC", "E_RANGE", "E_ARGS", "E_NACC", "E_INVARG", "E_QUOTA", "E_FLOAT" ]
#69 Error Generator.all_errors r = MOOList [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 ]
#69 Error Generator:raise this n/a this
raise(@args);
"this:(this.names[tonum(args[1]) + 1])()";
-------------------------------------------------------------------------------
#69 Error Generator:E_NONE this n/a this
"... hmmm... don't know how to raise E_NONE...";
return E_NONE;
-------------------------------------------------------------------------------
#69 Error Generator:E_TYPE this n/a this
"...raise E_TYPE ...";
1[2];
-------------------------------------------------------------------------------
#69 Error Generator:E_DIV this n/a this
"...raise E_DIV ...";
1 / 0;
-------------------------------------------------------------------------------
#69 Error Generator:E_PERM this n/a this
"...raise E_PERM ...";
this.owner.password;
-------------------------------------------------------------------------------
#69 Error Generator:E_PROPNF this n/a this
"...raise E_PROPNF ...";
this.a;
-------------------------------------------------------------------------------
#69 Error Generator:E_VERBNF this n/a this
"...raise E_VERBNF ...";
this:a();
-------------------------------------------------------------------------------
#69 Error Generator:E_VARNF this n/a this
"...raise E_VARNF ...";
a;
-------------------------------------------------------------------------------
#69 Error Generator:E_INVIND this n/a this
"...raise E_INVIND ...";
#-1.a;
-------------------------------------------------------------------------------
#69 Error Generator:E_RECMOVE this n/a this
move(this, this);
-------------------------------------------------------------------------------
#69 Error Generator:E_MAXREC this n/a this
"...raise E_MAXREC ...";
this:(verb)();
-------------------------------------------------------------------------------
#69 Error Generator:E_RANGE this n/a this
"...raise E_RANGE ...";
{}[1];
-------------------------------------------------------------------------------
#69 Error Generator:E_ARGS this n/a this
"...raise E_ARGS ...";
toint();
-------------------------------------------------------------------------------
#69 Error Generator:E_NACC this n/a this
"...raise E_NACC ...";
move($hacker, this);
-------------------------------------------------------------------------------
#69 Error Generator:E_INVARG this n/a this
"...raise E_INVARG ...";
parent(#-1);
-------------------------------------------------------------------------------
#69 Error Generator:E_QUOTA this n/a this
set_task_perms($no_one);
"...raise E_QUOTA ...";
create($thing);
-------------------------------------------------------------------------------
#69 Error Generator:accept this n/a this
return 0;
-------------------------------------------------------------------------------
#69 Error Generator:name this n/a this
return toliteral(args[1]);
"return this.names[tonum(args[1]) + 1];";
-------------------------------------------------------------------------------
#69 Error Generator:toerr this n/a this
"toerr -- given a string or a number, return the corresponding ERR.";
"If not found or an execution error, return -1.";
if (typeof(string = args[1]) == STR)
for e in (this.all_errors)
if (tostr(e) == string)
return e;
endif
endfor
elseif (typeof(number = args[1]) == INT)
for e in (this.all_errors)
if (toint(e) == number)
return e;
endif
endfor
endif
return -1;
-------------------------------------------------------------------------------
#69 Error Generator:match_error this n/a this
"match_error -- searches for tostr(E_WHATEVER) in a string, returning the ERR, returns -1 if no error string is found.";
string = args[1];
for e in (this.all_errors)
if (index(string, tostr(e)))
return e;
endif
endfor
return -1;
-------------------------------------------------------------------------------
================================#70 Site-Locks===============================================
#70 Site-Locks:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.mail_notify = {player};
player:set_current_message(this, 0, 0, 1);
this.moderated = 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
================================#71 housekeeper===============================================
#71 housekeeper.owners rc = MOOList [ #2 ]
#71 housekeeper.moveto_task rc = MOONumber 0
#71 housekeeper.drop_off_msg rc = MOOString "%[tpsc] arrives to drop off %n, who is sound asleep."
#71 housekeeper.testing rc = MOONumber 0
#71 housekeeper.requestors rc = MOOList [ ]
#71 housekeeper.eschews rc = MOOList [ ]
#71 housekeeper.public_places rc = MOOList [ ]
#71 housekeeper.take_away_msg rc = MOOString "%[tpsc] arrives to cart %n off to bed."
#71 housekeeper.litter rc = MOOList [ ]
#71 housekeeper.recycle_bins rc = MOOList [ ]
#71 housekeeper.player_queue r = MOOList [ ]
#71 housekeeper.task rc = MOONumber 0
#71 housekeeper.destination rc = MOOList [ ]
#71 housekeeper.cleaning rc = MOOObjRef #-1
#71 housekeeper.cleaning_index rc = MOONumber 0
#71 housekeeper.clean r = MOOList [ ]
#71 housekeeper.move_player_task r = MOONumber 0
#71 housekeeper:look_self this n/a this
player:tell_lines(this:description());
player:tell($string_utils:pronoun_sub("%S %<is> moving around from room to room, cleaning up.", this));
-------------------------------------------------------------------------------
#71 housekeeper:cleanup this n/a this
"$housekeeper:cleanup([insist]) => clean up player's objects. Argument is 'up' or 'up!' for manually requested cleanups (notify player differently)";
if (caller_perms() != this)
return E_PERM;
endif
for object in (this.clean)
x = object in this.clean;
if (this.requestors[x] == player)
if (result = this:replace(object, @args))
player:tell(result, ".");
endif
endif
$command_utils:suspend_if_needed(0);
endfor
player:tell("The housekeeper has finished cleaning up your objects.");
-------------------------------------------------------------------------------
#71 housekeeper:replace this n/a this
"replace the object given to its proper spot (if there is one).";
{object, ?insist = 0} = args;
i = object in this.clean;
if (!i)
return tostr(object, " is not on the ", this.name, "'s cleanup list");
endif
place = this.destination[i];
if (!((($recycler:valid(object) && ($recycler:valid(r = this.requestors[i]) && is_player(r))) && ($recycler:valid(place) || (place == #-1))) && (!(object.location in this.recycle_bins))))
"object no longer valid (recycled or something), remove it.";
this.clean = listdelete(this.clean, i);
this.requestors = listdelete(this.requestors, i);
this.destination = listdelete(this.destination, i);
return tostr(object) + " is no longer valid, removed from cleaning list";
endif
oldloc = loc = object.location;
if (object.location == place)
"already in its place";
return "";
endif
requestor = $recycler:valid(tr = this.requestors[i]) ? tr | $no_one;
if (insist != "up!")
if ($code_utils:verb_or_property(object, "in_use"))
return ("Not returning " + object.name) + " because it claims to be in use";
endif
for thing in (object.contents)
if (thing:is_listening())
return ((("Not returning " + object.name) + " because ") + thing.name) + " is inside";
endif
$command_utils:suspend_if_needed(0);
endfor
if (valid(loc) && (loc != $limbo))
if (loc:is_listening())
return ((("Not returning " + object.name) + " because ") + loc.name) + " is holding it";
endif
for y in (loc:contents())
if ((y != object) && y:is_listening())
return (((("Not returning " + object.name) + " because ") + y.name) + " is in ") + loc.name;
endif
$command_utils:suspend_if_needed(0);
endfor
endif
endif
if (valid(place) && (!place:acceptable(object)))
return (place.name + " won't accept ") + object.name;
endif
try
requestor:tell("As you requested, the housekeeper tidies ", $string_utils:nn(object), " from ", $string_utils:nn(loc), " to ", $string_utils:nn(place), ".");
if ($object_utils:has_verb(loc, "announce_all_but"))
loc:announce_all_but({requestor, object}, "At ", requestor.name, "'s request, the ", this.name, " sneaks in, picks up ", object.name, " and hurries off to put ", ($object_utils:has_property(object, "po") && (typeof(object.po) == STR)) ? object.po | "it", " away.");
endif
except (ANY)
"Ignore errors";
endtry
fork (0)
this:moveit(object, place, requestor);
if ((loc = object.location) == oldloc)
return (object.name + " wouldn't go; ") + ((!place:acceptable(object)) ? (" perhaps " + $string_utils:nn(place)) + " won't let it in" | ((" perhaps " + $string_utils:nn(loc)) + " won't let go of it"));
endif
try
object:tell("The housekeeper puts you away.");
if ($object_utils:isa(loc, $room))
loc:announce_all_but({object}, "At ", requestor.name, "'s request, the housekeeper sneaks in, deposits ", object:title(), " and leaves.");
else
loc:tell("You notice the housekeeper sneak in, give you ", object:title(), " and leave.");
endif
except (ANY)
"Ignore errors";
endtry
endfork
return "";
-------------------------------------------------------------------------------
#71 housekeeper:cleanup_list any n/a none
if (args)
if (!valid(who = args[1]))
return;
endif
player:tell(who.name, "'s personal cleanup list:");
else
who = 0;
player:tell("Housekeeper's complete cleanup list:");
endif
player:tell("------------------------------------------------------------------");
printed_anything = 0;
objs = this.clean;
reqs = this.requestors;
dest = this.destination;
objfieldwid = length(tostr(max_object())) + 1;
for i in [1..length(objs)]
$command_utils:suspend_if_needed(2);
req = $recycler:valid(tr = reqs[i]) ? tr | $no_one;
ob = objs[i];
place = dest[i];
if (((who == 0) || (req == who)) || (ob.owner == who))
if (!valid(ob))
player:tell($string_utils:left(tostr(ob), objfieldwid), $string_utils:left("** recycled **", 50), "(", req.name, ")");
else
player:tell($string_utils:left(tostr(ob), objfieldwid), $string_utils:left(ob.name, 26), "=>", $string_utils:left(tostr(place), objfieldwid), (valid(place) ? place.name | "nowhere") || "nowhere", " (", req.name, ")");
endif
printed_anything = 1;
endif
endfor
if (!printed_anything)
player:tell("** The housekeeper has nothing in the cleanup list.");
endif
player:tell("------------------------------------------------------------------");
-------------------------------------------------------------------------------
#71 housekeeper:add_cleanup any ?-2? any
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
{what, ?who = player, ?where = what.location} = args;
if ((what < #1) || (!valid(what)))
return "invalid object";
endif
if ($object_utils:isa(who, $guest))
return tostr("Guests can't use the ", this.name, ".");
endif
if (!is_player(who))
return tostr("Non-players can't use the ", this.name, ".");
endif
if (!valid(where))
return tostr("The ", this.name, " doesn't know how to find ", where, " in order to put away ", what.name, ".");
endif
if (is_player(what))
return ("The " + this.name) + " doesn't do players, except to cart them home when they fall asleep.";
endif
for x in (this.eschews)
if ($object_utils:isa(what, x[1]))
ok = 0;
for y in [3..length(x)]
if ($object_utils:isa(what, x[y]))
ok = 1;
endif
endfor
if (!ok)
return tostr("The ", this.name, " doesn't do ", x[2], "!");
endif
endif
endfor
if ($object_utils:has_callable_verb(where, "litterp") ? where:litterp(what) | ((where in this.public_places) && (!(what in where.residents))))
return tostr("The ", this.name, " won't litter ", where.name, "!");
endif
if (i = what in this.clean)
if ((!this:controls(i, who)) && valid(this.destination[i]))
return tostr($recycler:valid(tr = this.requestors[i]) ? tr.name | "Someone", " already asked that ", what.name, " be kept at ", this.destination[i].name, "!");
endif
this.requestors[i] = who;
this.destination[i] = where;
else
this.clean = {what, @this.clean};
this.requestors = {who, @this.requestors};
this.destination = {where, @this.destination};
endif
return tostr("The ", this.name, " will keep ", what.name, " (", what, ") at ", valid(where) ? ((where.name + " (") + tostr(where)) + ")" | where, ".");
-------------------------------------------------------------------------------
#71 housekeeper:remove_cleanup any n/a none
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
{what, ?who = player} = args;
if (i = what in this.clean)
if (!this:controls(i, who))
return tostr("You may remove an object from ", this.name, " list only if you own the object, the place it is kept, or if you placed the original cleaning order.");
endif
this.clean = listdelete(this.clean, i);
this.destination = listdelete(this.destination, i);
this.requestors = listdelete(this.requestors, i);
return tostr(what.name, " (", what, ") removed from cleanup list.");
else
return tostr(what.name, " not in cleanup list.");
endif
-------------------------------------------------------------------------------
#71 housekeeper:controls this n/a this
"does player control entry I?";
{i, who} = args;
if ((who in {this.owner, @this.owners}) || who.wizard)
return "Yessir.";
endif
cleanable = this.clean[i];
if (this.requestors[i] == who)
return "you asked for the previous result, you can change this one.";
elseif (((who == cleanable.owner) || (!valid(dest = this.destination[i]))) || (who == dest.owner))
return "you own the object or the place where it is being cleaned to, or the destination is no longer valid.";
else
return "";
endif
-------------------------------------------------------------------------------
#71 housekeeper:continuous this n/a this
"start the housekeeper cleaning continuously. Kill any previous continuous";
"task. Not meant to be called interactively.";
if (!$perm_utils:controls(caller_perms(), this))
return E_PERM;
endif
if ($code_utils:task_valid(this.task))
taskn = this.task;
this.task = 0;
kill_task(taskn);
endif
fork taskn (0)
while (1)
index = 1;
while (index <= length(this.clean))
this.cleaning = x = this.clean[index];
this.cleaning_index = index;
index = index + 1;
fork (0)
`this:replace(x) ! ANY';
endfork
suspend(this.testing ? 2 | this:time());
endwhile
suspend(5);
this:litterbug();
endwhile
endfork
this.task = taskn;
-------------------------------------------------------------------------------
#71 housekeeper:litterbug this n/a this
for room in (this.public_places)
for thingy in (room.contents)
suspend(10);
if (((thingy.location == room) && this:is_litter(thingy)) && (!this:is_watching(thingy, $nothing)))
"if it is litter and no-one is watching";
fork (0)
this:send_home(thingy);
endfork
suspend(0);
endif
endfor
endfor
-------------------------------------------------------------------------------
#71 housekeeper:is_watching this n/a this
return valid(thing = args[1]) && thing:is_listening();
-------------------------------------------------------------------------------
#71 housekeeper:send_home this n/a this
if (caller != this)
return E_PERM;
endif
litter = args[1];
littering = litter.location;
this:ejectit(litter, littering);
home = litter.location;
if ($object_utils:isa(home, $room))
home:announce_all("The ", this.name, " sneaks in, deposits ", litter:title(), " and leaves.");
else
home:tell("You notice the ", this.name, " sneak in, give you ", litter:title(), " and leave.");
endif
if ($object_utils:has_callable_verb(littering, "announce_all_but"))
littering:announce_all_but({litter}, "The ", this.name, " sneaks in, picks up ", litter:title(), " and rushes off to put it away.");
endif
-------------------------------------------------------------------------------
#71 housekeeper:moveit this n/a this
"Wizardly verb to move object with requestor's permission";
if (caller != this)
return E_PERM;
else
set_task_perms(player = args[3]);
return args[1]:moveto(args[2]);
endif
-------------------------------------------------------------------------------
#71 housekeeper:ejectit this n/a this
"this:ejectit(object,room): Eject args[1] from args[2].  Callable only by housekeeper's quarters verbs.";
if (caller == this)
args[2]:eject(args[1]);
endif
-------------------------------------------------------------------------------
#71 housekeeper:is_object_cleaned this n/a this
what = args[1];
if (!(where = what in this.clean))
return 0;
else
return {this.destination[where], this.requestors[where]};
endif
-------------------------------------------------------------------------------
#71 housekeeper:is_litter this n/a this
thingy = args[1];
for x in (this.litter)
if ($object_utils:isa(thingy, x[1]) && (!$object_utils:isa(thingy, x[2])))
return 1;
endif
endfor
return 0;
-------------------------------------------------------------------------------
#71 housekeeper:init_for_core this n/a this
if (caller_perms().wizard)
this.password = "Impossible password to type";
this.last_password_time = 0;
this.litter = {};
this.public_places = {};
this.requestors = {};
this.destination = {};
this.clean = {};
this.eschews = {};
this.recycle_bins = {};
this.cleaning = #-1;
this.task = 0;
this.owners = {#2};
this.mail_forward = {#2};
this.player_queue = {};
this.move_player_task = 0;
this.moveto_task = 0;
pass(@args);
endif
-------------------------------------------------------------------------------
#71 housekeeper:clean_status this n/a this
count = 0;
for i in (this.requestors)
if (i == player)
count = count + 1;
endif
$command_utils:suspend_if_needed(1);
endfor
player:tell("Number of items in cleanup list: ", tostr(length(this.clean)));
player:tell("Number of items you requested to be tidied: ", tostr(count));
player:tell("Number of requestors: ", tostr(length($list_utils:remove_duplicates(this.requestors))));
player:tell("Time to complete one cleaning circuit: ", $time_utils:english_time(length(this.clean) * this:time()));
player:tell("The Housekeeper is in " + (($housekeeper.testing == 0) ? "normal, non-testing mode." | "testing mode. "));
if (!$code_utils:task_valid($housekeeper.task))
player:tell("The Housekeeper task has died. Restarting...");
$housekeeper:continuous();
else
player:tell("The Housekeeper is actively cleaning.");
endif
-------------------------------------------------------------------------------
#71 housekeeper:is_cleaning this n/a this
"return a string status if the hosuekeeper is cleaning this object";
cleanable = args[1];
info = this:is_object_cleaned(cleanable);
if (info == 0)
return tostr(cleanable.name, " is not cleaned by the ", this.name, ".");
else
return tostr(cleanable.name, " is kept tidy at ", $string_utils:nn(info[1]), " at the request of ", $string_utils:nn(info[2]), ".");
endif
-------------------------------------------------------------------------------
#71 housekeeper:time this n/a this
"Returns the amount of time to suspend between objects while continuous cleaning.";
"Currently set to try to complete cleaning circuit in one hour, but not exceed one object every 20 seconds.";
return max(20 + $login:current_lag(), length(this.clean) ? 3600 / length(this.clean) | 0);
-------------------------------------------------------------------------------
#71 housekeeper:acceptable this n/a this
return caller == this;
-------------------------------------------------------------------------------
#71 housekeeper:move_players_home this n/a this
if (!$perm_utils:controls(caller_perms(), this))
"perms don't control the $housekeeper; probably not called by $room:disfunc then. Used to let args[1] call this. No longer.";
return E_PERM;
endif
this.player_queue = {@this.player_queue, {args[1], time() + 300}};
if ($code_utils:task_valid(this.move_player_task))
"the move-players-home task is already running";
return;
endif
fork tid (10)
while (this.player_queue)
if ((mtime = this.player_queue[1][2]) < (time() + 10))
who = this.player_queue[1][1];
"Remove from queue first so that if they do something malicious, like put a kill_task in a custom :accept_for_abode, they won't be in the queue when the task restarts with the next player disconnect. Ho_Yan 12/3/98";
this.player_queue = listdelete(this.player_queue, 1);
if (is_player(who) && (!$object_utils:connected(who)))
dest = `who.home:accept_for_abode(who) ! ANY => 0' ? who.home | $player_start;
if (who.location != dest)
player = who;
this:move_em(who, dest);
endif
endif
else
suspend(mtime - time());
endif
$command_utils:suspend_if_needed(1);
endwhile
endfork
this.move_player_task = tid;
-------------------------------------------------------------------------------
#71 housekeeper:move_em this n/a this
if (caller == this)
{who, dest} = args;
set_task_perms(who);
fork (0)
fork (0)
"This is forked so that it's protected from aborts due to errors in the player's :moveto verb.";
if (who.location != dest)
"Unfortunately, if who is -already- at $player_start, move() won't call :enterfunc and the sleeping body never goes to $limbo. Have to call explicitly for that case. Ho_Yan 11/2/95";
if (who.location == $player_start)
$player_start:enterfunc(who);
else
"Nosredna, 5/4/01: but wait, why don't we just moved them straight to limbo?";
move(who, $limbo);
endif
endif
endfork
start = who.location;
this:set_moveto_task();
who:moveto(dest);
if (who.location != start)
start:announce(this:take_away_msg(who));
endif
if (who.location == dest)
dest:announce(this:drop_off_msg(who));
endif
endfork
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#71 housekeeper:take_away_msg drop_off_msg this n/a this
return $string_utils:pronoun_sub(this.(verb), args[1], this);
-------------------------------------------------------------------------------
#71 housekeeper:set_moveto_task this n/a this
"sets $housekeeper.moveto_task to the current task_id() so player:moveto's can check for validity.";
if (caller != this)
return E_PERM;
endif
this.moveto_task = task_id();
-------------------------------------------------------------------------------
================================#72 Network Utilities===============================================
#72 Network Utilities.connect_connections_to  = MOOList [ ]
#72 Network Utilities.maildrop rc = MOOString "localhost"
#72 Network Utilities.valid_host_regexp rc = MOOString "^%([-_a-z0-9]+%.%)+%(gov%|edu%|com%|org%|int%|mil%|net%|%nato%|arpa%|name%|info%|[a-z][a-z]%)$"
#72 Network Utilities.envelope_from rc = MOOString "postmastername@yourhost"
#72 Network Utilities.postmaster rc = MOOString "postmastername@yourhost"
#72 Network Utilities.valid_email_regexp rc = MOOString "^[-a-z0-9_!.%+$'=/]*[-a-z0-9_!%+$'=]$"
#72 Network Utilities.queued_mail  = MOOList [ ]
#72 Network Utilities.suspicious_userids rc = MOOList [ "", "sysadmin", "root", "postmaster", "bin", "SYSTEM", "OPERATOR", "guest", "me", "mailer-daemon", "webmaster", "sysop", "info" ]
#72 Network Utilities.queued_mail_task r = MOONumber 1076002766
#72 Network Utilities.debugging rc = MOONumber 0
#72 Network Utilities.MOO_name rc = MOOString "YourMOO"
#72 Network Utilities.blank_envelope rc = MOONumber 0
#72 Network Utilities.invalid_userids rc = MOOList [ "", "sysadmin", "root", "postmaster", "system", "operator", "bin" ]
#72 Network Utilities.password_postmaster rc = MOOString "postmastername@yourhost"
#72 Network Utilities.active rc = MOONumber 0
#72 Network Utilities.site r = MOOString "yoursite"
#72 Network Utilities.trusts r = MOOList [ #36 ]
#72 Network Utilities.port rc = MOONumber 7777
#72 Network Utilities.large_domains r = MOOList [ ]
#72 Network Utilities.errors_to_address rc = MOOString "moomailerrors@yourhost"
#72 Network Utilities.usual_postmaster rc = MOOString "postmastername@yourhost"
#72 Network Utilities:parse_address this n/a this
"Given an email address, return {userid, site}.";
"Valid addresses are of the form `userid[@site]'.";
"At least for now, if [@site] is left out, site will be returned as blank.";
"Should be a default address site, or something, somewhere.";
address = args[1];
return (at = index(address, "@")) ? {address[1..at - 1], address[at + 1..$]} | {address, ""};
-------------------------------------------------------------------------------
#72 Network Utilities:local_domain this n/a this
"given a site, try to figure out what the `local' domain is.";
"if site has a @ or a % in it, give up and return E_INVARG.";
"blank site is returned as is; try this:local_domain(this.localhost) for the answer you probably want.";
site = args[1];
if (index(site, "@") || index(site, "%"))
return E_INVARG;
elseif (match(site, "^[0-9.]+$"))
return E_INVARG;
elseif (!site)
return "";
elseif (!(dot = rindex(site, ".")))
dot = rindex(site = this.site, ".");
endif
if ((!dot) || (!(dot = rindex(site[1..dot - 1], "."))))
return site;
else
domain = site[dot + 1..$];
site = site[1..dot - 1];
while (site && (domain in this.large_domains))
if (dot = rindex(site, "."))
domain = tostr(site[dot + 1..$], ".", domain);
site = site[1..dot - 1];
else
return tostr(site, ".", domain);
endif
endwhile
return domain;
endif
-------------------------------------------------------------------------------
#72 Network Utilities:open this n/a this
":open(address, port, [connect-connection-to])";
"Open a network connection to address/port.  If the connect-connection-to is passed, then the connection will be connected to that object when $login gets ahold of it.  If not, then the connection is just ignored by $login, i.e. not bothered by it with $welcome_message etc.";
"The object specified by connect-connection-to has to be a player (though it need not be a $player).";
"Returns the (initial) connection or an error, as in open_network_connection";
if (!this:trust(caller_perms()))
return E_PERM;
endif
{address, port, ?connect_to} = args;
if (length(args) < 3)
connect_to = $nothing;
elseif (((typeof(connect_to) == OBJ) && valid(connect_to)) && is_player(connect_to))
if (!$perm_utils:controls(caller_perms(), connect_to))
return E_PERM;
endif
else
return E_INVARG;
endif
if (typeof(connection = `open_network_connection(address, port) ! ANY') != ERR)
if (valid(connect_to))
this.connect_connections_to = {@this.connect_connections_to, {connection, connect_to}};
endif
endif
return connection;
-------------------------------------------------------------------------------
#72 Network Utilities:close this n/a this
if (!this:trust(caller_perms()))
return E_PERM;
endif
con = args[1];
if (!index(`connection_name(con) ! ANY => ""', " to "))
return E_INVARG;
endif
boot_player(con);
if (i = $list_utils:iassoc(con, $network.connect_connections_to))
$network.connect_connections_to = listdelete($network.connect_connections_to, i);
endif
return 1;
-------------------------------------------------------------------------------
#72 Network Utilities:sendmail any n/a none
"sendmail(to, subject, line1, line2, ...)";
"  sends mail to internet address 'to', with given subject.";
"  It fills in various fields, such as date, from (from player), etc.";
"  the rest of the arguments are remaining lines of the message, and may begin with additional header fields.";
"  (must match RFC822 specification).";
"Requires $network.trust to call (no anonymous mail from MOO).";
"Returns 0 if successful, or else error condition or string saying why not.";
if (!this:trust(caller_perms()))
return E_PERM;
endif
mooname = this.MOO_name;
mooinfo = tostr(mooname, " (", this.site, " ", this.port, ")");
if (reason = this:invalid_email_address(to = args[1]))
return reason;
endif
"took out Envelope-from:  + this.errors_to_address";
tries = 4;
result = "unknown";
while ((tries > 0) && (result != 0))
tries = tries - 1;
result = this:raw_sendmail(to, "Date: " + $time_utils:rfc822_ctime(), "From: " + this:return_address_for(player), "To: " + to, "Subject: " + args[2], "Errors-to: " + this.errors_to_address, "X-Mail-Agent: " + mooinfo, @args[3..$]);
endwhile
return result;
-------------------------------------------------------------------------------
#72 Network Utilities:trust this n/a this
return (who = args[1]).wizard || (who in this.trusts);
-------------------------------------------------------------------------------
#72 Network Utilities:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.active = 0;
this.errors_to_address = "moomailerrors@yourhost";
this.site = "yoursite";
this.postmaster = "postmastername@yourhost";
this.usual_postmaster = "postmastername@yourhost";
this.password_postmaster = "postmastername@yourhost";
this.envelope_from = "postmastername@yourhost";
this.blank_envelope = 0;
this.MOO_name = "YourMOO";
this.maildrop = "localhost";
this.port = 7777;
this.large_domains = {};
this.trusts = {$hacker};
this.connect_connections_to = {};
endif
-------------------------------------------------------------------------------
#72 Network Utilities:raw_sendmail any n/a none
"Copied from sendmail fix (#88079):raw_sendmail by Lineman (#108318) Mon Feb  1 19:29:43 1999 PST";
"rawsendmail(to, @lines)";
"sends mail without processing. Returns 0 if successful, or else reason why not.";
if (!caller_perms().wizard)
return E_PERM;
endif
if (!this.active)
return "Networking is disabled.";
endif
if (typeof(this.debugging) == LIST)
"who to notify";
debugging = this.debugging;
else
"notify this owner";
debugging = this.debugging && {this.owner};
endif
address = args[1];
body = listdelete(args, 1);
data = {"HELO " + this.site, ("MAIL FROM:<" + this.postmaster) + ">", ("RCPT TO:<" + address) + ">", "DATA"};
blank = 0;
for x in (body)
this:suspend_if_needed(0);
if (!(blank || match(x, "^[!-9;-~]+: ")))
if (x)
data = {@data, ""};
endif
blank = 1;
endif
data = {@data, (x && (x[1] == ".")) ? "." + x | x};
endfor
data = {@data, ".", "QUIT", ""};
suspend(0);
target = E_NONE;
for maildrop in ((typeof(this.maildrop) == LIST) ? this.maildrop | {this.maildrop})
target = $network:open(maildrop, 25);
if (typeof(target) != ERR)
break;
endif
endfor
if (typeof(target) == ERR)
return tostr(@(target == E_NONE) ? {"No maildrop specified"} | {"Cannot open connection to maildrop ", maildrop, ": ", target});
endif
set_connection_option(target, "hold-input", 1);
blast = 0;
msg = 0;
expects = {"220", "250", "250", "250%|251", "354", "250", "221"};
for line in (data)
if (!blast)
reply = this:tcp_wait(target);
if (typeof(reply) == ERR)
msg = "Connection dropped or timed out.";
break;
elseif (!match(reply[1..3], expects[1]))
msg = (("Expected " + expects[1]) + " but got ") + reply;
break;
endif
debugging && notify(debugging[1], "GET: " + reply);
expects[1..1] = {};
if (reply[1..3] == "221")
"Service closing transmission channel";
break;
elseif (reply[1..3] == "354")
"Start mail input; end with <CRLF>.<CRLF>";
blast = 1;
endif
elseif (line == ".")
blast = 0;
endif
debugging && notify(debugging[1], "SEND:" + line);
while (((ticks_left() < 4000) || (seconds_left() < 2)) || (!notify(target, line, 1)))
suspend(0);
endwhile
endfor
$network:close(target);
debugging && notify(debugging[1], "EXIT:" + (msg || "Mail sent successfully."));
return msg;
-------------------------------------------------------------------------------
#72 Network Utilities:invalid_email_address this n/a this
"invalid_email_address(email) -- check to see if email looks like a valid email address. Return reason why not.";
address = args[1];
if (!address)
return "no email address supplied";
endif
if (!(at = rindex(address, "@")))
return ("'" + address) + "' doesn't look like a valid internet email address";
endif
name = address[1..at - 1];
host = address[at + 1..$];
if (match(name, "^in%%") || match(name, "^smtp%%"))
return tostr("'", name, "' doesn't look like a valid username (try removing the 'in%' or 'smtp%')");
endif
if (!match(host, $network.valid_host_regexp))
return tostr("'", host, "' doesn't look like a valid internet host");
endif
if (!match(name, $network.valid_email_regexp))
return tostr("'", name, "' doesn't look like a valid user name for internet mail");
endif
return "";
-------------------------------------------------------------------------------
#72 Network Utilities:invalid_hostname this n/a this
return match(args[1], this.valid_host_regexp) ? "" | tostr("'", args[1], "' doesn't look like a valid internet host name");
-------------------------------------------------------------------------------
#72 Network Utilities:email_will_fail this n/a this
":email_will_fail(email-address[, display?]) => Makes sure the email-address is one that can actually be used by $network:sendmail().";
{email, ?display = 0} = args;
reason = this:invalid_email_address(email);
if (reason && display)
player:tell("Invalid email address: ", reason);
endif
return reason;
"following is code from OpalMOO, not used here";
"Possible situations where the address would be unusable are when the address is invalid or we can't connect to the site to send mail.";
"If <display> is true, error messages are displayed to the player and 1 is returned when address is unuable.  If <display> is false and address is unusable, the error message is returned.  If the address is usable, 0 is always returned.";
if (!this:approved_for_network(caller_perms()))
return E_PERM;
endif
if (!this:valid_email_address(email))
msg = tostr("Your email address (", email, ") is not a usable account.");
elseif ((result = this:verify_email_address(email)) == E_INVARG)
msg = tostr("Unable to connect to ", this:parse_address(email)[2], ".");
elseif (typeof(result) == STR)
msg = tostr("The site ", (parse = this:parse_address(email))[2], " does not recognize ", parse[1], " as a valid account.");
else
return 0;
endif
if (display)
player:tell(msg);
return 1;
else
return msg;
endif
"Last modified Tue Jun 15 00:19:01 1993 EDT by Ranma (#200).";
-------------------------------------------------------------------------------
#72 Network Utilities:read this n/a this
"for trusted players, they can read from objects they own or open connections";
if (!this:trust(caller_perms()))
return E_PERM;
elseif (valid(x = args[1]))
if ((x.owner == x) || (x.owner != caller_perms()))
return E_INVARG;
endif
"elseif (!this:is_outgoing_connection(x) return E_PERM";
endif
return `read(@args) ! ANY';
-------------------------------------------------------------------------------
#72 Network Utilities:is_open this n/a this
":is_open(object)";
"return true if the object is somehow connected, false otherwise.";
return typeof(`idle_seconds(@args) ! ANY') == INT;
"Relies on test in idle_seconds, and the error catching";
-------------------------------------------------------------------------------
#72 Network Utilities:incoming_connection this n/a this
function incoming_connection() {
	"Peer at an incoming connection.  Decide if it should be connected to something, return that object. If it should be ignored (outbound connection), return 1. Called only by #0:do_login_command";
	if (caller != #0) {
		return;
	}
	what = args[1];
	"this code for unix servers >= 1.7.5 only";
	if (false /*index(`connection_name(what) ! ANY => ""', " to ")*/ ) {
		"outbound connection";
		if (ct = $list_utils.assoc(what, this.connect_connections_to)) {
			_this.connect_connections_to = setremove(_this.connect_connections_to, ct);
			return ct[2];
		} else {
			return 1;
		}
	} else {
		return 0;
	}
}
incoming_connection();
-------------------------------------------------------------------------------
#72 Network Utilities:return_address_for this n/a this
":return_address_for(player) => string of 'return address'. Currently inbound mail doesn't work, so this is a bogus address.";
who = args[1];
if (valid(who) && is_player(who))
return tostr(toint(who), "@", this.site, " (", who.name, ")");
else
return tostr($login.registration_address, " (non-player ", who, ")");
endif
-------------------------------------------------------------------------------
#72 Network Utilities:server_started this n/a this
"called when restarting to clean out state.";
if (caller != #0)
return E_PERM;
endif
this.connect_connections_to = {};
-------------------------------------------------------------------------------
#72 Network Utilities:is_outgoing_connection this n/a this
return index(`connection_name(args[1]) ! ANY => ""', " to ");
-------------------------------------------------------------------------------
#72 Network Utilities:notify this n/a this
"for trusted players, they can write to connections";
if (!this:trust(caller_perms()))
return E_PERM;
elseif (valid(x = args[1]))
return E_INVARG;
elseif (!this:is_outgoing_connection(x))
return E_PERM;
endif
return notify(x, args[2]);
-------------------------------------------------------------------------------
#72 Network Utilities:suspend_if_needed this n/a this
"$command_utils:suspend_if_needed but chowned to player";
if ($command_utils:running_out_of_time())
set_task_perms(caller_perms().wizard ? player | caller_perms());
return $command_utils:suspend_if_needed(@args);
endif
-------------------------------------------------------------------------------
#72 Network Utilities:error this n/a this
":error(ERN, host, port) interpret open_network_connection(host, port) error";
{msg, host, port} = args;
if (msg == E_PERM)
return "Networking not enabled in server, or else user doesn't have permission to call o_n_c();";
elseif (msg == E_INVARG)
return tostr("The host/port ", toliteral(host), "/", toliteral(port), " is invalid or is not responding.");
elseif (msg == E_QUOTA)
return tostr("The connection to ", toliteral(host), "/", toliteral(port), " cannot be made at this time.");
else
return tostr("Unusual error: ", toliteral(msg));
endif
-------------------------------------------------------------------------------
#72 Network Utilities:help_msg this n/a this
"'cause this doesn't have a $_utils name";
return this:description();
-------------------------------------------------------------------------------
#72 Network Utilities:adjust_postmaster_for_password this n/a this
"adjust_postmaster_for_password(enter_or_exit): permits the MOO to have two different postmasters for different kinds of bounces.  If entering password (argument \"enter\"), change to $network.password_postmaster, else (argument \"exit\") change to $network.usual_postmaster.";
if (args[1] == "enter")
$network.postmaster = $network.password_postmaster;
$network.errors_to_address = $network.password_postmaster;
$network.envelope_from = $network.password_postmaster;
else
$network.postmaster = $network.usual_postmaster;
$network.errors_to_address = $network.usual_postmaster;
$network.envelope_from = $network.blank_envelope ? "" | $network.usual_postmaster;
endif
-------------------------------------------------------------------------------
#72 Network Utilities:add_queued_mail this n/a this
"$network:add_queued_mail( mail message )";
"  -- where `mail message' is in the same format as passed to :raw_sendmail";
if (caller == this)
this.queued_mail = {@this.queued_mail, {time(), args}};
if (!$code_utils:task_valid(this.queued_mail_task))
fork fid (3600)
this:send_queued_mail();
endfork
this.queued_mail_task = fid;
endif
return 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#72 Network Utilities:send_queued_mail this n/a this
"$network:send_queued_mail()";
"  -- tries to send the mail stored in the .queued_mail property";
while (queued_mail = this.queued_mail)
message = queued_mail[1];
if (!this:raw_sendmail(@message[2]))
this.queued_mail = setremove(this.queued_mail, message);
else
"wait an hour";
suspend(3600);
endif
endwhile
-------------------------------------------------------------------------------
#72 Network Utilities:tcp_wait this n/a this
"Copied from sendmail fix (#88079):tcp_wait by Lineman (#108318) Mon Feb  1 19:28:18 1999 PST";
{conn, ?timeout = 0} = args;
if (!caller_perms().wizard)
return E_PERM;
elseif (timeout)
fork task (timeout)
boot_player(conn);
endfork
endif
while (1)
if (typeof(line = `read(conn) ! ANY') == ERR)
break;
elseif (match(line, "^[0-9][0-9][0-9] "))
timeout && `kill_task(task) ! ANY';
break;
endif
endwhile
return line;
-------------------------------------------------------------------------------
================================#73 Generic BigList Resident===============================================
#73 Generic BigList Resident.mowner rc = MOOObjRef #36
#73 Generic BigList Resident._mgr rc = MOOObjRef #13
#73 Generic BigList Resident._genprop rc = MOOString "a"
#73 Generic BigList Resident:_make this n/a this
":_make(...) => new node with value {...}";
if (!(caller in {this._mgr, this}))
return E_PERM;
endif
prop = this:_genprop();
add_property(this, prop, args, {$generic_biglist_home.owner, ""});
return prop;
-------------------------------------------------------------------------------
#73 Generic BigList Resident:_kill this n/a this
":_kill(node) destroys the given node.";
if (!(caller in {this, this._mgr}))
return E_PERM;
endif
delete_property(this, args[1]);
-------------------------------------------------------------------------------
#73 Generic BigList Resident:_get this n/a this
return (caller == this._mgr) ? this.(args[1]) | E_PERM;
-------------------------------------------------------------------------------
#73 Generic BigList Resident:_put this n/a this
return (caller == this._mgr) ? this.(args[1]) = listdelete(args, 1) | E_PERM;
-------------------------------------------------------------------------------
#73 Generic BigList Resident:_genprop this n/a this
gp = this._genprop;
ngp = "";
for i in [1..length(gp)]
if (gp[i] != "z")
ngp = (ngp + "bcdefghijklmnopqrstuvwxyz"[strcmp(gp[i], "`")]) + gp[i + 1..$];
return " " + (this._genprop = ngp);
endif
ngp = ngp + "a";
endfor
return " " + (this._genprop = ngp + "a");
-------------------------------------------------------------------------------
#73 Generic BigList Resident:_ord this n/a this
"this is a dummy. You have to decide what your leaves are going to look like and then write this verb accordingly.  It should, given a leaf/list-element, return the corresponding key value.  So for an ordinary alist, where all of the leaves are of the form {key,datum}, you want:";
return args[1][1];
-------------------------------------------------------------------------------
#73 Generic BigList Resident:init_for_core this n/a this
if (!caller_perms().wizard)
return E_PERM;
endif
pass(@args);
this.mowner = $hacker;
this._mgr = $biglist;
-------------------------------------------------------------------------------
================================#74 Generic Feature Object===============================================
#74 Generic Feature Object.feature_ok r = MOONumber 1
#74 Generic Feature Object.feature_verbs r = MOOList [ "Using" ]
#74 Generic Feature Object.warehouse r = MOOObjRef #83
#74 Generic Feature Object.help_msg rc = MOOString "The Generic Feature Object--not to be used as a feature object."
#74 Generic Feature Object:help_msg this n/a this
all_help = this.help_msg;
if (typeof(all_help) == STR)
all_help = {all_help};
endif
helpless = {};
for vrb in (this.feature_verbs)
if (loc = $object_utils:has_verb(this, vrb))
loc = loc[1];
help = $code_utils:verb_documentation(loc, vrb);
if (help)
all_help = {@all_help, "", tostr(loc, ":", verb_info(loc, vrb)[3]), @help};
else
helpless = {@helpless, vrb};
endif
endif
endfor
if (helpless)
all_help = {@all_help, "", ("No help found on " + $string_utils:english_list(helpless, "nothing", " or ")) + "."};
endif
return {@all_help, "----"};
-------------------------------------------------------------------------------
#74 Generic Feature Object:look_self this n/a this
"Definition from #1";
desc = this:description();
if (desc)
player:tell_lines(desc);
else
player:tell("You see nothing special.");
endif
player:tell("Please type \"help ", this, "\" for more information.");
-------------------------------------------------------------------------------
#74 Generic Feature Object:using this this n/a this
"Proper usage for the Generic Feature Object:";
"";
"First of all, the Generic Feature Object is constructed with the idea";
"that its children will be @moved to #24300, which is kind of a warehouse";
"for feature objects.  If there's enough interest, I'll try to make the";
"stuff that works with that in mind optional.";
"";
"Make a short description.  This is so I can continue to have looking at";
"#24300 give the descriptions of each of the objects in its .contents.";
"The :look_msg automatically includes a pointer to `help <this object>',";
"so you don't have to.";
"";
"Put a list of the commands you want people to use in";
"<this object>.feature_verbs.  (You need to use the :set_feature_verbs";
"verb to do this.)";
"";
"When someone types `help <this object>', they will be told the comment";
"strings from each of the verbs named in .feature_verbs.";
-------------------------------------------------------------------------------
#74 Generic Feature Object:examine_commands_ok this n/a this
return this in args[1].features;
-------------------------------------------------------------------------------
#74 Generic Feature Object:set_feature_ok this n/a this
if ($perm_utils:controls(caller_perms(), this) || (caller == this))
return this.feature_ok = args[1];
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#74 Generic Feature Object:hidden_verbs this n/a this
"Can't see `get' unless it's in the room; can't see `drop' unless it's in the player.  Should possibly go on $thing.";
"Should use :contents, but I'm in a hurry.";
hidden = pass(@args);
if (this.location != args[1])
hidden = setadd(hidden, {$thing, verb_info($thing, "drop")[3], {"this", "none", "none"}});
hidden = setadd(hidden, {$thing, verb_info($thing, "give")[3], {"this", "at/to", "any"}});
endif
if (this.location != args[1].location)
hidden = setadd(hidden, {$thing, verb_info($thing, "get")[3], {"this", "none", "none"}});
endif
return hidden;
-------------------------------------------------------------------------------
#74 Generic Feature Object:set_feature_verbs this n/a this
if ($perm_utils:controls(caller_perms(), this) || (caller == this))
return this.feature_verbs = args[1];
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#74 Generic Feature Object:initialize this n/a this
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
pass(@args);
this.feature_verbs = {};
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#74 Generic Feature Object:init_for_core this n/a this
if (($code_utils:verb_location() == this) && caller_perms().wizard)
this.warehouse = $feature_warehouse;
`delete_property(this, "guest_ok") ! ANY';
`delete_verb(this, "set_ok_for_guest_use") ! ANY';
pass(@args);
endif
-------------------------------------------------------------------------------
#74 Generic Feature Object:feature_remove this n/a this
"This is just a blank verb definition to encourage others to use this verb name if they care when a user is no longer using that feature.";
-------------------------------------------------------------------------------
#74 Generic Feature Object:player_connected this n/a this
return;
-------------------------------------------------------------------------------
#74 Generic Feature Object:has_feature_verb this n/a this
":has_feature_verb(verb, dlist, plist, ilist)";
"If this feature has a feature verb that matches <verb> and whose {dobj, prep, iobj} arguments match the possibilities listed in <dlist>, <plist> and <ilist>, then return the name of that verb, otherwise return false.";
"Note: Individual FOs may over-ride this the method to redirect particular feature verbs to different verbs on the object. For example, 'sit with <any>' and 'sit on <any>' could be directed to separate :sit_with() and :sit_on() verbs -- which is something that the code below cannot do.";
{vrb, dlist, plist, ilist} = args;
if (`valid(loc = $object_utils:has_callable_verb(this, vrb)[1]) ! ANY => 0')
vargs = verb_args(loc, vrb);
if ((vargs[2] in plist) && ((vargs[1] in dlist) && (vargs[3] in ilist)))
return vrb;
endif
endif
return 0;
-------------------------------------------------------------------------------
================================#75 Gopher utilities===============================================
#75 Gopher utilities.cache_values r = MOOList [ ]
#75 Gopher utilities.cache_timeout r = MOONumber 900
#75 Gopher utilities.frozen rc = MOONumber 0
#75 Gopher utilities.cache_times r = MOOList [ ]
#75 Gopher utilities.cache_requests r = MOOList [ ]
#75 Gopher utilities.limit rc = MOONumber 2000
#75 Gopher utilities:get_now this n/a this
"Usage:  get_now(site, port, message)";
"Returns a list of strings, or an error if we couldn't connect.";
{host, port, message, ?extra = {0}} = args;
if (!this:trusted(caller_perms()))
return E_PERM;
elseif ((!match(host, $network.valid_host_regexp)) && (!match(host, "[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+")))
"allow either welformed internet hosts or explicit IP addresses.";
return E_INVARG;
elseif ((port < 100) && (!(port in {13, 70, 80, 81, 79})))
"I added port 13, which is used for atomic clock servers. -Krate";
"disallow connections to low number ports; necessary?";
return E_INVARG;
endif
opentime = time();
con = $network:open(host, port);
opentime = time() - opentime;
if (typeof(con) == ERR)
return con;
endif
notify(con, message);
results = {};
count = this.limit;
"perhaps this isn't necessary, but if a gopher source is slowly spewing things, perhaps we don't want to hang forever -- perhaps this should just fork a process to close the connection instead?";
now = time();
timeout = 30;
end = "^%.$";
if (extra[1] == "2")
end = "^[2-9]";
endif
while ((((typeof(string = `read(con) ! ANY') == STR) && (!match(string, end))) && ((count = count - 1) > 0)) && ((now + timeout) > (now = time())))
if (string && (string[1] == "."))
string = string[2..$];
endif
results = {@results, string};
endwhile
$network:close(con);
if (opentime > 0)
"This is to keep repeated calls to $network:open to 'slow responding hosts' from totally spamming.";
suspend(0);
endif
return results;
-------------------------------------------------------------------------------
#75 Gopher utilities:parse this n/a this
"parse gopher result line:";
"return {host, port, tag, label}";
"host/port/tag are what you send to the gopher server to get that line";
"label is <type>/human readable entry";
{string} = args;
tab = index(string, "	");
label = string[1..tab - 1];
string = string[tab + 1..$];
tab = index(string, "	");
tag = string[1..tab - 1];
string = string[tab + 1..$];
tab = index(string, "	");
host = string[1..tab - 1];
if (host[$] == ".")
host = host[1..$ - 1];
endif
string = string[tab + 1..$];
tab = index(string, "	");
port = toint(tab ? string[1..tab - 1] | string);
return {host, port, tag, label};
"ignore extra material after port, if any";
-------------------------------------------------------------------------------
#75 Gopher utilities:show_text this n/a this
"$gopher:show_text(who, start, end, ..node..)";
"like who:notify_lines($gopher:get(..node..)[start..end]), but pipelined";
if (!caller_perms().wizard)
return E_PERM;
endif
{who, start, end, @args} = args;
con = $network:open(who, start);
if (typeof(con) == ERR)
player:tell("Sorry, can't get this information now.");
return;
endif
notify(con, end);
line = 0;
sent = 0;
end = end || this.limit;
while (((string = `read(con) ! ANY') != ".") && (typeof(string) == STR))
line = line + 1;
if ((line >= start) && ((!end) || (line <= end)))
sent = sent + 1;
if (valid(who))
if (string && (string[1] == "."))
string = string[2..$];
endif
who:notify(string);
else
notify(who, string);
endif
endif
endwhile
$network:close(con);
return sent;
-------------------------------------------------------------------------------
#75 Gopher utilities:type this n/a this
type = args[1];
if (type == "1")
return "menu";
elseif (type == "?")
return "menu?";
elseif (type == "0")
return "text";
elseif (type == "7")
return "search";
elseif (type == "9")
return "binary";
elseif (type == "2")
return "phone directory";
elseif (type == "4")
return "binhex";
elseif (type == "8")
return "telnet";
elseif (type == "I")
return "image";
elseif (type == " ")
"not actually gopher protocol: used by 'goto'";
return "";
else
return "unknown";
endif
"not done, need to fill out";
-------------------------------------------------------------------------------
#75 Gopher utilities:summary this n/a this
"return a 'nice' string showing the information in a gopher node";
if (typeof(parse = args[1]) == STR)
parse = this:parse(parse);
endif
if (parse[1] == "!")
return {"[remembered set]", "", ""};
endif
if (length(parse) > 3)
label = parse[4];
if (label)
type = $gopher:type(label[1]);
label = label[2..$];
if (type == "menu")
elseif (type == "search")
label = (("<" + parse[3][rindex(parse[3], "	") + 1..$]) + "> ") + label;
else
label = (type + ": ") + label;
endif
else
label = "(top)";
endif
else
label = parse[3] + " (top)";
endif
port = "";
if (parse[2] != 70)
port = tostr(" ", parse[2]);
endif
return {tostr("[", parse[1], port, "]"), label, parse[3]};
-------------------------------------------------------------------------------
#75 Gopher utilities:get this n/a this
"Usage: get(site, port, selection)";
"returns a list of strings, or an error if it couldn't connect. Results are cached.";
if (this.frozen)
return E_QUOTA;
endif
request = args[1..3];
while ((index = request in this.cache_requests) && (this.cache_times[index] > time()))
if (typeof(result = this.cache_values[index]) != INT)
return result;
endif
if ($code_utils:task_valid(result))
"spin, let other process getting same data win, or timeout";
suspend(1);
else
"well, other process crashed, or terminated, or whatever.";
this.cache_times[index] = 0;
endif
endwhile
if (!this:trusted(caller_perms()))
return E_PERM;
endif
while (this.cache_times && (this.cache_times[1] < time()))
$command_utils:suspend_if_needed(0);
this.cache_times = listdelete(this.cache_times, 1);
this.cache_values = listdelete(this.cache_values, 1);
this.cache_requests = listdelete(this.cache_requests, 1);
"caution: don't want to suspend between test and removal";
endwhile
$command_utils:suspend_if_needed(0);
this:cache_entry(@request);
value = this:get_now(@args);
$command_utils:suspend_if_needed(0);
index = this:cache_entry(@request);
this.cache_times[index] = time() + ((typeof(value) == ERR) ? 120 | 1800);
this.cache_values[index] = value;
return value;
-------------------------------------------------------------------------------
#75 Gopher utilities:clear_cache this n/a this
if (!this:trusted(caller_perms()))
return E_PERM;
endif
if (!args)
this.cache_values = this.cache_times = this.cache_requests = {};
elseif (index = args[1..3] in this.cache_requests)
this.cache_requests = listdelete(this.cache_requests, index);
this.cache_times = listdelete(this.cache_times, index);
this.cache_values = listdelete(this.cache_values, index);
endif
-------------------------------------------------------------------------------
#75 Gopher utilities:unparse this n/a this
"unparse(host, port, tag, label) => string";
{host, port, tag, label} = args;
if (tab = index(tag, "	"))
"remove search terms from search nodes";
tag = tag[1..tab - 1];
endif
return tostr(label, "	", tag, "	", host, "	", port);
-------------------------------------------------------------------------------
#75 Gopher utilities:interpret_error this n/a this
"return an explanation for a 'false' $gopher:get result";
value = args[1];
if (value == E_INVARG)
return "That gopher server is not reachable or is not responding.";
elseif (value == E_QUOTA)
return "Gopher connections cannot be made at this time because of system resource limitations!";
elseif (typeof(value) == ERR)
return tostr("The gopher request results in an error: ", value);
else
return "The gopher request has no results.";
endif
-------------------------------------------------------------------------------
#75 Gopher utilities:trusted this n/a this
"default -- gopher trusts everybody";
return 1;
-------------------------------------------------------------------------------
#75 Gopher utilities:_textp this n/a this
"_textp(parsed node)";
"Return true iff the parsed info points to a text node.";
return index("02", args[1][4][1]);
-------------------------------------------------------------------------------
#75 Gopher utilities:_mail_text this n/a this
"_mail_text(parsed node)";
"Return the text to be mailed out for the given node.";
where = args[1];
if (this:_textp(where))
return $gopher:get(@where);
else
text = {};
for x in ($gopher:get(@where))
parse = $gopher:parse(x);
sel = parse[4];
text = {@text, "Type=" + sel[1], "Name=" + sel[2..$], "Path=" + parse[3], "Host=" + parse[1], "Port=" + tostr(parse[2]), "#"};
endfor
return text;
endif
-------------------------------------------------------------------------------
#75 Gopher utilities:init_for_core this n/a this
if (caller_perms().wizard)
this:clear_cache();
pass(@args);
endif
-------------------------------------------------------------------------------
#75 Gopher utilities:display_cache this n/a none
"Just for debugging -- shows what's in the gopher cache";
req = this.cache_requests;
tim = this.cache_times;
val = this.cache_values;
"save values in case cache changes while printing";
player:tell("size -- expires -- host (port) ------ selector ------------");
for i in [1..length(req)]
re = req[i];
host = $string_utils:left(re[1] + ((re[2] == 70) ? "" | tostr(" (", re[2], ")")), 24);
expires = $string_utils:right($time_utils:dhms(tim[i] - time()), 8);
va = val[i];
if (typeof(va) == LIST)
va = length(va);
elseif (typeof(va) == ERR)
va = toliteral(va);
else
va = tostr(va);
endif
selector = re[3];
if (length(selector) > 40)
selector = "..." + selector[$ - 37..$];
endif
player:tell($string_utils:right(va, 8), expires, " ", host, selector);
endfor
player:tell("--- end cache display -------------------------------------");
-------------------------------------------------------------------------------
#75 Gopher utilities:get_cache this n/a this
"Usage: get_cache(site, port, selection)";
"return current cache";
request = args[1..3];
if (index = request in this.cache_requests)
if (this.cache_times[index] > now)
return this.cache_values[index];
endif
endif
return 0;
-------------------------------------------------------------------------------
#75 Gopher utilities:cache_entry this n/a this
if (index = args in this.cache_requests)
return index;
else
this.cache_times = {@this.cache_times, time() + 240};
this.cache_values = {@this.cache_values, task_id()};
this.cache_requests = {@this.cache_requests, args};
return length(this.cache_requests);
endif
-------------------------------------------------------------------------------
#75 Gopher utilities:help_msg this n/a this
return this:description();
-------------------------------------------------------------------------------
#75 Gopher utilities:daily this n/a this
if (caller_perms().wizard)
day = 24 * 3600;
hour_of_day_GMT = 10;
fork ((((hour_of_day_GMT * 60) * 60) + day) - (time() % day))
this:daily();
endfork
"  this.frozen = 1";
this:clear_cache();
"  suspend(3900)";
this.frozen = 0;
endif
-------------------------------------------------------------------------------
#75 Gopher utilities:get_now_EXPERIMENTAL this n/a this
"Copied from Sleeper (#98232):get_now Thu Oct  2 17:15:49 2003 PDT";
"Copied from Gopher utilities (#15357):get_now by Retired-Wizard-1 (#49853) Thu Oct  2 16:57:12 2003 PDT";
"Usage:  get_now(site, port, message)";
"Returns a list of strings, or an error if we couldn't connect.";
{host, port, message, ?extra = {0}} = args;
if (!this:trusted(caller_perms()))
return E_PERM;
elseif ((!match(host, $network.valid_host_regexp)) && (!match(host, "[0-9]+%.[0-9]+%.[0-9]+%.[0-9]+")))
"allow either welformed internet hosts or explicit IP addresses.";
return E_INVARG;
elseif ((port < 100) && (!(port in {13, 70, 80, 81, 79})))
"I added port 13, which is used for atomic clock servers. -Krate";
"disallow connections to low number ports; necessary?";
return E_INVARG;
endif
opentime = time();
con = $network:open(host, port);
opentime = time() - opentime;
if (typeof(con) == ERR)
return con;
endif
if (typeof(message) == LIST)
for line in (message)
notify(con, line);
endfor
else
notify(con, message);
endif
results = {};
count = this.limit;
"perhaps this isn't necessary, but if a gopher source is slowly spewing things, perhaps we don't want to hang forever -- perhaps this should just fork a process to close the connection instead?";
now = time();
timeout = 30;
end = "^%.$";
if (extra[1] == "2")
end = "^[2-9]";
endif
while ((((typeof(string = `read(con) ! ANY') == STR) && (!match(string, end))) && ((count = count - 1) > 0)) && ((now + timeout) > (now = time())))
if (string && (string[1] == "."))
string = string[2..$];
endif
results = {@results, string};
endwhile
$network:close(con);
if (opentime > 0)
"This is to keep repeated calls to $network:open to 'slow responding hosts' from totally spamming.";
suspend(0);
endif
return results;
-------------------------------------------------------------------------------
================================#76 Programmer Options===============================================
#76 Programmer Options.show_rmverb_mail_backup rc = MOOList [ "@rmverb does not email you a backup", "@rmverb emails you a backup before deleting the verb" ]
#76 Programmer Options.type_@prop_flags rc = MOOList [ 2 ]
#76 Programmer Options.show_list_show_permissions rc = MOOList [ "@list does not display permissions in header", "@list displays permissions in header" ]
#76 Programmer Options.show_list_all_parens rc = MOOList [ "@list shows only necessary parentheses by default", "@list shows all parentheses by default" ]
#76 Programmer Options.show_eval_time rc = MOOList [ "eval does not show ticks/seconds consumed.", "eval shows ticks/seconds consumed." ]
#76 Programmer Options.show_list_no_numbers rc = MOOList [ "@list gives line numbers by default", "@list omits line numbers by default" ]
#76 Programmer Options.show_copy_expert rc = MOOList [ "@copy prints warning message.", "@copy omits warning message." ]
#76 Programmer Options:actual this n/a this
if (i = args[1] in {"list_numbers"})
return {{{"list_no_numbers"}[i], !args[2]}};
else
return {args};
endif
-------------------------------------------------------------------------------
#76 Programmer Options:show this n/a this
if (o = (name = args[2]) in {"list_numbers"})
args[2] = {"list_no_numbers"}[o];
return {@pass(@args), tostr("(", name, " is a synonym for -", args[2], ")")};
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#76 Programmer Options:show_verb_args this n/a this
if (value = this:get(@args))
return {value, {tostr("Default args for @verb:  ", $string_utils:from_list(value, " "))}};
else
return {0, {"Default args for @verb:  none none none"}};
endif
-------------------------------------------------------------------------------
#76 Programmer Options:check_verb_args this n/a this
value = args[1];
if (typeof(value) != LIST)
return "List expected";
elseif (length(value) != 3)
return "List of length 3 expected";
elseif (!(value[1] in {"this", "none", "any"}))
return tostr("Invalid dobj specification:  ", value[1]);
elseif (!((p = $code_utils:short_prep(value[2])) || (value[2] in {"none", "any"})))
return tostr("Invalid preposition:  ", value[2]);
elseif (!(value[3] in {"this", "none", "any"}))
return tostr("Invalid iobj specification:  ", value[3]);
else
if (p)
value[2] = p;
endif
return {value};
endif
-------------------------------------------------------------------------------
#76 Programmer Options:parse_verb_args this n/a this
{oname, raw, data} = args;
if (typeof(raw) == STR)
raw = $string_utils:explode(raw, " ");
elseif (typeof(raw) == INT)
return raw ? {oname, {"this", "none", "this"}} | {oname, 0};
endif
value = $code_utils:parse_argspec(@raw);
if (typeof(value) != LIST)
return tostr(value);
elseif (value[2])
return tostr("I don't understand \"", $string_utils:from_list(value[2], " "), "\"");
else
value = {@value[1], "none", "none", "none"}[1..3];
return {oname, (value == {"none", "none", "none"}) ? 0 | value};
endif
-------------------------------------------------------------------------------
#76 Programmer Options:show_@prop_flags this n/a this
value = this:get(@args);
if (value)
return {value, {tostr("Default permissions for @property=`", value, "'.")}};
else
return {0, {"Default permissions for @property=`rc'."}};
endif
-------------------------------------------------------------------------------
#76 Programmer Options:check_@prop_flags this n/a this
#76 Programmer Options:parse_@prop_flags this n/a this
{oname, raw, data} = args;
if (typeof(raw) != STR)
return "Must be a string composed of the characters `rwc'.";
endif
len = length(raw);
for x in [1..len]
if (!(raw[x] in {"r", "w", "c"}))
return "Must be a string composed of the characters `rwc'.";
endif
endfor
return {oname, raw};
-------------------------------------------------------------------------------
================================#77 Builder Options===============================================
#77 Builder Options.show_audit_bytes r = MOOList [ "@audit/@prospectus shows `<1K'", "@audit/@prospectus shows bytes" ]
#77 Builder Options.show_audit_float r = MOOList [ "@audit/@prospectus shows integer sizes (1K)", "@audit/@prospectus shows floating-point sizes (1.0K)" ]
#77 Builder Options.show_bi_create rc = MOOList [ "@create/@recycle re-use object numbers.", "@create/@recycle call create()/recycle() directly." ]
#77 Builder Options.type_dig_room rc = MOOList [ 1 ]
#77 Builder Options.type_dig_exit rc = MOOList [ 1 ]
#77 Builder Options:check_create_flags this n/a this
value = args[1];
if (m = match(value, "[^rwf]"))
return tostr("Unknown object flag:  ", value[m[1]]);
else
return {tostr(index(value, "r") ? "r" | "", index(value, "w") ? "w" | "", index(value, "f") ? "f" | "")};
endif
-------------------------------------------------------------------------------
#77 Builder Options:show_create_flags this n/a this
if (value = this:get(@args))
return {value, {tostr("Object flags for @create:  ", value)}};
else
return {0, {tostr("@create leaves all object flags reset")}};
endif
-------------------------------------------------------------------------------
#77 Builder Options:parse_create_flags this n/a this
raw = args[2];
if (raw == 1)
"...+create_flags => create_flags=r";
return {args[1], "r"};
elseif (typeof(raw) == STR)
return args[1..2];
elseif (typeof(raw) != LIST)
return "???";
elseif (length(raw) > 1)
return tostr("I don't understand \"", $string_utils:from_list(listdelete(raw, 1), " "), "\"");
else
return {args[1], raw[1]};
endif
-------------------------------------------------------------------------------
#77 Builder Options:show_dig_room show_dig_exit this n/a this
name = args[2];
what = (verb == "show_dig_room") ? "room" | "exit";
if ((value = this:get(args[1], name)) == 0)
return {0, {tostr("@dig ", what, "s are children of $", what, ".")}};
else
return {value, {tostr("@dig ", what, "s are children of ", value, " (", valid(value) ? value.name | "invalid", ").")}};
endif
-------------------------------------------------------------------------------
#77 Builder Options:parse_dig_room parse_dig_exit this n/a this
{oname, raw, data} = args;
if (typeof(raw) == LIST)
if (length(raw) > 1)
return tostr("I don't understand \"", $string_utils:from_list(listdelete(raw, 1), " "), "\".");
endif
raw = raw[1];
endif
if (typeof(raw) != STR)
return "You need to give an object id.";
elseif ($command_utils:object_match_failed(value = player:my_match_object(raw), raw))
return "Option unchanged.";
endif
what = (verb == "parse_dig_room") ? "room" | "exit";
generic = #0.(what);
if (value == generic)
return {oname, 0};
else
if (!$object_utils:isa(value, generic))
player:tell("Warning: ", value, " is not a descendant of $", what, ".");
endif
return {oname, value};
endif
-------------------------------------------------------------------------------
================================#78 Generic Utilities Package===============================================
#78 Generic Utilities Package.help_msg rc = MOOList [ "This is the Generic Utility Object.  One presumes it should have text in it explaining the use of the utility object in question." ]
================================#79 Byte Quota Utilities===============================================
#79 Byte Quota Utilities.large_negative_number rc = MOONumber -10000
#79 Byte Quota Utilities.large_objects rc = MOOList [ #32 ]
#79 Byte Quota Utilities.working rc = MOOObjRef #2
#79 Byte Quota Utilities.task_repeat rc = MOONumber 1
#79 Byte Quota Utilities.too_large rc = MOONumber 1000000
#79 Byte Quota Utilities.default_quota rc = MOOList [ 20000, 0, 0, 1 ]
#79 Byte Quota Utilities.repeat_cycle rc = MOONumber 0
#79 Byte Quota Utilities.cycle_days rc = MOONumber 5
#79 Byte Quota Utilities.max_unmeasured rc = MOONumber 10
#79 Byte Quota Utilities.exempted rc = MOOList [ ]
#79 Byte Quota Utilities.measurement_task_running rc = MOONumber 0
#79 Byte Quota Utilities.unmeasured_multiplier rc = MOONumber 100
#79 Byte Quota Utilities.report_recipients rc = MOOList [ #2 ]
#79 Byte Quota Utilities.task_time_limit rc = MOONumber 500
#79 Byte Quota Utilities.byte_based rc = MOONumber 1
#79 Byte Quota Utilities:initialize_quota this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
args[1].size_quota = this.default_quota;
args[1].ownership_quota = this.large_negative_number;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:init_for_core this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
pass(@args);
this.exempted = {};
this.working = #2;
this.task_time_limit = 500;
this.repeat_cycle = 0;
this.large_objects = {};
this.report_recipients = {#2};
this.default_quota = {100000, 0, 0, 1};
$quota_utils = this;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:adjust_quota_for_programmer this n/a this
return 0;
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:bi_create this n/a this
set_task_perms(caller_perms());
who = this:parse_create_args(@args);
"Because who can be E_INVARG, need to catch E_TYPE. Let $recycler:_create deal with returning E_PERM since that's what's going to happen. Ho_Yan 11/19/96.";
if ((!`who.wizard ! E_TYPE => 0') && $recycler.contents)
return $recycler:_create(@args);
elseif (this:creation_permitted(who))
this:enable_create(who);
value = `create(@args) ! ANY';
this:disable_create(who);
if (typeof(value) != ERR)
this:charge_quota(who, value);
if ((typeof(who.owned_objects) == LIST) && (!(value in who.owned_objects)))
this:add_owned_object(who, value);
endif
endif
return value;
else
return E_QUOTA;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:enable_create this n/a this
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
args[1].ownership_quota = 1;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:disable_create this n/a this
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
args[1].ownership_quota = this.large_negative_number;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:parse_create_args this n/a this
"This figures out who is gonna own the stuff @create does.  If one arg, return caller_perms().  If two args, then if caller_perms().wizard, args[2].";
{what, ?who = #-1} = args;
if (!valid(who))
return caller_perms();
elseif ($perm_utils:controls(caller_perms(), who))
return who;
else
return E_INVARG;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:creation_permitted verb_addition_permitted property_addition_permitted this n/a this
"Here's the tricky one.  Collect all the user's characters' cached usage data and total quotas.  Compare same.  If usage bigger than quotas, return 0.  Else, add up the total number of objects that haven't been measured recently.  If greater than the allowed, return 0.  Else, reluctantly, return 1.";
who = args[1];
if (who.wizard || (who == $hacker))
"... sorry folks --Rog";
return 1;
endif
if ((!$object_utils:has_property(who, "size_quota")) || is_clear_property(who, "size_quota"))
return 0;
endif
$recycler:check_quota_scam(who);
allwho = this:all_characters(who);
quota = 0;
usage = 0;
unmeasured = 0;
for x in (allwho)
quota = quota + x.size_quota[1];
usage = usage + x.size_quota[2];
unmeasured = unmeasured + x.size_quota[4];
endfor
if (usage >= quota)
return 0;
elseif (unmeasured >= this.max_unmeasured)
return 0;
else
return 1;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:all_characters this n/a this
{who} = args;
if ((caller != this) && (!this:can_peek(caller_perms(), who)))
return E_PERM;
elseif ($object_utils:has_property($local, "second_char_registry"))
seconds = $local.second_char_registry:all_second_chars(who);
if (seconds == E_INVARG)
return {who};
else
return seconds;
endif
else
return {who};
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:display_quota this n/a this
who = args[1];
if (this:can_peek(caller_perms(), who) && (length(all = this:all_characters(who)) > 1))
many = 1;
else
many = 0;
all = {who};
endif
if (many)
tquota = 0;
tusage = 0;
ttime = $maxint;
tunmeasured = 0;
tunmeasurable = 0;
endif
for x in (all)
{quota, usage, timestamp, unmeasured} = x.size_quota;
unmeasurable = 0;
if (unmeasured >= 100)
unmeasurable = unmeasured / 100;
unmeasured = unmeasured % 100;
endif
if (many)
player:tell(x.name, " quota: ", $string_utils:group_number(quota), "; usage: ", $string_utils:group_number(usage), "; unmeasured: ", unmeasured, "; no .object_size: ", unmeasurable, ".");
tquota = tquota + quota;
tusage = tusage + usage;
ttime = min(ttime, timestamp);
tunmeasured = tunmeasured + unmeasured;
tunmeasurable = tunmeasurable + unmeasurable;
endif
endfor
if (many)
this:display_quota_summary(who, tquota, tusage, ttime, tunmeasured, tunmeasurable);
else
this:display_quota_summary(who, quota, usage, timestamp, unmeasured, unmeasurable);
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:get_quota this n/a this
return args[1].size_quota[1];
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:charge_quota this n/a this
"Charge args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
usage_index = 2;
unmeasured_index = 4;
object_size = $object_utils:has_property(what, "object_size") ? what.object_size[1] | -1;
if (object_size <= 0)
who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] + 1;
else
who.size_quota[usage_index] = who.size_quota[usage_index] + object_size;
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:reimburse_quota this n/a this
"reimburse args[1] for the quota required to own args[2]";
"If it is a $garbage, then if who = $hacker, then we mostly ignore everything.  Who cares what $hacker's quota looks like.";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
usage_index = 2;
unmeasured_index = 4;
if (parent(what) == $garbage)
return 0;
elseif (((valid(who) && is_player(who)) && $object_utils:has_property(what, "object_size")) && (!is_clear_property(who, "size_quota")))
object_size = what.object_size[1];
if (object_size <= 0)
who.size_quota[unmeasured_index] = who.size_quota[unmeasured_index] - 1;
else
who.size_quota[usage_index] = who.size_quota[usage_index] - object_size;
endif
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:set_quota this n/a this
"Set args[1]'s quota to args[2]";
if ((caller_perms().wizard || (caller == this)) || this:can_touch(caller_perms()))
"Size_quota[1] is the total quota permitted.";
return args[1].size_quota[1] = args[2];
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:get_size_quota this n/a this
"Return args[1]'s quotas.  second arg of 1 means add all second chars.";
{who, ?all = 0} = args;
if (all && ((caller == this) || this:can_peek(caller_perms(), who)))
all = this:all_characters(who);
else
all = {who};
endif
baseline = {0, 0, 0, 0};
for x in (all)
baseline[1] = baseline[1] + x.size_quota[1];
baseline[2] = baseline[2] + x.size_quota[2];
baseline[3] = min(baseline[3], x.size_quota[3]) || x.size_quota[3];
baseline[4] = baseline[4] + x.size_quota[4];
endfor
return baseline;
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:display_quota_summary this n/a this
{who, quota, usage, timestamp, unmeasured, unmeasurable} = args;
player:tell(who.name, " has a total building quota of ", $string_utils:group_number(quota), " bytes.");
player:tell($gender_utils:get_pronoun("P", who), " total usage was ", $string_utils:group_number(usage), " as of ", player:ctime(timestamp), ".");
if (usage > quota)
player:tell(who.name, " is over quota by ", $string_utils:group_number(usage - quota), " bytes.");
else
player:tell(who.name, " may create up to ", $string_utils:group_number(quota - usage), " more bytes of objects, properties, or verbs.");
endif
if (unmeasured)
plural = unmeasured != 1;
player:tell("There ", plural ? tostr("are ", unmeasured, " objects") | "is 1 object", " which ", plural ? "are" | "is", " not yet included in the tally; this tally may thus be inaccurate.");
if (unmeasured >= this.max_unmeasured)
player:tell("The number of unmeasured objects is too large; no objects may be created until @measure new is used.");
endif
endif
if (unmeasurable)
plural = unmeasurable != 1;
player:tell("There ", plural ? tostr("are ", unmeasurable, " objects") | "is 1 object", " which do", plural ? "" | "es", " not have a .object_size property and will thus prevent additional building.", (who == player) ? "  Contact a wizard for assistance in having this situation repaired." | "");
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:quota_remaining this n/a this
"This wants to only be called by a wizard cuz I'm lazy.  This is just for @second-char anyway.";
if (caller_perms().wizard)
q = this:get_size_quota(args[1], 1);
return q[1] - q[2];
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:preliminary_reimburse_quota this n/a this
"This does the reimbursement work of the recycler, since we ignore $garbage in ordinary reimbursement.";
if (caller_perms().wizard)
this:reimburse_quota(@args);
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:value_bytes this n/a this
return value_bytes(args[1]);
set_task_perms(caller_perms());
v = args[1];
t = typeof(v);
if (t == LIST)
b = ((length(v) + 1) * 2) * 4;
for vv in (v)
$command_utils:suspend_if_needed(2);
b = b + this:value_bytes(vv);
endfor
return b;
elseif (t == STR)
return length(v) + 1;
else
return 0;
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:object_bytes object_size this n/a this
"No need for lengthy algorithms to measure an object, we have a builtin now. Ho_Yan 10/31/96";
set_task_perms($wiz_utils:random_wizard());
o = args[1];
if (((($object_utils:has_property(o, "object_size") && (o.object_size[1] > this.too_large)) && (!caller_perms().wizard)) && (caller_perms() != this.owner)) && (caller_perms() != $hacker))
return o.object_size[1];
endif
b = object_bytes(o);
if ($object_utils:has_property(o, "object_size"))
oldsize = is_clear_property(o, "object_size") ? 0 | o.object_size[1];
if ($object_utils:has_property(o.owner, "size_quota"))
"Update quota cache.";
if (oldsize)
o.owner.size_quota[2] = o.owner.size_quota[2] + (b - oldsize);
else
o.owner.size_quota[2] = o.owner.size_quota[2] + b;
if (o.owner.size_quota[4] > 0)
o.owner.size_quota[4] = o.owner.size_quota[4] - 1;
endif
endif
endif
o.object_size = {b, time()};
endif
if (b > this.too_large)
this.large_objects = setadd(this.large_objects, o);
endif
return b;
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:do_summary any none this
who = args[1];
results = this:summarize_one_user(who);
{total, nuncounted, nzeros, oldest, eldest} = results;
player:tell(who.name, " statistics:");
player:tell("  ", $string_utils:group_number(total), " bytes of storage measured.");
player:tell("  Oldest measurement date ", ctime(oldest), " (", $string_utils:from_seconds(time() - oldest), " ago) of object ", eldest, " (", valid(eldest) ? eldest.name | "$nothing", ")");
if (nzeros || nuncounted)
player:tell("  Number of objects with no statistics recorded:  ");
player:tell("      ", nzeros, " recently created, ", nuncounted, " not descendents of #1");
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:summarize_one_user this n/a this
"Summarizes total space usage by one user (args[1]).  Optional second argument is a flag to say whether to re-measure all objects for this user; specify the number of seconds out of date you are willing to accept.  If negative, will only re-measure objects which have no recorded data.";
"Returns a list of four values:";
"  total : total measured space in bytes";
"  uncounted : Number of objects that were not counted because they aren't descendents of #1";
"  zeros : Number of objects which have been created too recently to have any measurement data at all (presumably none if re-measuring)";
"  most-out-of-date : the time() the oldest actual measurement was taken";
"  object-thereof: the object who had this time()'d measurement";
who = args[1];
if (length(args) == 2)
if (args[2] < 0)
earliest = 1;
else
earliest = time() - args[2];
endif
else
earliest = 0;
endif
nzeros = 0;
oldest = time();
eldest = #-1;
nuncounted = 0;
total = 0;
for x in ((typeof(who.owned_objects) == LIST) ? who.owned_objects | {})
if (x.owner == who)
"Bulletproofing against recycling during suspends!";
"Leaves us open to unsummarized creation during this period, which is unfortunate.";
if ($object_utils:has_property(x, "object_size"))
size = x.object_size[1];
time = x.object_size[2];
if (time < earliest)
"Re-measure.  This side-effects x.object_size.";
this:object_bytes(x);
size = x.object_size[1];
time = x.object_size[2];
endif
if (time && (time <= oldest))
oldest = time;
eldest = x;
elseif (!time)
nzeros = nzeros + 1;
endif
if (size >= 0)
total = total + size;
endif
else
nuncounted = nuncounted + 1;
endif
endif
$command_utils:suspend_if_needed(0);
endfor
if (!is_clear_property(who, "size_quota"))
"Cache the data, but only if they aren't scamming.";
who.size_quota[2] = total;
who.size_quota[3] = oldest;
who.size_quota[4] = (nuncounted * this.unmeasured_multiplier) + nzeros;
endif
return {total, nuncounted, nzeros, oldest, eldest};
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:recent_object_bytes this n/a this
":recent_object_bytes(x, n) -- return object size of x, guaranteed to be no more than n days old.  N defaults to this.cycle_days.";
{object, ?since = this.cycle_days} = args;
if (!valid(object))
return 0;
elseif (`object.object_size[2] ! ANY => 0' > (time() - (((since * 24) * 60) * 60)))
"Trap error when doesn't have .object_size for some oddball reason ($garbage). Ho_Yan 11/19/96";
return object.object_size[1];
else
return this:object_bytes(object);
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:measurement_task this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
start_time = time();
{num_processed, num_repetitions} = this:measurement_task_body(args[1]);
players = players();
lengthp = length(players);
if ((!num_repetitions) && (num_processed < (lengthp / 2)))
"Add this in because we aren't getting people summarized like we should.  We're going to work for way longer now, cuz we're going to do a second pass, but we really need to get those summaries done.  Only do this if we hardly did any work.  Note the -1 here: measure all newly created objects as well.  More work, sigh.";
extra_end = time() + (3600 * 3);
for x in (players)
if (is_player(x) && (time() < extra_end))
"Robustness as above, plus don't run all day.  My kingdom for a break statement";
this:summarize_one_user(x, -1);
endif
$command_utils:suspend_if_needed(0);
endfor
endif
$mail_agent:send_message(player, this.report_recipients, "quota-utils report", {tostr("About to measure objects of player ", this.working.name, " (", this.working, "), ", $string_utils:ordinal(this.working in players), " out of ", lengthp, ".  We processed ", num_processed + (lengthp * num_repetitions), " players in this run in ", num_repetitions, " time", (num_repetitions == 1) ? "" | "s", " through all players.  Total time spent:  ", $time_utils:dhms(time() - start_time), ".")});
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:can_peek this n/a this
return (args[1] == this.owner) || $perm_utils:controls(args[1], args[2]);
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:can_touch this n/a this
return args[1].wizard;
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:do_breakdown this n/a this
dobj = args[1];
who = valid(caller_perms()) ? caller_perms() | player;
if (!this:can_peek(who, dobj.owner))
return E_PERM;
endif
props = $object_utils:all_properties_suspended(dobj);
grand_total = obj_over = this:object_overhead_bytes(dobj);
output = {tostr("Object overhead:  ", obj_over)};
if (props)
total = 0;
lines = {};
output = {@output, "Properties, defined and inherited, sorted by size:"};
for x in (props)
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
if (!is_clear_property(dobj, x))
size = value_bytes(dobj.(x));
total = total + size;
if (size)
lines = {@lines, {x, size}};
endif
endif
endfor
lines = $list_utils:reverse_suspended($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));
for x in (lines)
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
text = tostr("  ", x[1], ":  ", x[2]);
output = {@output, text};
endfor
output = {@output, tostr("Total size of properties:  ", total)};
grand_total = grand_total + total;
endif
prop_over = this:property_overhead_bytes(dobj, props);
output = {@output, tostr("Property overhead:  ", prop_over)};
grand_total = grand_total + prop_over;
if (verbs(dobj))
output = {@output, "Verbs, sorted by size:"};
total = 0;
lines = {};
for x in [1..length(verbs(dobj))]
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
vname = verb_info(dobj, x)[3];
size = (value_bytes(verb_code(dobj, x, 0, 0)) + length(vname)) + 1;
total = total + size;
lines = {@lines, {vname, size}};
endfor
lines = $list_utils:reverse_suspended($list_utils:sort_suspended(0, lines, $list_utils:slice(lines, 2)));
for x in (lines)
$command_utils:suspend_if_needed(0, "...One moment. Working on the breakdown...");
text = tostr("  ", x[1], ":  ", x[2]);
output = {@output, text};
endfor
output = {@output, tostr("Total size of verbs:  ", total)};
grand_total = grand_total + total;
verb_over = this:verb_overhead_bytes(dobj);
output = {@output, tostr("Verb overhead:  ", verb_over)};
grand_total = grand_total + verb_over;
endif
output = {@output, tostr("Grand total:  ", grand_total)};
return output;
"Last modified Sun Dec 31 10:12:14 2006 PST, by Roebare (#109000) @ LM.";
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:object_overhead_bytes this n/a this
object = args[1];
return ((13 * 4) + length(object.name)) + 1;
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:property_overhead_bytes this n/a this
{o, ?ps = $object_utils:all_properties_suspended(o)} = args;
return (value_bytes(properties(o)) - 4) + ((length(ps) * 4) * 4);
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:verb_overhead_bytes this n/a this
o = args[1];
vs = verbs(o);
return (length(vs) * 5) * 4;
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:add_owned_object this n/a this
":add_owned_object(who, what) -- adds what to whose .owned_objects.";
{who, what} = args;
if ((typeof(who.owned_objects) == LIST) && (what.owner == who))
who.owned_objects = setadd(who.owned_objects, what);
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:measurement_task_nofork this n/a this
"This is a one-shot run of the measurement task, as opposed to :measurement_task, which will fork once per day.";
if (!caller_perms().wizard)
return E_PERM;
else
{num_processed, num_repetitions} = this:measurement_task_body();
$mail_agent:send_message(player, player, "quota-utils report", {"finished one shot run of measurement task: processed ", num_processed, " players in ", num_repetitions, " runs through all players."});
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:measurement_task_body this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
num_processed = 0;
num_repetitions = 0;
usage_index = 2;
time_index = 3;
unmeasured_index = 4;
players = setremove(players(), $hacker);
lengthp = length(players);
index = this.working in players;
keep_going = 1;
if (!index)
"Uh, oh, our guy got reaped while we weren't looking.  Better look for someone else.";
index = 1;
while ((this.working > players[index]) && (index < lengthp))
$command_utils:suspend_if_needed(0);
index = index + 1;
endwhile
this.working = players[index];
endif
day = (60 * 60) * 24;
stop = time() + args[1];
early = time() - (day * this.cycle_days);
tooidle = day * this.cycle_days;
"tooidletime is only used if !this.repeat_cycle.";
tooidletime = time() - tooidle;
local_per_player_hack = $object_utils:has_verb($local, "per_player_daily_scan");
while ((time() < stop) && keep_going)
who = players[index];
if (is_player(who) && $object_utils:has_property(who, "size_quota"))
"Robustness in the face of reaping...";
if ((!this.repeat_cycle) || ((who.last_disconnect_time > tooidletime) && (who.last_disconnect_time != $maxint)))
"only measure people who login regularly if we're a big moo.";
usage = 0;
unmeasured = 0;
earliest = time();
for o in (who.owned_objects)
if ((valid(o) && (o.owner == who)) && (!(o in this.exempted)))
"sanity check: might have recycled while we suspended!";
if ($object_utils:has_property(o, "object_size"))
if (o.object_size[2] < early)
usage = usage + this:object_bytes(o);
else
usage = usage + o.object_size[1];
earliest = min(earliest, o.object_size[2]);
endif
else
unmeasured = unmeasured + 1;
endif
endif
$command_utils:suspend_if_needed(3);
endfor
if (!is_clear_property(who, "size_quota"))
who.size_quota[usage_index] = usage;
who.size_quota[unmeasured_index] = this.unmeasured_multiplier * unmeasured;
who.size_quota[time_index] = earliest;
else
$mail_agent:send_message(player, player, "Quota Violation", {tostr(who, " has a clear .size_quota property."), $string_utils:names_of({who, @$object_utils:ancestors(who)})});
endif
elseif (who.size_quota[unmeasured_index])
"If they managed to create an object *despite* being too idle (presumably programmatically), measure it.";
this:summarize_one_user(who, -1);
endif
elseif (is_player(who))
"They don't have a size_quota property.  Whine.";
$mail_agent:send_message(player, player, "Quota Violation", {tostr(who, " doesn't seem to have a .size_quota property."), $string_utils:names_of({who, @$object_utils:ancestors(who)})});
endif
if (local_per_player_hack)
$local:per_player_daily_scan(who);
endif
if (index >= lengthp)
index = 1;
else
index = index + 1;
endif
num_processed = num_processed + 1;
if (num_processed > lengthp)
if (this.repeat_cycle)
"If we've gotten everyone up to threshold, try measuring some later than that.";
early = early + ((24 * 60) * 60);
tooidle = tooidle * 4;
tooidletime = tooidletime - tooidle;
num_repetitions = num_repetitions + 1;
num_processed = 0;
if (early > time())
"Don't spin our wheels when we've measured everything!";
keep_going = 0;
endif
else
keep_going = 0;
endif
endif
this.working = players[index];
endwhile
return {num_processed, num_repetitions};
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:schedule_measurement_task this n/a this
if ((caller == this) || caller_perms().wizard)
day = 24 * 3600;
hour_of_day_GMT = 8;
fork ((((hour_of_day_GMT * 60) * 60) + day) - (time() % day))
this:schedule_measurement_task();
this.measurement_task_running = task_id();
this:measurement_task(this.task_time_limit);
this.measurement_task_running = 0;
endfork
endif
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:task_perms this n/a this
"Put all your wizards in $byte_quota_utils.wizards.  Then various long-running tasks will cycle among the permissions, spreading out the scheduler-induced personal lag.";
$wiz_utils.old_task_perms_user = setadd($wiz_utils.old_task_perms_user, caller);
return $wiz_utils:random_wizard();
-------------------------------------------------------------------------------
#79 Byte Quota Utilities:property_exists this n/a this
"this:property_exists(object, property)";
" => does the specified property exist?";
return !(!`property_info(@args) ! ANY');
-------------------------------------------------------------------------------
================================#80 @paranoid database===============================================
#80 @paranoid database.max_lines r = MOONumber 30
#80 @paranoid database:ensure_props_exist this n/a this
"*Must* be called with PDATA first, and LINES second.";
if ((caller != this) && (!caller_perms().wizard))
return E_PERM;
else
try
this.(args[2]);
except (E_PROPNF)
add_property(this, args[2], {}, {$hacker, ""});
endtry
try
this.(args[3]);
except (E_PROPNF)
add_property(this, args[3], 5, {$hacker, ""});
endtry
endif
-------------------------------------------------------------------------------
#80 @paranoid database:init_for_core this n/a this
if (!caller_perms().wizard)
return;
else
for x in (properties(this))
if (x[1] == "#")
delete_property(this, x);
endif
$command_utils:suspend_if_needed(0);
endfor
pass(@args);
endif
-------------------------------------------------------------------------------
#80 @paranoid database:add_data this n/a this
{who, newdata} = args;
if (is_player(who) && caller_perms().wizard)
"if ($perm_utils:controls(caller_perms(), who) && is_player(who))";
d = tostr(who, "pdata");
l = tostr(who, "lines");
this:ensure_props_exist(who, d, l);
data = this.(d);
lines = this.(l);
"Icky G7 code copied straight out of $player:tell.";
if (((len = length(this.(d) = {@data, newdata})) * 2) > (lines * 3))
this.(d) = this.(d)[(len - lines) + 1..len];
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#80 @paranoid database:get_data this n/a this
who = args[1];
if ($perm_utils:controls(caller_perms(), who))
d = tostr(who, "pdata");
if (typeof(`this.(d) ! ANY') == LIST)
return this.(d);
else
return {};
endif
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#80 @paranoid database:erase_data this n/a this
who = args[1];
if ($perm_utils:controls(caller_perms(), who))
d = tostr(who, "pdata");
"OK if this would toss its cookies if no prop, no damage.";
`this.(d) = {} ! ANY';
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#80 @paranoid database:set_kept_lines this n/a this
maximum = this.max_lines;
who = args[1];
if ($perm_utils:controls(caller_perms(), who) && is_player(who))
l = tostr(who, "lines");
this:ensure_props_exist(who, l, l);
kept = min(args[2], maximum);
this.(l) = kept;
return kept;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#80 @paranoid database:gc this n/a this
if ((((caller != this) && (caller_perms() != #-1)) && (caller_perms() != player)) || (!player.wizard))
$error:raise(E_PERM);
endif
threshold = ((60 * 60) * 24) * 3;
for x in (properties(this))
if (x[1] == "#")
l = length(x);
who = toobj(x[1..l - 5]);
if (((!valid(who)) || (!is_player(who))) || (!this:is_paranoid(who)))
delete_property(this, x);
else
if (index(x, "lines"))
if (typeof(this.(x)) != INT)
this.(x) = 10;
endif
elseif (index(x, "pdata"))
if (((!$object_utils:connected(who)) && (who.last_disconnect_time < (time() - threshold))) && (who.last_connect_time < (time() - threshold)))
this.(x) = {};
endif
if (typeof(this.(x)) != LIST)
this.(x) = {};
endif
endif
endif
endif
$command_utils:suspend_if_needed(0);
endfor
-------------------------------------------------------------------------------
#80 @paranoid database:help_msg this n/a this
return this:description();
-------------------------------------------------------------------------------
#80 @paranoid database:semiweeklyish this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
threedays = (3 * 24) * 3600;
fork ((((7 * 60) * 60) + threedays) - (time() % threedays))
this:(verb)();
endfork
this:gc();
endif
-------------------------------------------------------------------------------
#80 @paranoid database:is_paranoid this n/a this
"Some people make their .paranoid !r.  Wizardly verb to retrieve value.";
return `args[1].paranoid ! ANY';
-------------------------------------------------------------------------------
================================#81 Object Quota Utilities===============================================
#81 Object Quota Utilities.byte_based rc = MOONumber 0
#81 Object Quota Utilities:initialize_quota this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
args[1].ownership_quota = $wiz_utils.default_player_quota;
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:init_for_core this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
pass(@args);
"Uncomment this if you want to send the core out with object quota.";
"  $quota_utils = this";
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:adjust_quota_for_programmer this n/a this
if (!caller_perms().wizard)
return E_PERM;
else
victim = args[1];
oldquota = victim.ownership_quota;
if ($object_utils:has_property($local, "second_char_registry") && $local.second_char_registry:is_second_char(victim))
"don't increment quota for 2nd chars when programmering";
victim.ownership_quota = oldquota;
else
victim.ownership_quota = oldquota + ($wiz_utils.default_programmer_quota - $wiz_utils.default_player_quota);
endif
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:bi_create this n/a this
"Calls built-in create.";
set_task_perms(caller_perms());
return `create(@args) ! ANY';
-------------------------------------------------------------------------------
#81 Object Quota Utilities:creation_permitted this n/a this
$recycler:check_quota_scam(args[1]);
return args[1].ownership_quota > 0;
-------------------------------------------------------------------------------
#81 Object Quota Utilities:verb_addition_permitted property_addition_permitted this n/a this
return 1;
-------------------------------------------------------------------------------
#81 Object Quota Utilities:display_quota this n/a this
who = args[1];
if (caller_perms() == who)
q = who.ownership_quota;
total = (typeof(who.owned_objects) == LIST) ? length(setremove(who.owned_objects, who)) | 0;
if (q == 0)
player:tell(tostr("You can't create any more objects", (total < 1) ? "." | tostr(" until you recycle some of the ", total, " you already own.")));
else
player:tell(tostr("You can create ", q, " new object", (q == 1) ? "" | "s", (total == 0) ? "." | tostr(" without recycling any of the ", total, " that you already own.")));
endif
else
if ($perm_utils:controls(caller_perms(), who))
player:tell(tostr(who.name, "'s quota is currently ", who.ownership_quota, "."));
else
player:tell("Permission denied.");
endif
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:get_quota quota_remaining this n/a this
if ($perm_utils:controls(caller_perms(), args[1]) || (caller == this))
return args[1].ownership_quota;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:charge_quota this n/a this
"Charge args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
who.ownership_quota = who.ownership_quota - 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:reimburse_quota this n/a this
"Reimburse args[1] for the quota required to own args[2]";
{who, what} = args;
if ((caller == this) || caller_perms().wizard)
who.ownership_quota = who.ownership_quota + 1;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:set_quota this n/a this
"Set args[1]'s quota to args[2]";
{who, quota} = args;
if (caller_perms().wizard || (caller == this))
return who.ownership_quota = quota;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#81 Object Quota Utilities:preliminary_reimburse_quota this n/a this
return 0;
-------------------------------------------------------------------------------
#81 Object Quota Utilities:can_peek this n/a this
"Is args[1] permitted to examine args[2]'s quota information?";
return $perm_utils:controls(args[1], args[2]);
-------------------------------------------------------------------------------
#81 Object Quota Utilities:can_touch this n/a this
"Is args[1] permitted to examine args[2]'s quota information?";
return args[1].wizard;
-------------------------------------------------------------------------------
================================#82 Server Options===============================================
#82 Server Options.protect_set_verb_info rc = MOONumber 1
#82 Server Options.protect_set_property_info r = MOONumber 1
#82 Server Options.protect_force_input rc = MOONumber 1
#82 Server Options.queued_task_limit rc = MOONumber 300
#82 Server Options.protect_add_property rc = MOONumber 1
#82 Server Options.support_numeric_verbname_strings r = MOONumber 0
#82 Server Options.connect_msg rc = MOOString "*** Connected ***"
#82 Server Options.protect_recycle rc = MOONumber 1
#82 Server Options.help_msg rc = MOOList [ "                Server Options <$server_options>", "                --------------------------------", "", "messages: 'boot_msg', 'connect_msg', 'create_msg', 'recycle_msg', 'redirect_from_msg', 'redirect_to_msg', and 'timeout_msg'.", "A number of the messages printed to a connection by the server under various circumstances can now be customized or eliminated from within the DB.  In each case, a property on $server_options is checked at the time the message would be printed.  If the property does not exist, the standard message is printed.  If the property exists and its value is not a string, then no message is printed at all.  Otherwise, the string is printed in place of the standard message.  The following list covers all of the newly customizable messages, showing for each the name of the relevant property on $server_options, the default/standard message, and the circumstances under which the message is printed:", "'boot_msg'              "*** Disconnected ***"", "The function boot_player() was called on this connection.", "'connect_msg'           "*** Connected ***"", "The user object that just logged in on this connection existed before #0:do_login_command() was called.", "'create_msg'            "*** Created ***"", "The user object that just logged in on this connection did not exist before #0:do_login_command() was called.", "'recycle_msg'           "*** Recycled ***"", "The logged-in user of this connection has been recycled.", "'redirect_from_msg'     "*** Redirecting connection to new port ***"", "The logged-in user of this connection has just logged in on some other connection.", "'redirect_to_msg'       "*** Redirecting old connection to this port ***"", "The user who just logged in on this connection was already logged in on some other connection.", "'timeout_msg'           "*** Timed-out waiting for login. ***"", "This in-bound network connection was idle and un-logged-in for at least CONNECT_TIMEOUT seconds (as defined in options.h).", "", "Note: on a 1.8rN server, changes to $server_options will not take effect until load_server_options() has been called.", "", "", "Some properties on $server_options can change the server behavior:", "", "'bg_seconds', 'bg_ticks', 'fg_seconds', and 'fg_ticks'.", "If those properties exist and are numbers, the server use them instead of the constants DEFAULT_BG_SECONDS, DEFAULT_BG_TICKS, DEFAULT_FG_SECONDS and DEFAULT_FG_TICKS (respectively) defined at compile time in "options.h"; they are looked up anew every time a task begins or resumes execution. Those define ticks (basic operations)/real-time seconds any task is allowed to use without suspending. 'fg' constants/properties are used only for 'foreground' tasks (those started by either player input or the server's initiative and that have never suspended); the 'bg' constants/properties are used only for 'background' tasks (forked tasks and those of any kind that have suspended).", "", "'max_stack_depth' This allow to change in-db the the maximum verb-call depth. Originillay the maximum verb-call depth is defined at compile time by the DEFAULT_MAX_STACK_DEPTH constant in "options.h". The maximum stack depth for any task is set at the time that task is created and cannot be changed thereafter. This implies that suspended tasks, even after being saved in and restored from the DB, are not affected by later changes to $server_options.max_stack_depth. ", "", "'queued_task_limit' if this property exist and its value is non-negative, then it is used as the maximum of tasks a verb-owner (more exactly the user's perms the verb run with) can queue (through fork() and suspend()). This setting is overriden if the user has a 'queued_task_limit' property and if its value is non-negative. E_QUOTA is raised of either forking or suspending when the user is over quota for tasks.", "", "'protect_...' On every call to a built-in function 'foo', if the property $server_options.protect_foo exists and is true, and the programmer is not a wizard, then the server checks for the existence of #0:bf_<fuction> and calls that. If it doesn't exist then E_PERM is raised, i.e. the built-in function is made wiz-only.", "                --------------------------------" ]
#82 Server Options.fg_ticks rc = MOONumber 150000
#82 Server Options.protect_chparent rc = MOONumber 1
#82 Server Options.boot_msg rc = MOOString ""
#82 Server Options.protect_add_verb rc = MOONumber 1
#82 Server Options.bg_ticks rc = MOONumber 80000
#82 Server Options.permit_writable_verbs rc = MOONumber 0
#82 Server Options:help_msg this n/a this
output = {"On $server_options, the following settings have been established by the wizards:", ""};
wizonly = {};
etc = {};
mentioned = {};
for x in (setremove(properties(this), "help_msg"))
if (index(x, "protect_") == 1)
mentioned = {@mentioned, x[9..$]};
wizonly = {@wizonly, tostr(x[9..$], "() is ", this.(x) ? "" | "not ", "wizonly.")};
else
etc = {@etc, tostr("$server_options.", x, " = ", $string_utils:print(this.(x)))};
endif
endfor
if ("set_verb_code" in wizonly)
wizonly = {@wizonly, "", "Note: since the 'set_verb_code' built-in function is wiz-only, then the '.program' built-in command is wiz-only too."};
endif
if (bf = $set_utils:intersection(verbs(#0), mentioned))
bf = $list_utils:sort(bf);
etc = {@etc, "", "In your code, #0:(built-in)(@args) should be called rather than built-in(@args) when you would use one of the following built-in functions:", $string_utils:english_list(bf) + ".", ((("Example: #0:" + bf[1]) + "(@args) should be used instead of ") + bf[1]) + "(@args)"};
endif
return {@this.help_msg, @output, @wizonly, "", @etc};
-------------------------------------------------------------------------------
#82 Server Options:init_for_core this n/a this
if (!caller_perms().wizard)
raise(E_PERM);
endif
this.support_numeric_verbname_strings = 0;
pass(@args);
-------------------------------------------------------------------------------
================================#83 Feature Warehouse===============================================
#83 Feature Warehouse:list any at/to this
"Copied from Features Feature Object (#24300):list by Joe (#2612) Mon Oct 10 21:07:35 1994 PDT";
if (this.contents)
player:tell(".features objects:");
player:tell("----------------------");
first = 1;
for thing in (this.contents)
$command_utils:kill_if_laggy(10, "Sorry, the MOO is very laggy, and there are too many feature objects in here to list!");
$command_utils:suspend_if_needed(0);
if (!first)
player:tell();
endif
player:tell($string_utils:nn(thing), ":");
`thing:look_self() ! ANY => player:tell("<<Error printing description>>")';
first = 0;
endfor
player:tell("----------------------");
else
player:tell("No objects in ", this.name, ".");
endif
-------------------------------------------------------------------------------
================================#84 Builder Help DB===============================================
#84 Builder Help DB.@dump r = MOOList [ "Syntax:  @dump <object> [with [id=#<id>] [noprops] [noverbs] [create]]", "", "This spills out all the properties and verbs on an object, calling suspend at appropriate intervals.", "   id=#<id> -- specifies an idnumber to use in place of the object's actual id (for porting to another MOO)", "   noprops  -- don't show properties.", "   noverbs  -- don't show verbs.", "   create   -- indicates that a @create command should be generated and all of the verbs be introduced with @verb rather than @args; the default assumption is that the object already exists and you're just doing this to have a look at it." ]
#84 Builder Help DB.rooms r = MOOList [ "Rooms may be made by builders, using the DIG verb. By default, all rooms are instances of _the_ room, $room, or #3, which you can examine to see how it works. If you require a room to have a more specific behaviour, you can make a subclass of room." ]
#84 Builder Help DB.@recycle rc = MOOList [ "Syntax:  @recycle <object-name-or-number>", "", "Destroys the indicated object utterly and irretrievably.  Naturally, you may only do this to objects that you own." ]
#84 Builder Help DB.@opacity rc = MOOList [ "Syntax:", "  @opacity <container> is <integer>", "", "The opacity can take on one of three values:", "   0:  The container is transparent and you can always see into it.", "   1:  The container is opaque, and you cannot see into it when closed", "   2:  The container is a black hole, and you can never see into it whether closed or open.  ", "", "The default @opacity is 1." ]
#84 Builder Help DB.@remove-entrance rc = MOOList [ "Syntax:  @remove-entrance <entrance>", "", "Remove the specified entrance from the current entrances list of the room.  Entrance may be either the name or object number of an entrance to this room." ]
#84 Builder Help DB.building r = MOOList [ "There are a number of commands available to players for building new parts of the MOO.  Help on them is available under the following topics:", "", "creation -- making, unmaking, and listing your rooms, exits, and other objects", "topology -- making and listing the connections between rooms and exits", "descriptions -- setting the names and descriptive texts for new objects", "locking -- controlling use of and access to your objects" ]
#84 Builder Help DB.@contents rc = MOOList [ "Syntax:  @contents object", "", "A quick way to find out the contents of an object.  Prints out the names and object numbers of all direct contents.  This can be useful when you need to refer to something by object number because something is wrong with its aliases.", "", "Example:", "  @contents here", "  The Entrance Hall(#19) contains:", "  Strasbourg Clock(#71)   mirror at about head height(#7444)" ]
#84 Builder Help DB.@count r = MOOList [ "Syntax:  @count [player]", "", "Prints out the number of objects you or another person own.  Do not be surprised if this is one larger than you think it should be: remember that your player object is owned by you as well, even though you didn't create it in the usual way.", "", "If byte-based quota is enabled, also prints the total usage by all objects at last measurement." ]
#84 Builder Help DB.exit-messages r = MOOList [ "*subst*", "Several kinds of messages can be set on an exit object (see 'help messages' for instructions on doing so); they are printed to various audiences at certain times whenever an attempt is made to go through the exit.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.", "", "The default message is given in brackets after each name below:", "", "@leave  [%[$exit.leave_msg]]", "  Printed to the player just before they successfully use the exit.", "", "@oleave  [%[$exit.oleave_msg||"has left."]]", "  Printed to others in the source room when a player successfully uses the exit.", "", "@arrive  [%[$exit.arrive_msg]]", "  Printed to the player just after they successfully use the exit.", "", "@oarrive  [%[$exit.oarrive_msg||"has arrived."]]", "  Printed to others in the destination room when a player successfully uses the exit.", "", "@nogo  [%[$exit.nogo_msg||"You can't go that way."]]", "  Printed to the player when they fail in using the exit.", "", "@onogo  [%[$exit.onogo_msg]]", "  Printed to others when a player fails in using the exit." ]
#84 Builder Help DB.@build-options rc = MOOList [ "Syntax:  @build-option", "         @build-option <option>", "", "Synonyms:  @buildoption, @builder-option @builderoption", "", "The first form displays all of your builder options", "The second displays just that one option, which may be one of the flags listed below.  The builder options control various annoying details of your building commands (e.g., @create, ...)", "", "The remaining forms of this command are for setting your programmer options:", "", "         @build-option create_flags [is] <flags>", "         @build-option create_flags=<flags>", "         @build-option -create_flags", "                      (equivalent to create_flags="")", "", "where flags is some substring of "rwf".  This option determines the read/write/fertility permissions of an object freshly created with @create or @recreate (see `help @create' and `help @recreate' and `help @chmod').  E.g., to make every object you create henceforth readable by default, do", "", "         @build-option create_flags=r", "", "For controlling the behavior of @dig, we have", "", "         @build-option  dig_room=<room>", "         @build-option  dig_room [is] <room>", "         @build-option -dig_room", "                      (equivalent to dig_room=$room)", "         @build-option  dig_exit=<exit>", "         @build-option  dig_exit [is] <exit>", "         @build-option -dig_exit", "                      (equivalent to dig_exit=$exit)", "", "The following respectively set and reset the specified flag option", "", "         @build-option +<option>", "         @build-option -<option>", "         @build-option !<option>           (equivalent to -<option>)", "", "Currently the only builder flag option available is", " -bi_create     @create/@recycle re-use object numbers.", " +bi_create     @create/@recycle call create()/recycle() directly ", "", "we prefer that you not use +bi_create, since this drives up the object numbers." ]
#84 Builder Help DB.@builderoptions rc = MOOList [ "*forward*", "@build-options" ]
#84 Builder Help DB.@quota r = MOOList [ "*pass*", "@quota" ]
#84 Builder Help DB.@locations rc = MOOList [ "Syntax:  @locations object", "", "Prints out the names and object numbers of all containing objects.", "", "Example:", "  @locations ur-Rog", "  ur-Rog(#6349)   ur-Rog's Display Case(#6355)   Editorial Boardroom(#5747)" ]
#84 Builder Help DB.@lock_for_open rc = MOOList [ "Syntax:", "  @lock_for_open <container> with <key expression>", "", "Set the lock on <container> which restricts who can open it.  See 'help locking' for general information about locking and 'help keys' for the syntax and semantics of key expressions.", "", "See 'help containers' for information on containers." ]
#84 Builder Help DB.@add-exit r = MOOList [ "Syntax:  @add-exit <exit-object-number>", "", "Add the exit with the given object number as a conventional exit from the current room (that is, an exit that can be invoked simply by typing its name, like 'east').  Usually, @dig does this for you, but it doesn't if you don't own the room in question.  Instead, it tells you the object number of the new exit and you have to find the owner of the room and get them to use the @add-exit command to link it up." ]
#84 Builder Help DB.@remove-exit rc = MOOList [ "Syntax:  @remove-exit <exit>", "", "Remove the specified exit from the current exits list of the room.  Exit may be either the name or object number of an exit from this room." ]
#84 Builder Help DB.topology r = MOOList [ "The topology of the MOO universe is determined by the rooms that exist and the exits that connect them.  Several commands are available for creating and discovering the topology of the MOO.  Help on them is available under the following topics:", "", "@dig -- creating new rooms and exits", "@add-exit -- adding other players' exits from your rooms", "@add-entrance -- adding other player's entrances to your rooms", "@remove-exit -- removing exits from your room", "@remove-entrance -- removing entrances from your room", "@exits -- listing all of the conventional exits from your rooms", "@entrances -- listing all of the conventional entrances to your rooms", "@resident -- listing or changing the residents of your rooms" ]
#84 Builder Help DB.@measure rc = MOOList [ "Syntax:", "  @measure object <object name>", "  @measure summary [player]", "  @measure new [player]", "  @measure breakdown <object name>", "  @measure recent [number of days] [player]", "", "When the MOO is under byte-quota, objects in the MOO are measured approximately once a week, and the usage tally as reported by @quota is updated.  You may wish to measure an object specially, however, without waiting for the automatic measurement to take place, or if the MOO is under object-quota.  @measure has some subcommands to handle this.", "", "@measure object will measure an individual object right now, update the usage of that object in your usage as reported by @quota, and update the date of that object's measurement.", "", "@measure summary will go through your or another player's objects and produce the summary information that is printed by @quota.  Normally this will be just the same as @quota prints out, but occasionally the addition/subtraction done to keep @quota in sync will get out of date, and @measure summary will be needed.", "", "@measure new will go through all your or another player's objects, measuring exactly those which have never been measured before (that is, are too newly @created to have any measurement data).  This is necessary as any player is only permitted to own 10 unmeasured objects, or object creation will not be permitted.", "", "@measure breakdown will give you full information on where an object's size is coming from.  It will offer to moomail you the result.  Caution: don't forget to delete this message, as it is large and takes up a lot of space!", "", "@measure recent will let you re-measure objects of yours or another player's which have not been measured in the specified number of days (the default is the ordinary cycle of the measurement task)." ]
#84 Builder Help DB.@exits rc = MOOList [ "Syntax:  @exits", "", "Prints a list of all conventional exits from the current room (but only if you own the room).  A conventional exit is one that can be used simply by typing its name, like 'east'." ]
#84 Builder Help DB.container-messages rc = MOOList [ "*subst*", "Several kinds of messages can be set on a container object; they are printed to various audiences at certain times whenever an attempt is made to use the container.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.", "", "The default message is given in brackets after each name below:", "", "@empty[%[$container.empty_msg]]", "  Printed in place of the contents list when the container is empty.", "", "@open  [%[$container.open_msg]]", "  Printed to the player who successfully opens the container.", "", "@oopen  [%[$container.oopen_msg]]", "  Printed to others in the same room if the player successfully opens the container.", "", "@open_fail  [%[$container.open_fail_msg]]", "  Printed to the player who cannot open the container.", "", "@oopen_fail  [%[$container.oopen_fail_msg]]", "  Printed to others in the room when a player fails to open a container.", "", "@close  [%[$container.close_msg]]", "  Printed to the player who closes a container.", "", "@oclose  [%[$container.oclose_msg]]", "  Printed to others in the room when a player closes a container.", "", "@put  [%[$container.put_msg]]", "  Printed to a player when an object is successfully placed in a container.", "", "@oput  [%[$container.oput_msg]]", "  Printed to others in the room when a player successfully places an object in a container.", "", "@put_fail  [%[$container.put_fail_msg]]", "  Printed when a player fails to put an object in a container.", "", "@oput_fail  [%[$container.oput_fail_msg]]", "  Printed to others in the room when a player fails to place an object in a container.", "", "@remove  [%[$container.remove_msg]]", "  Printed when a player succeeds in removing an object from a container.", "", "@oremove  [%[$container.oremove_msg]]", "  Printed to others in the room when a player succeeds in removing an object from a container.", "", "@remove_fail  [%[$container.remove_fail_msg]]", "  Printed when a player fails to remove an object from a container.", "", "@oremove_fail  [%[$container.oremove_fail_msg]]", "  Printed to others in the room when a player fails to remove an object from a container." ]
#84 Builder Help DB.@setprop rc = MOOList [ "Syntax:  @set <object>.<prop-name> to <value>", "", "Changes the value of the specified object's property to the given value.", "You must have permission to modify the property, either because you own the property or if it is writable." ]
#84 Builder Help DB.thing-messages r = MOOList [ "*subst*", "Several kinds of messages can be set on 'things', objects that have $thing as an ancestor (see 'help messages' for instructions on doing so).  They are printed to various audiences under various circumstances when an attempt is made to 'take' or 'drop' a thing.  The ones whose names begin with 'o' are always shown prefixed with the name of the player making the attempt and a single space character.  The standard pronoun substitutions (with respect to the player) are made on each message before it is printed; see 'help pronouns' for details.", "", "The default message is given in brackets after each name below:", "", "@take_failed  [%[$thing.take_failed_msg]]", "  Printed to a player who fails to take the object.", "", "@otake_failed [%[$thing.otake_failed_msg]]", "  Printed to others in the same room if a player fails to take the object.", "", "@take_succeeded  [%[$thing.take_succeeded_msg]]", "  Printed to a player who succeeds in taking the object.", "", "@otake_succeeded  [%[$thing.otake_succeeded_msg]]", "  Printed to others in the same room if a player succeeds in taking the object.", "", "@drop_failed  [%[$thing.drop_failed_msg]]", "  Printed to a player who fails to drop the object.", "", "@odrop_failed [%[$thing.odrop_failed_msg]]", "  Printed to others in the same room if a player fails to drop the object.", "", "@drop_succeeded  [%[$thing.drop_succeeded_msg]]", "  Printed to a player who succeeds in dropping the object.", "", "@odrop_succeeded  [%[$thing.odrop_succeeded_msg]]", "  Printed to others in the room if a player succeeds in dropping the object." ]
#84 Builder Help DB.@recreate rc = MOOList [ "Usage: @recreate <object> as <parent> named <name spec>", "", "This is a combination of @create and @chparent.  It takes an existing object, completely strips it of any verbs, properties, and values for inherited properties.  This object is then reshaped into a child of the parent specified, as though @create had been called, but retaining the same object number as the original.", "", "You may use "called" instead of "named" in this command, if you wish.", "", "The <parent> and <name spec> arguments are as in @create." ]
#84 Builder Help DB.room-messages rc = MOOList [ "*subst*", "A few different messages can be set on a room object (see 'help messages' for instructions on doing so); they are printed to various audiences when a player or other object is ejected from the room.  (See 'help @eject'.)  The standard pronoun substitutions are made on each message before it is printed; see 'help pronouns' for details.", "", "The default message is given in brackets after each name below:", "", "@ejection  [%[$room.ejection_msg]]", "  Printed to the player doing the ejecting.", "", "@victim_ejection  [%[$room.victim_ejection_msg]]", "  Printed to the object being ejected.", "", "@oejection  [%[$room.oejection_msg]]", "  Printed to others in the room from which the object is being ejected." ]
#84 Builder Help DB.containers r = MOOList [ "Containers are objects that allow you to store other objects inside them.  The following help topics cover verbs that can be used with containers:", "", "put -- putting an object into a container", "remove -- taking an object out of a container", "", "Containers may be open or closed, using the verbs 'open container' and 'close container'.  Containers have a separate lock to determine if a player may open them.  See the following help topics:", "", "@lock_for_open -- setting the lock for opening a container", "@unlock_for_open -- clearing the lock", "", "You can make a container by creating a child of the standard container, $container (see 'help @create').", "", "Containers have a large number of messages which get printed when players act upon them.  See 'help container-messages' for more information.", "", "Containers have opacity.  See 'help @opacity' for more information." ]
#84 Builder Help DB.@set rc = MOOList [ "*forward*", "@setprop", "@set is a valid abbreviation for @setprop." ]
#84 Builder Help DB.@entrances rc = MOOList [ "Syntax:  @entrances", "", "Prints a list of all recognized entrances to the current room (but only if you own the room).  A recognized entrance is one whose use is not considered to be teleportation." ]
#84 Builder Help DB.@unlock_for_open rc = MOOList [ "Syntax:", "  @unlock_for_open <container>", "", "Clears the lock which restricts who may open <container>.  See 'help locking' for general information about locking. ", "", "See 'help containers' for information on containers." ]
#84 Builder Help DB.common_quota r = MOOList [ "Syntax:  @quota", "", "Each player has a limit as to how many objects that player may create, called their 'quota'.  Every object they create lowers the quota by one and every object they recycle increases it by one.  If the quota goes to zero, then that player may not create any more objects (unless, of course, they recycle some first).", "", "The @quota command prints out your current quota.", "", "The quota mechanism is intended to solve a long-standing problem in many MUDs: database bloat.  The problem is that a large number of people build a large number of dull objects and areas that are subsequently never used or visited.  The database becomes quite large and difficult to manage without getting substantially more interesting.  With the quota system, we can make it possible for players to experiment and learn while simultaneously keeping random building to acceptable levels." ]
#84 Builder Help DB.keys r = MOOList [ "LambdaMOO supports a simple but powerful notation for specifying locks on objects, encryption on notes, and other applications.  The idea is to describe a constraint that must be satisfied concerning what some object must be or contain in order to use some other object.", "", "The constraint is given in the form of a logical expression, made up of object numbers connected with the operators 'and', 'or', and 'not' (written '&&', '||', and '!', for compatibility with the MOO programming language).  When writing such expressions, though, one usually does not use object numbers directly, but rather gives their names, as with most MOO commands.", "", "These logical expressions (called 'key expressions') are always evaluated in the context of some particular 'candidate' object, to see if that object meets the constraint.  To do so, we consider the candidate object, along with every object it contains (and the ones those objects contain, and so on), to be 'true' and all other objects to be 'false'.", "", "As an example, suppose the player Munchkin wanted to lock the exit leading to his home so that only he and the holder of his magic wand could use it.  Further, suppose that Munchkin was object #999 and the wand was #1001.  Munchkin would use the '@lock' command to lock the exit with the following key expression:", "        me || magic wand", "and the system would understand this to mean", "        #999 || #1001", "That is, players could only use the exit if they were (or were carrying) either #999 or #1001.", "", "To encrypt a note so that it could only be read by Munchkin or someone carrying his book, his bell, and his candle, Munchkin would use the 'encrypt' command with the key expression", "        me || (bell && book && candle)", "", "Finally, to keep players from taking a large gold coffin through a particularly narrow exit, Munchkin would use this key expression:", "        ! coffin", "That is, the expression would be false for any object that was or was carrying the coffin.", "", "There is one other kind of clause that can appear in a key expression:", "        ? <object>", "This is evaluated by testing whether the given object is unlocked for the candidate object; if so, this clause is true, and otherwise, it is false.  This allows you to have several locks all sharing some single other one; when the other one is changed, all of the locks change their behavior simultaneously.", "", "[Note to programmers: The internal representation of key expressions, as stored in .key on every object, for example, is very simple and easy to construct on the fly.  For details, see 'help key-representation'.]" ]
#84 Builder Help DB.@parents rc = MOOList [ "Syntax:  @parents object", "", "A quick way to find out the ancestry of an object.  Prints out the names and object numbers of all ancestors.", "", "Example:", "  @parents Haakon", "  Haakon(#2)   generic wizard(#218)   generic programmer(#217)   generic ", "  player(#6)   Root Class(#1)" ]
#84 Builder Help DB.@create r = MOOList [ "Syntax:  @create <class-name> named "<names>"", "         @create <parent-object> named "<names>"", "", "The main command for creating objects other than rooms and exits (for them, see 'help @dig'; it's much more convenient).", "", "The first argument specifies the 'parent' of the new object: loosely speaking, the 'kind' of object you're creating.  <class-name> is one of the four standard classes of objects: $note, $letter, $thing, or $container.  As time goes on, more 'standard classes' may be added.  If the parent you have in mind for your new object isn't one of these, you may use the parent's name (if it's in the same room as you) or else its object number (e.g., #4562).", "", "You may use "called" instead of "named" in this command, if you wish.", "", "An object must be fertile to be used as a parent-class.  See help @chmod for details.", "", "The <names> are given in the same format as in the @rename command:", "        <name-and-alias>,<alias>,...,<alias> [preferred]", "        <name>:<alias>,...,<alias> [not preferred]", "", "See 'help @rename' for a discussion of the difference between a name and an alias." ]
#84 Builder Help DB.@classes r = MOOList [ "Syntax:  @classes", "         @classes <class-name> ...", "", "The wizards have identified several useful classes of objects in the database.  The @classes command is used to see which classes exist and what their member objects are.", "", "The first form simply lists all of the defined classes along with short descriptions of the membership of each.", "", "The second form prints an indented listing of that subset of the object parent/child hierarchy containing the objects in the class(es) you specify." ]
#84 Builder Help DB.@builder-options rc = MOOList [ "*forward*", "@build-options" ]
#84 Builder Help DB.@lock r = MOOList [ "Syntax:  @lock <object> with <key expression>", "", "Set a lock on <object> to restrict its use.  See 'help locking' for general information about locking and 'help keys' for the syntax and semantics of key expressions.", "", "N.B.  In the case of rooms, you are actually better off setting room.free_entry to 0 thus preventing teleportation and then @locking the various entrances.  The problem with @locking the room itself is that this can make it impossible to drop objects in the room." ]
#84 Builder Help DB.@audit r = MOOList [ "Syntax:  @audit [<player>] [for <string>] [from <number>] [to <number>] ", "", "`@audit'        prints a report of all of the objects you own.", "`@audit player' prints the same report for another player.", "", "The `for' string restricts the search to objects whose names begin with that string.", "It is also possible to restrict the range of object numbers to include only those above a given number (`from') or below a given number (`to').", "", "All forms of @audit print a report:", "", "   #14 Gemba                          [The Pool]", "  #144 Popgun                         [Gemba]", " #1479 Cockatoo                      *[The Living Room]", " #1673 Bottom of Swimming Pool       ", " #2147 Cavern                        <-*west", " #2148 tunnel                         Bottom of Swimming ->Cavern", "", "The first column is the object's number, the second its name. The third column shows the object's location: Gemba is in The Pool, and is carrying the Popgun (#144).", "For exits, the third column shows source ->dest.", "For rooms, the third column shows any entrances owned by someone else.", "Object location, exit sources and destinations owned by another player are preceded by a *.", "", "@audit uses a property .owned_objects on the player, for speed.  This property is updated at the time of each object creation and destruction and ownership change.  The verb @auditdb (same args as @audit) actually searches through the entire database for objects.", "", "See also @verify-owned, @sort-owned, and @add-owned.", "", "See also @prospectus, which gives some additional information." ]
#84 Builder Help DB.audit_bytes r = MOOList [ "Usage:  @build-option [+|-|!]audit_bytes", "Lets you see the actual bytes of small objects in @audit and @prospectus.  Ignored if `audit_float' is turned on.", "", "  -audit_bytes     @audit/@prospectus shows `<1K'", "  +audit_bytes     @audit/@prospectus shows bytes.", "", "Default: -audit_bytes" ]
#84 Builder Help DB.@dig rc = MOOList [ "Syntax:  @dig "<new-room-name>"", "         @dig <exit-spec> to "<new-room-name>"", "         @dig <exit-spec> to <old-room-object-number>", "", "This is the basic building tool.  The first form of the command creates a new room with the given name.  The new room is not connected to anywhere else; it is floating in limbo.  The @dig command tells you its object number, though, so you can use the @move command to get there easily.", "", "The second form of the command not only creates the room, but one or two exits linking your current location to (and possibly from) the new room.  An <exit-spec> has one of the following two forms:", "        <names>", "        <names>|<names>", "where the first form is used when you only want to create one exit, from your current room to the new room, and the second form when you also want an exit back, from the new room to your current room.  In any case, the <names> piece is just a list of names for the exit, separated by commas; these are the names of the commands players can type to use the exit.  It is usually a good idea to include explicitly the standard abbreviations for direction names (e.g., 'n' for 'north', 'se' for 'southeast', etc.).  DO NOT put spaces in the names of exits; they are useless in MOO.", "", "The third form of the command is just like the second form except that no new room is created; you instead specify by object number the other room to/from which the new exits will connect.", "", "NOTE: You must own the room at one end or the other of the exits you create.  If you own both, everything is hunky-dorey.  If you own only one end, then after creating the exits you should write down their object numbers.  You must then get the owner of the other room to use @add-exit and @add-entrance to link your new exits to their room.", "", "Examples:", "    @dig "The Conservatory"", "creates a new room named "The Conservatory" and prints out its object number.", "    @dig north,n to "The North Pole"", "creates a new room and also an exit linking the player's current location to the new room; players would say either 'north' or 'n' to get from here to the new room.  No way to get back from that room is created.", "    @dig west,w|east,e,out to "The Department of Auto-Musicology"", "creates a new room and two exits, one taking players from here to the new room (via the commands 'west' or 'w') and one taking them from the new room to here (via 'east', 'e', or 'out').", "    @dig up,u to #7164", "creates an exit leading from the player's current room to #7164, which must be an existing room." ]
#84 Builder Help DB.@verify-owned rc = MOOList [ "Syntax:  @verify-owned", "", "Checks that all the objects in your .owned_objects property are actually owned by you, and effects repairs if needed.  See help @audit for more information." ]
#84 Builder Help DB.creation r = MOOList [ "The primary means for players to extend the MOO is for them to create new objects with interesting behavior.  There are convenient commands for creating and recycling objects and for keeping track of the objects you've created.  Help is available on these commands in the following topics:", "", "@dig -- conveniently building new rooms and exits", "@create -- making other kinds of objects", "@recycle -- destroying objects you no longer want", "@quota -- determining how many more objects you can build", "@count -- determining how many objects you already own", "@audit -- listing all of your objects", "@classes -- listing all of the public classes available for your use", "@move -- moving your objects from place to place", "@parents, @kids -- examine the inheritance hierarchy." ]
#84 Builder Help DB.builder-index rc = MOOList [ "*index*", "Builder Help Topics" ]
#84 Builder Help DB.locking r = MOOList [ "It is frequently useful to restrict the use of some object.  For example, one might want to keep people from using a particular exit unless they're carrying a bell, a book, and a candle.  Alternatively, one might allow anyone to use the exit unless they're carrying that huge golden coffin in the corner.  LambdaMOO supports a general locking mechanism designed to make such restrictions easy to implement, usually without any programming.", "", "Every object supports a notion of being 'locked' with respect to certain other objects.  For example, the exit above might be locked for any object that was carrying the coffin object but unlocked for all other objects.  In general, if some object 'A' is locked for another object, 'B', then 'B' is usually prevented from using 'A'.  Of course, the meaning of 'use' in this context depends upon the kind of object.", "", "The various standard classes of objects use locking as follows:", "  + Rooms and containers refuse to allow any object inside them if they're locked for it.", "  + Exits refuse to transport any object that they're locked for.", "  + Things (including notes and letters) cannot be moved to locations that they're locked for.", "", "There are two sides to locking:", "  + How is it specified whether one object is locked for another one?", "  + What is the effect of an object being locked?", "Note that these two questions are entirely independent: one could invent a brand-new way to specify locking, but the effect of an exit being locked would be unchanged.", "", "[Note to programmers: the interface between these two sides is the verb x:is_unlocked_for(y), which is called by x to determine if it is locked for the object y.  The way in which 'is_unlocked_for' is implemented is entirely independent of the ways in which x uses its results.  Note that you can play on either side of this interface with your own objects, either defining new implementations of 'is_unlocked_for' that match your particular circumstances or having your objects interpret their being locked in new ways.]", "", "There is a default way to specify locks on objects; the following help topics cover the relevant commands:", "", "@lock -- setting a lock on an object", "@unlock -- clearing the lock on an object", "keys -- describes the language used to describe lock keys" ]
#84 Builder Help DB.@add-entrance r = MOOList [ "Syntax:  @add-entrance <exit-object-number>", "", "Add the exit with the given object number as a recognized entrance to the current room (that is, one whose use is not considered teleportation).  Usually, @dig does this for you, but it doesn't if you don't own the room in question.  Instead, it tells you the object number of the new exit and you have to find the owner of the room and get them to use the @add-entrance command to link it up." ]
#84 Builder Help DB.@unlock r = MOOList [ "Syntax:  @unlock <object>", "", "Clear any lock that might exist on the given object.  See 'help locking' for general information about locking." ]
#84 Builder Help DB.@buildoptions rc = MOOList [ "*forward*", "@build-options" ]
#84 Builder Help DB.@add-owned rc = MOOList [ "Syntax:  @add-owned <object>", "", "Adds an object to your .owned_objects property in case it managed not to get updated properly upon creation of that object.  Checks to ensure that the objects is really owned by you and otherwise belongs in your .owned_objects property.  See help @audit for more information." ]
#84 Builder Help DB.object-quota rc = MOOList [ "*forward*", "common_quota", "", "To get a larger quota, talk to a wizard.  They will take a look at what you've done with the objects you've built so far and make a determination about whether or not it would be a net gain for the MOO community if you were to build some more things.  If so, they will increase your quota; if not, they will try to explain some ways in which you could build things that were more useful, entertaining, or otherwise interesting to other players.  Wizards may be more impressed by objects which are interactive and employ a fair number of verbs." ]
#84 Builder Help DB.audit_float r = MOOList [ "Usage: @build-option [+|-|!]audit_float", "Lets you see object sizes in @audit and @prospectus as floating point numbers to one decimal place.", "", "  -audit_float     @audit/@prospectus shows integer sizes (1K)", "  +audit_float     @audit/@prospectus shows floating-point sizes (1.2K)", "", "Default: -audit_float" ]
#84 Builder Help DB.key-representation r = MOOList [ "The representation of key expressions is very simple and makes it easy to construct new keys on the fly.", "", "Objects are represented by their object numbers and all other kinds of key expressions are represented by lists.  These lists have as their first element a string drawn from the following set:", "        "&&"     "||"     "!"     "?"", "For the first two of these, the list should be three elements long; the second and third elements are the representations of the key expressions on the left- and right-hand sides of the appropriate operator.  In the third case, "!", the list should be two elements long; the second element is again a representation of the operand.  Finally, in the "?" case, the list is also two elements long but the second element must be an object number.", "", "As an example, the key expression", "        #45  &&  ?#46  &&  (#47  ||  !#48)", "would be represented as follows:", "        {"&&", {"&&", #45, {"?", #46}}, {"||", #47, {"!", #48}}}" ]
#84 Builder Help DB.@sort-owned rc = MOOList [ "Syntax:  @sort-owned  [ object | size ]", "", "Sorts your .owned_objects property so @audit shows up sorted.  See help @audit for more information.", "", "@sort-owned object will sort by object number (the default).  @sort-owned size will sort by size of object as periodically recorded." ]
#84 Builder Help DB.@resident rc = MOOList [ "Syntax: @resident player", "        @resident !player", "        @resident", "", "Adds or removes a player from the residents list of a room.  The residents list controls who is allowed to use @sethome in that room.  This defaults to just the owner of the room; by manipulating the residents list you may allow additional players to use that room as their home.", "", "@resident player adds that player to the list.  ", "@resident !player removes that player from the list.", "@resident with no arguments simply displays the current list (which may be "none", indicating no additional people besides the owner may use that room as their home).", "", "See also help @sethome.", "", "Hints for programmers: The verb $room:accept_for_abode is called by @sethome.  By overriding this verb you can give different criteria to @sethome.  It should return 1 for allowed and 0 for denied." ]
#84 Builder Help DB:init_for_core this n/a this
if (!caller_perms().wizard)
raise(E_PERM);
endif
pass(@args);
this.("@quota") = {"*forward*", "object-quota"};
-------------------------------------------------------------------------------
================================#85 Mail Commands Help Db===============================================
#85 Mail Commands Help Db.@nn rc = MOOList [ "Alternative mail reading commands.", "", "Syntax:  @nn", "", "This command finds a folder containing an unread message, displays the first such, and updates your last-read-time for that folder.  Your personal mail and all @subscribed folders are checked.", "", "Syntax:  @mail-all-new-mail", "", "Displays headers of all unread messages on all of your folders (i.e., your personal folder and all @subscribed folders).", "", "Syntax:  @read-all-new-mail", "", "Displays all unread messages on all of your folders (i.e., your personal folder and all @subscribed folders).  This command ends with a prompt, "Did you get all of that? [Enter `yes' or `no']."  Answering "yes" causes all of your last-read times to be updated.  You will probably want to check for <<<n lines flushed>>> indications before you answer this question.", "", "@read-all-new-mail (with a "yes" answer at the end) is equivalent to doing a large number of @nn's." ]
#85 Mail Commands Help Db.@qreply rc = MOOList [ "*forward*", "@quickreply" ]
#85 Mail Commands Help Db.@skip rc = MOOList [ "Syntax:  @skip [<collection>...]", "         @unsubscribe [<collection>...]", "", "For each collection of mail messages that you read other from your own, a current message and a last-read-time is kept.  Normally, if you neglect to actually @read any messages on a collection other from your own, @rn (or :check_mail_lists) will continue to remind you that they are there.", "", "The @skip command indicates that you're not interested in reading the rest of the messages that currently exist in that given collection.  ", "", "The @unsubscribe command flushes the current-message/last-read-time information completely, indicating that you are not only uninterested in the rest of the messages on that collection, but also likewise uninterested in anything else that may appear on that collection later on.  @unsubscribe also removes you from the collection's .mail_notify list." ]
#85 Mail Commands Help Db.mail rc = MOOList [ "The MOO email system allows you to send and receive messages to and from other players.  It provides commands to view and manage your own collection of saved messages and, in addition, to browse through other collections that may be available (e.g.,archives of public mailing lists).  Help is available on the following commands:", "", "@mail     -- seeing a table of contents for a collection of email messages", "@read     -- reading individual messages ", "@next     -- reading the 'next'     message", "@prev     -- reading the 'previous' message", "", "@send     -- composing and sending a message to other players", "@answer   -- replying to one of the messages in a collection", "@forward  -- resending one of the messages in a collection somewhere else", "", "@rmmail   -- discarding some subset of a collection", "@unrmmail -- undoing the most recent @rmm on a collection", "@unsend   -- try to remove a message you accidentally sent", "@renumber -- renumbering the messages in a collection", "@keep-mail - marking messages in a collection as exempt from expiration", "", "@mail-option -- describes and sets various customization flags", "", "help mail-forwarding", " -- describes mail forwarding", "help message-sequences", " -- describes message-sequences arguments to @mail, @read, @rmm, and @answer.", "", "For viewing collections other from your own, the following commands are useful:", "", "@rn          -- list those collections that have new messages on them", "@subscribe   -- indicate that you want @rn to report on a given collection", "                  and add yourself to its .mail_notify list", "@skip        -- ignore any remaining new messages in a given collection", "@unsubscribe -- ignore a given collection entirely from now on", "                  and remove yourself from its .mail_notify list", "@unsubscribed-- show the mailing lists that you aren't subscribed to.", "@subscribed  -- like @rn, but shows all lists that you are subscribed to", "                even if they have no new activity" ]
#85 Mail Commands Help Db.@add-notify rc = MOOList [ "Usage:  @add-notify me to player", "    Sends mail to player saying that I want to be added to their mail notification property.", "Usage:  @add-notify player to me", "    Makes sure that player wants to be notified, if so, adds them to my .mail_notify property.", "", "In order for one person to be notified that another person has new mail, both the mail recipient and the notification recipient should agree that this is an OK transfer of information.  This verb facilitates that transaction." ]
#85 Mail Commands Help Db.@subscribe rc = MOOList [ "Syntax:  @subscribe *<collection> [with|without notification] [before|after *<collection>]", "         @subscribe", "         @subscribe-quick", "", "The second and third form of the command gives a list of all mail collections that are readable by you. The third form omits the mail collection description.", "", "The first form of this command sets up a current message and a last-read-time for the given mail collection so that when you next log in or issue the @rn command, you will be informed about new mail that has appeared there.  Note that this happens automatically whenever you @read messages on a given collection, so if this much is all you care about, you don't need to use this command; just do, e.g.,", "         @read last on *<collection>", "", "Specifying "with notification" causes you to be added to the immediate-notification list (.mail_notify) for that collection, i.e., whenever new mail arrives there, you will be notified immediately.  Specifying "without notification" causes you to be removed from the collection's .mail_notify.", "", "Specifying "before *<other-collection>" causes <collection> to be placed immediately before *<collection> in your @rn listing (which see) and likewise for the "after" clause.  By default, new collections are placed at the end of your list.  The before/after specification is only useful if you have @mail-option rn_order=fixed set (see `help @mail-options').", "", "@subscribing to a collection for which you already have a current-message/last-read-time has no effect other from possibly changing that collection's .mail_notify and/or reordering your collections for @rn.", "", "You can only @subscribe to collections that are readable by you.", "", "Note that this is entirely different from the Mail Room `subscribe' command", "which actually adds you to the .mail_forward list for a given collection/", "mailing-list, so that mail sent to the list actually shows up in your own", "mail collection.", "We're probably going to phase out the Mail Room `subscribe' command..." ]
#85 Mail Commands Help Db.@reply rc = MOOList [ "*forward*", "@answer" ]
#85 Mail Commands Help Db.@next r = MOOList [ "Syntax:  @next [<number>] [on <collection>]", "", "Print the `next' message in a given email collection (defaults to your own).  The mail system's notion of your 'current message' for that collection is incremented.  Thus, e.g., one can read all of one's new messages one-by-one simply by typing '@next' repeatedly.  If <number> is supplied, prints and advances that many messages." ]
#85 Mail Commands Help Db.@quickreply rc = MOOList [ "Syntax:   @quickreply  <msg> [on *<recipient>] [<flags>...]", "          @quickreply  <msg> [<flags>...] [on *<recipient>] ", "", "Synonym:  @qreply", "", "The @quickreply command allows you to do a short reply to a mail message without heading for the mail room.  As with @reply, the subject line on the reply message is taken from the original.  <flags> are as with @reply, except that `include' is not recognized --- if you're going to include the original message, you *have* to trim it down, and that requires the editor." ]
#85 Mail Commands Help Db.@copymail rc = MOOList [ "*forward*", "@refile" ]
#85 Mail Commands Help Db.@unsend rc = MOOList [ "The @unsend command was created by ballot on LambdaMOO, *B:Unsend (#77081).", "", "Syntax: @unsend [message-sequence] from <user>", "", "A message cannot be unsent to a player if e has read the message, it has been forwarded to eir e-mail address, or e has set an option to prevent messages being unsent to em.  A message cannot be unsent to a group of players unless it can be unsent to each player in the group.", "", "The unsender may not view a list of unread messages on a player.  E may only select the message(s) to be unsent by filters such as "subject:<subject>" or "since:today".", "", "In order to protect privacy, if any of the restrictions above, such as one of the users having already read the message, are not met, the error message will be quite generic and not tell you exactly what went wrong, but simply that messages could not be unsent.", "", "The following mail options are available:", "", "@mail-option +no_unsend      No one may @unsend messages they sent to you", "@mail-option -no_unsend      People may @unsend unread messages they send to you", "@mail-option @unsend=<message sequence>", "", "sets the default message sequence that the @unsend command will operate upon.  The default is "last:1"." ]
#85 Mail Commands Help Db.@qsend rc = MOOList [ "*forward*", "@quicksend" ]
#85 Mail Commands Help Db.@read-all-new-mail rc = MOOList [ "*forward*", "@nn" ]
#85 Mail Commands Help Db.@peek rc = MOOList [ "*forward*", "@read" ]
#85 Mail Commands Help Db.@unrmmail rc = MOOList [ "Syntax:  @unrmmail [list|expunge] [on *<collection>]", "", "When you do @rmmail on a particular message collection, the messages removed don't go away immediately, but are rather saved elsewhere.  These "zombie" messages can be brought back or examined using the @UNrmmail command.", "", "Without `list' or `expunge', @unrmm restores the zombie messages, thus undoing the effect of the most recent @rmmail command.  Only the most recent @rmmail can be undone in this way; messages deleted by any previous @rmmail commands on this same collection are lost and gone forever.", "", "The `list' option merely lists the headers of the zombie messages without actually restoring them.", "", "The `expunge' option banishes the zombie messages forever.", "", "Note that the message numbers used by zombie messages are held in reserve against the possibility that you might @unrmm them some day; with such messages around, new messages received will be given higher numbers than you might have expected.  @renumber does an implicit @unrmm expunge.", "", "`@unrmmail' and `@unrmmail expunge' on collections other than your own are only allowed when you have write access.  Likewise, `@unrmmail list' on other collections is only possible when they are readable by you." ]
#85 Mail Commands Help Db.@answer rc = MOOList [ "Syntax:  @answer [<message-number>] [sender] [all] [include] [noinclude] [followup]", "", "Synonym: @reply", "", "Prepares for you to compose a MOO email message to the players who either received or composed the indicated message from your collection.  The usual editor is invoked (see `help editors' for details).  The subject line for the new message will be initialized from that of the indicated message.  If you leave off the message number, the reply will be to your current message, if that exists.  In fact you may give a general message-sequence (see `help message-sequences') argument here, provided that it indicates only a single message (e.g., `@answer last:1')", "", "If there is a Reply-to: field in the message you are @answer'ing, its contents will be used to initialize the To: line of your reply.  Otherwise, a To: line is determined depending on whether you specified `sender', `all', or `followup' in the command line (or your .mail_options).", "  `sender'   replies to sender only", "  `all'      replies to sender and all original recipients", "  `followup' replies to first original recipient that is a non-player", "             (no effect if there are no non-player recipients).", "", "`include' includes the text of the original message in your reply, `noinclude' does not.  ", "", "`sender', `all', `followup', `include', and `noinclude' can all be abbreviated (e.g., `@answer i').", "", "Defaults are `sender' and `noinclude', but you can change this by setting your .mail-options (see `help mail-options').  " ]
#85 Mail Commands Help Db.@resend rc = MOOList [ "*forward*", "@forward" ]
#85 Mail Commands Help Db.@netforward rc = MOOList [ "Syntax:  @netforward <message-number>", "         @netforward ", "         @netforward <message-sequence> on *collection", "", "Forwards the contents of the indiciated messages from your MOO email collection to your registered email address.  You get the message numbers for use here by typing the '@mail' command, which prints a table of contents for your entire MOO email collection.  If no arguments are given to @netforward, then the 'current message' in your collection is sent.  In any case, the 'current message' after @netforward finishes is not affected.", "", "The most general form of the @netforward command is", "", "         @netforward <message-sequence> [on *<collection>]", "", "where <message-sequence> is as described in `help message-sequences'.", "As with the @mail command you may @netforward messages on any publically readable collection (child of $mail_recipient).", "", "Before messages are sent, you are asked to confirm the email unless you have set your `expert_netfwd' mail option on.  See `help @mail-options' for details.", "", "If you do not have a valid registered email address, you will not be able to use this command and must first @registerme or get a wizard to register your address. `help @registerme' for details." ]
#85 Mail Commands Help Db.@keepmail rc = MOOList [ "*forward*", "@keep-mail" ]
#85 Mail Commands Help Db.@refile rc = MOOList [ "Syntax:  @refile <message-seq> [on mail-recipient] to mail-recipient", "         @copymail <message-seq> [on mail-recipient] to mail-recipient", "", "Moves a message sequence directly from one mail recipient (defaulting as per the sticky @mail-option) to another, without adding headers or reordering.", "", "NOTE:  The recipient of @refiled messages may well have its mail out of order.  This can confuse a variety of features of the mail system, which expects its messages to always be in chronological order.  Care should be exercised with @refile/@copymail." ]
#85 Mail Commands Help Db.@unsubscribe rc = MOOList [ "*forward*", "@skip" ]
#85 Mail Commands Help Db.@quicksend rc = MOOList [ "Syntax:   @quicksend <player> [subj="<text>"] <one-line-message>...", "          @quicksend <player> [subj="<text>"]", "", "Synonym:  @qsend", "", "The @quicksend command allows you to send a short mail message without heading for the mail room.  With the second form of the command you will be prompted for the body of the message (and a subject line unless your `nosubject' mailoption is set (see `help @mail-option') or you already gave a subject line)." ]
#85 Mail Commands Help Db.mail-index rc = MOOList [ "*index*", "Mail System Help Topics" ]
#85 Mail Commands Help Db.@prev rc = MOOList [ "Syntax:  @prev [<number>] [on <collection>]", "", "Print the 'previous' message in a given email collection (defaults to your own).  The mail system's notion of your 'current message' for that collection is decremented.  Thus, e.g., one can review all of one's previous messages one-by-one simply by typing '@prev' repeatedly.  If <number> is supplied, print (and decrement current message by) that many messages." ]
#85 Mail Commands Help Db.@mail-all-new-mail rc = MOOList [ "*forward*", "@nn" ]
#85 Mail Commands Help Db.@mail r = MOOList [ "Syntax:  @mail", "         @mail new            (to see recent messages)", "         @mail 1-$            (to see *all* messages)", "", "Shows a table of contents for your MOO email message collection.  You are notified when you connect to the MOO if there are any such messages.  A little arrow indicates the mail system's notion of your 'current message'.  ", "The first form lists all of your messages or the last 15 if you have more than that many; the second form lists only those messages after your `current message'.  The third form shows your entire collection.", "", "If you have a large number of mail messages, you can give arguments so that @mail only lists the messages you're interested in.  You can also list messages residing on mail recipients which are public or for which you have read access.", "The general format is", "", "         @mail <message-sequence> [on *<recipient>]", "", "<recipient> must name some child of $mail_recipient (e.g., a mailing list);", "<message-sequence> can be a sequence of message numbers; you can also scan the recipient for articles that fit a given description, as specified in `help message-sequences'.", "", "Note that if you view mail on some other recipient and have "sticky" in your .mail_options (see `help mail-options'), all further mail commands (e.g., @read, @next, @rmm,...) will apply to that recipient.  In this case use `@mail on me' to go back to looking at your own mail." ]
#85 Mail Commands Help Db.@keep-mail rc = MOOList [ "Syntax:  @keep-mail [<message-sequence>]", "         @keep-mail none", "", "Synonym: @keepmail", "", "As a space-saving measure, there is a task that runs periodically and from all player collections removes those messages that are", "  (1) marked as read (i.e., dated before the last-read-date), ", "  (2) older than a certain expire time, and", "  (3) not specifically marked as "kept".", "", ""kept" messages will show up in your @mail listing with an `=' to the right of the message number.", "", "The first form of the @keep-mail command marks the indicated messages as kept.  The message-sequence argument is as with other mail commands (see `help message-sequences').  @keep-mail without any arguments marks your current message as kept.", "", "The second form of the command is used to remove all such marks from your mail collection.", "", "    @mail kept:", "", "will produce a list of all messages marked as kept (see `help message-sequences').", "", "You can use @mail-option expire (see `help @mail-option') to change your expire time.", "", "You can use the @netforward command (see `help @netforward') to send mail to your email address for local archival.", "", "[...At the time of this writing, player mail is taking up a large fraction of LambdaMOO's database.  It would be appreciated if you not @keep any more mail than you have to...]" ]
#85 Mail Commands Help Db.zombie-messages rc = MOOList [ "*forward*", "@unrmmail" ]
#85 Mail Commands Help Db.mail-forwarding rc = MOOList [ "There are 3 personal properties that you can use to customize how your mail is composed and forwarded", "", ".mail_forward ", " -- list of objects that will receive any mail that gets sent to you.", "    Objects on this list should either be players or descendants of ", "    $mail_recipient.", "    If this list is nonempty, you will not receive any mail yourself unless", "    you are on it.  E.g., if Rog is #4292 and ur-Rog is #6349", "", "  #6349.mail_forward={}            -- usual case; ur-Rog gets his own mail.", "  #6349.mail_forward={#4292}       -- Rog gets ur-Rog's mail instead.", "  #6349.mail_forward={#6349,#4292} -- ur-Rog gets mail and Rog gets a copy.", "  #6349.mail_forward={#-1}         -- ur-Rog's mail disappears without a trace.", "", ".mail_notify", " -- list of objects to be notified whenever mail is sent to you.", "    This list may include anything that has a :notify_mail() verb.", "    Notification will take place regardless of whether or how your mail", "    is forwarded.  ", "", "Thus, in the previous example", "", "  #4292.mail_notify={#6349} --- means that ur-Rog will be told", "                                whenever Rog is sent new mail.", "", ".mail_options", " -- this controls lots of miscellaneous things.  Use the @mail-option command", "    to view and set these options (see `help @mail-option')", "", "See `help mail-resolve' for more detail on how mail forwarding and mail notification work.  See `help MR-subscribing' for information on how to change .mail_forward and .mail_notify on $mail_recipient children, where they are !c properties." ]
#85 Mail Commands Help Db.@subscribed rc = MOOList [ "Syntax: @subscribed", "", "Like @rn, but shows you ALL mailing lists to which you are subscribed, even those which have no new messages." ]
#85 Mail Commands Help Db.@forward rc = MOOList [ "Syntax:  @forward <msg> [on *<collection>] to <recipient> [<recipient>...]", "Syntax:  @resend  <msg> [on *<collection>] to <recipient> [<recipient>...]", "", "Both of these commands take the indicated message in your (or some other) message collection, and sends it on to the indicated recipients in some form.", "", "@forward sends an entirely new message whose body is the original message (both headers and body).", "@resend sends the original message, but with a header containing the lines", "", "  From:  original-sender", "  To:    original-recipients...", "  Resent-By: you", "  Resent-To: new-recipients...", "", "If you prefer to have yourself in the From: line of messages you @resend, set the mail option `resend_forw (see `help @mail-options').  In this case, the message will instead have a header containing the lines", "", "  From:  you", "  To:    new-recipients...", "  Original-From:  original-sender" ]
#85 Mail Commands Help Db.@read rc = MOOList [ "Syntax:  @read <message-number>", "         @read", "         @peek ...", "", "Prints the contents of the indiciated messages from your MOO email collection.  You get the message numbers for use here by typing the '@mail' command, which prints a table of contents for your entire MOO email collection.  If no arguments are given to @read, then the 'current message' in your collection is printed.  In any case, the 'current message' after @read finishes is the last one printed.", "", "The most general form of the @read command is", "", "         @read <message-sequence> [on *<collection>]  ", "", "where <message-sequence> is as described in `help message-sequences'.", "As with the @mail command you may @read messages on any publically readable collection (child of $mail_recipient).", "", "The @peek command is a variant of @read that works no differently except that it refrains from setting your `current message'.  This is useful, for example, if you want to see some particular message on a collection without losing track of where you are in it." ]
#85 Mail Commands Help Db.@mail-options rc = MOOList [ "Syntax:  @mail-option", "         @mail-option <option>", "", "Synonym:  @mailoption", "", "The first form displays all of your mail options", "The second displays just that one option, which may be either `@mail', `replyto', or one of the flags listed below.  The mail options control various annoying details of your mail reading and mail editing commands.", "", "The remaining forms of this command are for setting your mail options:", "", "         @mail-option +<flag>", "         @mail-option -<flag>", "         @mail-option !<flag>           (equivalent to -<flag>)", "", "These respectively set and reset the specified flag", "", " -include          @replys start out with a blank message body", " +include          @replys start with original message included", " -all              @replys go to sender only", " +all              @replys go to sender and all original recipients", " -followup         @replys go as directed by `all' flag", " +followup         @replys go to first nonplayer recipient if any", "                    (if there are no non-player recipients, use `all' flag).", " -nosubject        @send forces you to provide a Subject: line", " +nosubject        allow entering the mail editor without giving a subject line", " -expert           novice mail user (various annoying messages will be printed)", " +expert           expert mail user (suppress printing of annoying messages)", " -enter            start each mail editing session in the usual command mode.", " +enter            start each mail editing session with an implicit `enter'", "                    command", " -sticky           each mail command applies by default to one's own collection", " +sticky           each mail command applies by default to the same message ", "                    collection that the previous successful command did", " -netmail          mail to you accumulates in your MOO mailbox", " +netmail          mail to you is actually forwarded to your registered email", "                    address, if you have one.", " -resend_forw      @resend puts player in Resent-By: header", " +resend_forw      @resend puts player in From: header (like @forward)", " -no_auto_forward  @netforward when expiring messages", " +no_auto_forward  do not @netforward messages when expiring mail", " -expert_netfwd    @netforward confirms before emailing messages", " +expert_netfwd    @netforward doesn't confirm before emailing messages", " -no_dupcc         send a personal copy even if already subscribed to a ", "                    mailing list on the to: line", " +no_dupcc         don't send personal copies of mail also sent to lists", "                    you are subscribed to", " -no_unsend        People may @unsend unread messages they send to you", " +no_unsend        No one may @unsend messages they sent to you", "", "For "sticky", `mail command' is one of @mail, @read, @prev, @next, @answer.", "All flags default to the `-' settings.  ", "", "Next, we have", "", "         @mail-option  manymsgs [is] <number>", "         @mail-option  manymsgs=<number>", "         @mail-option -manymsgs", "", "The first two forms specify that if you give a @mail or @read command asking for <number> or more messages, you will first be given a yes-or-no prompt to continue, the idea being that you many not actually have wanted to see that many messages.  The third form turns off this behavior.", "", "         @mail-option  @mail [is] <message-sequence>", "", "The "@mail" option determines what message-sequence the @mail command uses by ", "default.  Initially, this is "last:15", but other reasonable choices include", ""new" and "1-last"", "", "         @mail-option  replyto [is] <recipient> [<recipient>...]", "         @mail-option -replyto", "", "The first form specifies that a Reply-To: field is to be placed in all messages constructed by @send or @answer.  Note this can still be changed before sending via the mail room's reply-to command.  ", "The second form resets this option so that no Reply-to: is initially inserted.", "", "        @mail-option rn_order=<order>", "", "controls the order in which folders listed by @rn and @subscribed will appear.  <order> can be one of", "", " read    folders are sorted by last read date. (default)", " send    folders are sorted by last send date.", " fixed   folders are not sorted", "", "To control expiration of messages (see `help @keep-mail') we have", "", "        @mail-option expire [is] <time-interval>", "        @mail-option expire=<time-interval>", "", "<time-interval> can either be a number of seconds or something with units in it, e.g.,", "", "        @mail-option expire 13 days", "        @mail-option expire 1 year 39 days", "", "A negative number or", "", "        @mail-option +expire", "", "disables message expiration entirely", "", "        @mail-option -expire", "", "sets your message expiration time to the current default.", "", "        @mail-option @unsend=<message sequence>", "", "sets the default message sequence that the @unsend command will operate upon.  The default is "last:1"." ]
#85 Mail Commands Help Db.@mailoptions r = MOOList [ "*forward*", "@mail-options" ]
#85 Mail Commands Help Db.@renumber rc = MOOList [ "Syntax:  @renumber [<collection>]", "", "Renumbers the messages in your collection to go from 1 to however many you have at the moment.  The optional argument allows you to renumber the messages stored in some other collection (@renumber, like @rmmail, requires write access).", "", "Note that if you have zombie messages from a previous @rmmail command (see `help zombie-messages'), these will be expunged." ]
#85 Mail Commands Help Db.@send rc = MOOList [ "Syntax:  @send <recipient> [<recipient> ...]  [subj[ect]="<subject>"]", "", "Prepares for you to compose a MOO email message to the recipients named on the command line.  A recipient can be specified by giving a player name or object-id, or a '*' followed by the name or object-id of some non-player mail recipient (e.g., a mailing list or a mail folder) -- a list of such non-player recipients is available from within the mailroom with the 'showlists' command.", "", "The usual editor is invoked.   ", "You will be prompted for a subject line if you did not specify one in the @send command (see `help mail_options' for how to avoid this).", "Use `say' (") to insert lines in the body of your message.  ", "See `help editors' for details.", "", "Giving this command without arguments resumes editing the previous unsent draft message if one exists." ]
#85 Mail Commands Help Db.@rmmail rc = MOOList [ "Syntax:  @rmmail [<message-sequence>] [from *<recipient>]", "", "Deletes the indicated messages from your MOO email collection.", "By default, your current message is deleted.", "See `help message-sequence' for the full list of possible arguments.", "You get the message numbers for use here by typing the '@mail' command.", "", "There is no confirmation for this action, so be careful.  While it is true that @unrmmail will be able to bring back the messages deleted by the last @rmm, any messages deleted before then are really gone, i.e., irrecoverable.  See `help @unrmmail' for more information.", "", "This command may be used on other mail recipients (children of $mail_recipient), but only ones to which you have write access (you either have to own it or be on good terms with whoever does...).", "", "You can try to delete messages that you accidentally sent to a person with the command @unsend (see `help @unsend').  Note there are restrictions on the operation, so it often will not work." ]
#85 Mail Commands Help Db.@rn rc = MOOList [ "Syntax:  @rn", "", "For each collection of mail messages that you read other from your own, a last-read-time is kept.  This command tells you which collections (out of all those you have ever read) have recently had messages added to them, i.e., more recently than when you last did a @read, @prev, @next, or @skip on that collection.", "", "Etymologists' note:  If you thought @rn had anything to do with the popular UNIX newsreading program `rn', it's just your imagination." ]
#85 Mail Commands Help Db.message-sequences r = MOOList [ "Certain mail commands, including @mail, @read, and @rmmail, allow a <message-sequence> argument that indicates to which messages in one's collection the command is to apply.  Any combination of the following may appear as a <message-sequence> argument to any of the various mail commands (@mail, @read, @answer, @rmm).", "", "  17        message number 17 if there is one (and likewise for other integers)", "  17..23    all messages numbered between 17 and 23 (inclusive), if any.", "  cur       the current message", "  prev      the message before", "  next      the message after", "  prev17    the 17 messages prior to the current message", "  next17    the 17 messages after the current message", "  first     the first message if any", "  last      the final message if any (`$' is a synonym for `last')", "  new       unread messages if any", "", "You may use as many of these at once as sanity permits, e.g.,", "", "  @mail cur 1..5 last", "", "which will display the header for your current message, your messages in the range 1..5, and your last message.  Though some of these ranges may overlap, the header for any given message is only shown once in any event.", "", "In addition, there are other message-sequence arguments that act as filters on whatever precedes them. ", "", " before:<date>               messages strictly before the given date", " after:<date>                messages strictly after the given date", " since:<date>                messages on or after the given date", " until:<date>                messages on or before the given date", " from:<player>[|<player...]  messages from the given player(s)", " to:<recip>[|<recip>...]     messages to the given recipient(s)", " %from:<string>              messages with <string> in the From: line", " %to:<string>                messages with <string> in the To: line", " subject:<string>            messages with <string> in the subject", " body:<string>               messages with <string> in the body (SLOW!!!)", " first:<number>              the first <number> messages", " last:<number>               the last <number> messages", " kept:                       messages marked as kept (see `help @keep-mail')", " unkept:                     messages not marked as kept", "", "<date>  is either a weekday, "today", "yesterday", or", "        a dd-Month, dd-Month-yy or dd-Month-yyyy date", "<recip> is either <player> or *<$mail_recipient kid>", "", "Examples:", "", "  @read from:G7|Gemba              read all messages from G7 or Gemba", "  @rmm to:yduJ|*Core               remove messages that are to yduJ or to *Core", "  @mail since:1-Jan before:1-Feb   show messages dated in January", "  @mail since:Tues                 show messages dated on or after Tuesday", "  @rmm subject:manners             remove msgs with `manners' in the subject:", "  @mail subject:"stupid idiots"    (search string contains a space => need "'s)", "  @rmm to:yduJ to:*Core            remove messages that are to yduJ and *Core", "  @mail from:Haakon last:5         show the last 5 messages from Haakon", "  @mail %from:guest                show mail from players with "guest" in", "                                   their names", "  @mail last:10 body:fribble       show those of the last 10 messages having", "                                   `fribble' in the body (one should always try", "                                   to narrow body searches in this way)." ]
================================#86 FTP utilities===============================================
#86 FTP utilities.trusted rc = MOONumber 1
#86 FTP utilities.port rc = MOONumber 21
#86 FTP utilities.connections  = MOOList [ ]
#86 FTP utilities:open this n/a this
if (!this:trusted(caller_perms()))
return E_PERM;
endif
{host, ?user = "", ?pass = ""} = args;
if (typeof(conn = $network:open(host, this.port)) == ERR)
return {"Unable to connect to host."};
endif
this.connections = {@this.connections, {conn, caller_perms(), {}, 0, {}}};
if (((!this:wait_for_response(conn)) || (user && (!this:do_command(conn, "USER " + user)))) || (pass && (!this:do_command(conn, "PASS " + pass))))
messages = this:get_messages(conn);
this.connections = listdelete(this.connections, $list_utils:iassoc(conn, this.connections));
$network:close(conn);
return messages;
endif
return conn;
-------------------------------------------------------------------------------
#86 FTP utilities:close this n/a this
conn = args[1];
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
this:do_command(conn, "QUIT");
info = $list_utils:assoc(conn, this.connections);
this.connections = setremove(this.connections, info);
$network:close(conn);
if ($network:is_open(info[4]))
$network:close(info[4]);
endif
return info[3];
-------------------------------------------------------------------------------
#86 FTP utilities:do_command this n/a this
{conn, cmd, ?nowait = 0} = args;
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
$network:notify(conn, cmd);
return nowait ? 1 | this:wait_for_response(conn);
-------------------------------------------------------------------------------
#86 FTP utilities:wait_for_response this n/a this
{conn, ?first_only = 0} = args;
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
matchstr = first_only ? "^[1-9][0-9][0-9] " | "^[2-9][0-9][0-9] ";
messages = {};
result = "";
while ((typeof(result) == STR) && (!match(result, matchstr)))
result = $network:read(conn);
messages = {@messages, result};
endwhile
i = $list_utils:iassoc(conn, this.connections);
this.connections[i][3] = {@this.connections[i][3], @messages};
if (typeof(result) == STR)
if (result[1] in {"4", "5"})
player:tell(result);
return E_NONE;
else
return 1;
endif
else
return result;
endif
-------------------------------------------------------------------------------
#86 FTP utilities:controls this n/a this
return args[1].wizard || ({@$list_utils:assoc(args[2], this.connections), 0, 0}[2] == args[1]);
-------------------------------------------------------------------------------
#86 FTP utilities:get_messages this n/a this
{conn, ?keep = 0} = args;
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
i = $list_utils:iassoc(conn, this.connections);
messages = this.connections[i][3];
if (!keep)
this.connections[i][3] = {};
endif
return messages;
-------------------------------------------------------------------------------
#86 FTP utilities:open_data this n/a this
conn = args[1];
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
i = $list_utils:iassoc(conn, this.connections);
if (!$network:is_open(this.connections[i][4]))
this:do_command(conn, "PASV");
msg = (msg = this:get_messages(conn, 1))[$];
if (msg[1..3] != "227")
return E_TYPE;
elseif (!(match = match(msg, "(%([0-9]+%),%([0-9]+%),%([0-9]+%),%([0-9]+%),%([0-9]+%),%([0-9]+%))")))
return E_TYPE;
elseif (typeof(dconn = $network:open(substitute("%1.%2.%3.%4", match), (toint(substitute("%5", match)) * 256) + toint(substitute("%6", match)))) == ERR)
return dconn;
else
this.connections[i][4] = dconn;
endif
this.connections[i][5] = E_INVARG;
set_task_perms(caller_perms());
fork (0)
this:listen(conn, dconn);
endfork
endif
return 1;
-------------------------------------------------------------------------------
#86 FTP utilities:get_data this n/a this
{conn, ?nowait = 0} = args;
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
i = $list_utils:iassoc(conn, this.connections);
while ((!nowait) && (this.connections[i][5] == E_INVARG))
suspend(0);
endwhile
return this.connections[i][5];
-------------------------------------------------------------------------------
#86 FTP utilities:put_data this n/a this
{conn, data} = args;
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
i = $list_utils:iassoc(conn, this.connections);
dconn = this.connections[i][4];
if (!$network:is_open(dconn))
return E_INVARG;
else
for line in (data)
notify(dconn, line);
$command_utils:suspend_if_needed(0);
endfor
this:close_data(conn);
this.connections[i][4] = 0;
endif
-------------------------------------------------------------------------------
#86 FTP utilities:trusted this n/a this
return args[1].wizard || ((typeof(this.trusted) == LIST) ? args[1] in this.trusted | this.trusted);
-------------------------------------------------------------------------------
#86 FTP utilities:listen this n/a this
if (caller != this)
return E_PERM;
endif
{conn, dconn} = args;
data = {};
line = `read(dconn) ! ANY';
while (typeof(line) == STR)
data = {@data, line};
line = read(dconn);
$command_utils:suspend_if_needed(0);
endwhile
if (i = $list_utils:iassoc(conn, this.connections))
this.connections[i][5] = data;
endif
-------------------------------------------------------------------------------
#86 FTP utilities:close_data this n/a this
conn = args[1];
if (!this:controls(caller_perms(), conn))
return E_PERM;
endif
if (!$network:is_open(dconn = $list_utils:assoc(conn, this.connections)[4]))
return E_INVARG;
else
$network:close(dconn);
"...let the reading task come to terms with its abrupt superfluousness...";
suspend(0);
return 1;
endif
-------------------------------------------------------------------------------
#86 FTP utilities:get this n/a this
":get(host, username, password, filename)";
if (!this:trusted(caller_perms()))
return E_PERM;
endif
if (typeof(conn = this:open(@args[1..3])) != OBJ)
return E_NACC;
else
result = (this:open_data(conn) && this:do_command(conn, "RETR " + args[4])) && this:get_data(conn);
this:close(conn);
return result;
endif
-------------------------------------------------------------------------------
#86 FTP utilities:init_for_core this n/a this
if (caller_perms().wizard)
this.connections = {};
this.trusted = 1;
pass(@args);
endif
-------------------------------------------------------------------------------
#86 FTP utilities:put this n/a this
":put(host, username, password, filename, data)";
if (!this:trusted(caller_perms()))
return E_PERM;
endif
if (typeof(conn = this:open(@args[1..3])) != OBJ)
return E_NACC;
else
result = (this:open_data(conn) && this:do_command(conn, "STOR " + args[4], 1)) && this:put_data(conn, args[5]);
this:close(conn);
return result;
endif
-------------------------------------------------------------------------------
#86 FTP utilities:data_connection this n/a this
"return the data connection associated with the control connection args[1]";
conn = args[1];
i = $list_utils:iassoc(conn, this.connections);
return this.connections[i][4];
-------------------------------------------------------------------------------
================================#87 password verifier===============================================
#87 password verifier.require_funky_characters r = MOONumber 0
#87 password verifier.check_against_name r = MOONumber 0
#87 password verifier.check_against_email r = MOONumber 0
#87 password verifier.minimum_password_length r = MOONumber 0
#87 password verifier.check_against_moo r = MOONumber 0
#87 password verifier.help_msg r = MOOList [ "Password Verifier", "==================", "", "To check for the validity of a password, use", "  :reject_password( password [, for-whom? ] )", "... If it returns a true value, that value will contain the string representing the reason why the password was rejected.  If it returns a false value, the password is OK.", "", "The toggle switches for this checking are:" ]
#87 password verifier.check_obscure_stuff r = MOONumber 0
#87 password verifier.check_against_hosts r = MOONumber 0
#87 password verifier.check_against_dictionary r = MOONumber 0
#87 password verifier:help_msg this n/a this
if (typeof(base = this.(verb)) == STR)
base = {base};
endif
base = {@base, "", tostr(".minimum_password_length = ", toliteral(x = this.minimum_password_length)), x ? tostr("Passwords are required to be a minimum of ", $string_utils:english_number(x), " characters in length.") | "There is no minimum length requirement for passwords."};
base = {@base, "", tostr(".check_against_moo = ", toliteral(x = this.check_against_moo)), tostr("Passwords ", x ? "may not" | "may", " be variants on the MOO's name (", $network.MOO_name, ").")};
base = {@base, "", tostr(".check_against_name = ", toliteral(x = this.check_against_name)), tostr("Passwords ", x ? "may not" | "may", " be variants on the player's MOO name and/or aliases.")};
base = {@base, "", tostr(".check_against_email = ", toliteral(x = this.check_against_email)), x ? "Passwords may not be variants on the player's email address." | "Passwords are not checked against the player's email address."};
base = {@base, "", tostr(".check_against_hosts = ", toliteral(x = this.check_against_hosts)), x ? "Passwords may not be variants on the player's hostname(s)." | "Passwords are not checked against the player's hostname(s)."};
base = {@base, "", tostr(".check_against_dictionary = ", toliteral(x = this.check_against_dictionary)), tostr("Passwords ", (typeof(x) in {LIST, OBJ}) ? "may not" | "may", " be dictionary words.", (x && (!$network.active)) ? "  (This option is set but unavailable.)" | "")};
base = {@base, "", tostr(".require_funky_characters = ", toliteral(x = this.require_funky_characters)), tostr("Non-alphabetic characters are ", x ? "" | "not ", "required in passwords.")};
base = {@base, "", tostr(".check_obscure_stuff = ", toliteral(x = this.check_obscure_stuff)), x ? "Misc. obscure checks enabled" | "No obscure checks in use."};
return base;
-------------------------------------------------------------------------------
#87 password verifier:reject_password this n/a this
":reject_password ( STR password [ , OBJ for-whom ] );";
"=> string value [if the password is rejected, why?]";
"=> false value [if the password isn't rejected]";
if (length(args) == 1)
trust = 0;
else
if ($perm_utils:controls(caller_perms(), args[2]))
trust = 1;
else
return "Permissions don't permit setting of that password.";
endif
endif
"this is gonna be huge";
return (((((((this:trivial_check(@args) || (this.minimum_password_length && this:check_length(@args))) || ((this.check_against_name && trust) && this:check_name(@args))) || ((this.check_against_email && trust) && this:check_email(@args))) || ((this.check_against_hosts && trust) && this:check_hosts(@args))) || ((typeof(this.check_against_dictionary) in {LIST, OBJ}) && this:check_dictionary(@args))) || (this.require_funky_characters && this:check_for_funky_characters(@args))) || (this.check_against_moo && this:check_against_moo(@args))) || (this.check_obscure_stuff && this:check_obscure_combinations(@args));
-------------------------------------------------------------------------------
#87 password verifier:trivial_check this n/a this
if (typeof(pwd = args[1]) != STR)
return "Passwords must be strings.";
elseif (index(pwd, " "))
return "Passwords may not contain spaces.";
elseif (length(args) == 2)
if (((typeof(who = args[2]) != OBJ) || (!valid(who))) || (!is_player(who)))
return "That's not a player.";
elseif (!$perm_utils:controls(caller_perms(), who))
return "You can't set the password for that player.";
elseif ($object_utils:isa(who, $guest))
return "Sorry, but guest characters are not allowed to change their passwords.";
endif
endif
-------------------------------------------------------------------------------
#87 password verifier:check_length this n/a this
if ((l = this.minimum_password_length) && (length(args[1]) < l))
return tostr("Passwords must be a minimum of ", $string_utils:english_number(l), (l == 1) ? " character " | " characters ", "long.");
endif
-------------------------------------------------------------------------------
#87 password verifier:check_name this n/a this
pwd = args[1];
if (valid($player_db:find_exact(pwd)))
return "Passwords may not be close to a player's name/alias pair.";
elseif (valid($player_db:find($string_utils:reverse(pwd))))
return "Passwords ought not be the reverse of a player's name/alias.";
endif
-------------------------------------------------------------------------------
#87 password verifier:check_email this n/a this
{pwd, who} = args;
if (!$perm_utils:controls(caller_perms(), who))
return "Permission denied.";
endif
email = $wiz_utils:get_email_address(who);
if (!email)
"can't check";
return;
endif
if (index(email, pwd))
return "Passwords can't match your registered email address.";
endif
-------------------------------------------------------------------------------
#87 password verifier:check_hosts this n/a this
{pwd, who} = args;
if (!$perm_utils:controls(caller_perms(), who))
return "Permission denied.";
endif
hosts = who.all_connect_places;
for x in (hosts)
if (index(x, pwd))
return "Passwords may not match hostnames.";
endif
endfor
-------------------------------------------------------------------------------
#87 password verifier:check_dictionary this n/a this
pwd = args[1];
if ((typeof(dict = this.check_against_dictionary) == LIST) && $network.active)
"assume we're checking an on-line dictionary";
dict[3] = dict[3] + pwd;
result = $gopher:get(@dict);
if (typeof(result) == ERR)
"we probably can't check the dictionary anyway";
return;
elseif ((result[1] && (result[1][1] != "0")) && (!this:_is_funky_case(pwd)))
return "Dictionary words are not permitted for passwords.";
endif
elseif (typeof(dict) == OBJ)
"assume we're checking mr spell";
try
if (dict:find_exact(pwd) && (!this:_is_funky_case(pwd)))
return "Dictionary words are not permitted for passwords.";
endif
except (ANY)
"in case this is messed up. Just let it go and return 0;";
endtry
endif
-------------------------------------------------------------------------------
#87 password verifier:check_for_funky_characters this n/a this
if (this:_is_funky_case(pwd = args[1]))
return;
endif
alphabet = $string_utils.alphabet;
for i in [1..length(pwd)]
if (!index(alphabet, pwd[i]))
return;
endif
endfor
return "At least one unusual capitalization and/or numeric or punctuation character is required.";
-------------------------------------------------------------------------------
#87 password verifier:check_against_moo this n/a this
pwd = args[1];
moo = $network.MOO_Name;
if (this:_is_funky_case(pwd))
return;
endif
if (pwd == moo)
return "The MOO's name is not secure as a password.";
endif
if (moo[$ - 2..$] == "MOO")
if (pwd == moo[1..$ - 3])
return "The MOO's name is not secure as a password.";
endif
endif
-------------------------------------------------------------------------------
#87 password verifier:_is_funky_case this n/a this
pwd = args[1];
if (!strcmp(pwd, u = $string_utils:uppercase(pwd)))
return 0;
elseif (!strcmp(pwd, l = $string_utils:lowercase(pwd)))
return 0;
elseif (!strcmp(pwd, tostr(u[1], l[2..$])))
return 0;
else
return 1;
endif
-------------------------------------------------------------------------------
#87 password verifier:check_obscure_combinations this n/a this
pwd = args[1];
if (match(pwd, "^[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]$"))
return "Social security numbers are potentially insecure passwords.";
elseif (match(pwd, "^[0-9]+/[0-9]+/[0-9]+$"))
return "Passwords which look like dates are potentially insecure passwords.";
endif
-------------------------------------------------------------------------------
#87 password verifier:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
this.minimum_password_length = this.check_against_name = this.check_against_email = this.check_against_hosts = this.check_against_dictionary = this.require_funky_characters = this.check_against_moo = this.check_obscure_stuff = 0;
endif
-------------------------------------------------------------------------------
================================#88 Frand's player class===============================================
#88 Frand's player class.report_refusal r = MOONumber 0
#88 Frand's player class.rooms r = MOOList [ ]
#88 Frand's player class.at_room_width rc = MOONumber 30
#88 Frand's player class.player_port_msg rc = MOOString "You teleport %n."
#88 Frand's player class.page_refused r = MOONumber 0
#88 Frand's player class.join_msg rc = MOOString "You join %n."
#88 Frand's player class.player_arrive_msg rc = MOOString "%T teleports %n in."
#88 Frand's player class.page_refused_msg rc = MOOString "%N refuses your page."
#88 Frand's player class.object_port_msg rc = MOOString "teleports you."
#88 Frand's player class.whisper_refused_msg rc = MOOString "%N refuses your whisper."
#88 Frand's player class.victim_port_msg rc = MOOString "teleports you."
#88 Frand's player class.oplayer_port_msg rc = MOOString "%T teleports %n out."
#88 Frand's player class.thing_port_msg rc = MOOString "You teleport %n."
#88 Frand's player class.default_refusal_time r = MOONumber 604800
#88 Frand's player class.refused_until r = MOOList [ ]
#88 Frand's player class.refused_actions r = MOOList [ ]
#88 Frand's player class.self_port_msg rc = MOOString ""
#88 Frand's player class.mail_refused_msg rc = MOOString "%N refuses your mail."
#88 Frand's player class.spurned_objects r = MOOList [ ]
#88 Frand's player class.refused_extra r = MOOList [ ]
#88 Frand's player class.oself_port_msg rc = MOOString "%<teleports> out."
#88 Frand's player class.at_number rc = MOONumber 0
#88 Frand's player class.refused_origins r = MOOList [ ]
#88 Frand's player class.thing_arrive_msg rc = MOOString "%T teleports %n in."
#88 Frand's player class.self_arrive_msg rc = MOOString "%<teleports> in."
#88 Frand's player class.othing_port_msg rc = MOOString "%T teleports %n out."
#88 Frand's player class:@rooms none n/a none
"'@rooms' - List the rooms which are known by name.";
line = "";
for item in (this.rooms)
line = (((line + item[1]) + "(") + tostr(item[2])) + ")   ";
endfor
player:tell(line);
-------------------------------------------------------------------------------
#88 Frand's player class:names_of this n/a this
"Return a string giving the names of the objects in a list. Now on $string_utils";
return $string_utils:names_of(@args);
-------------------------------------------------------------------------------
#88 Frand's player class:@go any n/a none
"'@go <place>' - Teleport yourself somewhere. Example: '@go liv' to go to the living room.";
dest = this:lookup_room(dobjstr);
if (dest == $failed_match)
player:tell("There's no such place known.");
else
this:teleport(player, dest);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:lookup_room this n/a this
"Look up a room in your personal database of room names, returning its object number. If it's not in your database, it checks to see if it's a number or a nearby object.";
room = args[1];
if (room == "home")
return player.home;
elseif (room == "me")
return player;
elseif (room == "here")
return player.location;
elseif (!room)
return $failed_match;
endif
index = this:index_room(room);
if (index)
return this.rooms[index][2];
else
return this:my_match_object(room);
"old code no longer used, 2/11/96 Heathcliff";
source = player.location;
if (!(valid(source) && ($room in $object_utils:ancestors(source))))
source = $room;
endif
return source:match_object(room);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:teleport this n/a this
"Teleport a player or object. For printing messages, there are three cases: (1) teleport self (2) teleport other player (3) teleport object. There's a spot of complexity for handling the invalid location #-1.";
set_task_perms((caller == this) ? this | $no_one);
{thing, dest} = args;
source = thing.location;
if (valid(dest))
dest_name = dest.name;
else
dest_name = tostr(dest);
endif
if (source == dest)
player:tell(thing.name, " is already at ", dest_name, ".");
return;
endif
thing:moveto(dest);
if (thing.location == dest)
tsd = {thing, source, dest};
if (thing == player)
this:teleport_messages(@tsd, this:self_port_msg(@tsd), this:oself_port_msg(@tsd), this:self_arrive_msg(@tsd), "");
elseif (is_player(thing))
this:teleport_messages(@tsd, this:player_port_msg(@tsd), this:oplayer_port_msg(@tsd), this:player_arrive_msg(@tsd), this:victim_port_msg(@tsd));
else
this:teleport_messages(@tsd, this:thing_port_msg(@tsd), this:othing_port_msg(@tsd), this:thing_arrive_msg(@tsd), this:object_port_msg(@tsd));
endif
elseif (thing.location == source)
if ($object_utils:contains(thing, dest))
player:tell("Ooh, it's all twisty. ", dest_name, " is inside ", thing.name, ".");
else
if ($object_utils:has_property(thing, "po"))
pronoun = thing.po;
else
pronoun = "it";
endif
player:tell("Either ", thing.name, " doesn't want to go, or ", dest_name, " didn't accept ", pronoun, ".");
endif
else
thing_name = (thing == player) ? "you" | thing.name;
player:tell("A strange force deflects ", thing_name, " from the destination.");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:teleport_messages this n/a this
"Send teleport messages. There's a slight complication in that the source and dest need not be valid objects.";
{thing, source, dest, pmsg, smsg, dmsg, tmsg} = args;
if (pmsg)
"The player's own message.";
player:tell(pmsg);
endif
if (smsg)
`source:room_announce_all_but({thing, player}, smsg) ! E_VERBNF, E_INVIND';
endif
if (dmsg)
`dest:room_announce_all_but({thing, player}, dmsg) ! E_VERBNF, E_INVIND';
endif
if (tmsg)
"A message to the victim being teleported.";
thing:tell(tmsg);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@move any ?-2? any
"'@move <object> to <place>' - Teleport an object. Example: '@move trash to #11' to move trash to the closet.";
here = player.location;
if ((prepstr != "to") || (!iobjstr))
player:tell("Usage: @move <object> to <location>");
return;
endif
if ((!dobjstr) || (dobjstr == "me"))
thing = this;
else
thing = `here:match_object(dobjstr) ! E_VERBNF, E_INVIND => $failed_match';
if (thing == $failed_match)
thing = player:my_match_object(dobjstr);
endif
endif
if ($command_utils:object_match_failed(thing, dobjstr))
return;
endif
if ((!player.programmer) && ((thing.owner != player) && (thing != player)))
player:tell("You can only move your own objects.");
return;
endif
dest = this:lookup_room(iobjstr);
if ((dest == #-1) || (!$command_utils:object_match_failed(dest, iobjstr)))
this:teleport(thing, dest);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:index_room this n/a this
"'index_room (<room name>)' - Look up a room in your personal database of room names, returning its index in the list. Return 0 if it is not in the list. If the room name is the empty string, then only exact matches are considered; otherwise, a leading match is good enough.";
room = tostr(args[1]);
size = length(room);
index = 1;
match = 0;
for item in (this.rooms)
item_name = item[1];
if (room == item_name)
return index;
elseif ((size && (length(item_name) >= size)) && (room == item_name[1..size]))
match = index;
endif
index = index + 1;
endfor
return match;
-------------------------------------------------------------------------------
#88 Frand's player class:@addr*oom any n/a none
"'@addroom <name> <object>', '@addroom <object> <name>', '@addroom <name>', '@addroom <object>', '@addroom' - Add a room to your personal database of teleport destinations. Example: '@addroom Kitchen #24'. Reasonable <object>s are numbers (#17) and 'here'. If you leave out <object>, the object is the current room. If you leave out <name>, the name is the specified room's name. If you leave out both, you get the current room and its name.";
if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))
if (!caller)
player:tell(E_PERM);
endif
return E_PERM;
endif
if (!dobjstr)
object = this.location;
name = valid(object) ? object.name | "Nowhere";
elseif (command = this:parse_out_object(dobjstr))
name = command[1];
object = command[2];
else
name = dobjstr;
object = this.location;
endif
if (!valid(object))
player:tell("This is not a valid location.");
return E_INVARG;
endif
player:tell("Adding ", name, "(", tostr(object), ") to your database of rooms.");
this.rooms = {@this.rooms, {name, object}};
-------------------------------------------------------------------------------
#88 Frand's player class:@rmr*oom any n/a none
"'@rmroom <roomname>' - Remove a room from your personal database of teleport destinations. Example: '@rmroom library'.";
if (((!caller) && (player != this)) || (caller && (callers()[1][3] != this)))
if (!caller)
player:tell(E_PERM);
endif
return E_PERM;
endif
index = this:index_room(dobjstr);
if (index)
player:tell("Removing ", this.rooms[index][1], "(", this.rooms[index][2], ").");
this.rooms = listdelete(this.rooms, index);
else
player:tell("That room is not in your database of rooms. Check '@rooms'.");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@join any n/a none
"'@join <player>' - Teleport yourself to the location of any player, whether connected or not.";
if (dobjstr == "")
player:tell("Usage: @join <player>. For example, '@join frand'.");
return;
endif
target = $string_utils:match_player(dobjstr);
$command_utils:player_match_result(target, dobjstr);
if (valid(target))
if (target == this)
if (player == this)
player:tell("There is little need to join yourself, unless you are split up.");
else
player:tell("No thank you. Please get your own join verb.");
endif
return;
endif
dest = target.location;
msg = this:enlist(this:join_msg());
editing = $object_utils:isa(dest, $generic_editor);
if (editing)
dest = dest.original[target in dest.active];
editing_msg = "%N is editing at the moment. You can wait here until %s is done.";
if (player.location == dest)
msg = {editing_msg};
else
msg = {@msg, editing_msg};
endif
endif
if (msg && ((player.location != dest) || editing))
player:tell_lines($string_utils:pronoun_sub(msg, target));
elseif (player.location == dest)
player:tell("OK, you're there. You didn't need to actually move, though.");
return;
endif
this:teleport(player, dest);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@find any n/a none
"'@find #<object>', '@find <player>', '@find :<verb>' '@find .<property>' - Attempt to locate things. Verbs and properties are found on any object in the player's vicinity, and some other places.  '@find ?<help>' looks for a help topic on any available help database.";
if (!dobjstr)
player:tell("Usage: '@find #<object>' or '@find <player>' or '@find :<verb>' or '@find .<property>' or '@find ?<help topic>'.");
return;
endif
if (dobjstr[1] == ":")
name = dobjstr[2..$];
this:find_verb(name);
return;
elseif (dobjstr[1] == ".")
name = dobjstr[2..$];
this:find_property(name);
return;
elseif (dobjstr[1] == "#")
target = toobj(dobjstr);
if (!valid(target))
player:tell(target, " does not exist.");
endif
elseif (dobjstr[1] == "?")
name = dobjstr[2..$];
this:find_help(name);
return;
else
target = $string_utils:match_player(dobjstr);
$command_utils:player_match_result(target, dobjstr);
endif
if (valid(target))
player:tell(target.name, " (", target, ") is at ", valid(target.location) ? target.location.name | "Nowhere", " (", target.location, ").");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:find_verb this n/a this
"'find_verb (<name>)' - Search for a verb with the given name. The objects searched are those returned by this:find_verbs_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.";
name = args[1];
results = "";
objects = $list_utils:remove_duplicates(this:find_verbs_on());
for thing in (objects)
if (valid(thing) && (mom = $object_utils:has_verb(thing, name)))
results = ((((results + "   ") + thing.name) + "(") + tostr(thing)) + ")";
mom = mom[1];
if (thing != mom)
results = ((((results + "--") + mom.name) + "(") + tostr(mom)) + ")";
endif
endif
endfor
if (results)
this:tell("The verb :", name, " is on", results);
else
this:tell("The verb :", name, " is nowhere to be found.");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@ways any n/a none
"'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given).";
if (dobjstr)
room = dobj;
else
room = this.location;
endif
if ((!valid(room)) || (!($room in $object_utils:ancestors(room))))
player:tell("You can only pry into the exits of a room.");
return;
endif
exits = {};
if ($object_utils:has_verb(room, "obvious_exits"))
exits = room:obvious_exits();
endif
exits = this:checkexits(this:obvious_exits(), room, exits);
exits = this:findexits(room, exits);
this:tell_ways(exits, room);
-------------------------------------------------------------------------------
#88 Frand's player class:findexits this n/a this
"Add to the 'exits' list any exits in the room which have a single-letter alias.";
{room, exits} = args;
alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
for i in [1..length(alphabet)]
found = room:match_exit(alphabet[i]);
if (valid(found) && (!(found in exits)))
exits = {@exits, found};
endif
endfor
return exits;
-------------------------------------------------------------------------------
#88 Frand's player class:checkexits this n/a this
"Check a list of exits to see if any of them are in the given room.";
{to_check, room, exits} = args;
for word in (to_check)
found = room:match_exit(word);
if (valid(found) && (!(found in exits)))
exits = {@exits, found};
endif
endfor
return exits;
-------------------------------------------------------------------------------
#88 Frand's player class:self_port_msg player_port_msg thing_port_msg join_msg this n/a this
"This verb returns messages that go only to you. You don't need to have your name tacked on to the beginning of these. Heh.";
msg = this.(verb);
if (msg && (length(args) >= 3))
msg = this:msg_sub(msg, @args);
endif
return msg;
-------------------------------------------------------------------------------
#88 Frand's player class:oself_port_msg self_arrive_msg oplayer_port_msg player_arrive_msg victim_port_msg othing_port_msg thing_arrive_msg object_port_msg this n/a this
"This verb returns messages that go to other players. It does pronoun substitutions; if your name is not included in the final string, it adds the name in front.";
msg = this.(verb);
if (!msg)
msg = $frand_class.(verb);
endif
if (length(args) >= 3)
msg = this:msg_sub(msg, @args);
endif
if (!$string_utils:index_delimited(msg, player.name))
msg = (player.name + " ") + msg;
endif
return msg;
-------------------------------------------------------------------------------
#88 Frand's player class:msg_sub this n/a this
"Do pronoun and other substitutions on the teleport messages. The arguments are: 1. The original message, before any substitutions; 2. object being teleported; 3. from location; 4. to location. The return value is the final message.";
{msg, thing, from, to} = args;
msg = $string_utils:substitute(msg, $string_utils:pronoun_quote({{"%<from room>", valid(from) ? from.name | "Nowhere"}, {"%<to room>", valid(to) ? to.name | "Nowhere"}}));
msg = $string_utils:pronoun_sub(msg, thing);
return msg;
-------------------------------------------------------------------------------
#88 Frand's player class:obvious_exits this n/a this
"'obvious_exits()' - Return a list of common exit names which are obviously worth looking for in a room.";
return {"n", "ne", "e", "se", "s", "sw", "w", "nw", "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "u", "d", "up", "down", "out", "exit", "leave", "enter"};
-------------------------------------------------------------------------------
#88 Frand's player class:tell_ways this n/a this
":tell_ways (<list of exits>)' - Tell yourself a list of exits, for @ways. You can override it to print the exits in any format.";
exits = args[1];
answer = {};
for e in (exits)
answer = {@answer, ((e.name + " (") + $string_utils:english_list(e.aliases)) + ")"};
endfor
player:tell("Obvious exits: ", $string_utils:english_list(answer), ".");
-------------------------------------------------------------------------------
#88 Frand's player class:tell_obj this n/a this
"Return the name and number of an object, e.g. 'Root Class (#1)'.";
o = args[1];
return (((valid(o) ? o.name | "Nothing") + " (") + tostr(o)) + ")";
-------------------------------------------------------------------------------
#88 Frand's player class:parse_out_object this n/a this
"'parse_out_object (<string>)' -> {<name>, <object>}, or 0. Given a string, attempt to find an object at its beginning or its end. An object can be either an object number, or 'here'. If this succeeds, return a list of the object and the unmatched part of the string, called the name. If it fails, return 0.";
words = $string_utils:words(args[1]);
if (!length(words))
return 0;
endif
word1 = words[1];
wordN = words[$];
if (length(word1) && (word1[1] == "#"))
start = 2;
finish = length(words);
what = toobj(word1);
elseif (word1 == "here")
start = 2;
finish = length(words);
what = this.location;
elseif (length(wordN) && (wordN[1] == "#"))
start = 1;
finish = length(words) - 1;
what = toobj(wordN);
elseif (wordN == "here")
start = 1;
finish = length(words) - 1;
what = this.location;
else
return 0;
endif
"toobj() has the nasty property that invalid strings get turned into #0. Here we just pretend that all references to #0 are actually meant for #-1.";
if (what == #0)
what = $nothing;
endif
name = $string_utils:from_list(words[start..finish], " ");
if (!name)
name = valid(what) ? what.name | "Nowhere";
endif
return {name, what};
-------------------------------------------------------------------------------
#88 Frand's player class:enlist this n/a this
"'enlist (<x>)' - If x is a list, just return it; otherwise, return {x}. The purpose here is to turn message strings into lists, so that lines can be added. It is not guaranteed to work for non-string non-lists.";
x = args[1];
if (!x)
return {};
elseif (typeof(x) == LIST)
return x;
else
return {x};
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@spellm*essages @spellp*roperties any ?-2? any
"@spellproperties <object>";
"@spellmessages <object>";
"Spell checks the string properties of an object, or the subset of said properties which are suffixed _msg, respectively.";
set_task_perms(player);
if (!dobjstr)
player:notify(tostr("Usage: ", verb, " <object>"));
return;
elseif ($command_utils:object_match_failed(dobj = player:my_match_object(dobjstr), dobjstr))
return;
elseif (typeof(props = $object_utils:all_properties(dobj)) == ERR)
player:notify("Permission denied to read properties on that object.");
return;
endif
props = setremove(props, "messages");
if (verb[1..7] == "@spellm")
spell = {};
for prop in (props)
if ((index(prop, "_msg") == (length(prop) - 3)) && index(prop, "_msg"))
spell = {@spell, prop};
endif
endfor
props = spell;
endif
if (props == {})
player:notify(tostr("No ", (verb[1..7] == "@spellm") ? "messages" | "properties", " found to spellcheck on ", dobj, "."));
return;
endif
for data in (props)
if (typeof(dd = `dobj.(data) ! ANY') == LIST)
text = {};
for linenum in (dd)
text = listappend(text, linenum);
endfor
elseif ((((typeof(dd) == OBJ) || (typeof(dd) == INT)) || (typeof(dd) == ERR)) || (typeof(dd) == FLOAT))
text = "";
elseif (typeof(dd) == STR)
text = dd;
endif
if (typeof(text) == STR)
text = {text};
endif
linenumber = 0;
for thisline in (text)
$command_utils:suspend_if_needed(0);
linenumber = linenumber + 1;
if (((((typeof(thisline) != LIST) && (typeof(thisline) != OBJ)) && (typeof(thisline) != INT)) && (typeof(thisline) != FLOAT)) && (typeof(thisline) != ERR))
i = $string_utils:strip_chars(thisline, "!@#$%^&*()_+1234567890={}[]<>?:;,./|\"~'");
if (i)
i = $string_utils:words(i);
for ii in [1..length(i)]
$command_utils:suspend_if_needed(0);
if (!$spell:valid(i[ii]))
if ((rindex(i[ii], "s") == length(i[ii])) && $spell:valid(i[ii][1..$ - 1]))
msg = "Possible match: " + i[ii];
elseif ((rindex(i[ii], "'s") == (length(i[ii]) - 1)) && $spell:valid(i[ii][1..$ - 2]))
msg = "Possible match: " + i[ii];
else
msg = "Unknown word: " + i[ii];
endif
if (length(text) == 1)
foo = ": ";
else
foo = (" (line " + tostr(linenumber)) + "): ";
endif
player:notify(tostr(dobj, ".", data, foo, msg));
endif
endfor
endif
endif
endfor
endfor
player:notify(tostr("Done spellchecking ", dobj, "."));
-------------------------------------------------------------------------------
#88 Frand's player class:@at any ?-2? any
"'@at' - Find out where everyone is. '@at <player>' - Find out where <player> is, and who else is there. '@at <obj>' - Find out who else is at the same place as <obj>. '@at <place>' - Find out who is at the place. The place can be given by number, or it can be a name from your @rooms list. '@at #-1' - Find out who is at #-1. '@at me' - Find out who is in the room with you. '@at home' - Find out who is at your home.";
this:internal_at(argstr);
-------------------------------------------------------------------------------
#88 Frand's player class:at_players this n/a this
"'at_players ()' - Return a list of players to be displayed by @at.";
return connected_players();
-------------------------------------------------------------------------------
#88 Frand's player class:do_at_all this n/a this
"'do_at_all ()' - List where everyone is, sorted by popularity of location. This is called when you type '@at'.";
locations = {};
parties = {};
counts = {};
for who in (this:at_players())
loc = who.location;
if (i = loc in locations)
parties[i] = setadd(parties[i], who);
counts[i] = counts[i] - 1;
else
locations = {@locations, loc};
parties = {@parties, {who}};
counts = {@counts, 0};
endif
endfor
locations = $list_utils:sort(locations, counts);
parties = $list_utils:sort(parties, counts);
this:print_at_items(locations, parties);
-------------------------------------------------------------------------------
#88 Frand's player class:do_at this n/a this
"'do_at (<location>)' - List the players at a given location.";
loc = args[1];
party = {};
for who in (this:at_players())
if (who.location == loc)
party = setadd(party, who);
endif
endfor
this:print_at_items({loc}, {party});
-------------------------------------------------------------------------------
#88 Frand's player class:print_at_items this n/a this
"'print_at_items (<locations>, <parties>)' - Print a list of locations and people, for @at. Override this if you want to make a change to @at's output that you can't make in :at_item.";
{locations, parties} = args;
for i in [1..length(locations)]
$command_utils:suspend_if_needed(0);
player:tell_lines(this:at_item(locations[i], parties[i]));
endfor
-------------------------------------------------------------------------------
#88 Frand's player class:at_item this n/a this
"'at_item (<location>, <party>)' - Given a location and a list of the people there, return a string displaying the information. Override this if you want to change the format of each line of @at's output.";
{loc, party} = args;
su = $string_utils;
if (this.at_number)
number = su:right(tostr(loc), 7) + " ";
else
number = "";
endif
room = su:left(valid(loc) ? loc.name | "[Nowhere]", this.at_room_width);
if (length(room) > this.at_room_width)
room = room[1..this.at_room_width];
endif
text = (number + room) + " ";
if (party)
filler = su:space(length(text) - 2);
line = text;
text = {};
for who in (party)
name = " " + (valid(who) ? who.name | "[Nobody]");
if ((length(line) + length(name)) > this:linelen())
text = {@text, line};
line = filler + name;
else
line = line + name;
endif
endfor
text = {@text, line};
else
text = text + " [deserted]";
endif
return text;
-------------------------------------------------------------------------------
#88 Frand's player class:internal_at this n/a this
"'internal_at (<argument string>)' - Perform the function of @at. The argument string is whatever the user typed after @at. This is factored out so that other verbs can call it.";
where = $string_utils:trim(args[1]);
if (where)
if (where[1] == "#")
result = toobj(where);
if ((!valid(result)) && (result != #-1))
player:tell("That object does not exist.");
return;
endif
else
result = this:lookup_room(where);
if (!valid(result))
result = $string_utils:match_player(where);
if (!valid(result))
player:tell("That is neither a player nor a room name.");
return;
endif
endif
endif
if (valid(result) && (!$object_utils:isa(result, $room)))
result = result.location;
endif
this:do_at(result);
else
this:do_at_all();
endif
-------------------------------------------------------------------------------
#88 Frand's player class:confunc this n/a this
"'confunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has connected.";
if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))
return E_PERM;
endif
pass(@args);
set_task_perms(this);
for feature in (this.features)
try
feature:player_connected(player, @args);
except (E_VERBNF)
continue feature;
except id (ANY)
player:tell("Feature initialization failure for ", feature, ": ", id[2], ".");
endtry
$command_utils:suspend_if_needed(0);
endfor
-------------------------------------------------------------------------------
#88 Frand's player class:disfunc this n/a this
"'disfunc ()' - Besides the inherited behavior, notify the player's feature objects that the player has disconnected.";
if ((valid(cp = caller_perms()) && (caller != this)) && (!$perm_utils:controls(cp, this)))
return E_PERM;
endif
pass(@args);
"This is forked off to protect :disfunc from buggy :player_disconnected verbs.";
set_task_perms(this);
fork (max(0, $login:current_lag()))
for feature in (this.features)
try
feature:player_disconnected(player, @args);
except (ANY)
continue feature;
endtry
endfor
endfork
-------------------------------------------------------------------------------
#88 Frand's player class:@addword @adddict any ?-2? any
set_task_perms(player);
if ((verb == "@adddict") && (!((player in $spell.trusted) || player.wizard)))
player:tell("You may not add to the master dictionary. The following words will instead by put in a list of words to be approved for later addition to the dictionary. Thanks for your contribution.");
endif
if (!argstr)
player:notify(tostr("Usage: ", verb, " one or more words"));
player:notify(tostr("       ", verb, " object:verb"));
player:notify(tostr("       ", verb, " object.prop"));
elseif (!$perm_utils:controls(player, player))
player:notify("Cannot modify dictionary on players who do not own themselves.");
elseif (data = $spell:get_input(argstr))
num_learned = 0;
for i in [1..length(data)]
line = $string_utils:words(data[i]);
for ii in [1..length(line)]
if (seconds_left() < 2)
suspend(0);
endif
if (verb == "@adddict")
result = $spell:add_word(line[ii]);
if (result == E_PERM)
if ($spell:find_exact(line[ii]) == $failed_match)
player:notify(tostr("Submitted for approval:  ", line[ii]));
$spell:submit(line[ii]);
else
player:notify(tostr("Already in dictionary:  " + line[ii]));
endif
elseif (typeof(result) == ERR)
player:notify(tostr(result));
elseif (result)
player:notify(tostr("Word added:  ", line[ii]));
num_learned = num_learned + 1;
else
player:notify(tostr("Already in dictionary:  " + line[ii]));
endif
elseif (!$spell:valid(line[ii]))
player.dict = listappend(player.dict, line[ii]);
player:notify(tostr("Word added:  ", line[ii]));
num_learned = num_learned + 1;
endif
endfor
endfor
player:notify(tostr(num_learned ? num_learned | "No", " word", (num_learned != 1) ? "s " | " ", "added to ", (verb == "@adddict") ? "main " | "personal ", "dictionary."));
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@spell @cspell @complete any ?-2? any
"@spell a word or phrase  -- Spell check a word or phrase.";
"@spell thing.prop  -- Spell check a property. The value must be a string or a list of strings.";
"@spell thing:verb  -- Spell check a verb. Only the quoted strings in the verb are checked.";
"@cspell word  -- Spell check a word, and if it is not in the dictionary, offset suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.";
"@complete prefix  -- List all the word in the dictionary which begin with the given prefix. For example, `@complete zoo' lists zoo, zoologist, zoology, and zoom.";
"";
"Mr. Spell was written by waffle (waffle@euclid.humboldt.edu), for use by";
"MOOers all over this big green earth. (....and other places....)";
"This monstrosity programmed Sept-Oct 1991, when I should have been studying.";
set_task_perms(player);
if (!argstr)
if (verb == "@complete")
player:notify(tostr("Usage: ", verb, " word-prefix"));
else
player:notify(tostr("Usage: ", verb, " object.property"));
player:notify(tostr("       ", verb, " object:verb"));
player:notify(tostr("       ", verb, " one or more words"));
endif
elseif (verb == "@complete")
if ((foo = $string_utils:from_list($spell:sort($spell:find_all(argstr)), " ")) == "")
player:notify(tostr("No words found that begin with `", argstr, "'"));
else
player:notify(tostr(foo));
endif
else
"@spell or @cspell.";
corrected_words = {};
data = $spell:get_input(argstr);
if (data)
misspelling = 0;
for i in [1..length(data)]
line = $string_utils:words(data[i]);
for ii in [1..length(line)]
$command_utils:suspend_if_needed(0);
if (!$spell:valid(line[ii]))
if ((rindex(line[ii], "s") == length(line[ii])) && $spell:valid(line[ii][1..$ - 1]))
msg = "Possible match: " + line[ii];
msg = (msg + " ") + ((length(data) != 1) ? ("(line " + tostr(i)) + ")  " | "  ");
elseif ((rindex(line[ii], "'s") == (length(line[ii]) - 1)) && $spell:valid(line[ii][1..$ - 2]))
msg = "Possible match: " + line[ii];
msg = (msg + " ") + ((length(data) != 1) ? ("(line " + tostr(i)) + ")  " | "  ");
else
misspelling = misspelling + 1;
msg = ("Unknown word: " + line[ii]) + ((length(data) != 1) ? (" (line " + tostr(i)) + ")  " | "  ");
if ((verb == "@cspell") && (!(line[ii] in corrected_words)))
corrected_words = listappend(corrected_words, line[ii]);
guesses = $string_utils:from_list($spell:guess_words(line[ii]), " ");
if (guesses == "")
msg = msg + "-No guesses";
else
msg = msg + "-Possible correct spelling";
msg = msg + (index(guesses, " ") ? "s: " | ": ");
msg = msg + guesses;
endif
endif
endif
player:notify(tostr(msg));
endif
endfor
endfor
player:notify(tostr("Found ", misspelling ? misspelling | "no", " misspelled word", (misspelling == 1) ? "." | "s."));
elseif (data != $failed_match)
player:notify(tostr("Nothing found to spellcheck!"));
endif
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@rmword any ?-2? any
set_task_perms(player);
if (argstr in player.dict)
player.dict = setremove(player.dict, argstr);
player:notify(tostr("`", argstr, "' removed from personal dictionary."));
else
player:notify(tostr("`", argstr, "' not found in personal dictionary."));
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@rmdict any ?-2? any
set_task_perms(player);
result = $spell:remove_word(argstr);
if (result == E_PERM)
player:notify("You may not remove words from the main dictionary. Use `@rmword' to remove words from your personal dictionary.");
elseif (typeof(result) == ERR)
player:notify(tostr(result));
elseif (result)
player:notify(tostr("`", argstr, "' removed."));
else
player:notify(tostr("`", argstr, "' not found in dictionary."));
endif
-------------------------------------------------------------------------------
#88 Frand's player class:find_property this n/a this
"'find_property (<name>)' - Search for a property with the given name. The objects searched are those returned by this:find_properties_on(). The printing order relies on $list_utils:remove_duplicates to leave the *first* copy of each duplicated element in a list; for example, {1, 2, 1} -> {1, 2}, not to {2, 1}.";
name = args[1];
results = "";
objects = $list_utils:remove_duplicates(this:find_properties_on());
for thing in (objects)
if (valid(thing) && (mom = $object_utils:has_property(thing, name)))
results = ((((results + "   ") + thing.name) + "(") + tostr(thing)) + ")";
mom = this:property_inherited_from(thing, name);
if (thing != mom)
if (valid(mom))
results = ((((results + "--") + mom.name) + "(") + tostr(mom)) + ")";
else
results = results + "--built-in";
endif
endif
endif
endfor
if (results)
this:tell("The property .", name, " is on", results);
else
this:tell("The property .", name, " is nowhere to be found.");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:find_verbs_on this n/a this
"'find_verbs_on ()' -> list of objects - Return the objects that @find searches when looking for a verb. The objects are searched (and the results printed) in the order returned. Feature objects are included in the search. Duplicate entries are removed by the caller.";
return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents(), @this.features};
-------------------------------------------------------------------------------
#88 Frand's player class:find_properties_on this n/a this
"'find_properties_on ()' -> list of objects - Return the objects that @find searches when looking for a property. The objects are searched (and the results printed) in the order returned. Feature objects are *not* included in the search. Duplicate entries are removed by the caller.";
return {this, this.location, @valid(this.location) ? this.location:contents() | {}, @this:contents()};
-------------------------------------------------------------------------------
#88 Frand's player class:property_inherited_from this n/a this
"'property_inherited_from (<object>, <property name>)' -> object - Return the ancestor of <object> on which <object>.<property> is originally defined. If <object>.<property> is not actually defined, return 0. The property is taken as originally defined on the earliest ancestor of <object> which has it. If the property is built-in, return $nothing.";
{what, prop} = args;
if (!$object_utils:has_property(what, prop))
return 0;
elseif (prop in $code_utils.builtin_props)
return $nothing;
endif
ancestor = what;
while ($object_utils:has_property(parent(ancestor), prop))
ancestor = parent(ancestor);
endwhile
return ancestor;
-------------------------------------------------------------------------------
#88 Frand's player class:@ref*use any ?-2? any
"'@refuse <action(s)> [ from <player> ] [ for <time> ]' - Refuse all of a list of one or more actions. If a player is given, refuse actions from the player; otherwise, refuse all actions. If a time is specified, refuse the actions for the given amount of time; otherwise, refuse them for a week. If the actions are already refused, then the only their times are adjusted.";
if (!argstr)
player:tell("@refuse <action(s)> [ from <player> ] [ for <time> ]");
return;
endif
stuff = this:parse_refuse_arguments(argstr);
if (stuff)
if (((typeof(who = stuff[1]) == OBJ) && (who != $nothing)) && (!is_player(who)))
player:tell("You must give the name of some player.");
else
"'stuff' is now in the form {<origin>, <actions>, <duration>}.";
if ((stuff[3] < 0) || (stuff[3] > (($maxint - time()) - 2)))
stuff[3] = ($maxint - time()) - 2;
player:tell("That amount of time is too large.  It has been capped at ", $time_utils:english_time(stuff[3]), ".");
endif
this:add_refusal(@stuff);
player:tell("Refusal of ", this:refusal_origin_to_name(stuff[1]), " for ", $time_utils:english_time(stuff[3]), " added.");
endif
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@unref*use @allow any ?-2? any
"'@unrefuse <action(s)> [ from <player> ]' - Stop refusing all of a list of actions. If a player is given, stop refusing actions by the player; otherwise, stop refusing all actions of the given kinds. '@unrefuse everything' - Remove all refusals.";
if (argstr == "everything")
if ($command_utils:yes_or_no("Do you really want to erase all your refusals?"))
this:clear_refusals();
player:tell("OK, they are gone.");
else
player:tell("OK, no harm done.");
endif
return;
endif
stuff = this:parse_refuse_arguments(argstr);
if (!stuff)
return;
endif
"'stuff' is now in the form {<origin>, <actions>, <duration>}.";
origins = stuff[1];
actions = stuff[2];
if (typeof(origins) != LIST)
origins = {origins};
endif
n = 0;
for origin in (origins)
n = n + this:remove_refusal(origin, actions);
endfor
plural = ((n == 1) && (length(origins) == 1)) ? "" | "s";
if (n)
player:tell("Refusal", plural, " removed.");
else
player:tell("You have no such refusal", plural, ".");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@refusals none ?-2? any
"'@refusals' - List your refusals. '@refusals for <player>' - List the given player's refusals.";
if (iobjstr)
who = $string_utils:match_player(iobjstr);
if ($command_utils:player_match_failed(who, iobjstr))
return;
endif
if (!$object_utils:has_verb(who, "refusals_text"))
player:tell("That player does not have the refusal facility.");
return;
endif
else
who = player;
endif
who:remove_expired_refusals();
player:tell_lines(this:refusals_text(who));
-------------------------------------------------------------------------------
#88 Frand's player class:@refusal-r*eporting any ?-2? any
"'@refusal-reporting' - See if refusal reporting is on. '@refusal-reporting on', '@refusal-reporting off' - Turn it on or off..";
if (!argstr)
player:tell("Refusal reporting is ", this.report_refusal ? "on" | "off", ".");
elseif (argstr in {"on", "yes", "y", "1"})
this.report_refusal = 1;
player:tell("Refusals will be reported to you as they happen.");
elseif (argstr in {"off", "no", "n", "0"})
this.report_refusal = 0;
player:tell("Refusals will happen silently.");
else
player:tell("@refusal-reporting on     - turn on refusal reporting");
player:tell("@refusal-reporting off    - turn it off");
player:tell("@refusal-reporting        - see if it's on or off");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:parse_refuse_arguments this n/a this
"'parse_refuse_arguments (<string>)' -> {<who>, <actions>, <duration>} - Parse the arguments of a @refuse or @unrefuse command. <who> is the player requested, or $nothing if none was. <actions> is a list of the actions asked for. <duration> is how long the refusal should last, or 0 if no expiration is given. <errors> is a list of actions (or other words) which are wrong. If there are any errors, this prints an error message and returns 0.";
words = $string_utils:explode(args[1]);
possible_actions = this:refusable_actions();
who = $nothing;
actions = {};
until = this.default_refusal_time;
errors = {};
skip_to = 0;
for i in [1..length(words)]
word = words[i];
if (i <= skip_to)
elseif (which = $string_utils:find_prefix(word, possible_actions))
actions = setadd(actions, possible_actions[which]);
elseif ((word[$] == "s") && (which = $string_utils:find_prefix(word[1..$ - 1], possible_actions)))
"The word seems to be the plural of an action.";
actions = setadd(actions, possible_actions[which]);
elseif (results = this:translate_refusal_synonym(word))
actions = $set_utils:union(actions, results);
elseif ((word == "from") && (i < length(words)))
"Modified to allow refusals from all guests at once. 5-27-94, Gelfin";
if (words[i + 1] == "guests")
who = "all guests";
elseif (!(typeof(who = $code_utils:toobj(words[i + 1])) == OBJ))
who = $string_utils:match_player(words[i + 1]);
if ($command_utils:player_match_failed(who, words[i + 1]))
return 0;
endif
endif
skip_to = i + 1;
elseif ((word == "for") && (i < length(words)))
n_words = this:parse_time_length(words[i + 1..$]);
until = this:parse_time(words[i + 1..i + n_words]);
if (!until)
return 0;
endif
skip_to = i + n_words;
else
errors = {@errors, word};
endif
endfor
if (errors)
player:tell((length(errors) > 1) ? "These parts of the command were not understood: " | "This part of the command was not understood: ", $string_utils:english_list(errors, 0, " ", " ", " "));
return 0;
endif
return {this:player_to_refusal_origin(who), actions, until};
-------------------------------------------------------------------------------
#88 Frand's player class:time_word_to_seconds this n/a this
"'time_word_to_seconds (<string>)' - The <string> is expected to be a time word, 'second', 'minute', 'hour', 'day', 'week', or 'month'. Return the number of seconds in that amount of time (a month is taken to be 30 days). If <string> is not a time word, return 0. This is used both as a test of whether a word is a time word and as a converter.";
return $time_utils:parse_english_time_interval("1", args[1]);
-------------------------------------------------------------------------------
#88 Frand's player class:parse_time_length this n/a this
"'parse_time_length (<words>)' -> n - Given a list of words which is expected to begin with a time expression, return how many of them belong to the time expression. A time expression can be a positive integer, a time word, or a positive integer followed by a time word. A time word is anything that this:time_word_to_seconds this is one. The return value is 0, 1, or 2.";
words = {@args[1], "dummy"};
n = 0;
if (toint(words[1]) || this:time_word_to_seconds(words[1]))
n = 1;
endif
if (this:time_word_to_seconds(words[n + 1]))
n = n + 1;
endif
return n;
-------------------------------------------------------------------------------
#88 Frand's player class:parse_time this n/a this
"'parse_time (<words>)' -> <seconds> - Given a list of zero or more words, either empty or a valid time expression, return the number of seconds that the time expression refers to. This is a duration, not an absolute time.";
words = args[1];
"If the list is empty, return the default refusal time.";
if (!words)
return this.default_refusal_time;
endif
"If the list has one word, either <units> or <n>.";
"If it is a unit, like 'hour', return the time for 1 <unit>.";
"If it is a number, return the time for <n> days.";
if (length(words) == 1)
return this:time_word_to_seconds(words[1]) || (toint(words[1]) * this:time_word_to_seconds("days"));
endif
"The list must contain two words, <n> <units>.";
return toint(words[1]) * this:time_word_to_seconds(words[2]);
-------------------------------------------------------------------------------
#88 Frand's player class:clear_refusals this n/a this
"'clear_refusals ()' - Erase all of this player's refusals.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
this.refused_origins = {};
this.refused_actions = {};
this.refused_until = {};
this.refused_extra = {};
-------------------------------------------------------------------------------
#88 Frand's player class:set_default_refusal_time this n/a this
"'set_default_refusal_time (<seconds>)' - Set the length of time that a refusal lasts if its duration isn't specified.";
if ((caller != this) && (!$perm_utils:controls(caller_perms(), this)))
return E_PERM;
endif
this.default_refusal_time = toint(args[1]);
-------------------------------------------------------------------------------
#88 Frand's player class:refusable_actions this n/a this
"'refusable_actions ()' -> {'page', 'whisper', ...} - Return a list of the actions that can be refused. This is a verb, rather than a property, so that it can be inherited properly. If you override this verb to add new refusable actions, write something like 'return {@pass (), 'action1', 'action2', ...}'. That way people can add new refusable actions at any level of the player class hierarchy, without clobbering any that were added higher up.";
return {"page", "whisper", "move", "join", "accept", "mail"};
-------------------------------------------------------------------------------
#88 Frand's player class:translate_refusal_synonym this n/a this
"'translate_refusal_synonym (<word>)' -> list - If the <word> is a synonym for some set of refusals, return the list of those refusals. Otherwise return the empty list, {}. Programmers can override this verb to provide more synonyms.";
word = args[1];
if (word == "all")
return this:refusable_actions();
endif
return {};
-------------------------------------------------------------------------------
#88 Frand's player class:default_refusals_text_filter this n/a this
"'default_refusals_text_filter (<origin>, <actions>)' - Return any actions by this <origin> which should be included in the text returned by :refusals_text. This is the default filter, which includes all actions.";
return args[2];
-------------------------------------------------------------------------------
#88 Frand's player class:refusals_text this n/a this
"'refusals_text (<player>, [<filter verb name>])' - Return text describing the given player's refusals. The filter verb name is optional; if it is given, this verb takes an origin and a list of actions and returns any actions which should be included in the refusals text. This verb works only if <player> is a player who has the refusals facility; it does not check for this itself.";
who = args[1];
"Used to allow you to supply the filter verb name, but that introduced a security hole. --Nosredna";
filter_verb = "default_refusals_text_filter";
text = {};
for i in [1..length(who.refused_origins)]
origin = who.refused_origins[i];
actions = this:(filter_verb)(origin, who.refused_actions[i]);
if (actions)
line = "";
for action in (actions)
line = (line + " ") + action;
endfor
line = (this:refusal_origin_to_name(origin) + ": ") + line;
line = (ctime(who.refused_until[i]) + " ") + line;
text = {@text, line};
endif
endfor
if (!text)
text = {"No refusals."};
endif
return text;
-------------------------------------------------------------------------------
#88 Frand's player class:player_to_refusal_origin this n/a this
"'player_to_refusal_origin (<player>)' -> <origin> - Convert a player to a unique identifier called the player's 'refusal origin'. For most players, it's just their object number. For guests, it is a hash of the site they are connecting from. Converting an origin to an origin is a safe no-op--the code relies on this.";
set_task_perms(caller_perms());
{who} = args;
if (((typeof(who) == OBJ) && valid(who)) && (parent(who) == `$local.guest ! E_PROPNF, E_INVIND => $guest'))
return who:connection_name_hash("xx");
else
return who;
endif
-------------------------------------------------------------------------------
#88 Frand's player class:refusal_origin_to_name this n/a this
"'refusal_origin_to_name (<origin>)' -> string - Convert a refusal origin to a name.";
origin = args[1];
if (origin in {"all guests", "everybody"})
return origin;
elseif ((typeof(origin) == STR) && (origin == "Permission denied"))
return "an errorful origin";
elseif (typeof(origin) != OBJ)
return "a certain guest";
elseif (origin == #-1)
return "Everybody";
else
return $string_utils:name_and_number(origin);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:check_refusal_actions this n/a this
"'check_refusal_actions (<actions>)' - Check a list of refusal actions, and return whether they are all legal.";
actions = args[1];
legal_actions = this:refusable_actions();
for action in (actions)
if (!(action in legal_actions))
return 0;
endif
endfor
return 1;
-------------------------------------------------------------------------------
#88 Frand's player class:add_refusal this n/a this
"'add_refusal (<origin>, <actions> [, <duration> [, <extra>]])' - Add refusal(s) to this player's list. <Actions> is a list of the actions to be refused. The list should contain only actions, no synonyms. <Origin> is the actor whose actions are to be refused. <Until> is the time that the actions are being refused until, in the form returned by time(). It is optional; if it's not given, it defaults to .default_refusal_time. <Extra> is any extra information; it can be used for comments, or to make finer distinctions about the actions being refused, or whatever. If it is not given, it defaults to 0. The extra information is per-action; that is, it is stored separately for each action that it applies to.";
if (caller != this)
return E_PERM;
endif
{orig, actions, ?duration = this.default_refusal_time, ?extra = 0} = args;
origins = this:player_to_refusal_origin(orig);
if (typeof(origins) != LIST)
origins = {origins};
endif
if (typeof(actions) != LIST)
actions = {actions};
endif
if (!this:check_refusal_actions(actions))
return E_INVARG;
endif
until = time() + duration;
for origin in (origins)
if (i = origin in this.refused_origins)
this.refused_until[i] = until;
for action in (actions)
if (j = action in this.refused_actions[i])
this.refused_extra[i][j] = extra;
else
this.refused_actions[i] = {@this.refused_actions[i], action};
this.refused_extra[i] = {@this.refused_extra[i], extra};
endif
endfor
else
this.refused_origins = {@this.refused_origins, origin};
this.refused_actions = {@this.refused_actions, actions};
this.refused_until = {@this.refused_until, until};
this.refused_extra = {@this.refused_extra, $list_utils:make(length(actions), extra)};
endif
endfor
-------------------------------------------------------------------------------
#88 Frand's player class:remove_refusal this n/a this
"'remove_refusal (<origin>, <actions>)' - Remove any refused <actions> by <origin>. The <actions> list should contain only actions, no synonyms. Return the number of such refusals found (0 if none).";
if (caller != this)
return E_PERM;
endif
{origin, actions} = args;
if (typeof(actions) != LIST)
actions = {actions};
endif
count = 0;
i = origin in this.refused_origins;
if (i)
for action in (actions)
if (j = action in this.refused_actions[i])
this.refused_actions[i] = listdelete(this.refused_actions[i], j);
this.refused_extra[i] = listdelete(this.refused_extra[i], j);
count = count + 1;
endif
endfor
if (!this.refused_actions[i])
this.refused_origins = listdelete(this.refused_origins, i);
this.refused_actions = listdelete(this.refused_actions, i);
this.refused_until = listdelete(this.refused_until, i);
this.refused_extra = listdelete(this.refused_extra, i);
endif
endif
return count;
-------------------------------------------------------------------------------
#88 Frand's player class:remove_expired_refusals this n/a this
"'remove_expired_refusals ()' - Remove refusal entries which are past their time limits.";
origins = {};
"Before removing any refusals, figure out which ones to remove. Removing one changes the indices and invalidates the loop invariant.";
for i in [1..length(this.refused_origins)]
if ((time() >= this.refused_until[i]) || ((typeof(this.refused_origins[i]) == OBJ) && (!$recycler:valid(this.refused_origins[i]))))
origins = {@origins, this.refused_origins[i]};
endif
endfor
for origin in (origins)
this:remove_refusal(origin, this:refusable_actions());
endfor
-------------------------------------------------------------------------------
#88 Frand's player class:refuses_action this n/a this
"'refuses_action (<origin>, <action>, ...)' - Return whether this object refuses the given <action> by <origin>. <Origin> is typically a player. Extra arguments after <origin>, if any, are used to further describe the action.";
"Modified by Diopter (#98842) at LambdaMOO";
{origin, action, @extra_args} = args;
extra_args = {origin, @extra_args};
rorigin = this:player_to_refusal_origin(origin);
if (((which = rorigin in this.refused_origins) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
elseif (((((typeof(rorigin) == OBJ) && valid(rorigin)) && (which = rorigin.owner in this.refused_origins)) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
elseif ((((which = $nothing in this.refused_origins) && (rorigin != this)) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
elseif ((((which = "all guests" in this.refused_origins) && $object_utils:isa(origin, $guest)) && (action in this.refused_actions[which])) && this:("refuses_action_" + action)(which, @extra_args))
return 1;
endif
return 0;
-------------------------------------------------------------------------------
#88 Frand's player class:refuses_action_* this n/a this
"'refuses_action_* (<which>, <origin>, ...)' - The action (such as 'whisper' for the verb :refuses_action_whisper) is being considered for refusal. Return whether the action should really be refused. <Which> is an index into this.refused_origins. By default, always refuse non-outdated actions that get this far.";
{which, @junk} = args;
if (time() >= this.refused_until[which])
fork (0)
"This <origin> is no longer refused. Remove any outdated refusals.";
this:remove_expired_refusals();
endfork
return 0;
else
return 1;
endif
-------------------------------------------------------------------------------
#88 Frand's player class:report_refusal this n/a this
"'report_refusal (<player>, <message>, ...)' - If refusal reporting is turned on, print the given <message> to report the refusal of some action by <player>. The message may take more than one argument. You can override this verb to do more selective reporting.";
if (this.report_refusal)
this:tell(@listdelete(args, 1));
endif
-------------------------------------------------------------------------------
#88 Frand's player class:wh*isper any any this
"'whisper <message> to <this player>' - Whisper a message to this player which nobody else can see.";
if (this:refuses_action(player, "whisper"))
player:tell(this:whisper_refused_msg());
this:report_refusal(player, "You just refused a whisper from ", player.name, ".");
else
pass(@args);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:receive_page this n/a this
"'receive_page (<message>)' - Receive a page. If the page is accepted, pass(@args) shows it to the player.";
if (this:refuses_action(player, "page"))
this.page_refused = task_id();
return 0;
endif
this.page_refused = 0;
return pass(@args);
-------------------------------------------------------------------------------
#88 Frand's player class:page_echo_msg this n/a this
"'page_echo_msg ()' - Return a message to inform the pager what happened to their page.";
if (task_id() == this.page_refused)
this:report_refusal(player, "You just refused a page from ", player.name, ".");
return this:page_refused_msg();
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:moveto acceptable this n/a this
"'moveto (<destination>)', 'accept (<object>)' - Check whether this :moveto or :accept is allowed or refused. If it is allowed, do it. This code is slightly modified from an original verb by Grump.  Upgraded by Bits to account for forthcoming 1.8.0 behavior of callers().";
by = callers();
"Ignore all the verbs on this.";
while (((y = by[1])[1] == this) && (y[2] == verb))
by = listdelete(by, 1);
endwhile
act = (verb == "moveto") ? "move" | "accept";
if ((player != this) && this:refuses_action(player, act, args[1]))
"check player";
return 0;
endif
last = #-1;
for k in (by)
if ((((perms = k[3]) == #-1) && (k[2] != "")) && (k[1] == #-1))
elseif ((!perms.wizard) && (perms != this))
if (perms != last)
"check for possible malicious programmer";
if (this:refuses_action(perms, act, args[1]))
return 0;
endif
last = perms;
endif
endif
endfor
"Coded added 11/8/98 by TheCat, to refuse spurned objects.";
if ((act == "accept") && (typeof(this.spurned_objects) == LIST))
for item in (this.spurned_objects)
if ($object_utils:isa(args[1], item))
return 0;
endif
endfor
endif
"(end of code added by TheCat)";
return pass(@args);
-------------------------------------------------------------------------------
#88 Frand's player class:receive_message this n/a this
"'receive_message (<message>, <sender>)' - Receive the given mail message from the given sender. This version handles refusal of the message.";
if ((!$perm_utils:controls(caller_perms(), this)) && (caller != this))
return E_PERM;
elseif (this:refuses_action(args[2], "mail"))
return this:mail_refused_msg();
else
return pass(@args);
endif
-------------------------------------------------------------------------------
#88 Frand's player class:whisper_refused_msg page_refused_msg mail_refused_msg this n/a this
"'whisper_refused_msg()', 'page_refused_msg()', etc. - Return a message string.";
return $string_utils:pronoun_sub(this.(verb), this);
-------------------------------------------------------------------------------
#88 Frand's player class:last_huh this n/a this
set_task_perms(caller_perms());
if (pass(@args))
return 1;
endif
{verb, args} = args;
if (valid(dobj = $string_utils:literal_object(dobjstr)) && (r = $match_utils:match_verb(verb, dobj, args)))
return r;
elseif (valid(iobj = $string_utils:literal_object(iobjstr)) && (r = $match_utils:match_verb(verb, iobj, args)))
return r;
else
return 0;
endif
-------------------------------------------------------------------------------
#88 Frand's player class:ping_features this n/a this
":ping_features()";
" -- cleans up the .features list to remove !valid objects";
" ==> cleaned-up .features list";
features = this.features;
for x in (features)
if (!$recycler:valid(x))
features = setremove(features, x);
endif
endfor
return this.features = features;
-------------------------------------------------------------------------------
#88 Frand's player class:set_owned_objects this n/a this
":set_owned_objects( LIST owned-objects list )";
"  -- set your .owned_objects, ordered as you please";
"  -- no, it will NOT let you set to to anything you want";
if ((caller == this) || $perm_utils:controls(caller_perms(), this))
new = args[1];
old = this.owned_objects;
"make sure they're the same";
if (length(new) != length(old))
return E_INVARG;
endif
for i in (new)
old = setremove(old, i);
endfor
if (old)
"something's funky";
return E_INVARG;
endif
return this.owned_objects = new;
else
return E_PERM;
endif
-------------------------------------------------------------------------------
#88 Frand's player class:init_for_core this n/a this
if (caller_perms().wizard)
pass(@args);
if ($code_utils:verb_location() == this)
this.rooms = {};
else
clear_property(this, "rooms");
endif
this.features = {$pasting_feature, $stage_talk};
endif
-------------------------------------------------------------------------------
#88 Frand's player class:find_help this n/a this
"'find_help (<name>[, databases])'";
"Search for a help topic with the given name. [<databases>] defaults to the ones returned by $code_utils:help_db_list().";
{name, ?databases = $code_utils:help_db_list()} = args;
if (!name)
this:tell("What topic do you want to search for?");
elseif (result = $code_utils:help_db_search(name, databases))
{object, realname} = result;
if (object == $ambiguous_match)
this:tell("The help topic \"", name, "\" could refer to any of the following:  ", $string_utils:english_list(realname));
elseif (((object == $help) && (!$object_utils:has_property(object, realname))) && valid(o = $string_utils:match_object(name, player.location)))
if ($object_utils:has_callable_verb(o, "help_msg"))
this:tell("That help topic was returned by ", $string_utils:nn(o), ":help_msg().");
elseif ($object_utils:has_property(o, "help_msg"))
this:tell("That help topic is located in ", $string_utils:nn(o), ".help_msg.");
else
this:tell("That help topic was matched by $help but there doesn't seem to be any help available for it.");
endif
elseif (object == $verb_help)
if (((what = $code_utils:parse_verbref(realname)) && valid(what[1] = $string_utils:match_object(what[1], player.location))) && $object_utils:has_verb(@what))
this:tell("That help topic is located at the beginning of the verb ", $string_utils:nn(what[1]), ":", what[2], ".");
else
this:tell("That help topic was matched by $verb_help but there doesn't seem to be any help available for it.");
endif
else
where = {};
for x in (databases)
if ({realname} == x:find_topics(realname))
where = setadd(where, x);
endif
endfor
asname = (name == realname) ? "" | ((" as \"" + realname) + "\"");
if (where)
this:tell("That help topic is located on ", $string_utils:nn(where), asname, ".");
else
"...this shouldn't happen unless $code_utils:help_db_search finds a match we weren't expecting";
this:tell("That help topic appears to be located on ", $string_utils:nn(object), asname, ", although this command could not find it.");
endif
endif
else
this:tell("The help topic \"", name, "\" could not be found.");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@spurn any n/a none
"Prevent an object or any of its descendents from going into your inventory, regardless of whose player perms sent it there.";
"Syntax:  @spurn <object>";
"         @spurn !<object>";
"The second form removes an object from your list of spurned objects.";
"Verb created by TheCat, 11/8/98";
if (caller != this)
return E_PERM;
endif
if (!argstr)
this:tell("Spurn what?");
elseif (argstr[1] == "!")
"Stop spurning something.";
item = this:my_match_object(argstr[2..$]);
if (item in this.spurned_objects)
this.spurned_objects = $list_utils:setremove_all(this.spurned_objects, item);
this:tell(("You are no longer spurning " + $string_utils:nn(item)) + " or any kids of it.");
else
this:tell(("You are not spurning " + $string_utils:nn(item)) + ".");
endif
else
"Spurn something.";
item = this:my_match_object(argstr);
if (!$command_utils:object_match_failed(item, argstr))
if (item in this.spurned_objects)
this:tell(("You are already spurning " + $string_utils:nn(item)) + " plus any and all kids of it.");
else
this.spurned_objects = setadd(this.spurned_objects, item);
this:tell(("You are now spurning " + $string_utils:nn(item)) + " plus any and all kids of it.");
endif
endif
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@spurned none n/a none
"Displays a list of spurned objects.";
"Verb created by TheCat, 11/8/98";
if (this.spurned_objects)
this:tell("You are spurning the following objects, including any and all descendents:  " + $string_utils:nn(this.spurned_objects));
else
this:tell("You are not spurning any objects.");
endif
-------------------------------------------------------------------------------
#88 Frand's player class:set_spurned_objects this n/a this
"Permits programmatic setting of .spurned_objects, which is -c.";
{spurned_objects} = args;
if ($perm_utils:controls(caller_perms(), this))
"Note, the final result must be a list of objects, otherwise there's no point.";
if (typeof(spurned_objects) != LIST)
spurned_objects = {spurned_objects};
endif
this.spurned_objects = spurned_objects;
endif
-------------------------------------------------------------------------------
#88 Frand's player class:@addsubmitted @rmsubmitted @submitted none n/a none
"Copied from Roebare (#109000):@submitted at Sat Feb 26 19:41:37 2005 PST";
"Usage: @addsubmitted => Process submissions to the global spelling dictionary";
"       @rmsubmitted  => Reject a submission";
"       @submitted    => Review outstanding submissions";
if (!((player in $spell.trusted) || player.wizard))
return player:tell("You may not process submissions to the master dictionary.");
endif
"...clean-up first...";
$spell.submitted = pending = $list_utils:remove_duplicates($spell.submitted);
"...nothing to do...";
if (!pending)
return player:notify("No submissions to the global spelling dictionary are pending.");
endif
"...do the work...";
if (!(cmd = verb[2..index(verb, "submitted") - 1]))
player:notify(tostr("The following ", length($spell.submitted), " words have been submitted to the master dictionary and await approval:"));
player:notify_lines($string_utils:columnize($list_utils:sort($spell.submitted), abs(player.linelen) / (length($list_utils:longest($spell.submitted)) + 1)));
elseif (cmd == "add")
player:notify(tostr("A total of ", length($spell.submitted), " words have been submitted to the master dictionary and await approval."));
if ($command_utils:yes_or_no("Do you wish to review the list first?"))
return player:notify_lines($string_utils:columnize($list_utils:sort($spell.submitted), abs(player.linelen) / (length($list_utils:longest($spell.submitted)) + 1)));
else
num_learned = num_skipped = num_errors = num_rejects = 0;
if ($command_utils:yes_or_no("Do you wish to process each word individually? Recommended, but may take a couple minutes."))
for candidate in ($spell.submitted)
$command_utils:suspend_if_needed(0);
if (!$command_utils:yes_or_no(tostr("Submitted: `", candidate, "'. Add this word?")))
num_skipped = num_skipped + 1;
player:notify(tostr("The word `", candidate, "' was skipped."));
else
if (result = $spell:add_word(candidate))
player:notify(tostr("Word added: ", candidate));
num_learned = num_learned + 1;
$spell.submitted = setremove($spell.submitted, candidate);
elseif (result == E_PERM)
return player:notify("Permissions error. Command cancelled.");
elseif (typeof(result) == ERR)
num_errors = num_errors + 1;
player:notify(tostr(result));
else
player:notify(tostr("Already in dictionary: ", candidate));
num_rejects = num_rejects + 1;
$spell.submitted = setremove($spell.submitted, candidate);
endif
endif
if ($command_utils:yes_or_no(tostr("Remove `", candidate, "' from the submission list?")))
$spell.submitted = setremove($spell.submitted, candidate);
player:notify(tostr("The word `", candidate, "' has been removed."));
endif
if (!$command_utils:yes_or_no("Continue on to the next word?"))
return player:notify_lines({"Command aborted.", tostr(" ", num_learned, " words added"), tostr(" ", num_skipped, " words skipped"), tostr(" ", num_errors, " words errored"), tostr(" ", num_rejects, " words rejected")});
endif
endfor
player:notify_lines({"End of submissions.", tostr(" ", num_learned, " words added"), tostr(" ", num_skipped, " words skipped"), tostr(" ", num_errors, " words errored"), tostr(" ", num_rejects, " words rejected")});
else
if ($command_utils:yes_or_no("Last chance. Do you wish to cancel?"))
return player:notify(tostr("Command cancelled. ", $network.MOO_name, "'s lexicographers thank you."));
else
for candidate in ($spell.submitted)
$command_utils:suspend_if_needed(0);
result = $spell:add_word(candidate);
if (result)
num_learned = num_learned + 1;
player:notify(tostr("Word added: ", candidate));
else
num_errors = num_errors + 1;
player:notify(tostr(result));
player:notify(tostr("The word `", candidate, "' was not added."));
endif
endfor
player:notify_lines({"End of submissions.", tostr(" ", num_learned, " words added"), tostr(" ", num_errors, " words errored"), ""});
if ($command_utils:yes_or_no("Clear the submission list?"))
"...framing required for `-' call...";
"$spell:(\"clear-submitted\")()";
"...incomplete perms check, do it the long way...";
$spell.submitted = {};
player:notify("List cleared.");
else
player:notify("List unchanged. Please review and prune the submission list manually.");
endif
endif
endif
endif
elseif (cmd == "rm")
player:tell("Which word do you want removed from the submission list?");
if ((reject = $command_utils:read()) in $spell.submitted)
$spell.submitted = setremove($spell.submitted, reject);
player:notify(tostr("The word `", reject, "' was rejected from the submission list."));
else
player:notify(tostr("The word `", reject, "' was not found in the submission list."));
endif
endif
"Created Sat Feb 19 16:57:27 2005 PST, by CherLouis (#109000).";
"Last modified Sat Feb 26 09:46:36 2005 PST, by CherLouis (#109000).";
-------------------------------------------------------------------------------
================================#89 Stage-Talk Feature===============================================
#89 Stage-Talk Feature:stage `* -* any ?-2? any
"Say something out loud, directed at someone or something.";
"Usage:";
"  `target message";
"Example:";
"  Munchkin is talking to Kenneth, who's in the same room with him.  He types:";
"      `kenneth What is the frequency?";
"  The room sees:";
"       Munchkin [to Kenneth]: What is the frequency?";
name = verb[2..$];
who = player.location:match_object(name);
if ($command_utils:object_match_failed(who, name))
return;
endif
player.location:announce_all(player.name, " [to ", who.name, "]: ", argstr);
-------------------------------------------------------------------------------
#89 Stage-Talk Feature:stage [* any ?-2? any
"Say something out loud, in some specific way.";
"Usage:";
"  [how]: message";
"Example:";
"  Munchkin decideds to sing some lyrics.  He types:";
"      [sings]: I am the eggman";
"  The room sees:";
"      Munchkin [sings]: I am the eggman";
player.location:announce_all((((player.name + " ") + verb) + " ") + argstr);
-------------------------------------------------------------------------------
#89 Stage-Talk Feature:stage ]* any ?-2? any
"Perform some physical, non-verbal, action.";
"Usage:";
"  ]third person action";
"Example:";
"  Munchkin has annoyed some would-be tough guy.  He types:";
"      ]hides behind the reactor.";
"  The room sees:";
"      [Munchkin hides behind the reactor.]";
player.location:announce_all("[", (((player.name + " ") + verb[2..$]) + (argstr ? " " + argstr | "")) + "]");
-------------------------------------------------------------------------------
#89 Stage-Talk Feature:~* any ?-2? any
name = verb[2..$];
argstr = $code_utils:argstr(verb, args, argstr);
player.location:announce_all(player.name, " [", name, "]: ", argstr);
-------------------------------------------------------------------------------
#89 Stage-Talk Feature:stage <* any ?-2? any
"Point to yourself.";
"Usage:";
"  <message";
"Example:";
"  Muchkin decides he's being strange. He types:";
"    <being strange.";
"  The room sees:";
"    Munchkin <- being strange.";
player.location:announce_all((((player.name + " <- ") + verb[2..$]) + " ") + argstr);
-------------------------------------------------------------------------------
================================#90 Pasting Feature===============================================
#90 Pasting Feature:@paste any ?-2? any
"Usage: @paste <prefix> <suffix>";
"Announce a series of entered lines to the room the player is in.";
"Before the lines are quoted, player.paste_header is run through";
"$string_utils:pronoun_sub(), and if the result contains the player's";
"name, it is used as a header.  Otherwise player.name centered in a";
"line of dashes is used.";
"A footer comes afterwards, likewise derived from player.paste_footer.";
"<prefix> and <suffix> are placed before and after each line.";
"";
"This verb is, as one might guess, designed for pasting text to MOO using";
"GnuEmacs or a windowing system.  You should remember that after you";
"have pasted the lines in, you must type . on a line by itself, or you'll";
"sit around waiting for $command_utils:read_lines() to finish _forever_.";
{?prefix = "", ?suffix = ""} = args;
lines = $command_utils:read_lines();
header = $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, "paste_header"), "") || $string_utils:center(player.name, 75, "-");
to_tell = {header};
for line in (lines)
to_tell = listappend(to_tell, (prefix + line) + suffix);
endfor
to_tell = listappend(to_tell, $string_utils:pronoun_sub_secure($code_utils:verb_or_property(player, "paste_footer"), "") || $string_utils:center("finished", 75, "-"));
for thing in (player.location.contents)
$command_utils:suspend_if_needed(0);
thing:tell_lines(to_tell);
endfor
player:tell("Done @pasting.");
-------------------------------------------------------------------------------
#90 Pasting Feature:|* any ?-2? any
"Echo a line prefaced by a vertical bar.";
"Usage:";
"  |message";
"Example:";
"  Hacker wants to echo to the room what he just saw. He enters (either by hand, or with Emacs or a windowing system):";
"      |Haakon has disconnected.";
"  The room sees:";
"      Hacker | Haakon has disconnected.";
player.location:announce_all((((player.name + " | ") + verb[2..$]) + " ") + argstr);
-------------------------------------------------------------------------------
#90 Pasting Feature:@pasteto @paste-to any n/a none
"Syntax: @paste-to <player>";
"";
"Which will then prompt you for the lines to privately send to <player>. The lines will be surrounded by a default footer and header.";
target = $string_utils:match_player(dobjstr);
$command_utils:player_match_result(target, dobjstr);
if (!valid(target))
return;
endif
prefix = "";
suffix = "";
lines = $command_utils:read_lines();
to_tell = {$string_utils:center("Private message from " + player.name, 75, "-")};
for line in (lines)
to_tell = listappend(to_tell, (prefix + line) + suffix);
endfor
to_tell = listappend(to_tell, $string_utils:center("end message", 75, "-"));
target:tell_lines(to_tell);
player:tell("Done @pasting.");
-------------------------------------------------------------------------------
================================#91 Vector and Matrix Utils===============================================
#91 Vector and Matrix Utils.note rc = MOOString "Please contact Uther@LambdaMOO if you make changes to this object, so he can make the changes on Lambda and elsewhere."
#91 Vector and Matrix Utils:vector_add vector_sub vector_mul vector_div this n/a this
":vector_add(V1 [,V2 ...]) => VN such that VN[n] = V1[n] + V2[n]...";
":vector_sub(V1 [,V2 ...]) => VN such that VN[n] = V1[n] - V2[n]...";
":vector_mul(V1 [,V2 ...]) => VN such that VN[n] = V1[n] * V2[n]...";
":vector_div(V1 [,V2 ...]) => VN such that VN[n] = V1[n] / V2[n]...";
"Vectors do not need to be the same length, but they should be. VN's length will be the length of the longest vector in the arguments. :vector_add and :vector_sub will pad out the smaller vectors with 0's or 0.0's. :vector_mul and :vector_div will pad out the smaller vectors with 1's or 1.0's. Vectors do not need to contain homogeneous data, but the nth term of each vector must be of the same type.";
"I can see a reason for wanting to do vector addition or subtraction, but multiplication and divareion is usually handled in other ways. I've included them here for novelty, and becuase it was easy enough to do.";
"";
"Vector addition is used when two or more similar vector quantities are at work and need to be resolved into a single vector. For instance, a ship travelling in a current will be acted upon by (at least) two forces: a force propelling it forward (its engine), and a force pushing it off course (the current). The sum of these two forces gives the resultant net force acting upon the ship and, since Force = Mass * Acceleration, the direction the ship is accelerating.";
"";
"Vector subtraction can be used to reverse the process of vector addition. In the ship problem above, let's say the actual resultant force is known, but it does not match the result of adding the propelling force and the drifting force. Friction is probably acting against the motion of the ship. Subtracting the computed resultant force from the known net force will yield the frictional force acting against the progress of the ship.";
"";
"Vector multiplication and division do not have RL examples, but vector multiplication of this type makes computing the dot product of two vectors simple.";
"";
if (length(args) == 1)
return args;
elseif (!args)
return raise(E_INVARG);
endif
type = verb[$ - 2..$];
lresult = max = length(args[1]);
results = args[1];
for n in [2..length(args)]
$command_utils:suspend_if_needed(0);
if (type == "add")
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] + args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];
endif
elseif (type == "sub")
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] - args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
for m in [lresult + 1..lcurr]
results = {@results, -args[n][m]};
$command_utils:suspend_if_needed(0);
endfor
endif
elseif (type == "mul")
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] * args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
results[lresult + 1..lcurr] = args[n][lresult + 1..lcurr];
endif
else
for m in [1..min(lcurr = length(args[n]), lresult)]
results[m] = results[m] / args[n][m];
$command_utils:suspend_if_needed(0);
endfor
if (lcurr > lresult)
for m in [lresult + 1..lcurr]
results = {@results, (typeof(foo = args[n][m]) == INT) ? 1 / foo | (1.0 / foo)};
$command_utils:suspend_if_needed(0);
endfor
endif
endif
endfor
return results;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:matrix_add matrix_sub this n/a this
":matrix_add(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] + M2[m][n]...";
":matrix_sub(M1 [, M2 ...]) => MN such that MN[m][n] = M1[m][n] - M2[m][n]...";
"Matrices should all be of the same size.";
"";
"Matrix addition and subtraction is simply the addition or subtraction of the vectors contained in the matrices. See 'help $matrix_utils:vector:add' for more help.";
type = verb[$ - 2..$];
results = args[1];
if (typeof(results[1][1]) == LIST)
for n in [1..length(results)]
results[n] = this:(verb)(results[n], @$list_utils:slice(args[2..$], n));
endfor
else
for n in [1..length(results)]
results[n] = this:("vector_" + type)(results[n], @$list_utils:slice(args[2..$], n));
endfor
endif
return results;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:transpose this n/a this
":transpose(Mmn) => Mnm";
"Transpose an m by n matrix into an n by m matrix by making the rows in the original the columns in the output.";
{mat} = args;
if (!this:is_matrix(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
j = this:dimensions(mat)[2];
result = {};
for n in [1..j]
result = {@result, this:column(mat, n)};
$command_utils:suspend_if_needed(0);
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:determinant this n/a this
":determinant(M) => NUM the determinant of the matrix.";
"";
"There are several properties of a matrix's determinant. Adding or subtracting a row or column from another row or colum of a matrix does not hange the value of its determinant. Multiplying a row or column of a matrix by a single scalar value has the effect of multiplying the matrix's determinant by the same scalar.";
"";
"However, the most dramatic use of determinants is in solving linear equations. For example, the solution to this system of equations:";
"";
"Ax1 + Bx2 + Cx3 = D";
"Ex1 + Fx2 + Gx3 = H";
"Ix1 + Jx2 + Kx3 = L";
"";
"is";
"";
"     1 |D B C|         1 |A D C|        1 |A B D|";
"x1 = - |H F G|    x2 = - |E H G|   x3 = - |E F H|";
"     Z |L J K|         Z |I L K|        Z |I J L|";
"";
"          |A B C|";
"where Z = |E F G|";
"          |I J K|";
"";
"or, in other words, x1, x2, and x3 are some determinant divided by Z, another determinant.";
"";
"Determinants are also used in computing the cross product of two vectors. See 'help $matrix_utils:cross_prod' for more info.";
"";
{mat} = args;
if (!this:is_square(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
elseif (this:dimensions(mat) == {1, 1})
return mat[1][1];
elseif (this:dimensions(mat)[1] == 2)
return (mat[1][1] * mat[2][2]) - (mat[1][2] * mat[2][1]);
else
result = (typeof(mat[1][1]) == INT) ? 0 | 0.0;
coeff = (typeof(mat[1][1]) == INT) ? 1 | 1.0;
for n in [1..length(mat[1])]
result = result + ((coeff * mat[1][n]) * this:determinant(this:submatrix(1, n, mat)));
coeff = -coeff;
endfor
return result;
endif
"elseif dims == {1,1} lines are courtesy of Link (#122143).  21-Oct-05";
"Originated by Uther. Modified by Link (#122143) on 16-Nov-2005.";
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:inverse this n/a this
":inverse(M) => MN such that M * MN = I";
"";
"The inverse of a matrix is very similar to the reciprocal of a scalar number. If two numbers, A and B, equal 1 (the scalar identity number) when multiplied together (AB=1), then B is said the be the reciprocal of A, and A is the reciprocal of B. If A and B are matrices, and the result of multiplying them togeter is the Identity Matrix, then B is the inverse of A, and A is the inverse of B.";
"";
"Computing the inverse involves the solutions of several linear equations. Since linear equations can be easily solved with determinants, this is rather simple. See 'help $matrix_utils:determinant' for more on how determinants solve linear equations.";
"";
{mat} = args;
{i, j} = this:dimensions(mat);
if (tofloat(det = this:determinant(mat)) == 0.0)
return raise("E_NOINV", "No Inverse Exists");
endif
result = {};
for k in [1..i]
sub = {};
for l in [1..j]
sub = {@sub, ($math_utils:pow((typeof(mat[1][1]) == INT) ? -1 | -1.0, k + l) * this:determinant(this:submatrix(l, k, mat))) / det};
endfor
result = {@result, sub};
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:identity this n/a this
":identity(INT <size>) => Identity matrix (I) of dimensions <size> by <size>.";
"All elements of I are 0, except for the diagonal elements which are 1.";
"";
"The Identity Matrix has the unique property such that when another matrix is multiplied by it, the other matrix remains unchanged. This is similar to the number 1. a*1 = a. A * I = A, if the dimensions of I and A are the same.";
"";
n = args[1];
result = this:null(n, n);
for i in [1..n]
result[i][i] = 1;
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:null this n/a this
":null(INT <size>) => Null matrix (O) of dimensions <size> by <size>.";
"All elements of O are 0.";
"";
"The Null Matrix has the property that is equivalent to the number 0; it reduces the original matrix to itself. a * 0 = 0. A * N = N.";
"";
{m, ?n = m} = args;
result = {};
for i in [1..m]
result = {@result, {}};
for j in [1..n]
result[i] = {@result[i], 0};
endfor
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_square this n/a this
":is_square(M) => 1 iff dimensions of M are equal to each other.";
{m} = args;
return (this:is_matrix(m) && (this:order(m) == 2)) && ((dim = this:dimensions(m))[1] == dim[2]);
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_null this n/a this
":is_null(M) => 1 iff M is O.";
m = length(mat = args[1]);
if (!this:is_square(mat))
return 0;
endif
for i in [1..m]
for j in [1..m]
if (mat[i][j] != 0)
return 0;
endif
endfor
endfor
return 1;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_identity this n/a this
":is_identity(M) => 1 iff M is I.";
m = length(mat = args[1]);
if (!this:is_square(mat))
return 0;
endif
for i in [1..m]
for j in [1..m]
if ((mat[i][j] != 0) && ((i != j) ? 1 | (mat[i][j] != 1)))
return 0;
endif
endfor
endfor
return 1;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:cross_prod outer_prod vector_prod this n/a this
":cross_prod(V1, V2) => VN, the vector perpendicular to both V1 and V2 with length equal to the area of the parallelogram spanned by V1 and V2, and direction governed by the rule of thumb.";
"";
"If A = a1i + a2j + a3k, represented as a list as {a1, a2, a3}";
"and B = b1i + b2j + b3k, or {b1, b2, b3}, then";
"";
"        |i  j  k |";
"A x B = |a1 a2 a3| = |a2 a3|i - |a1 a3|j + |a1 a2|k";
"        |b1 b2 b3| = |b2 b3|    |b1 b3|    |b1 b2|";
"";
"or, in list terms, as the list of the coefficients of i, j, and k.";
"";
"Note: i, j, and k are unit vectors in the x, y, and z direction respectively.";
"";
"The rule of thumb: A x B = C  If you hold your right hand out so that your fingers point in the direction of A, and so that you can curl them through B as you make a hitchhiking fist, your thumb will point in the direction of C.";
"";
"Put another way, A x B = ABsin(THETA) (A cross B equals the magnitude of A times the magnitude of B times the sin of the angle between them) This is expressed as a vector perpendicular the the A-B plane, pointing `up' if you curl your right hand fingers from A to B, and `down' if your right hand fingers curl from B to A.";
"";
"The cross product has many uses in physics. Angular momentum is the cross product of a particles position vector from the point it is rotating around and it's linear momentum (L = r x p). Torque is the cross product of position and Force (t = r x F).";
"";
{v1, v2} = args;
if (((((l = length(v1)) != length(v2)) || (l != 3)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))
return raise("E_INVVEC", "Invalid Vector Format");
endif
mat = {{1, 1, 1}, v1, v2};
coeff = 1;
result = {};
for n in [1..3]
result = {@result, coeff * this:determinant(this:submatrix(1, n, mat))};
coeff = -coeff;
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:norm length this n/a this
":norm(V) => FLOAT";
":length(V) => FLOAT";
"The norm is the length of a vector, the square root of the sum of the squares of its elements.";
"";
"In school, we all should have learned the Pythagorean Theorem of right triangles: The sum of the squares of the sides of a right triagle is equal to the square of the hypoteneuse. The Theorem holds true no matter how many dimensions are being considered. The length of a vector is equal to the square root of the sum of the squares of its components. The dot product of a vector with itself happens to be the sum of the squares of its components.";
"";
{v} = args;
return this:is_vector(v) ? sqrt(tofloat(this:dot_prod(v, v))) | E_TYPE;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:submatrix this n/a this
":submatrix(i, j, M1) => M2, the matrix formed from deleting the ith row and jth column from M1.";
{i, j, mat} = args;
{k, l} = this:dimensions(mat);
result = {};
for m in [1..k]
sub = {};
for n in [1..l]
if ((m != i) && (n != j))
sub = {@sub, mat[m][n]};
endif
endfor
if (sub)
result = {@result, sub};
endif
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:dot_prod inner_prod scalar_prod this n/a this
":dot_prod(V1, V2) => NUM";
":inner_prod(V1, V2) => NUM";
"The dot, or inner, product of two vectors is the sum of the products of the corresponding elements of the vectors.";
"If V1 = {1, 2, 3} and V2 = {4, 5, 6}, then V1.V2 = 1*4 + 2*5 + 3*6 = 32";
"";
"The dot product is useful in computing the angle between two vectors, and the length of a vector. See 'help $matrix_utils:subtended_angle' and 'help $matrix_utils:length'.";
"";
"A . B = ABcos(THETA)  (A dot B equals the magnitude of A times the magnitude of B times the cosine of the angle between them.)";
"";
{v1, v2} = args;
if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))
return raise("E_INVVEC", "Invalid Vector Format");
endif
temp = this:vector_mul(v1, v2);
result = (typeof(temp[1]) == INT) ? 0 | 0.0;
for n in [1..l]
$command_utils:suspend_if_needed(0);
result = result + temp[n];
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:dimension*s this n/a this
":dimensions(M) => LIST of dimensional sizes.";
l = {length(m = args[1])};
if (typeof(m[1]) == LIST)
l = {@l, @this:dimensions(m[1])};
endif
return l;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:order this n/a this
":order(M) => INT how many dimensions does this matrix have? 1 means vector";
return length(this:dimensions(args[1]));
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:scalar_vector_add scalar_vector_sub scalar_vector_mul scalar_vector_div this n/a this
":scalar_vector_add(S, V) => VN such that VN[n] = V[n] + S...";
":scalar_vector_sub(S, V) => VN such that VN[n] = V[n] - S...";
":scalar_vector_mul(S, V) => VN such that VN[n] = V[n] * S...";
":scalar_vector_div(S, V) => VN such that VN[n] = V[n] / S...";
"Actually, arguments can be (S, V) or (V, S). Each element of V is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in V.";
"";
"I can see a reason for wanting to do scalar/vector multiplcation or division, but addition and subtraction between vector and scalar types is not done. I've included them here for novelty, and because it was easy enough to to.";
"";
"Scalar-vector multiplication stretches a vector along its direction, generating points along a line. One of the more famous uses from physics is Force equals mass times acceleration. F = ma. Force and acceleration are both vectors. Mass is a scalar quantity.";
"";
if (typeof(args[1]) == LIST)
{vval, sval} = args;
else
{sval, vval} = args;
endif
if (!this:is_vector(vval))
return raise("E_INVVEC", "Invalid Vector Format");
endif
type = verb[$ - 2..$];
for n in [1..length(vval)]
if (type == "add")
vval[n] = vval[n] + sval;
elseif (type == "sub")
vval[n] = vval[n] - sval;
elseif (type == "mul")
vval[n] = vval[n] * sval;
else
vval[n] = vval[n] / sval;
endif
endfor
return vval;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:subtended_angle this n/a this
":subtended_angle(V1, V2) => FLOAT smallest angle defined by V1, V2 in radians";
"";
"Any two vectors define two angles, one less than or equal to 180 degrees, the other 180 degrees or more. The larger can be determined from the smaller, since their sum must be 360 degrees.";
"";
"The dot product of the two angles, divided by the lengths of each of the vectors is the cosine of the smaller angle defined by the two vectors.";
"";
{v1, v2} = args;
if ((((l = length(v1)) != length(v2)) || (!this:is_vector(v1))) || (!this:is_vector(v2)))
return raise("E_INVVEC", "Invalid Vector Format");
endif
return acos(tofloat(this:dot_prod(v1, v2)) / (this:norm(v1) * this:norm(v2)));
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:column this n/a this
":column(M, INT <n>) => LIST the nth column of M.";
{mat, i} = args;
j = this:dimensions(mat)[1];
result = {};
for m in [1..j]
result = {@result, mat[m][i]};
$command_utils:suspend_if_needed(0);
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:matrix_mul this n/a this
":matrix_mul(M1, M2) => MN such that MN[m][n] = the dot product of the mth row of M1 and the transpose of thenth column of M2.";
"";
"Matrix multiplication is the most common and complex operation performed on two matrices. First, matrices can only be multiplied if they are of compatible sizes. An i by j matrix can only be multiplied by a j by k matrix, and the results of this multiplication will be a matrix of size i by k. Each element in the resulting matrix is the dot product of a row from the first matrix and a column from the second matrix. (See 'help $matrix_utils:dot_prod'.)";
"";
{m1, m2} = args;
{i, j} = this:dimensions(m1);
{k, l} = this:dimensions(m2);
if (((j != k) || (!this:is_matrix(m1))) || (!this:is_matrix(m2)))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
result = {};
for m in [1..i]
sub = {};
for n in [1..l]
$command_utils:suspend_if_needed(0);
sub = {@sub, this:dot_prod(m1[m], this:column(m2, n))};
endfor
result = {@result, sub};
endfor
return result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:scalar_matrix_mul scalar_matrix_div this n/a this
":scalar_matrix_add(S, M) => MN such that MN[m][n] = MN[m][n] + S...";
":scalar_matrix_sub(S, M) => MN such that MN[m][n] = MN[m][n] - S...";
":scalar_matrix_mul(S, M) => MN such that MN[m][n] = MN[m][n] * S...";
":scalar_matrix_div(S, M) => MN such that MN[m][n] = MN[m][n] / S...";
"Actually, arguments can be (S, M) or (M, S). Each element of M is augmented by S. S should be either an INT or a FLOAT, as appropriate to the values in M.";
"I can see a reason for wanting to do scalar/matrix multiplication or division, but addition and subtraction between matrix and scalar types is not done. I've included them here for novelty, and because it was easy enough to do.";
type = verb[$ - 2..$];
if (typeof(args[1]) == LIST)
{mval, sval} = args;
else
{sval, mval} = args;
endif
if (!this:is_matrix(mval))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
results = {};
if (typeof(mval[1][1] == LIST))
for n in [1..length(mval)]
results = {@results, this:(verb)(mval[n], sval)};
endfor
else
for n in [1..length(mval)]
results = {@results, this:("scalar_vector_" + type)(mval[n], sval)};
endfor
endif
return results;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_matrix this n/a this
"A matrix is defined as a list of vectors, each having the smae number of elements.";
{m} = args;
if ((typeof(m) != LIST) || (typeof(m[1]) != LIST))
return 0;
endif
len = length(m[1]);
for v in (m)
if ((!this:is_vector(v)) || (length(v) != len))
return 0;
endif
endfor
return 1;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_vector this n/a this
"A vector shall be defined as a list of INTs or FLOATs. (I'm not gonna worry about them all being the same type.)";
flag = 1;
{v} = args;
if (typeof(v) != LIST)
return 0;
endif
for n in (v)
if (((ntype = typeof(n)) != INT) && (ntype != FLOAT))
flag = 0;
break;
endif
$command_utils:suspend_if_needed(0);
endfor
return flag;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_reflexive is_areflexive this n/a this
":is_reflexive   (M) => 1 if M is a reflexive relation, -1 if areflexive,";
"                       0 otherwise.";
":is_areflexive does the same, but with 1 and -1 reversed.";
{m} = args;
if (!this:is_square(m))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
good = bad = 0;
for n in [1..length(m)]
if (!m[n][n])
bad = 1;
else
good = 1;
endif
endfor
return this:_relation_result(good, bad, verb[4] == "a");
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_symmetric is_asymmetric this n/a this
":is_symmetric   (M) => 1 if M is a symmetric relation, -1 if asymmetric,";
"                       0 otherwise.";
":is_asymmetric does the same, but with 1 and -1 reversed.";
{mat} = args;
if (!this:is_square(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
good = bad = 0;
for m in [1..len = length(mat)]
for n in [m + 1..len]
if (mat[m][n] == mat[n][m])
good = 1;
else
bad = 1;
endif
endfor
endfor
return this:_relation_result(good, bad, verb[4] == "a");
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_transitive is_atransitive this n/a this
":is_transitive  (M) => 1 if M is a transitive relation, -1 if atransitive,";
"                       0 otherwise.";
":is_atransitive does the same, but with 1 and -1 reversed.";
{mat} = args;
if (!this:is_square(mat))
return raise("E_INVMAT", "Invalid Matrix Format");
endif
good = bad = 0;
for m in [1..len = length(mat)]
for n in [1..len]
if (mat[m][n])
for l in [1..len]
if (mat[n][l])
if (mat[m][l])
good = 1;
else
bad = 1;
endif
endif
endfor
endif
endfor
endfor
return this:_relation_result(good, bad, verb[4] == "a");
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:_relation_result this n/a this
"Common code for is_reflexive, is_symmetric, and is_transitive.";
{good, bad, flag} = args;
if (good && (!bad))
result = 1;
elseif ((!good) && bad)
result = -1;
else
result = 0;
endif
return flag * result;
-------------------------------------------------------------------------------
#91 Vector and Matrix Utils:is_partial_ordering this n/a this
":is_partial_ordering(M) => 1 iff M is a reflexive, asymmetric, transitive relation.";
{mat} = args;
return ((this:is_asymmetric(mat) == this:is_reflexive(mat)) == this:is_transitive(mat)) == 1;
-------------------------------------------------------------------------------
================================#92 Frand Help DB===============================================
#92 Frand Help DB.refusal-programming rc = MOOList [ "", "  -- -- --  refusal programming", "", "This entry explains how to program new kinds of refusal for the refusal mechanism. This information is only useful for programmers. For basic information about the refusal mechanism, read the 'refusal' entry.", "", " - making a new refusable action", "", "Making a refusable action has several steps. You have to (1) override the verb that lists your refusable actions, (2) write a verb to handle any special cases in determining when an action should be refused, and (3) write the code that does the actual acceptance or refusal of the action.", "", "You can put new refusable actions on yourself, or on a player class. If you put them on yourself, then you are the only one who can use them. If you put them on a player class, then everyone who belongs to that class can use them.", "", "I'll walk you through the example of making a refusable action 'smirk'. If you '@refuse smirk from Munchkin' then anything Munchkin tells you with the word 'smirk' in it will be refused. Since this is useless, I'll assume that you're defining it on yourself, instead of on a player class.", "", "(1) You have to make 'smirk' a refusable action. You do that by overriding your :refusable_actions verb. :Refusable_actions is a verb which returns the actions that you know how to refuse. It is a verb instead of a property so that players can add refusable actions at all levels of the player class hierarchy without interfering with each other.", "", "    @verb me:refusable_actions this none this", "    @program me:refusable_actions", "      return {@pass(@args), "smirk"};", "    .", "", "'@pass (@args)' means 'include the actions that my parent knows how to refuse, because I know how to refuse them too.'", "", "(2) The refusal mechanism provides for special cases in deciding whether an action should be refused. None of the refusals defined on Frand's Player Class actually make use of this special case, and you probably won't have to use it either. But you still have to write a verb to deal with it.", "", "The verb should be named :refuses_action_<action>, where <action> is the action that the verb is for. In this case, it should be :refuses_action_smirk. The verb takes some arguments and returns whether the action should be refused. The details of this will someday be explained in the next section, 'fancy refusable actions', but in all simple cases the verb should simply return 1.", "", "    @verb me:refuses_action_smirk this none this", "    @program me:refuses_action_smirk", "      return 1;", "    .", "", "(3) Finally you must implement the refusal itself. The code that performs the action should call <target>:refuses_action (player, <action>). <target> is the target of the action; it is you, because others are smirking at you. 'Player' is the current player, the one who is attempting to perform the action. <action> is the action the player is attempting, 'smirk'.", "", "In this case, you want to change your :tell verb to check whether its message contains the word 'smirk', and whether you are refusing smirks from the player who's talking. It also has to do two other things: (1) inform the player whose smirk was refused, and (2) call this:report_refusal, which tests whether you have refusal reporting turned on, and if so, reports the refusal to you. The call is this:report_refusal (<player>, <message>).", "", "    @verb me:tell this none this", "    @program me:tell", "      line = tostr (@args);", "      if (index (line, "smirk") &&", "          this:refuses_action (player, "smirk"))", "        player:tell (this.name, " refuses your s m i r k.");", "        this:report_refusal (player, "You refused a s m i r k.");", "      else", "        pass (@args);", "      endif", "    .", "", "The messages say 's m i r k' instead of 'smirk' to prevent an infinite :tell loop.", "", "It may help to study some examples. To see how whisper refusal works, read #3133:whisper. For page refusal, see #3133:receive_page and #3133:page_echo_msg. For mail refusal, #3133:receive_message. For move and accept refusal, #3133:moveto or #3133:accept (they are the same verb).", "", " - refusal data structures", "", "Refusal information is stored in four main properties, all lists.", "", "    .refused_origins    - who you are refusing actions from", "    .refused_actions    - for each, what actions you're refusing", "    .refused_until      - when the refusals expire", "    .refused_extra      - any further information about each refused action", "", "These properties are all readable and owned by Frand. You (or anyone) can see their values, but you can only change them by calling verbs for the purpose. The verbs are explained later on.", "", "Your .refused_origins property remembers who you are refusing actions from. It might have the value {#47, #34567} if you are refusing actions from Frand (#47) and Stupid_Jerk (#34567). If you are refusing actions by guests, it will have entries like "xxP1Xw.nkQzft". This weird string is a code word that stands for the guest's connection site; you are refusing actions not by a certain guest character, but by any guest who may connect from that site. The verb :player_to_refusal_origin (<player>) converts a player object to a refusal origin (either the same player object or a guest's site code) suitable to be stored in .refused_origins.", "", "Your .refused_actions property stores, for each origin in .refused_origins, a list of the actions you are refusing for that origin. Continuing the example from the last paragraph, if you are refusing page from Frand and page, whisper, and mail from Stupid_Jerk, then your .refused_actions has the value {{"page"}, {"page", "whisper", "mail"}}.", "", "Your .refused_until stores an expiration time for each refusal origin, in the form used by time(), the number of seconds since midnight, 1 January 1970, GMT. All actions that you are refusing from a given player expire at the same time. If you are refusing Frand until 19 December 1992, and Stupid_Jerk for seven years, your .refused_until might have the value {724763397, 928384392}.", "", "Your .refused_extra property stores any additional information needed for fancy refusals. It stores one piece of information for every action you are refusing from every player. In other words, .refused_extra contains a list of lists which are parallel to the lists in .refused_actions. None of the built-in refusals on #3133 is fancy, so for them, the extra piece of information is always 0. In the example, your .refused_extra has the value {{0}, {0, 0, 0}}. The next section explains how to use .refused_extra in fancy refusals.", "", "Another property, .default_refusal_time, stores the duration in seconds that a refusal lasts by default. This property is readable and owned by Frand. Its value is usually 604800, seven days. You can set it via the verb :set_default_refusal_time.", "", " - fancy refusable actions", "", "THIS SECTION IS NOT YET WRITTEN", "", " - selective refusal reporting", "", "If you have done '@refusal-reporting on', then you see a message when you refuse somebody else's action (for some actions). This reporting is done by the verb :report_refusal.", "", "    :report_refusal (<player>, <message>, ...)", "", "The first argument is the player whose action is refused, and the rest are concatenated to form the message that you see.", "", "You can override this verb if you want more selective refusal reporting. If you're refusing pages, for example, you might find that the refusal report is just as annoying as the original page--but you still don't want to turn it off. In that case, you might decide to give no more than one refusal report per minute, using code like this:", "", "    @property me.refusal_time 0", "    @property me.refusal_count 0", "    @verb me:report_refusal this none this", "    @program me:report_refusal", "      if (time() - this.refusal_time < 60)", "        this.refusal_count = this.refusal_count + 1;", "      else", "        if (this.refusal_count > 0)", "           pass (args [1], "You've refused ", this.refusal_count+1,", "                 " actions recently.");", "        else", "          pass (@args);", "        endif", "        this.refusal_time = time();", "        this.refusal_count = 0;", "      endif", "    .", "", "The property that remembers whether refusal reporting is turned on is .report_refusal, which may have the values 0 or 1. The property is owned by Frand, so you can't change it directly.", "", " - refusal synonyms", "", "You can give a refusal more than one name by overriding the verb :translate_refusal_synonym. The verb takes one argument, a word from the command line, and it returns a list of refusal names that the word stands for. If the word is not a synonym, :translate_refusal_synonym should return the empty list, {}.", "", "    :translate_refusal_synonym (<word>) -> <list>", "", "If you want 'noise' to mean both page and whisper for you, then you'd write this. You need to pass(@args) to get the synonym 'all', which stands for all refusable actions. If you type '@refuse noises from Munchkin', the plural 's' is removed automatically, so you don't have to worry about that.", "", "    @verb me:translate_refusal_synonym this none this", "    @program me:translate_refusal_synonym", "      return pass(@args) ||", "             (args [1] == "noise") ? {"page", "whisper"} | {};", "    .", "", " - refusing actions by classes of players", "", "THIS SECTION IS NOT YET WRITTEN" ]
#92 Frand Help DB.@refuse rc = MOOList [ "", "The refusal facility allows you to ignore specific actions by players. You can ignore all mail that Stupid_Jerk (#34567) sends you, for", "example, or you can ignore all whispers and pages, no matter who they are from.", "", "There are three basic refusal commands. They are explained below.", "", "    @refuse <action> from <player>", "    @unrefuse <action> from <player>", "    @refusals", "", "The actions you can refuse are page, whisper, mail, move, join, and accept. These are explained in a table farther down.", "", "For example, '@refuse mail from Stupid_Jerk'. Any future mail that Stupid_Jerk sends you will be dropped on the floor, and Stupid_Jerk will", "be told that you refused to receive it. The refusal stays active for a week; after the week is over, Stupid_Jerk's mail will again get", "through. (If you want the refusal to last a longer or shorter time, keep on reading.)", "", "You can refuse more than one action at a time. '@refuse page whisper from Stupid_Jerk' refuses both pages and whispers.", "", "You can also refuse actions from everybody.", "", "    @refuse <actions>", "", "For example, '@refuse page' refuses every page. These refusals are listed as refusals of 'everybody' when you use the @refusals command,", "below.", "", "See `help @unrefuse' and `help @refusal-reporting' for information on undoing refusals and finding out what you're refusing.", "", " - the actions", "", "The actions everybody can refuse are page, whisper, mail, move, and join.", "refuse other things as well, depending on your player class.", "", " refuse this      to prevent somebody from doing this", " -----------      -----------------------------------", "    page        - tell you a message with the 'page' command", "    whisper     - tell you a message with the 'whisper' or 'murmur' command", "    mail        - send you a MOOmail message via @send", "    move        - teleport you", "    join        - enter the same room as you (only works in a some rooms)", "    accept      - hand you an object (or teleport it to you)", "    flames      - posts are suppressed on mail lists", "    politics    - set yourself `apolitical' [see `help apolitical']", "    all         - all of the above", "", "Refusing move is a little tricky. The player will not be able to teleport you, but you will not be able to pass through any special exits", "that the player may have programmed either. Refusing move means refusing *all* movement, including movement through programmed exits.", "Fortunately most exits are plain exits, and you will always be able to pass through them. Only specially programmed exits by the player you", "are refusing move from are barred to you.", "", "Refusing join only works in special rooms that support it.", "", " - time limits", "", "Refusals expire after a certain amount of time has gone by. Unless you say otherwise, they expire after a week. You can add '... for", "<time>' to the end of a @refuse command:", "", "    @refuse <action> from <player> for <time>", "    @refuse <action> for <time>", "", "For example, '@refuse join from Stupid_Jerk for 3 days'.", "", "The <time> is always a number followed by a unit, like '10 weeks' or '45 seconds'. The possible units are second, minute, hour, day, week,", "and month." ]
#92 Frand Help DB.@rooms rc = MOOList [ "When you aren't in the same room with an object, you have to refer to it by number. When teleporting, that means you usually have to give your destination as a number. To avoid this, Frand's player class provides a way for you to store a database of rooms by name. If the library is in your list of rooms, you can just '@go library' to teleport there. Or '@move book to lib' to teleport an object there.", "", "  @rooms                     - see a list of the rooms you know by name", "  @addr*oom <name> <number>  - remember a room by name", "  @rmr*oom  <name>           - forget about a room's name", "", "For example, to add the kitchen to your database of rooms, type '@addr Kitchen #24'. To remove it, type '@rmr kitchen'." ]
#92 Frand Help DB.@refusal-reporting rc = MOOList [ "[See help @refuse for a discussion of the refusal facility]", "", "    @refusals", "    @refusals for <player>", "", "List the players and actions you are refusing, or the players and actions that another player is refusing. For example, you can see if", "Stupid_Jerk is refusing your mail too: '@refusals for Stupid_Jerk'.", "", "Normally refusal works without your awareness. You don't even notice when Stupid_Jerk attempts to send you mail. If you would rather be", "notified when it happens (so you can thumb your nose), then do", "", "    @refusal-reporting on", "", "Actually, all you need to type is '@refusal-r on'. You will see a message like 'Mail from Stupid_Jerk (#34567) refused.' as soon as", "Stupid_Jerk types 'send' in the mail editor.", "", "Refusal reporting only works for some actions. It works for page, whisper, and mail, but not for move, join or accept. Sorry.", "", "You will only be notified if you are connected when the refusal happens. If you are not connected when Stupid_Jerk tries to send you mail,", "you won't know about it, no matter whether refusal reporting is on or off.", "", "You can turn off refusal reporting with '@refusal-r off'. You can check whether it is on or off with '@refusal-r'. Here's the list:", "", "    @refusal-reporting on     - turn on refusal reporting", "    @refusal-reporting off    - turn off refusal reporting", "    @refusal-reporting        - see whether it is on or off" ]
#92 Frand Help DB.@rmword rc = MOOList [ "Usage: @rmword <word or words>", "", "Will remove all words found from your personal dictionary, stored in player property ".dict"." ]
#92 Frand Help DB.@adddict r = MOOList [ "*forward*", "@addword" ]
#92 Frand Help DB.@spurn r = MOOList [ "*verbdoc*", "$frand_class", "@spurn" ]
#92 Frand Help DB.@find rc = MOOList [ "  @find #<object>   - locate an object by number", "  @find <player>    - locate a player", "  @find :<verb>     - locate a verb on an object in your vicinity", "  @find .<property> - locate a property on objects in your vicinity.", "  @find ?<topic>    - locate a help topic on a help database.", "", "For example, '@find frand' shows Frand's number and location. '@find :jump' lists every object in the same room as you (including you and the room itself) which has a 'jump' verb.  For properties and verbs, output is a list of pairs of objects: each object on which the property or verb exists, and the ancestor that actually defines it." ]
#92 Frand Help DB.@addword rc = MOOList [ "Syntax: @addword <word or words>", "        @addword object.property", "        @addword object:verb", "", "Will add all words found and unknown into your personal dictionary.", "Your dictionary is stored in a property named ".dict"." ]
#92 Frand Help DB.@spell rc = MOOList [ "Syntax: @spell <any number of words>", "           - will check the words from the command line.", "        @spell object.property", "           - will spellcheck the contents of a prop. Must be a string or", "             list of strings.", "        @spell object:verb", "           - will check everything within quoted strings in a verb. E.g.,", "             only the quoted part of player:tell("Spellchecking is fun.");", "             will be examined for errors.", "", "Refer to Help Spelling for general information about the spell checker." ]
#92 Frand Help DB.@unrefuse rc = MOOList [ "Syntax:", "    @unrefuse <actions> from <player>", "", "If Stupid_Jerk reforms, you can change your mind. '@unrefuse mail from Stupid_Jerk' will remove the refusal.", "", "'@unrefuse' can also be called '@allow', for those who prefer English over clarity.", "", "    @unrefuse <actions>", "", "If you don't mention a player, you remove only refusals that apply to everybody. '@unrefuse page' turns off any '@refuse page' command you", "gave before, but does not affect refusals of specific players. You will still be refusing pages from Stupid_Jerk, if you were before.", "", "    @unrefuse everything", "", " If you '@unrefuse everything', all your refusals are removed. This command asks if you are sure before erasing them all." ]
#92 Frand Help DB.@complete rc = MOOList [ "Syntax:  @complete prefix", "", "This verb is part of the MOO spelling checker.  It will show you all the words in the dictionary that start with the prefix letters you specify.  You should be specific as to what you're looking for (for example, you might use @complete comput, rather than @complete co) in order to avoid getting an excessive number of words output.", "", "Refer to help spelling for more information." ]
#92 Frand Help DB.@ways rc = MOOList [ "'@ways', '@ways <room>' - List any obvious exits from the given room (or this room, if none is given)." ]
#92 Frand Help DB.@rmroom rc = MOOList [ "*forward*", "@rooms" ]
#92 Frand Help DB.@join rc = MOOList [ "*forward*", "@move" ]
#92 Frand Help DB.@addroom rc = MOOList [ "*forward*", "@rooms" ]
#92 Frand Help DB.@submitted r = MOOList [ "*verbdoc*", "$frand_class", "@submitted" ]
#92 Frand Help DB.@cspell rc = MOOList [ "Syntax: @cspell <any number of words>", "        @cspell object.property", "        @cspell object:verb", "", "Like @spell, but attempts to guess at correct spellings for words it believes are spelled incorrectly.   This verb can be quite slow, so correcting large chunks of text may not be a good idea.", "", "Refer to help spelling and help @spell for more information." ]
#92 Frand Help DB.@spellmessages rc = MOOList [ "Syntax: @spellproperties <object>", "        @spellmessages <object>", "These commands will spellcheck all properties or messages, respectively, on an object.  The object must be owned or readable by the user.  Messages and properties will be spellchecked if they contain a string or a list of strings; others will be ignored.", "", "Refer to help spelling for general information about the spellchecker." ]
#92 Frand Help DB.spelling rc = MOOList [ "The MOO has a built in spelling checker and dictionary.  There are several player commands which access the database, as well as some programming features available.  Additional documentation is available under individual commands.", "", "The current dictionary only contains about 20,000 words, and thus is somewhat incomplete.  Words may be added to a personal dictionary, as well as to the main dictionary (only a few people can add to the main dictionary).", "", "@spell a word or phrase - Spell check a word or phrase.", "@spell thing.prop - Spell check a property. The value must be a string or a list of strings.", "@spell thing:verb - Spell check a verb. Only the quoted strings in the verb are checked.", "@spellproperties object - Spell check all text properties of an object.", "@spellmessages object - Spell check only message properties of an object.", "@cspell word - Spell check a word, and if it is not in the dictionary, offers suggestions about what the right spelling might be. This actually works with thing.prop and thing:verb too, but it is too slow to be useful--it takes maybe 30 seconds per unknown word.", "@complete prefix - List all the word in the dictionary which begin with the given prefix. For example, '@complete zoo' lists zoo, zoologist, zoology, and zoom.", "@addword word - Add a word to your personal dictionary.", "@rmword word - Remove a word from your personal dictionary.", "@adddict word - Add a word to the global dictionary.", "@rmdict word - Remove a word from the global dictionary.", "", "For programmers, the verb $spell:random() is available -- returns a word, at random, from the dictionary.", "", "Questions and comments should be directed to waffle on LambdaMOO." ]
#92 Frand Help DB.teleport-messages rc = MOOList [ "Teleporting using @go, @move, or @join causes various messages to appear. The messages are defined on you as properties. Here are the messages, who sees them, and when.", "", " when you teleport -  yourself      a player        a thing", "", "           you see -  self_port     player_port     thing_port", "        others see -  oself_port    oplayer_port    othing_port", "  destination sees -  self_arrive   player_arrive   thing_arrive", "   teleportee sees -                victim_port     object_port", "", "When you @join a player, your join message is printed to you.", "", "You can set the messages with commands like '@oself_port me is "vanishes in a shimmering haze."', '@join me is "You visit %n."', and so on.", "", "The messages to you are printed as they stand. The messages to others are printed after your name. If you set a message to "", the null string, nothing will print for that message. But if you have a non-empty message which does not include your name, then your name will be added in front of the message. You can use the usual pronoun substitutions, like '%n' to refer to the object you are teleporting. You can also use the special substitutions %<from room> and %<to room> to refer to the original and destination rooms for the teleport.", "", "If you are leaving your name out of the messages, and relying on its being inserted automatically, you have to be careful about the substitutions you use. If Frand has an oself_port message "jumps to %<to room>.", for example, and Frand teleports to Frand's MOOhome, the message printed will be "jumps to Frand's MOOhome." My name is there, so it isn't added in. If you want to include your name as a substitution, the one to use is %t, 'this'. "%t jumps to %<to room>." will work." ]
#92 Frand Help DB.@addsubmitted r = MOOList [ "*forward*", "@submitted" ]
#92 Frand Help DB.frand-index rc = MOOList [ "*index*", "Frand's Player Class Help Topics" ]
#92 Frand Help DB.@spellproperties rc = MOOList [ "*forward*", "@spellmessages" ]
#92 Frand Help DB.@go rc = MOOList [ "*forward*", "@move" ]
#92 Frand Help DB.@move rc = MOOList [ "  @move <obj> to <location>  - teleport an object to a given location", "  @go <location>             - teleport yourself to a given location", "  @join <player>             - teleport yourself to a player's location", "", "You can teleport an object (if it allows this) to any location that will accept it. For example, `@move rock to #11' will teleport the rock to the closet. `@move #123 to here' will move object #123 to your location. `@go home' will teleport you home. `@join yduj' will teleport you to yduJ's location. You can also teleport an object to #-1, which is nowhere.", "", "See help teleport-messages for information on customizing the text that appears", "(both to you and to others in the vicinity) when you teleport.", "See also help @rooms for information on naming rooms for convenient movement.", "If @move doesn't work and you own the place where the object is located, try using @eject instead." ]
#92 Frand Help DB.@rmsubmitted r = MOOList [ "*forward*", "@submitted" ]
#92 Frand Help DB.@spurned r = MOOList [ "*verbdoc*", "$frand_class", "@spurned" ]
#92 Frand Help DB.@at rc = MOOList [ " '@at' - Find out where everyone is.", " '@at <player>' - Find out where <player> is, and who else is there.", " '@at <obj>' - Find out who else is at the same place as <obj>.", " '@at <place>' - Find out who is at the place.", " The place can be given by number, or it can be a name from your @rooms list.", " '@at #-1' - Find out who is at #-1.", " '@at me' - Find out who is in the room with you.", " '@at home' - Find out who is at your home." ]
#92 Frand Help DB.@rmdict r = MOOList [ "*forward*", "@rmword" ]
#92 Frand Help DB.@refusals rc = MOOList [ "*forward*", "@refusal-reporting" ]
================================#93 Conversion Utils===============================================
#93 Conversion Utils.lusec r = MOOString "1e-6 mm hg m3/s"
#93 Conversion Utils.physdalton r = MOOString "physamu"
#93 Conversion Utils.puncheon r = MOOString "84 gal"
#93 Conversion Utils.year r = MOOString "365.24219879 day"
#93 Conversion Utils.bag r = MOOString "3 brbushels"
#93 Conversion Utils.centare r = MOOString "0.01 are"
#93 Conversion Utils.lux r = MOOString "lumen/m2"
#93 Conversion Utils.bar r = MOOString "1e6 dyne/cm2"
#93 Conversion Utils.ccs r = MOOString "1|36 erlang"
#93 Conversion Utils.statfarad r = MOOString "1.112646e-12 farad"
#93 Conversion Utils.perch r = MOOString "24.75 ft3"
#93 Conversion Utils.boardfoot r = MOOString "144 in3"
#93 Conversion Utils.energy r = MOOString "c2"
#93 Conversion Utils.pica r = MOOString "0.166044 inch"
#93 Conversion Utils.% r = MOOString "1|100"
#93 Conversion Utils.mile r = MOOString "5280 feet"
#93 Conversion Utils.league r = MOOString "3 mi"
#93 Conversion Utils.hefnerunit r = MOOString ".92 cd"
#93 Conversion Utils.coul r = MOOString "coulomb"
#93 Conversion Utils.au r = MOOString "1.49599e11 m"
#93 Conversion Utils.equivalentlux r = MOOString "lumen/pi m2"
#93 Conversion Utils.poise r = MOOString "gram/cm sec"
#93 Conversion Utils.biot r = MOOString "10 amp"
#93 Conversion Utils.brbushel r = MOOString "8 dry british gal"
#93 Conversion Utils.turn r = MOOString "2 pi radian"
#93 Conversion Utils.sec r = MOOString "second"
#93 Conversion Utils.bu r = MOOString "bushel"
#93 Conversion Utils.abampere r = MOOString "10 amp"
#93 Conversion Utils.foot r = MOOString "12 in"
#93 Conversion Utils.hand r = MOOString "4 in"
#93 Conversion Utils.displacementton r = MOOString "35 ft3"
#93 Conversion Utils.cc r = MOOString "cm3"
#93 Conversion Utils.cd r = MOOString "candela"
#93 Conversion Utils.c r = MOOString "2.99792458e8 m/sec"
#93 Conversion Utils.cg r = MOOString "centigram"
#93 Conversion Utils.e r = MOOString "1.6020e-19 coul"
#93 Conversion Utils.crith r = MOOString "9.06e-2 gram"
#93 Conversion Utils.g r = MOOString "9.80665 m/sec2"
#93 Conversion Utils.physamu r = MOOString "1.65979e-24 g"
#93 Conversion Utils.metricton r = MOOString "1000 kg"
#93 Conversion Utils.cm r = MOOString "centimeter"
#93 Conversion Utils.firkin r = MOOString "72 pint"
#93 Conversion Utils.k r = MOOString "1.38047e-16 erg/kelvin"
#93 Conversion Utils.l r = MOOString "liter"
#93 Conversion Utils.cfs r = MOOString "ft3/sec"
#93 Conversion Utils.centesimalsecond r = MOOString "1e-4 grade"
#93 Conversion Utils.skein r = MOOString "360 feet"
#93 Conversion Utils.brbarrel r = MOOString "4.5 brbushels"
#93 Conversion Utils.v r = MOOString "volt"
#93 Conversion Utils.abohm r = MOOString "10 ohm"
#93 Conversion Utils.fifth r = MOOString "1|5 gal"
#93 Conversion Utils.inch r = MOOString "2.54 cm"
#93 Conversion Utils.imperial r = MOOString "1.200949"
#93 Conversion Utils.quarter r = MOOString "9 in"
#93 Conversion Utils.rydberg r = MOOString "1.36054e1 ev"
#93 Conversion Utils.gunterchain r = MOOString "66 ft"
#93 Conversion Utils.faraday r = MOOString "9.648456e4coul"
#93 Conversion Utils.dr r = MOOString "dram"
#93 Conversion Utils.bev r = MOOString "1e9 ev"
#93 Conversion Utils.homestead r = MOOString "1|4 mi2"
#93 Conversion Utils.longquarter r = MOOString "28 lb"
#93 Conversion Utils.stathenry r = MOOString "8.987584e11 henry"
#93 Conversion Utils.sigma r = MOOString "microsec"
#93 Conversion Utils.ell r = MOOString "45 in"
#93 Conversion Utils.horsepower r = MOOString "550 ft lb g/sec"
#93 Conversion Utils.footcandle r = MOOString "lumen/ft2"
#93 Conversion Utils.footlambert r = MOOString "cd/pi ft2"
#93 Conversion Utils.farad r = MOOString "coul/volt"
#93 Conversion Utils.ev r = MOOString "e volt"
#93 Conversion Utils.month r = MOOString "1|12 year"
#93 Conversion Utils.oersted r = MOOString "1 gilbert / cm"
#93 Conversion Utils.dopplezentner r = MOOString "100 kg"
#93 Conversion Utils.parsec r = MOOString "au radian/arcsec"
#93 Conversion Utils.equivalentfootcandle r = MOOString "lumen/pi ft2"
#93 Conversion Utils.engineerschain r = MOOString "100 ft"
#93 Conversion Utils.reyn r = MOOString "6.89476e-6 centipoise"
#93 Conversion Utils.clusec r = MOOString "1e-8 mm hg m3/s"
#93 Conversion Utils.shortton r = MOOString "2000 lb"
#93 Conversion Utils.rope r = MOOString "20 ft"
#93 Conversion Utils.minim r = MOOString "1|480 floz"
#93 Conversion Utils.mach r = MOOString "331.45 m/sec"
#93 Conversion Utils.ft r = MOOString "foot"
#93 Conversion Utils.statvolt r = MOOString "299.7930 volt"
#93 Conversion Utils.pound r = MOOString "lb"
#93 Conversion Utils.bakersdozen r = MOOString "13"
#93 Conversion Utils.brpeck r = MOOString "2 dry british gal"
#93 Conversion Utils.cubichectare r = MOOString "1000000 m3"
#93 Conversion Utils.gb r = MOOString "1024 mb"
#93 Conversion Utils.tonne r = MOOString "1e6 gram"
#93 Conversion Utils.gunterlink r = MOOString "0.01 gunterchain"
#93 Conversion Utils.gm r = MOOString "gram"
#93 Conversion Utils.caliber r = MOOString "0.01 in"
#93 Conversion Utils.rood r = MOOString "0.25 acre"
#93 Conversion Utils.atomicmassunit r = MOOString "amu"
#93 Conversion Utils.gr r = MOOString "grain"
#93 Conversion Utils.kilderkin r = MOOString "18 imperial gal"
#93 Conversion Utils.petrbarrel r = MOOString "42 gal"
#93 Conversion Utils.rhe r = MOOString "1/poise"
#93 Conversion Utils.henry r = MOOString "sec2/farad"
#93 Conversion Utils.pdl r = MOOString "poundal"
#93 Conversion Utils.hd r = MOOString "hogshead"
#93 Conversion Utils.township r = MOOString "36 mi2"
#93 Conversion Utils.astronomicalunit r = MOOString "au"
#93 Conversion Utils.hg r = MOOString "mercury"
#93 Conversion Utils.atmosphere r = MOOString "1.01325 bar"
#93 Conversion Utils.floz r = MOOString "1|4 gill"
#93 Conversion Utils.decade r = MOOString "10 year"
#93 Conversion Utils.hogshead r = MOOString "63 gal"
#93 Conversion Utils.hp r = MOOString "horsepower"
#93 Conversion Utils.hr r = MOOString "hour"
#93 Conversion Utils.hz r = MOOString "hertz"
#93 Conversion Utils.geographicalmile r = MOOString "nmile"
#93 Conversion Utils.dram r = MOOString "avdram"
#93 Conversion Utils.fathom r = MOOString "6 ft"
#93 Conversion Utils.block r = MOOString "512 byte"
#93 Conversion Utils.karat r = MOOString "1|24"
#93 Conversion Utils.dyne r = MOOString "erg/cm"
#93 Conversion Utils.in r = MOOString "inch"
#93 Conversion Utils.byte r = MOOString "8 bit"
#93 Conversion Utils.peck r = MOOString "2 dry gallon"
#93 Conversion Utils.basic_units_template r = MOOList [ [ "m", 0 ], [ "kg", 0 ], [ "s", 0 ], [ "coul", 0 ], [ "candela", 0 ], [ "radian", 0 ], [ "bit", 0 ], [ "erlang", 0 ], [ "kelvin", 0 ] ]
#93 Conversion Utils.cordfoot r = MOOString "0.125 cord"
#93 Conversion Utils.arcmin r = MOOString "1|60 arcdeg"
#93 Conversion Utils.tnt r = MOOString "4.6e6 m2/sec2"
#93 Conversion Utils.bottommeasure r = MOOString "1|40 in"
#93 Conversion Utils.shorthundredweight r = MOOString "100 lb"
#93 Conversion Utils.noggin r = MOOString "1 imperial gill"
#93 Conversion Utils.pint r = MOOString "1|2 qt"
#93 Conversion Utils.fluidounce r = MOOString "floz"
#93 Conversion Utils.ton r = MOOString "shortton"
#93 Conversion Utils.sphere r = MOOString "4 pi steradian"
#93 Conversion Utils.kb r = MOOString "1024 byte"
#93 Conversion Utils.erg r = MOOString "1e-7 joule"
#93 Conversion Utils.cental r = MOOString "100 lb"
#93 Conversion Utils.gilbert r = MOOString "0.7957747154 amp"
#93 Conversion Utils.km r = MOOString "kilometer"
#93 Conversion Utils.bushel r = MOOString "8 dry gal"
#93 Conversion Utils.century r = MOOString "100 year"
#93 Conversion Utils.lb r = MOOString "0.45359237 kg"
#93 Conversion Utils.candle r = MOOString "cd"
#93 Conversion Utils.equivalentphot r = MOOString "cd/pi cm2"
#93 Conversion Utils.hyl r = MOOString "gram force sec2/m"
#93 Conversion Utils.sabin r = MOOString "1 ft2"
#93 Conversion Utils.tbsp r = MOOString "tablespoon"
#93 Conversion Utils.blondel r = MOOString "cd/pi m2"
#93 Conversion Utils.nautleague r = MOOString "3 nmile"
#93 Conversion Utils.feet r = MOOString "foot"
#93 Conversion Utils.lumen r = MOOString "cd sr"
#93 Conversion Utils.sign r = MOOString "1|12 circle"
#93 Conversion Utils.british r = MOOString "277.4193|231"
#93 Conversion Utils.carcel r = MOOString "9.61 cd"
#93 Conversion Utils.second r = MOOString "s"
#93 Conversion Utils.imaginarycubicfoot r = MOOString "1.4 ft3"
#93 Conversion Utils.mb r = MOOString "1024 kb"
#93 Conversion Utils.langley r = MOOString "cal/cm cm"
#93 Conversion Utils.rontgen r = MOOString "2.58e-4 curie/kg"
#93 Conversion Utils.mg r = MOOString "milligram"
#93 Conversion Utils.pipe r = MOOString "4 barrel"
#93 Conversion Utils.grain r = MOOString "1|7000 lb"
#93 Conversion Utils.mh r = MOOString "millihenry"
#93 Conversion Utils.mi r = MOOString "mile"
#93 Conversion Utils.cable r = MOOString "720 ft"
#93 Conversion Utils.longton r = MOOString "2240 lb"
#93 Conversion Utils.ml r = MOOString "milliliter"
#93 Conversion Utils.mm r = MOOString "millimeter"
#93 Conversion Utils.mo r = MOOString "month"
#93 Conversion Utils.fermi r = MOOString "1e-13 cm"
#93 Conversion Utils.ramdenlink r = MOOString "0.01 ramdenchain"
#93 Conversion Utils.ms r = MOOString "millisec"
#93 Conversion Utils.meter r = MOOString "m"
#93 Conversion Utils.cps r = MOOString "hertz"
#93 Conversion Utils.shippington r = MOOString "40 ft3"
#93 Conversion Utils.ream r = MOOString "500"
#93 Conversion Utils.dry r = MOOString "268.8025 in3/gallon"
#93 Conversion Utils.dioptre r = MOOString "1/m"
#93 Conversion Utils.arpentcan r = MOOString "27.52 mi"
#93 Conversion Utils.lbf r = MOOString "lb g"
#93 Conversion Utils.hertz r = MOOString "1/sec"
#93 Conversion Utils.ohm r = MOOString "volt/amp"
#93 Conversion Utils.engcandle r = MOOString "1.04 cd"
#93 Conversion Utils.abfarad r = MOOString "10 farad"
#93 Conversion Utils.franklin r = MOOString "3.33564e-10 coul"
#93 Conversion Utils.weber r = MOOString "volt sec"
#93 Conversion Utils.nm r = MOOString "nanometer"
#93 Conversion Utils.ns r = MOOString "nanosec"
#93 Conversion Utils.amp r = MOOString "ampere"
#93 Conversion Utils.rod r = MOOString "16.5 ft"
#93 Conversion Utils.nt r = MOOString "newton"
#93 Conversion Utils.amu r = MOOString "chemamu"
#93 Conversion Utils.seam r = MOOString "8 brbushels"
#93 Conversion Utils.torr r = MOOString "mm hg"
#93 Conversion Utils.tsp r = MOOString "teaspoon"
#93 Conversion Utils.liqquarten r = MOOString "0.1420613 l"
#93 Conversion Utils.gill r = MOOString "1|4 pt"
#93 Conversion Utils.hour r = MOOString "60 min"
#93 Conversion Utils.oe r = MOOString "oersted"
#93 Conversion Utils.quire r = MOOString "25"
#93 Conversion Utils.micron r = MOOString "1e-6 meter"
#93 Conversion Utils.stere r = MOOString "m3"
#93 Conversion Utils.spindle r = MOOString "14400 yd"
#93 Conversion Utils.boardfeet r = MOOString "boardfoot"
#93 Conversion Utils.mev r = MOOString "1e6 ev"
#93 Conversion Utils.minersinch r = MOOString "1.5 ft3/min"
#93 Conversion Utils.phot r = MOOString "lumen/cm2"
#93 Conversion Utils.oz r = MOOString "ounce"
#93 Conversion Utils.teaspoon r = MOOString "1|3 tablespoon"
#93 Conversion Utils.rpm r = MOOString "revolution/minute"
#93 Conversion Utils.minute r = MOOString "60 sec"
#93 Conversion Utils.pc r = MOOString "parsec"
#93 Conversion Utils.refrigeration r = MOOString "12000 but/ton hr"
#93 Conversion Utils.pf r = MOOString "picofarad"
#93 Conversion Utils.abhenry r = MOOString "10 henry"
#93 Conversion Utils.acre r = MOOString "43560 ft2"
#93 Conversion Utils.pi r = MOOString "3.14159265358979323846264338327950288"
#93 Conversion Utils.pk r = MOOString "peck"
#93 Conversion Utils.barie r = MOOString "1e-1 nt/m2"
#93 Conversion Utils.ramdenchain r = MOOString "100 ft"
#93 Conversion Utils.ps r = MOOString "picosec"
#93 Conversion Utils.pt r = MOOString "pint"
#93 Conversion Utils.skot r = MOOString "1e-3 apostilb"
#93 Conversion Utils.mgd r = MOOString "megagal/day"
#93 Conversion Utils.tun r = MOOString "252 gal"
#93 Conversion Utils.nit r = MOOString "cd/m2"
#93 Conversion Utils.qt r = MOOString "quart"
#93 Conversion Utils.nail r = MOOString "1|16 yd"
#93 Conversion Utils.pace r = MOOString "30 inch"
#93 Conversion Utils.ra r = MOOString "100 erg/gram"
#93 Conversion Utils.rd r = MOOString "rod"
#93 Conversion Utils.mho r = MOOString "1/ohm"
#93 Conversion Utils.apdram r = MOOString "60 grain"
#93 Conversion Utils.volt r = MOOString "watt/amp"
#93 Conversion Utils.grade r = MOOString "1|400 circle"
#93 Conversion Utils.circle r = MOOString "2 pi radian"
#93 Conversion Utils.butt r = MOOString "126 gal"
#93 Conversion Utils.mhz r = MOOString "megahz"
#93 Conversion Utils.cup r = MOOString "1|2 pt"
#93 Conversion Utils.long r = MOOString "4 word"
#93 Conversion Utils.mil r = MOOString "0.001 in"
#93 Conversion Utils.quartersection r = MOOString "1|4 mi2"
#93 Conversion Utils.min r = MOOString "minute"
#93 Conversion Utils.shortquarter r = MOOString "500 lb"
#93 Conversion Utils.are r = MOOString "100 m2"
#93 Conversion Utils.germancandle r = MOOString "1.05 cd"
#93 Conversion Utils.kev r = MOOString "1e3 ev"
#93 Conversion Utils.sr r = MOOString "steradian"
#93 Conversion Utils.btu r = MOOString "1054.35 joule"
#93 Conversion Utils.gram r = MOOString "1|1000 kg"
#93 Conversion Utils.cordfeet r = MOOString "cordfoot"
#93 Conversion Utils.maxwell r = MOOString "1e-8 weber"
#93 Conversion Utils.rehoboam r = MOOString "156 floz"
#93 Conversion Utils.apounce r = MOOString "480 grain"
#93 Conversion Utils.gallon r = MOOString "231 in3"
#93 Conversion Utils.brfirkin r = MOOString "1.125 brbushel"
#93 Conversion Utils.rankine r = MOOString "1.8 kelvin"
#93 Conversion Utils.grad r = MOOString "1|400 circle"
#93 Conversion Utils.gamma r = MOOString "1e-6 g"
#93 Conversion Utils.apostilb r = MOOString "cd/pi m2"
#93 Conversion Utils.abvolt r = MOOString "10 volt"
#93 Conversion Utils.stoke r = MOOString "1 cm2/sec"
#93 Conversion Utils.engineerslink r = MOOString "0.01 engineerschain"
#93 Conversion Utils.galileo r = MOOString "1e-2 m/sec2"
#93 Conversion Utils.barn r = MOOString "1e-24 cm2"
#93 Conversion Utils.hefnercandle r = MOOString "hefnerunit"
#93 Conversion Utils.atm r = MOOString "atmosphere"
#93 Conversion Utils.nautmile r = MOOString "nmile"
#93 Conversion Utils.slug r = MOOString "lb g sec2/ft"
#93 Conversion Utils.us r = MOOString "microsec"
#93 Conversion Utils.chemamu r = MOOString "1.66024e-24 g"
#93 Conversion Utils.last r = MOOString "80 bu"
#93 Conversion Utils.carat r = MOOString "205.3 mg"
#93 Conversion Utils.mole r = MOOString "6.022045e23"
#93 Conversion Utils.degree r = MOOString "1|180 pi radian"
#93 Conversion Utils.brbucket r = MOOString "4 dry british gal"
#93 Conversion Utils.ampere r = MOOString "coul/sec"
#93 Conversion Utils.scruple r = MOOString "20 grain"
#93 Conversion Utils.fortnight r = MOOString "14 day"
#93 Conversion Utils.knot r = MOOString "nmile/hr"
#93 Conversion Utils.bolt r = MOOString "120 feet"
#93 Conversion Utils.khz r = MOOString "kilohz"
#93 Conversion Utils.lightyear r = MOOString "c yr"
#93 Conversion Utils.statcoul r = MOOString "3.335635e-10 coul"
#93 Conversion Utils.psi r = MOOString "lb g/in2"
#93 Conversion Utils.pennyweight r = MOOString "24 grain"
#93 Conversion Utils.timberfoot r = MOOString "ft3"
#93 Conversion Utils.newton r = MOOString "kg m/sec2"
#93 Conversion Utils.gal r = MOOString "gallon"
#93 Conversion Utils.magnum r = MOOString "2 qt"
#93 Conversion Utils.nox r = MOOString "1e-3 lux"
#93 Conversion Utils.avdram r = MOOString "1|16 oz"
#93 Conversion Utils.circularinch r = MOOString "1|4 pi in2"
#93 Conversion Utils.steradian r = MOOString "radian radian"
#93 Conversion Utils.hectare r = MOOString "100 are"
#93 Conversion Utils.gramcalorie r = MOOString "cal"
#93 Conversion Utils.stone r = MOOString "14 lb"
#93 Conversion Utils.usdram r = MOOString "1|8 oz"
#93 Conversion Utils.cubit r = MOOString "18 in"
#93 Conversion Utils.curie r = MOOString "3.7e10/sec"
#93 Conversion Utils.barleycorn r = MOOString "1|3 in"
#93 Conversion Utils.longhundredweight r = MOOString "112 lb"
#93 Conversion Utils.siemens r = MOOString "mho"
#93 Conversion Utils.myriagram r = MOOString "10 kg"
#93 Conversion Utils.watt r = MOOString "joule/sec"
#93 Conversion Utils.yard r = MOOString "3 ft"
#93 Conversion Utils.appound r = MOOString "5760 grain"
#93 Conversion Utils.palm r = MOOString "3 in"
#93 Conversion Utils.thermie r = MOOString "1e6 cal"
#93 Conversion Utils.registerton r = MOOString "100 ft3"
#93 Conversion Utils.yd r = MOOString "yard"
#93 Conversion Utils.revolution r = MOOString "360 degrees"
#93 Conversion Utils.inches r = MOOString "inch"
#93 Conversion Utils.stilb r = MOOString "cd/cm2"
#93 Conversion Utils.jeroboam r = MOOString "4|5 gal"
#93 Conversion Utils.abcoulomb r = MOOString "10 coul"
#93 Conversion Utils.yr r = MOOString "year"
#93 Conversion Utils.proof r = MOOString "1|200"
#93 Conversion Utils.baud r = MOOString "bit/sec"
#93 Conversion Utils.mph r = MOOString "mile/hr"
#93 Conversion Utils.mpg r = MOOString "mile/gal"
#93 Conversion Utils.quadrant r = MOOString "5400 minute"
#93 Conversion Utils.drachm r = MOOString "3.551531 ml"
#93 Conversion Utils.xunit r = MOOString "1.00202e-13 m"
#93 Conversion Utils.chemdalton r = MOOString "chemamu"
#93 Conversion Utils.force r = MOOString "g"
#93 Conversion Utils.word r = MOOString "4 byte"
#93 Conversion Utils.joule r = MOOString "nt m"
#93 Conversion Utils.arcsec r = MOOString "1|60 arcmin"
#93 Conversion Utils.pascal r = MOOString "nt/m2"
#93 Conversion Utils.dalton r = MOOString "chemamu"
#93 Conversion Utils.basic_units r = MOOList [ "m", "kg", "s", "coul", "candela", "radian", "bit", "erlang", "kelvin" ]
#93 Conversion Utils.finger r = MOOString "7|8 in"
#93 Conversion Utils.barrel r = MOOString "31.5 gal"
#93 Conversion Utils.chain r = MOOString "gunterchain"
#93 Conversion Utils.frigorie r = MOOString "kilocal"
#93 Conversion Utils.candlepower r = MOOString "12.566370 lumen"
#93 Conversion Utils.spat r = MOOString "sphere"
#93 Conversion Utils.wey r = MOOString "252 lb"
#93 Conversion Utils.brknot r = MOOString "6080 ft/hr"
#93 Conversion Utils.arpentlin r = MOOString "191.835 ft"
#93 Conversion Utils.tablespoon r = MOOString "4 fldr"
#93 Conversion Utils.millenium r = MOOString "1000 year"
#93 Conversion Utils.circularmil r = MOOString "1e-6|4 pi in2"
#93 Conversion Utils.span r = MOOString "9 in"
#93 Conversion Utils.poundal r = MOOString "ft lb/sec2"
#93 Conversion Utils.sthene r = MOOString "1e3 nt"
#93 Conversion Utils.tesla r = MOOString "weber/m2"
#93 Conversion Utils.lambert r = MOOString "cd/pi cm2"
#93 Conversion Utils.section r = MOOString "mi2"
#93 Conversion Utils.pole r = MOOString "rd"
#93 Conversion Utils.dozen r = MOOString "12"
#93 Conversion Utils.arcdeg r = MOOString "1 degree"
#93 Conversion Utils.kcalorie r = MOOString "kilocal"
#93 Conversion Utils.day r = MOOString "24 hr"
#93 Conversion Utils.gauss r = MOOString "maxwell/cm2"
#93 Conversion Utils.electronvolt r = MOOString "e volt"
#93 Conversion Utils.gross r = MOOString "144"
#93 Conversion Utils.furlong r = MOOString "660 ft"
#93 Conversion Utils.liter r = MOOString "1000 cc"
#93 Conversion Utils.water r = MOOString "0.22491|2.54 kg/m2 sec2"
#93 Conversion Utils.cord r = MOOString "128 ft3"
#93 Conversion Utils.kcal r = MOOString "kilocal"
#93 Conversion Utils.square r = MOOString "100 ft2"
#93 Conversion Utils.angstrom r = MOOString "1e-8 meter"
#93 Conversion Utils.calorie r = MOOString "cal"
#93 Conversion Utils.marineleague r = MOOString "3nmile"
#93 Conversion Utils.nmile r = MOOString "1852 m"
#93 Conversion Utils.week r = MOOString "7 day"
#93 Conversion Utils.rutherford r = MOOString "1e6/sec"
#93 Conversion Utils.mercury r = MOOString "1.3157895 atm/m"
#93 Conversion Utils.line r = MOOString "1|12 in"
#93 Conversion Utils.link r = MOOString "66|100 ft"
#93 Conversion Utils.percent r = MOOString "%"
#93 Conversion Utils.barye r = MOOString "1e-1 nt/m2"
#93 Conversion Utils.sennight r = MOOString "1 week"
#93 Conversion Utils.point r = MOOString "1|72.27 in"
#93 Conversion Utils.cal r = MOOString "4.1868 joule"
#93 Conversion Utils.quart r = MOOString "1|4 gal"
#93 Conversion Utils.centesimalminute r = MOOString "1e-2 grade"
#93 Conversion Utils.pieze r = MOOString "1e3 nt/mt2"
#93 Conversion Utils.dryquartern r = MOOString "2.272980 l"
#93 Conversion Utils.quintal r = MOOString "100 kg"
#93 Conversion Utils.abmho r = MOOString "10 mho"
#93 Conversion Utils.metriccarat r = MOOString "200 mg"
#93 Conversion Utils.ounce r = MOOString "1|16 lb"
#93 Conversion Utils.fldr r = MOOString "1|32 gill"
#93 Conversion Utils.coomb r = MOOString "4 bu"
#93 Conversion Utils:dd_to_dms dh_to_hms this n/a this
":dd_to_dms(INT|FLOAT <degrees>) => LIST {INT <degrees>, INT <minutes>, FLOAT <seconds>}";
"This verb converts decimal degrees to degrees, minutes, and seconds.";
dd = tofloat(args[1]);
s = (((dd - tofloat(d = toint(dd))) * 60.0) - tofloat(m = toint((dd - tofloat(d)) * 60.0))) * 60.0;
return {d, m, s};
-------------------------------------------------------------------------------
#93 Conversion Utils:dms_to_dd hms_to_dh this n/a this
":dms_to_dd(INT|FLOAT <deg>, INT|FLOAT <min>, INT|FLOAT <sec>) => FLOAT <deg>";
"This verb converts degrees/minutes/seconds to decimal degrees.";
{d, m, s} = args[1..3];
d = tofloat(d);
m = tofloat(m);
s = tofloat(s);
return (d + (m / 60.0)) + (s / 3600.0);
-------------------------------------------------------------------------------
#93 Conversion Utils:rect_to_polar this n/a this
":rect_to_polar(INT|FLOAT <x>, INT|FLOAT <y>) => FLOAT <radius>, FLOAT <angle>.";
"This verb converts from rectangular (x,y) coordinates to polar (r, theta) coordinates.";
{x, y} = args[1..2];
x = tofloat(x);
y = tofloat(y);
return {sqrt((x * x) + (x * x)), `atan(y, x) ! E_INVARG => 0.0'};
-------------------------------------------------------------------------------
#93 Conversion Utils:polar_to_rect this n/a this
":polar_to_rect(INT|FLOAT <radius>, INT|FLOAT <angle>) => FLOAT <x>, FLOAT <y>";
"This verb converts from polar (radius, angle) coordinates to rectangulat (x,y) coordinates.";
{r, a} = args[1..2];
r = tofloat(r);
a = tofloat(a);
return {(r = r / (1.0 + (z2 = (z = tan(a / 2.0)) * z))) * (1.0 - z2), (r * 2.0) * z};
-------------------------------------------------------------------------------
#93 Conversion Utils:F_to_C degF_to_degC this n/a this
":F_to_C(INT|FLOAT <Fahrenheit>) => FLOAT <Celsius>";
"This verb converts Fahrenheit degrees to Celsius degrees.";
return (tofloat(args[1]) - 32.0) / 1.8;
-------------------------------------------------------------------------------
#93 Conversion Utils:C_to_F degC_to_degF this n/a this
":C_to_F(INT|FLOAT <Celsius>) => FLOAT <Fahrenheit>";
"This verb converts Celsius degrees to Fahrenheit degrees.";
return (tofloat(args[1]) * 1.8) + 32.0;
-------------------------------------------------------------------------------
#93 Conversion Utils:convert this n/a this
":convert(STR <units>, STR <units>) => FLOAT conversion factor | LIST errors.";
"This verb attempts to compute the conversion factor between two sets of units. If the two inputs are of the same type (two speeds, two lengths, etc.), the value is returned. If the two inputs are not of the same type, a LIST is returned as follows: {1, {FLOAT <value>, STR <units>}. {FLOAT <value>, STR <units>}}. The 1 indicates that the two inputs were correctly formed. <value> is the conversion factor of the input into the basic <units>. This error output is useful for determining the basic structure and value of an unknown unit of measure. If either of the inputs can not be broken down to known units, a LIST is returned as follows: {0, STR <bad input>}.";
"";
"The format of the input strings is fairly straight forward: any multiplicative combination of units, ending in an optional digit to represent that unit is raised to a power, the whole of which is preceeded by an initial value. Examples: \"100 kg m/sec2\", \"35 joules\", \"2000 furlongs/fortnight\"";
"";
"Some example uses:";
";$convert_utils:convert(\"2000 furlongs/fortnight\", \"mph\")";
"=> 0.744047619047619";
";$convert_utils:convert(\"kilowatt hours\", \"joules\")";
"=> 3600000.0";
"";
";$convert_utils:convert(\"furlongs\", \"mph\")";
"=> {1, {201.168, \"m\"}, {044704, \"m / s\"}}";
"";
";$convert_utils:convert(\"junk\", \"meters\")";
"=> {0, \"junk\"}";
{havestr, wantstr} = args;
{havenum, havestr} = $string_utils:first_word(havestr);
havestr = $string_utils:trimr(tostr(havenum, " ", strsub(havestr, " ", "")));
wantstr = strsub(wantstr, " ", "");
"Preceeding three lines added by GD (#110777) on 23-June-2007 to stop an annoying error when you try to convert to/from things like 'fluid ounces'.";
have = this:_do_convert(havestr);
want = this:_do_convert(wantstr);
if ((have && want) && (have[2] == want[2]))
return have[1] / want[1];
elseif (have && want)
return {1, {have[1], this:_format_units(@have[2])}, {want[1], this:_format_units(@want[2])}};
else
return {0, have ? wantstr | havestr};
endif
-------------------------------------------------------------------------------
#93 Conversion Utils:_do_convert this n/a this
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_do_convert is the workhorse of $convert_utils:convert and is based loosely upon the 'units' Perl script the ships with BSD Unix.";
"Essentially, it breaks the input up into values and units, attempts to break each unit down into elementary (basic) units, modifies the value as it goes, until it has no more input or can not convert a unit into a basic unit.";
instr = args[1];
units = this.basic_units_template;
value = 1.0;
top = 1;
"Ensure that the division mark is a spearate word.";
instr = $string_utils:substitute(instr, {{"/", " / "}});
while (instr)
"Grab the next word to process";
{first, instr} = $string_utils:first_word(instr);
if (first == "/")
"Now we're working with values under the division mark - units with negative exponents.";
top = 1 - top;
continue;
elseif (match(first, "|"))
"The word was a value expressed as a ratio. Compute the ratio and adjust the value accordingly.";
value = this:_do_value(first, value, top);
continue;
elseif ($string_utils:is_integer(first) || $string_utils:is_float(first))
"The word was a value. Adjust the accumulated value accordingly.";
value = top ? value * tofloat(first) | (value / tofloat(first));
continue;
elseif (match(first, "[0-9]$"))
"The word ends with a digit, but isn't a value. It must be a powered unit. Expand it: cm3 => cm cm cm";
subs = match(first, "%([a-zA-Z]+%)%([0-9]+%)");
first = substitute("%1", subs);
power = toint(substitute("%2", subs));
while (power > 0)
instr = (first + " ") + instr;
power = power - 1;
endwhile
continue;
else
"Check to see if the word starts with one or more metric prefix and attempt to evaluate the prefix.";
{first, value, top} = this:_try_metric_prefix(first, value, top);
"Check to see if we have a basic unit. If so, adjust the apropriate unit count.";
if (index = first in this.basic_units)
units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);
continue;
elseif (prop = `this.(first) ! E_PROPNF => 0')
"Check to see if this is a known unit. If so, convert it and adjust the value and units.";
result = this:_do_convert(prop);
value = top ? value * result[1] | (value / result[1]);
for i in [1..length(units)]
units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);
endfor
continue;
elseif (first[$] == "s")
"Check to see if this is a normal 's'-ending plural, and try to do the above checks again.";
temp = first[1..$ - 1];
if (index = temp in this.basic_units)
units[index][2] = top ? units[index][2] + 1 | (units[index][2] - 1);
continue;
elseif (prop = `this.(temp) ! E_PROPNF => 0')
result = this:_do_convert(prop);
value = top ? value * result[1] | (value / result[1]);
for i in [1..length(units)]
units[i][2] = top ? units[i][2] + result[2][i][2] | (units[i][2] - result[2][i][2]);
endfor
continue;
endif
endif
"We were unable to find any conversion for the current word, so halt all operation and return 0.";
return 0;
endif
endwhile
"We were able to successfully convert each part of the input. Return the equivalent value and units.";
return {value, units};
-------------------------------------------------------------------------------
#93 Conversion Utils:_try_metric_prefix this n/a this
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_try_metric_prefix runs through the metrix multipliers and tries to match them against the beginning of the input string. If successful, the given value is adjusted appropritately, and the input string is modified. The verb loops until there are no more prefix matches. (Hence, \"kilodecameter\" can be matched with only one verb call.";
"If anyone knows of other possibilities here, please let me know.";
{first, value, top} = args;
while (1)
if (subs = match(first, "^yocto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+24 | (value * 1e+24);
continue;
endif
if (subs = match(first, "^zepto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+21 | (value * 1e+21);
continue;
endif
if (subs = match(first, "^atto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+18 | (value * 1e+18);
continue;
endif
if (subs = match(first, "^femto%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1e+15 | (value * 1e+15);
continue;
endif
if (subs = match(first, "^pico%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000000000000.0 | (value * 1000000000000.0);
continue;
endif
if (subs = match(first, "^nano%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000000000.0 | (value * 1000000000.0);
continue;
endif
if (match(first, "^micron"))
break;
endif
if (subs = match(first, "^micro%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000000.0 | (value * 1000000.0);
continue;
endif
if (subs = match(first, "^milli%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 1000.0 | (value * 1000.0);
continue;
endif
if (subs = match(first, "^centi%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 100.0 | (value * 100.0);
continue;
endif
if (subs = match(first, "^deci%(.*%)"))
first = substitute("%1", subs);
value = top ? value / 10.0 | (value * 10.0);
continue;
endif
if (subs = match(first, "^%(deca%|deka%)%(.*%)"))
first = substitute("%2", subs);
value = (!top) ? value / 10.0 | (value * 10.0);
continue;
endif
if (subs = match(first, "^hecto%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 100.0 | (value * 100.0);
continue;
endif
if (subs = match(first, "^kilo%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000.0 | (value * 1000.0);
continue;
endif
if (subs = match(first, "^mega%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000000.0 | (value * 1000000.0);
continue;
endif
if (subs = match(first, "^giga%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000000000.0 | (value * 1000000000.0);
continue;
endif
if (subs = match(first, "^tera%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1000000000000.0 | (value * 1000000000000.0);
continue;
endif
if (subs = match(first, "^peta%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+15 | (value * 1e+15);
continue;
endif
if (subs = match(first, "^exa%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+18 | (value * 1e+18);
continue;
endif
if (subs = match(first, "^zetta%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+21 | (value * 1e+21);
continue;
endif
if (subs = match(first, "^yotta%(.*%)"))
first = substitute("%1", subs);
value = (!top) ? value / 1e+24 | (value * 1e+24);
continue;
endif
break;
endwhile
return {first, value, top};
-------------------------------------------------------------------------------
#93 Conversion Utils:_format_units this n/a this
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_format_units takes the associative list of units and powers and construct a more user friendly string.";
top = bottom = "";
for pair in (args)
if (pair[2] > 0)
top = tostr(top, " ", pair[1], (pair[2] > 1) ? pair[2] | "");
elseif (pair[2] < 0)
bottom = tostr(bottom, " ", pair[1], (pair[2] < -1) ? -pair[2] | "");
endif
endfor
if (bottom)
return ((top + " /") + bottom)[2..$];
else
return top[2..$];
endif
-------------------------------------------------------------------------------
#93 Conversion Utils:K_to_C degK_to_degC this n/a this
":K_to_C (INT|FLOAT <Kelvin>) => FLOAT <Celcius>";
"This verb converts Kelvin degrees to Celcius degrees.";
return tofloat(args[1]) - 273.0;
-------------------------------------------------------------------------------
#93 Conversion Utils:C_to_K degC_to_degK this n/a this
":C_to_K (INT|FLOAT <Celcius>) => FLOAT <Kelvin>";
"This verb converts Celcius degrees to Kelvin degrees.";
return tofloat(args[1]) + 273.0;
-------------------------------------------------------------------------------
#93 Conversion Utils:F_to_R degF_to_degR this n/a this
":F_to_R (INT|FLOAT <Fahrenheit>) => FLOAT <Rankine>";
"This verb converts Fahrenheit degrees to Rankine degrees.";
return tofloat(args[1]) + 459.67;
-------------------------------------------------------------------------------
#93 Conversion Utils:R_to_F degR_to_degF this n/a this
":R_to_F (INT|FLOAT <Rankine>) => FLOAT <Fahrenheit>";
"This verb converts Rankine degrees to Fahrenheit degrees.";
return tofloat(args[1]) - 459.67;
-------------------------------------------------------------------------------
#93 Conversion Utils:_do_value this n/a this
"THIS VERB IS NOT INTENDED FOR USER USAGE.";
":_do_value takes a string of the form <number>|<number>, interprets it as a ratio, and applies that ratio to the incoming 'value' accordingly with the 'top' input, and returns it back to the calling verb.";
{first, value, top} = args;
{numer, denom} = $string_utils:explode(first, "|");
return top ? (value * tofloat(numer)) / tofloat(denom) | ((value * tofloat(denom)) / tofloat(numer));
-------------------------------------------------------------------------------
================================#94 Generic Gendered Object===============================================
#94 Generic Gendered Object.pp rc = MOOString "its"
#94 Generic Gendered Object.prc rc = MOOString "Itself"
#94 Generic Gendered Object.pq rc = MOOString "its"
#94 Generic Gendered Object.psc rc = MOOString "It"
#94 Generic Gendered Object.ppc rc = MOOString "Its"
#94 Generic Gendered Object.pr rc = MOOString "itself"
#94 Generic Gendered Object.pqc rc = MOOString "its"
#94 Generic Gendered Object.ps rc = MOOString "it"
#94 Generic Gendered Object.gender rc = MOOString "neuter"
#94 Generic Gendered Object.poc rc = MOOString "It"
#94 Generic Gendered Object.po rc = MOOString "it"
#94 Generic Gendered Object:set_gender this n/a this
"set_gender(newgender) attempts to change this.gender to newgender";
"  => E_PERM   if you don't own this or aren't its parent";
"  => Other return values as from $gender_utils:set.";
if (!($perm_utils:controls(caller_perms(), this) || (this == caller)))
return E_PERM;
else
result = $gender_utils:set(this, args[1]);
this.gender = (typeof(result) == STR) ? result | args[1];
return result;
endif
-------------------------------------------------------------------------------
#94 Generic Gendered Object:@gen*der this beside any
if (player.wizard || (player == this.owner))
player:tell(this:set_gender(iobjstr) ? "Gender and pronouns set." | "Gender set.");
else
player:tell("Permission denied.");
endif
-------------------------------------------------------------------------------
#94 Generic Gendered Object:verb_sub this n/a this
"Copied from generic player (#6):verb_sub by ur-Rog (#6349) Fri Jan 22 11:20:11 1999 PST";
"This verb was copied by TheCat on 01/22/99, so that the generic gendered object will be able to do verb conjugation as well as pronoun substitution.";
text = args[1];
if (a = `$list_utils:assoc(text, this.verb_subs) ! ANY')
return a[2];
else
return $gender_utils:get_conj(text, this);
endif
-------------------------------------------------------------------------------
================================#95 List Editor===============================================
#95 List Editor.objects r = MOOList [ ]
#95 List Editor.properties r = MOOList [ ]
#95 List Editor:e*dit any n/a none
if (this:changed(who = player in this.active))
player:tell("You are still editing ", this:working_on(who), ".  Please type ABORT or SAVE first.");
elseif (spec = this:parse_invoke(dobjstr, verb))
this:init_session(who, @spec);
endif
-------------------------------------------------------------------------------
#95 List Editor:save any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
return;
endif
if (dobjstr)
if (objprop = this:property_match_result(dobjstr))
this.objects[who] = objprop[1];
this.properties[who] = objprop[2];
else
return;
endif
else
objprop = {this.objects[who], this.properties[who]};
endif
value_list = this:to_value(@this:text(who));
if (value_list[1])
player:tell("Error on line ", value_list[1], ":  ", value_list[2]);
player:tell("Value not saved to ", this:working_on(who));
elseif (result = this:set_property(@objprop, value_list[2]))
player:tell("Value written to ", this:working_on(who), ".");
this:set_changed(who, 0);
else
player:tell(result);
player:tell("Value not saved to ", this:working_on(who));
endif
-------------------------------------------------------------------------------
#95 List Editor:join* fill any ?-2? any
player:tell("I don't understand that.");
-------------------------------------------------------------------------------
#95 List Editor:expl*ode any ?-2? any
if (!(who = this:loaded(player)))
player:tell(this:nothing_loaded_msg());
elseif (typeof(range = this:parse_range(who, {"_", "1"}, @args)) != LIST)
player:tell(range);
elseif (range[3])
player:tell("Junk at end of cmd:  ", range[3]);
else
text = this.texts[who];
newins = ins = this.inserting[who];
start = range[1];
if (typeof(debris = this:explode_line("", text[start])) == STR)
player:tell("Line ", start, ":  ", debris);
return;
endif
if (!debris[1])
debris = listdelete(debris, 1);
endif
newlines = {};
for line in (text[i = start + 1..end = range[2]])
dlen = length(debris);
newlines = {@newlines, @debris[1..dlen - 1]};
if (ins == i)
newins = (start + length(newlines)) + 1;
endif
if (typeof(debris = this:explode_line(debris[dlen], line)) == STR)
player:tell("Line ", i, ":  ", debris);
return;
endif
i = i + 1;
endfor
explen = length(newlines) + length(debris);
if (ins > end)
newins = (ins - ((end - start) + 1)) + explen;
endif
this.texts[who] = {@text[1..start - 1], @newlines, @debris, @text[end + 1..length(text)]};
this.inserting[who] = newins;
player:tell("--> ", start, "..", (start + explen) - 1);
endif
-------------------------------------------------------------------------------
#95 List Editor:value this n/a this
if (!(e = this:readable(who = args ? args[1] | (player in this.active)) || this:ok(who)))
return e;
endif
vlist = this:to_value(@this:text(who));
if (vlist[1])
player:tell("Error on line ", vlist[1], ":  ", vlist[2]);
return E_INVARG;
else
return vlist[2];
endif
-------------------------------------------------------------------------------
#95 List Editor:working_on this n/a this
if (!(who = args[1]))
return "????";
endif
object = this.objects[who];
prop = this.properties[who] || "(???)";
return valid(object) ? tostr("\"", object.name, "\"(", object, ")", "." + prop) | tostr(".", prop, " on an invalid object (", object, ")");
-------------------------------------------------------------------------------
#95 List Editor:init_session this n/a this
if (this:ok(who = args[1]))
this:load(who, args[4]);
this.objects[who] = args[2];
this.properties[who] = args[3];
player:tell("Now editing ", this:working_on(who), ".");
endif
-------------------------------------------------------------------------------
#95 List Editor:property_match_result this n/a this
if (!(pp = $code_utils:parse_propref(string = args[1])))
player:tell("Property specification expected.");
return 0;
endif
objstr = pp[1];
prop = pp[2];
if ($command_utils:object_match_failed(object = player:my_match_object(objstr, this:get_room(player)), objstr))
elseif (!$object_utils:has_property(object, prop))
player:tell(object.name, "(", object, ") has no \".", prop, "\" property.");
else
return {object, prop};
endif
return 0;
-------------------------------------------------------------------------------
#95 List Editor:property this n/a this
"WIZARDLY";
vl = $code_utils:verb_loc();
if ((caller != vl) || (caller_perms() != vl.owner))
return E_PERM;
endif
set_task_perms(player);
return args[1].(args[2]);
-------------------------------------------------------------------------------
#95 List Editor:set_property this n/a this
"WIZARDLY";
vl = $code_utils:verb_loc();
if ((caller != vl) || (caller_perms() != vl.owner))
return E_PERM;
endif
{object, pname, value} = args;
set_task_perms(player);
if ($object_utils:has_callable_verb(object, "set_" + pname))
if (typeof(attempt = object:("set_" + pname)(value)) != ERR)
return attempt;
endif
endif
return (typeof(e = object.(pname) = value) == ERR) ? e | 1;
-------------------------------------------------------------------------------
#95 List Editor:explode_line this n/a this
su = $string_utils;
prev = args[1];
line = su:triml(args[2]);
indent = length(args[2]) - length(line);
if (line[1] == "@")
if (!(splicee = $no_one:eval(("{" + line[2..length(line)]) + "}"))[1])
return "Can't eval what's after the @.";
endif
newlines = this:explode_list(indent + 1, splicee[2]);
return {prev, @newlines};
elseif (line[1] == "}")
if (this:is_delimiter(prev) && (!index(prev, "{")))
return {tostr(args[2][1..indent], su:trim(prev), " ", line)};
else
return args;
endif
elseif (line[1] != "{")
return args;
elseif (!rindex(line, "}"))
if (this:is_delimiter(prev))
return {(su:trimr(prev) + (rindex(prev, "{") ? " " | ", ")) + line};
else
return args;
endif
elseif (!(v = $no_one:eval(line))[1])
return "Can't eval this line.";
else
newlines = {@this:explode_list(indent + 2, v[2]), su:space(indent) + "}"};
if (this:is_delimiter(prev))
return {su:trimr(prev) + (rindex(prev, "{") ? " {" | ", {"), @newlines};
else
return {prev, su:space(indent) + "{", @newlines};
endif
endif
-------------------------------------------------------------------------------
#95 List Editor:explode_list this n/a this
":explode_list(indent,list) => corresponding list of strings to use.";
lines = {};
indent = $string_utils:space(args[1]);
for element in (args[2])
if (typeof(element) == STR)
lines = {@lines, (indent + "\"") + element};
else
lines = {@lines, indent + $string_utils:print(element)};
endif
endfor
return lines;
-------------------------------------------------------------------------------
#95 List Editor:is_delimiter this n/a this
line = $string_utils:triml(args[1]);
return line && ((line[1] == "}") || ((line[1] == "{") && (!rindex(line, "}"))));
-------------------------------------------------------------------------------
#95 List Editor:to_value this n/a this
":to_value(@list_of_strings) => {line#, error_message} or {0,value}";
"converts the given list of strings back into a value if possible";
stack = {};
curlist = {};
curstr = 0;
i = 0;
for line in (args)
i = i + 1;
if (!(line = $string_utils:triml(line)))
"skip blank lines";
elseif ((char = line[1]) == "+")
if (curstr == 0)
return {i, "previous line is not a string"};
endif
curstr = curstr + line[2..length(line)];
else
if (curstr != 0)
curlist = {@curlist, curstr};
curstr = 0;
endif
if ((char == "}") || ((char == "{") && (!rindex(line, "}"))))
comma = 0;
for c in [1..length(line)]
char = line[c];
if (char == "}")
if (comma)
return {i, "unexpected `}'"};
elseif (!stack)
return {i, "too many }'s"};
endif
curlist = {@stack[1], curlist};
stack = listdelete(stack, 1);
elseif (char == "{")
comma = 1;
stack = {curlist, @stack};
curlist = {};
elseif (char == " ")
elseif ((!comma) && (char == ","))
comma = 1;
else
return {i, tostr("unexpected `", char, "'")};
endif
endfor
elseif (char == "\"")
curstr = line[2..length(line)];
elseif (char == "@")
if (!(v = $no_one:eval(("{" + line[2..length(line)]) + "}"))[1])
return {i, "Can't eval what's after the @"};
endif
curlist = {@curlist, @v[2]};
else
if (!(v = $no_one:eval(line))[1])
return {i, "Can't eval this line"};
endif
curlist = {@curlist, v[2]};
endif
endif
endfor
if (stack)
return {i, "missing }"};
endif
if (curstr != 0)
return {0, {@curlist, curstr}};
else
return {0, curlist};
endif
-------------------------------------------------------------------------------
#95 List Editor:parse_invoke this n/a this
if (caller != this)
raise(E_PERM);
elseif (!(string = args[1]))
player:tell_lines({("Usage:  " + args[2]) + " <object>.<property>", ("        " + args[2]) + "          (continues editing an unsaved property)"});
elseif (!(objprop = this:property_match_result(string)))
elseif (ERR == typeof(value = this:property(@objprop)))
player:tell("Couldn't get property value:  ", value);
elseif (typeof(value) != LIST)
player:tell("Sorry... expecting a list-valued property.");
if (typeof(value) == STR)
player:tell("Use @notedit to edit string-valued properties");
else
player:tell("Anyway, you don't need an editor to edit `", value, "'.");
endif
else
return {@objprop, this:explode_list(0, value)};
endif
return 0;
-------------------------------------------------------------------------------
================================#96 Editor_Owner===============================================
================================#97 HTTP Server===============================================
#97 HTTP Server.alpha rc = MOOString "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
#97 HTTP Server.nonalpha rc = MOOString " !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~"
#97 HTTP Server.help_msg rc = MOOList [ "HTTP Server", "-----------", "", "To use this device, all you need to do is put a .html property on your object. It will then serve a web page at http://SITE:PORT/OBJID where OBJID is the object's ID number without the # sign, SITE is your MOO's address, and PORT is your MOO's port.", "If it starts with the line <HTML>, the server will automatically serve it up as HTML code.", "Otherwise, you will need to use your own HTTP headers (for example, if you want to serve plain text instead of HTML).", "", "If you want to have more functionality than this, you can make a verb :html(args), that does the same thing. The args are a list of anything after the OBJID divided by /.", "For example, the URL http://SITE:PORT/123/foo/10 will result in a call to #123:html("foo","10"). This call should return a list of strings that is HTML, or HTTP stuff with the appropriate headers.", "", "Additionally, your object can call http:tell_key(player). This will generate a special keyed URL for that player, so when your :html() verb is called, the built-in variable PLAYER will be set to the person who was issued the key.", "This verb tells the player their custom key directly." ]
#97 HTTP Server.guests rc = MOOList [ ]
#97 HTTP Server.master_key rc = MOOString "902894a52d08e5cf3c45812a321cac36"
#97 HTTP Server:handle_connection this n/a this
"HTTP Server";
"";
"This gets called by the #0:do_login_command";
"It keeps track of web browser guests, and it feeds them HTTP instead of Telnet.";
if ((caller != #0) && (caller != this))
return E_PERM;
endif
not_http = args ? args | {$login.blank_command};
guest = $string_utils:connection_hostname(connection_name(player));
if (!args)
if ((guestnum = $list_utils:iassoc(guest, this.guests)) > 0)
guestinfo = this.guests[guestnum];
if (guestinfo[3] > 1)
"Three blank requests means this is not a guest anymore.";
this.guests = listdelete(this.guests, guestnum);
return not_http;
endif
guestinfo[3] = guestinfo[3] + 1;
this.guests[guestnum] = guestinfo;
else
"Don't know who this is. Do the regular welcome.";
return not_http;
endif
elseif ((guestnum = $list_utils:iassoc(guest, this.guests)) > 0)
"Previously registered HTTP guest.";
if (args && (args[1] == "GET"))
"Registered guest does a GET.";
guestinfo = {guest, time(), 0};
this.guests[guestnum] = guestinfo;
html = {};
keys = $string_utils:explode(args[2], "/");
objid = keys ? toobj(keys[1]) | #-1;
if (valid(objid))
if ($object_utils:has_callable_verb(objid, "html"))
new_player = $no_one;
if ((length(keys) >= 3) && (length(keys[3]) > 2))
if (keys[3] == this:gen_key(keys[1], keys[2], keys[3][1..2]))
new_player = toobj(keys[2]);
keys = (length(keys) > 3) ? keys[4..$] | {};
endif
endif
old_player = player;
player = new_player;
html = `objid:html(@keys) ! ANY';
player = old_player;
if (typeof(html) == ERR)
html = {"HTTP/1.1 500 Internal Server Error", "Content-Type: text/plain", "", "", "ERROR:", tostr(objid) + ":html()", tostr(html)};
endif
elseif ($object_utils:has_readable_property(objid, "html"))
html = objid.html;
else
html = {"HTTP/1.1 404 NOT FOUND", "Content-Type: text/plain", "", "", "HTML not found."};
endif
else
html = {"HTTP/1.1 404 NOT FOUND", "Content-Type: text/plain", "", "", "Object not found."};
endif
"Default header is HTML";
html_header = {"HTTP/1.1 200 OK", "Content-Type: text/html", "", ""};
if (typeof(html) == STR)
html = {html};
endif
if (`html[1][1..6] == "<HTML>" ! ANY => 0')
html = {@html_header, @html};
endif
if ((typeof(html) == LIST) && (length(html) == 0))
html = html_header;
endif
if (html && (typeof(html) == LIST))
for h in (html)
if (typeof(h) == STR)
notify(player, h);
endif
endfor
endif
"Server options need a suspend before they take effect.";
old_boot = $server_options.boot_msg;
$server_options.boot_msg = "";
suspend(0);
boot_player(player);
$server_options.boot_msg = old_boot;
elseif (args[1][$] == ":")
"Client is telling us some HTTP header info.";
boot_player(player);
else
"They stopped doing GETs, so remove them as HTTP.";
this.guests = listdelete(this.guests, guestnum);
return not_http;
endif
elseif (args && (args[1] == "GET"))
"First visit. Register them as a guest and ask them to refresh.";
guestinfo = {guest, time(), 0};
this.guests = {@this.guests, guestinfo};
html = {"HTTP/1.1 200 OK", "Content-Type: text/html", "", "", "<meta http-equiv=\"refresh\" content=\"0\"><br><b>", "", "", "", "Web service initialized. Please reload this page.", "</b>"};
for h in (html)
notify(player, h);
endfor
boot_player(player);
else
"Regular telnet client.";
return not_http;
endif
"HTTP Session successful";
return;
-------------------------------------------------------------------------------
#97 HTTP Server:tell_key this n/a this
"This makes a URL key for a specific object and player.";
"With the keyed URL, the PLAYER will be set correctly when :HTML() is called";
key = this:gen_key(player, caller);
notify(player, ("This is the private key for you, " + player.name) + ". Do not share it.");
notify(player, ((((((((("http://" + $network.site) + ":") + $network.port) + "/") + tostr(caller)[2..$]) + "/") + tostr(player)[2..$]) + "/") + key) + "/");
-------------------------------------------------------------------------------
#97 HTTP Server:gen_key this n/a this
if (caller != this)
return E_PERM;
endif
player = args[1];
object = args[2];
hash = ((tonum(player) + tonum(object)) + this.master_key) % 100000000;
if (length(args) > 2)
salt = args[3];
key = crypt(tostr(hash), salt);
else
"Make it only alphanumeric salt, to get through a URL";
salt = this.alpha[random(length(this.alpha))] + this.alpha[random(length(this.alpha))];
key = crypt(tostr(hash), salt);
endif
"Clean out the non-alpha to make key work in a URL";
for i in [1..length(key)]
if (j = index(this.nonalpha, key[i], 1))
key[i] = this.alpha[j];
endif
endfor
return key;
-------------------------------------------------------------------------------
